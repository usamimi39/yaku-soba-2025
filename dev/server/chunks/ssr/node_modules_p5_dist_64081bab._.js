module.exports = [
"[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "$",
    ()=>BLUR,
    "A",
    ()=>AXES,
    "B",
    ()=>BEVEL,
    "C",
    ()=>CENTER,
    "D",
    ()=>DEG_TO_RAD,
    "E",
    ()=>EMPTY_PATH,
    "F",
    ()=>FLAT,
    "G",
    ()=>GRID,
    "H",
    ()=>HAND,
    "I",
    ()=>INCLUDE,
    "J",
    ()=>JOIN,
    "K",
    ()=>OPAQUE,
    "L",
    ()=>LINES,
    "M",
    ()=>MOVE,
    "N",
    ()=>NORMAL,
    "O",
    ()=>OPEN,
    "P",
    ()=>P2D,
    "Q",
    ()=>QUADS,
    "R",
    ()=>RIGHT,
    "S",
    ()=>SQUARE,
    "T",
    ()=>TEXTURE,
    "U",
    ()=>POSTERIZE,
    "V",
    ()=>DILATE,
    "W",
    ()=>WAIT,
    "X",
    ()=>GRAY,
    "Y",
    ()=>ERODE,
    "Z",
    ()=>THRESHOLD,
    "_",
    ()=>INVERT,
    "a",
    ()=>RADIUS,
    "a$",
    ()=>BOLDITALIC,
    "a0",
    ()=>WEBGL,
    "a1",
    ()=>IMAGE,
    "a2",
    ()=>_DEFAULT_FILL,
    "a3",
    ()=>_DEFAULT_STROKE,
    "a4",
    ()=>REMOVE,
    "a5",
    ()=>SUBTRACT,
    "a6",
    ()=>DARKEST,
    "a7",
    ()=>LIGHTEST,
    "a8",
    ()=>DIFFERENCE,
    "a9",
    ()=>MULTIPLY,
    "aA",
    ()=>MIRROR,
    "aB",
    ()=>FLOAT,
    "aC",
    ()=>LINEAR,
    "aD",
    ()=>HALF_FLOAT,
    "aE",
    ()=>P2DHDR,
    "aF",
    ()=>QUARTER_PI,
    "aG",
    ()=>TAU,
    "aH",
    ()=>TOP,
    "aI",
    ()=>LINE_STRIP,
    "aJ",
    ()=>LINE_LOOP,
    "aK",
    ()=>TESS,
    "aL",
    ()=>ALT,
    "aM",
    ()=>BACKSPACE,
    "aN",
    ()=>CONTROL,
    "aO",
    ()=>DELETE,
    "aP",
    ()=>DOWN_ARROW,
    "aQ",
    ()=>ENTER,
    "aR",
    ()=>ESCAPE,
    "aS",
    ()=>LEFT_ARROW,
    "aT",
    ()=>OPTION,
    "aU",
    ()=>RETURN,
    "aV",
    ()=>RIGHT_ARROW,
    "aW",
    ()=>SHIFT,
    "aX",
    ()=>TAB,
    "aY",
    ()=>UP_ARROW,
    "aZ",
    ()=>ITALIC,
    "a_",
    ()=>BOLD,
    "aa",
    ()=>EXCLUSION,
    "ab",
    ()=>SCREEN,
    "ac",
    ()=>REPLACE,
    "ad",
    ()=>OVERLAY,
    "ae",
    ()=>HARD_LIGHT,
    "af",
    ()=>SOFT_LIGHT,
    "ag",
    ()=>DODGE,
    "ah",
    ()=>BURN,
    "ai",
    ()=>ADD,
    "aj",
    ()=>PIE,
    "ak",
    ()=>CHORD,
    "al",
    ()=>VERSION,
    "am",
    ()=>WORD,
    "an",
    ()=>BASELINE,
    "ao",
    ()=>LEFT,
    "ap",
    ()=>COVER,
    "aq",
    ()=>CONTAIN,
    "ar",
    ()=>BOTTOM,
    "as",
    ()=>FILL,
    "at",
    ()=>CLAMP,
    "au",
    ()=>UNSIGNED_INT,
    "av",
    ()=>UNSIGNED_BYTE,
    "aw",
    ()=>SIMPLE,
    "ax",
    ()=>FULL,
    "ay",
    ()=>NEAREST,
    "az",
    ()=>REPEAT,
    "b",
    ()=>ARROW,
    "b0",
    ()=>CHAR,
    "b1",
    ()=>_DEFAULT_TEXT_FILL,
    "b2",
    ()=>_DEFAULT_LEADMULT,
    "b3",
    ()=>_CTX_MIDDLE,
    "b4",
    ()=>QUADRATIC,
    "b5",
    ()=>BEZIER,
    "b6",
    ()=>CURVE,
    "b7",
    ()=>STROKE,
    "b8",
    ()=>IMMEDIATE,
    "b9",
    ()=>LANDSCAPE,
    "ba",
    ()=>PORTRAIT,
    "bb",
    ()=>LABEL,
    "bc",
    ()=>FALLBACK,
    "c",
    ()=>CROSS,
    "d",
    ()=>TEXT,
    "e",
    ()=>CORNER,
    "f",
    ()=>TWO_PI,
    "g",
    ()=>HALF_PI,
    "h",
    ()=>PI,
    "i",
    ()=>CORNERS,
    "j",
    ()=>ROUND,
    "k",
    ()=>PROJECT,
    "l",
    ()=>MITER,
    "m",
    ()=>PATH,
    "n",
    ()=>CLOSE,
    "o",
    ()=>POINTS,
    "p",
    ()=>TRIANGLES,
    "q",
    ()=>TRIANGLE_FAN,
    "r",
    ()=>TRIANGLE_STRIP,
    "s",
    ()=>QUAD_STRIP,
    "t",
    ()=>EXCLUDE,
    "u",
    ()=>BLEND,
    "v",
    ()=>constants,
    "w",
    ()=>AUTO,
    "x",
    ()=>RAD_TO_DEG,
    "y",
    ()=>SMOOTH,
    "z",
    ()=>WEBGL2
]);
/**
 * @module Constants
 * @submodule Constants
 * @for p5
 */ const _PI = Math.PI;
/**
 * Version of this p5.js.
 * @property {String} VERSION
 * @final
 */ const VERSION = '2.1.2';
// GRAPHICS RENDERER
/**
 * The default, two-dimensional renderer in p5.js.
 *
 * Use this when calling <a href="#/p5/createCanvas"> (for example,
 * `createCanvas(400, 400, P2D)`) to specify a 2D context.
 *
 * @typedef {'p2d'} P2D
 * @property {P2D} P2D
 * @final
 */ const P2D = 'p2d';
/**
 * A high-dynamic-range (HDR) variant of the default, two-dimensional renderer.
 *
 * When available, this mode can allow for extended color ranges and more
 * dynamic color representation. Use it similarly to `P2D`:
 * `createCanvas(400, 400, P2DHDR)`.
 *
 * @typedef {'p2d-hdr'} P2DHDR
 * @property {P2DHDR} P2DHDR
 * @final
 */ const P2DHDR = 'p2d-hdr';
/**
 * One of the two render modes in p5.js, used for computationally intensive tasks like 3D rendering and shaders.
 *
 * `WEBGL` differs from the default <a href="/reference/p5/P2D">`P2D`</a> renderer in the following ways:
 *
 * - **Coordinate System** - When drawing in `WEBGL` mode, the origin point (0,0,0) is located at the center of the screen, not the top-left corner. See <a href="https://p5js.org/tutorials/coordinates-and-transformations/">the tutorial page about coordinates and transformations</a>.
 * - **3D Shapes** - `WEBGL` mode can be used to draw 3-dimensional shapes like <a href="#/p5/box">box()</a>, <a href="#/p5/sphere">sphere()</a>, <a href="#/p5/cone">cone()</a>, and <a href="https://p5js.org/reference/#3D%20Primitives">more</a>. See <a href="https://p5js.org/tutorials/custom-geometry/">the tutorial page about custom geometry</a> to make more complex objects.
 * - **Shape Detail** - When drawing in `WEBGL` mode, you can specify how smooth curves should be drawn by using a `detail` parameter. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#3d-primitives-shapes">the wiki section about shapes</a> for a more information and an example.
 * - **Textures** - A texture is like a skin that wraps onto a shape. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#textures">the wiki section about textures</a> for examples of mapping images onto surfaces with textures.
 * - **Materials and Lighting** - `WEBGL` offers different types of lights like <a href="#/p5/ambientLight">ambientLight()</a> to place around a scene. Materials like <a href="#/p5/specularMaterial">specularMaterial()</a> reflect the lighting to convey shape and depth. See <a href="https://p5js.org/tutorials/lights-camera-materials/">the tutorial page for styling and appearance</a> to experiment with different combinations.
 * - **Camera** - The viewport of a `WEBGL` sketch can be adjusted by changing camera attributes. See <a href="https://p5js.org/tutorials/lights-camera-materials#camera-and-view">the tutorial page section about cameras</a> for an explanation of camera controls.
 * - **Text** - `WEBGL` requires opentype/truetype font files to be preloaded using <a href="#/p5/loadFont">loadFont()</a>. See <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5#text">the wiki section about text</a> for details, along with a workaround.
 * - **Shaders** - Shaders are hardware accelerated programs that can be used for a variety of effects and graphics. See the <a href="https://p5js.org/tutorials/intro-to-shaders/">introduction to shaders</a> to get started with shaders in p5.js.
 * - **Graphics Acceleration** - `WEBGL` mode uses the graphics card instead of the CPU, so it may help boost the performance of your sketch (example: drawing more shapes on the screen at once).
 *
 * To learn more about WEBGL mode, check out <a href="https://p5js.org/tutorials/#webgl">all the interactive WEBGL tutorials</a> in the "Tutorials" section of this website, or read the wiki article <a href="https://github.com/processing/p5.js/wiki/Getting-started-with-WebGL-in-p5">"Getting started with WebGL in p5"</a>.
 *
 * @typedef {'webgl'} WEBGL
 * @property {WEBGL} WEBGL
 * @final
 */ const WEBGL = 'webgl';
/**
 * One of the two possible values of a WebGL canvas (either WEBGL or WEBGL2),
 * which can be used to determine what capabilities the rendering environment
 * has.
 * @typedef {'webgl2'} WEBGL2
 * @property {WEBGL2} WEBGL2
 * @final
 */ const WEBGL2 = 'webgl2';
// ENVIRONMENT
/**
 * @typedef {'default'} ARROW
 * @property {ARROW} ARROW
 * @final
 */ const ARROW = 'default';
/**
 * @property {String} SIMPLE
 * @final
 */ const SIMPLE = 'simple';
/**
 * @property {String} FULL
 * @final
 */ const FULL = 'full';
/**
 * @typedef {'crosshair'} CROSS
 * @property {CROSS} CROSS
 * @final
 */ const CROSS = 'crosshair';
/**
 * @typedef {'pointer'} HAND
 * @property {HAND} HAND
 * @final
 */ const HAND = 'pointer';
/**
 * @typedef {'move'} MOVE
 * @property {MOVE} MOVE
 * @final
 */ const MOVE = 'move';
/**
 * @typedef {'text'} TEXT
 * @property {TEXT} TEXT
 * @final
 */ const TEXT = 'text';
/**
 * @typedef {'wait'} WAIT
 * @property {WAIT} WAIT
 * @final
 */ const WAIT = 'wait';
// TRIGONOMETRY
/**
 * A `Number` constant that's approximately 1.5708.
 *
 * `HALF_PI` is half the value of the mathematical constant π. It's useful for
 * many tasks that involve rotation and oscillation. For example, calling
 * `rotate(HALF_PI)` rotates the coordinate system `HALF_PI` radians, which is
 * a quarter turn (90˚).
 *
 * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
 * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
 *
 * @property {Number} HALF_PI
 * @final
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Draw an arc from 0 to HALF_PI.
 *   arc(50, 50, 80, 80, 0, HALF_PI);
 *
 *   describe('The bottom-right quarter of a circle drawn in white on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Draw a line.
 *   line(0, 0, 40, 0);
 *
 *   // Rotate a quarter turn.
 *   rotate(HALF_PI);
 *
 *   // Draw the same line, rotated.
 *   line(0, 0, 40, 0);
 *
 *   describe('Two black lines on a gray background. One line extends from the center to the right. The other line extends from the center to the bottom.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   describe(
 *     'A red circle and a blue circle oscillate from left to right on a gray background. The red circle appears to chase the blue circle.'
 *   );
 * }
 *
 * function draw() {
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Calculate the x-coordinates.
 *   let x1 = 40 * sin(frameCount * 0.05);
 *   let x2 = 40 * sin(frameCount * 0.05 + HALF_PI);
 *
 *   // Style the oscillators.
 *   noStroke();
 *
 *   // Draw the red oscillator.
 *   fill(255, 0, 0);
 *   circle(x1, 0, 20);
 *
 *   // Draw the blue oscillator.
 *   fill(0, 0, 255);
 *   circle(x2, 0, 20);
 * }
 * </code>
 * </div>
 */ const HALF_PI = _PI / 2;
/**
 * A `Number` constant that's approximately 3.1416.
 *
 * `PI` is the mathematical constant π. It's useful for many tasks that
 * involve rotation and oscillation. For example, calling `rotate(PI)` rotates
 * the coordinate system `PI` radians, which is a half turn (180˚).
 *
 * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
 * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
 *
 * @property {Number} PI
 * @final
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Draw an arc from 0 to PI.
 *   arc(50, 50, 80, 80, 0, PI);
 *
 *   describe('The bottom half of a circle drawn in white on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Draw a line.
 *   line(0, 0, 40, 0);
 *
 *   // Rotate a half turn.
 *   rotate(PI);
 *
 *   // Draw the same line, rotated.
 *   line(0, 0, 40, 0);
 *
 *   describe('A horizontal black line on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   describe(
 *     'A red circle and a blue circle oscillate from left to right on a gray background. The circles drift apart, then meet in the middle, over and over again.'
 *   );
 * }
 *
 * function draw() {
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Calculate the x-coordinates.
 *   let x1 = 40 * sin(frameCount * 0.05);
 *   let x2 = 40 * sin(frameCount * 0.05 + PI);
 *
 *   // Style the oscillators.
 *   noStroke();
 *
 *   // Draw the red oscillator.
 *   fill(255, 0, 0);
 *   circle(x1, 0, 20);
 *
 *   // Draw the blue oscillator.
 *   fill(0, 0, 255);
 *   circle(x2, 0, 20);
 * }
 * </code>
 * </div>
 */ const PI = _PI;
/**
 * A `Number` constant that's approximately 0.7854.
 *
 * `QUARTER_PI` is one-fourth the value of the mathematical constant π. It's
 * useful for many tasks that involve rotation and oscillation. For example,
 * calling `rotate(QUARTER_PI)` rotates the coordinate system `QUARTER_PI`
 * radians, which is an eighth of a turn (45˚).
 *
 * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
 * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
 *
 * @property {Number} QUARTER_PI
 * @final
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Draw an arc from 0 to QUARTER_PI.
 *   arc(50, 50, 80, 80, 0, QUARTER_PI);
 *
 *   describe('A one-eighth slice of a circle drawn in white on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Draw a line.
 *   line(0, 0, 40, 0);
 *
 *   // Rotate an eighth turn.
 *   rotate(QUARTER_PI);
 *
 *   // Draw the same line, rotated.
 *   line(0, 0, 40, 0);
 *
 *   describe('Two black lines that form a "V" opening towards the bottom-right corner of a gray square.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   describe(
 *     'A red circle and a blue circle oscillate from left to right on a gray background. The red circle appears to chase the blue circle.'
 *   );
 * }
 *
 * function draw() {
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Calculate the x-coordinates.
 *   let x1 = 40 * sin(frameCount * 0.05);
 *   let x2 = 40 * sin(frameCount * 0.05 + QUARTER_PI);
 *
 *   // Style the oscillators.
 *   noStroke();
 *
 *   // Draw the red oscillator.
 *   fill(255, 0, 0);
 *   circle(x1, 0, 20);
 *
 *   // Draw the blue oscillator.
 *   fill(0, 0, 255);
 *   circle(x2, 0, 20);
 * }
 * </code>
 * </div>
 */ const QUARTER_PI = _PI / 4;
/**
 * A `Number` constant that's approximately 6.2382.
 *
 * `TAU` is twice the value of the mathematical constant π. It's useful for
 * many tasks that involve rotation and oscillation. For example, calling
 * `rotate(TAU)` rotates the coordinate system `TAU` radians, which is one
 * full turn (360˚). `TAU` and `TWO_PI` are equal.
 *
 * Note: `TAU` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
 * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
 *
 * @property {Number} TAU
 * @final
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Draw an arc from 0 to TAU.
 *   arc(50, 50, 80, 80, 0, TAU);
 *
 *   describe('A white circle drawn on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Draw a line.
 *   line(0, 0, 40, 0);
 *
 *   // Rotate a full turn.
 *   rotate(TAU);
 *
 *   // Style the second line.
 *   strokeWeight(5);
 *
 *   // Draw the same line, shorter and rotated.
 *   line(0, 0, 20, 0);
 *
 *   describe(
 *     'Two horizontal black lines on a gray background. A thick line extends from the center toward the right. A thin line extends from the end of the thick line.'
 *   );
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   describe(
 *     'A red circle with a blue center oscillates from left to right on a gray background.'
 *   );
 * }
 *
 * function draw() {
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Calculate the x-coordinates.
 *   let x1 = 40 * sin(frameCount * 0.05);
 *   let x2 = 40 * sin(frameCount * 0.05 + TAU);
 *
 *   // Style the oscillators.
 *   noStroke();
 *
 *   // Draw the red oscillator.
 *   fill(255, 0, 0);
 *   circle(x1, 0, 20);
 *
 *   // Draw the blue oscillator, smaller.
 *   fill(0, 0, 255);
 *   circle(x2, 0, 10);
 * }
 * </code>
 * </div>
 */ const TAU = _PI * 2;
/**
 * A `Number` constant that's approximately 6.2382.
 *
 * `TWO_PI` is twice the value of the mathematical constant π. It's useful for
 * many tasks that involve rotation and oscillation. For example, calling
 * `rotate(TWO_PI)` rotates the coordinate system `TWO_PI` radians, which is
 * one full turn (360˚). `TWO_PI` and `TAU` are equal.
 *
 * Note: `TWO_PI` radians equals 360˚, `PI` radians equals 180˚, `HALF_PI`
 * radians equals 90˚, and `QUARTER_PI` radians equals 45˚.
 *
 * @property {Number} TWO_PI
 * @final
 *
 * @example
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Draw an arc from 0 to TWO_PI.
 *   arc(50, 50, 80, 80, 0, TWO_PI);
 *
 *   describe('A white circle drawn on a gray background.');
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Draw a line.
 *   line(0, 0, 40, 0);
 *
 *   // Rotate a full turn.
 *   rotate(TWO_PI);
 *
 *   // Style the second line.
 *   strokeWeight(5);
 *
 *   // Draw the same line, shorter and rotated.
 *   line(0, 0, 20, 0);
 *
 *   describe(
 *     'Two horizontal black lines on a gray background. A thick line extends from the center toward the right. A thin line extends from the end of the thick line.'
 *   );
 * }
 * </code>
 * </div>
 *
 * <div>
 * <code>
 * function setup() {
 *   createCanvas(100, 100);
 *
 *   describe(
 *     'A red circle with a blue center oscillates from left to right on a gray background.'
 *   );
 * }
 *
 * function draw() {
 *   background(200);
 *
 *   // Translate the origin to the center.
 *   translate(50, 50);
 *
 *   // Calculate the x-coordinates.
 *   let x1 = 40 * sin(frameCount * 0.05);
 *   let x2 = 40 * sin(frameCount * 0.05 + TWO_PI);
 *
 *   // Style the oscillators.
 *   noStroke();
 *
 *   // Draw the red oscillator.
 *   fill(255, 0, 0);
 *   circle(x1, 0, 20);
 *
 *   // Draw the blue oscillator, smaller.
 *   fill(0, 0, 255);
 *   circle(x2, 0, 10);
 * }
 * </code>
 * </div>
 */ const TWO_PI = _PI * 2;
/**
 * @property {Number} DEG_TO_RAD
 * @final
 */ const DEG_TO_RAD = _PI / 180.0;
/**
 * @property {Number} RAD_TO_DEG
 * @final
 */ const RAD_TO_DEG = 180.0 / _PI;
// SHAPE
/**
 * @typedef {'corner'} CORNER
 * @property {CORNER} CORNER
 * @final
 */ const CORNER = 'corner';
/**
 * @typedef {'corners'} CORNERS
 * @property {CORNERS} CORNERS
 * @final
 */ const CORNERS = 'corners';
/**
 * @typedef {'radius'} RADIUS
 * @property {RADIUS} RADIUS
 * @final
 */ const RADIUS = 'radius';
/**
 * @typedef {'right'} RIGHT
 * @property {RIGHT} RIGHT
 * @final
 */ const RIGHT = 'right';
/**
 * @typedef {'left'} LEFT
 * @property {LEFT} LEFT
 * @final
 */ const LEFT = 'left';
/**
 * @typedef {'center'} CENTER
 * @property {CENTER} CENTER
 * @final
 */ const CENTER = 'center';
/**
 * @typedef {'top'} TOP
 * @property {TOP} TOP
 * @final
 */ const TOP = 'top';
/**
 * @typedef {'bottom'} BOTTOM
 * @property {BOTTOM} BOTTOM
 * @final
 */ const BOTTOM = 'bottom';
/**
 * @typedef {'alphabetic'} BASELINE
 * @property {BASELINE} BASELINE
 * @final
 */ const BASELINE = 'alphabetic';
/**
 * @typedef {0x0000} POINTS
 * @property {POINTS} POINTS
 * @final
 */ const POINTS = 0x0000;
/**
 * @typedef {0x0001} LINES
 * @property {LINES} LINES
 * @final
 */ const LINES = 0x0001;
/**
 * @typedef {0x0003} LINE_STRIP
 * @property {LINE_STRIP} LINE_STRIP
 * @final
 */ const LINE_STRIP = 0x0003;
/**
 * @typedef {0x0002} LINE_LOOP
 * @property {LINE_LOOP} LINE_LOOP
 * @final
 */ const LINE_LOOP = 0x0002;
/**
 * @typedef {0x0004} TRIANGLES
 * @property {TRIANGLES} TRIANGLES
 * @final
 */ const TRIANGLES = 0x0004;
/**
 * @typedef {0x0006} TRIANGLE_FAN
 * @property {TRIANGLE_FAN} TRIANGLE_FAN
 * @final
 */ const TRIANGLE_FAN = 0x0006;
/**
 * @typedef {0x0005} TRIANGLE_STRIP
 * @property {TRIANGLE_STRIP} TRIANGLE_STRIP
 * @final
 */ const TRIANGLE_STRIP = 0x0005;
/**
 * @typedef {'quads'} QUADS
 * @property {QUADS} QUADS
 * @final
 */ const QUADS = 'quads';
/**
 * @typedef {'quad_strip'} QUAD_STRIP
 * @property {QUAD_STRIP} QUAD_STRIP
 * @final
 */ const QUAD_STRIP = 'quad_strip';
/**
 * @typedef {'tess'} TESS
 * @property {TESS} TESS
 * @final
 */ const TESS = 'tess';
/**
 * @typedef {0x0007} EMPTY_PATH
 * @property {EMPTY_PATH} EMPTY_PATH
 * @final
 */ const EMPTY_PATH = 0x0007;
/**
 * @typedef {0x0008} PATH
 * @property {PATH} PATH
 * @final
 */ const PATH = 0x0008;
/**
 * @typedef {'close'} CLOSE
 * @property {CLOSE} CLOSE
 * @final
 */ const CLOSE = 'close';
/**
 * @typedef {'open'} OPEN
 * @property {OPEN} OPEN
 * @final
 */ const OPEN = 'open';
/**
 * @typedef {'chord'} CHORD
 * @property {CHORD} CHORD
 * @final
 */ const CHORD = 'chord';
/**
 * @typedef {'pie'} PIE
 * @property {PIE} PIE
 * @final
 */ const PIE = 'pie';
/**
 * @typedef {'square'} PROJECT
 * @property {PROJECT} PROJECT
 * @final
 */ const PROJECT = 'square'; // PEND: careful this is counterintuitive
/**
 * @typedef {'butt'} SQUARE
 * @property {SQUARE} SQUARE
 * @final
 */ const SQUARE = 'butt';
/**
 * @typedef {'round'} ROUND
 * @property {ROUND} ROUND
 * @final
 */ const ROUND = 'round';
/**
 * @typedef {'bevel'} BEVEL
 * @property {BEVEL} BEVEL
 * @final
 */ const BEVEL = 'bevel';
/**
 * @typedef {'miter'} MITER
 * @property {MITER} MITER
 * @final
 */ const MITER = 'miter';
// DOM EXTENSION
/**
 * AUTO allows us to automatically set the width or height of an element (but not both),
 * based on the current height and width of the element. Only one parameter can
 * be passed to the <a href="/reference/p5.Element/size">size</a> function as AUTO, at a time.
 *
 * @typedef {'auto'} AUTO
 * @property {AUTO} AUTO
 * @final
 */ const AUTO = 'auto';
// INPUT
/**
 * @typedef {'Alt'} ALT
 * @property {ALT} ALT
 * @final
 */ const ALT = 'Alt';
/**
 * @typedef {'Backspace'} BACKSPACE
 * @property {BACKSPACE} BACKSPACE
 * @final
 */ const BACKSPACE = 'Backspace';
/**
 * @typedef {'Control' | 'Control'} CONTROL
 * @property {CONTROL} CONTROL
 * @final
 */ const CONTROL = 'Control';
/**
 * @typedef {'Delete'} DELETE
 * @property {DELETE} DELETE
 * @final
 */ const DELETE = 'Delete';
/**
 * @typedef {'ArrowDown'} DOWN_ARROW
 * @property {DOWN_ARROW} DOWN_ARROW
 * @final
 */ const DOWN_ARROW = 'ArrowDown';
/**
 * @typedef {'Enter'} ENTER
 * @property {ENTER} ENTER
 * @final
 */ const ENTER = 'Enter';
/**
 * @typedef {'Escape'} ESCAPE
 * @property {ESCAPE} ESCAPE
 * @final
 */ const ESCAPE = 'Escape';
/**
 * @typedef {'ArrowLeft'} LEFT_ARROW
 * @property {LEFT_ARROW} LEFT_ARROW
 * @final
 */ const LEFT_ARROW = 'ArrowLeft';
/**
 * @typedef {'Alt'} OPTION
 * @property {OPTION} OPTION
 * @final
 */ const OPTION = 'Alt';
/**
 * @typedef {'Enter'} RETURN
 * @property {RETURN} RETURN
 * @final
 */ const RETURN = 'Enter';
/**
 * @typedef {'ArrowRight'} RIGHT_ARROW
 * @property {RIGHT_ARROW} RIGHT_ARROW
 * @final
 */ const RIGHT_ARROW = 'ArrowRight';
/**
 * @typedef {'Shift'} SHIFT
 * @property {SHIFT} SHIFT
 * @final
 */ const SHIFT = 'Shift';
/**
 * @typedef {'Tab'} TAB
 * @property {TAB} TAB
 * @final
 */ const TAB = 'Tab';
/**
 * @typedef {'ArrowUp'} UP_ARROW
 * @property {UP_ARROW} UP_ARROW
 * @final
 */ const UP_ARROW = 'ArrowUp';
// RENDERING
/**
 * @typedef {'source-over'} BLEND
 * @property {BLEND} BLEND
 * @final
 */ const BLEND = 'source-over';
/**
 * @typedef {'destination-out'} REMOVE
 * @property {REMOVE} REMOVE
 * @final
 */ const REMOVE = 'destination-out';
/**
 * @typedef {'lighter'} ADD
 * @property {ADD} ADD
 * @final
 */ const ADD = 'lighter';
/**
 * @typedef {'darken'} DARKEST
 * @property {DARKEST} DARKEST
 * @final
 */ const DARKEST = 'darken';
/**
 * @typedef {'lighten'} LIGHTEST
 * @property {LIGHTEST} LIGHTEST
 * @final
 */ const LIGHTEST = 'lighten';
/**
 * @typedef {'difference'} DIFFERENCE
 * @property {DIFFERENCE} DIFFERENCE
 * @final
 */ const DIFFERENCE = 'difference';
/**
 * @typedef {'subtract'} SUBTRACT
 * @property {SUBTRACT} SUBTRACT
 * @final
 */ const SUBTRACT = 'subtract';
/**
 * @typedef {'exclusion'} EXCLUSION
 * @property {EXCLUSION} EXCLUSION
 * @final
 */ const EXCLUSION = 'exclusion';
/**
 * @typedef {'multiply'} MULTIPLY
 * @property {MULTIPLY} MULTIPLY
 * @final
 */ const MULTIPLY = 'multiply';
/**
 * @typedef {'screen'} SCREEN
 * @property {SCREEN} SCREEN
 * @final
 */ const SCREEN = 'screen';
/**
 * @typedef {'copy'} REPLACE
 * @property {REPLACE} REPLACE
 * @final
 */ const REPLACE = 'copy';
/**
 * @typedef {'overlay'} OVERLAY
 * @property {OVERLAY} OVERLAY
 * @final
 */ const OVERLAY = 'overlay';
/**
 * @typedef {'hard-light'} HARD_LIGHT
 * @property {HARD_LIGHT} HARD_LIGHT
 * @final
 */ const HARD_LIGHT = 'hard-light';
/**
 * @typedef {'soft-light'} SOFT_LIGHT
 * @property {SOFT_LIGHT} SOFT_LIGHT
 * @final
 */ const SOFT_LIGHT = 'soft-light';
/**
 * @typedef {'color-dodge'} DODGE
 * @property {DODGE} DODGE
 * @final
 */ const DODGE = 'color-dodge';
/**
 * @typedef {'color-burn'} BURN
 * @property {BURN} BURN
 * @final
 */ const BURN = 'color-burn';
// FILTERS
/**
 * @typedef {'threshold'} THRESHOLD
 * @property {THRESHOLD} THRESHOLD
 * @final
 */ const THRESHOLD = 'threshold';
/**
 * @typedef {'gray'} GRAY
 * @property {GRAY} GRAY
 * @final
 */ const GRAY = 'gray';
/**
 * @typedef {'opaque'} OPAQUE
 * @property {OPAQUE} OPAQUE
 * @final
 */ const OPAQUE = 'opaque';
/**
 * @typedef {'invert'} INVERT
 * @property {INVERT} INVERT
 * @final
 */ const INVERT = 'invert';
/**
 * @typedef {'posterize'} POSTERIZE
 * @property {POSTERIZE} POSTERIZE
 * @final
 */ const POSTERIZE = 'posterize';
/**
 * @typedef {'dilate'} DILATE
 * @property {DILATE} DILATE
 * @final
 */ const DILATE = 'dilate';
/**
 * @typedef {'erode'} ERODE
 * @property {ERODE} ERODE
 * @final
 */ const ERODE = 'erode';
/**
 * @typedef {'blur'} BLUR
 * @property {BLUR} BLUR
 * @final
 */ const BLUR = 'blur';
// TYPOGRAPHY
/**
 * @typedef {'normal'} NORMAL
 * @property {NORMAL} NORMAL
 * @final
 */ const NORMAL = 'normal';
/**
 * @typedef {'italic'} ITALIC
 * @property {ITALIC} ITALIC
 * @final
 */ const ITALIC = 'italic';
/**
 * @typedef {'bold'} BOLD
 * @property {BOLD} BOLD
 * @final
 */ const BOLD = 'bold';
/**
 * @typedef {'bold italic'} BOLDITALIC
 * @property {BOLDITALIC} BOLDITALIC
 * @final
 */ const BOLDITALIC = 'bold italic';
/**
 * @typedef {'CHAR'} CHAR
 * @property {CHAR} CHAR
 * @final
 */ const CHAR = 'CHAR';
/**
 * @typedef {'WORD'} WORD
 * @property {WORD} WORD
 * @final
 */ const WORD = 'WORD';
// TYPOGRAPHY-INTERNAL
const _DEFAULT_TEXT_FILL = '#000000';
const _DEFAULT_LEADMULT = 1.25;
const _CTX_MIDDLE = 'middle';
// VERTICES
/**
 * @typedef {'linear'} LINEAR
 * @property {LINEAR} LINEAR
 * @final
 */ const LINEAR = 'linear';
/**
 * @typedef {'quadratic'} QUADRATIC
 * @property {QUADRATIC} QUADRATIC
 * @final
 */ const QUADRATIC = 'quadratic';
/**
 * @typedef {'bezier'} BEZIER
 * @property {BEZIER} BEZIER
 * @final
 */ const BEZIER = 'bezier';
/**
 * @typedef {'curve'} CURVE
 * @property {CURVE} CURVE
 * @final
 */ const CURVE = 'curve';
// WEBGL DRAWMODES
/**
 * @typedef {'stroke'} STROKE
 * @property {STROKE} STROKE
 * @final
 */ const STROKE = 'stroke';
/**
 * @typedef {'fill'} FILL
 * @property {FILL} FILL
 * @final
 */ const FILL = 'fill';
/**
 * @typedef {'texture'} TEXTURE
 * @property {TEXTURE} TEXTURE
 * @final
 */ const TEXTURE = 'texture';
/**
 * @typedef {'immediate'} IMMEDIATE
 * @property {IMMEDIATE} IMMEDIATE
 * @final
 */ const IMMEDIATE = 'immediate';
// WEBGL TEXTURE MODE
// NORMAL already exists for typography
/**
 * @typedef {'image'} IMAGE
 * @property {IMAGE} IMAGE
 * @final
 */ const IMAGE = 'image';
// WEBGL TEXTURE WRAP AND FILTERING
// LINEAR already exists above
/**
 * @typedef {'nearest'} NEAREST
 * @property {NEAREST} NEAREST
 * @final
 */ const NEAREST = 'nearest';
/**
 * @typedef {'repeat'} REPEAT
 * @property {REPEAT} REPEAT
 * @final
 */ const REPEAT = 'repeat';
/**
 * @typedef {'clamp'} CLAMP
 * @property {CLAMP} CLAMP
 * @final
 */ const CLAMP = 'clamp';
/**
 * @typedef {'mirror'} MIRROR
 * @property {MIRROR} MIRROR
 * @final
 */ const MIRROR = 'mirror';
// WEBGL GEOMETRY SHADING
/**
 * @typedef {'flat'} FLAT
 * @property {FLAT} FLAT
 * @final
 */ const FLAT = 'flat';
/**
 * @typedef {'smooth'} SMOOTH
 * @property {SMOOTH} SMOOTH
 * @final
 */ const SMOOTH = 'smooth';
// DEVICE-ORIENTATION
/**
 * @typedef {'landscape'} LANDSCAPE
 * @property {LANDSCAPE} LANDSCAPE
 * @final
 */ const LANDSCAPE = 'landscape';
/**
 * @typedef {'portrait'} PORTRAIT
 * @property {PORTRAIT} PORTRAIT
 * @final
 */ const PORTRAIT = 'portrait';
// DEFAULTS
const _DEFAULT_STROKE = '#000000';
const _DEFAULT_FILL = '#FFFFFF';
/**
 * @typedef {'grid'} GRID
 * @property {GRID} GRID
 * @final
 */ const GRID = 'grid';
/**
 * @typedef {'axes'} AXES
 * @property {AXES} AXES
 * @final
 */ const AXES = 'axes';
/**
 * @typedef {'label'} LABEL
 * @property {LABEL} LABEL
 * @final
 */ const LABEL = 'label';
/**
 * @typedef {'fallback'} FALLBACK
 * @property {FALLBACK} FALLBACK
 * @final
 */ const FALLBACK = 'fallback';
/**
 * @typedef {'contain'} CONTAIN
 * @property {CONTAIN} CONTAIN
 * @final
 */ const CONTAIN = 'contain';
/**
 * @typedef {'cover'} COVER
 * @property {COVER} COVER
 * @final
 */ const COVER = 'cover';
/**
 * @typedef {'unsigned-byte'} UNSIGNED_BYTE
 * @property {UNSIGNED_BYTE} UNSIGNED_BYTE
 * @final
 */ const UNSIGNED_BYTE = 'unsigned-byte';
/**
 * @typedef {'unsigned-int'} UNSIGNED_INT
 * @property {UNSIGNED_INT} UNSIGNED_INT
 * @final
 */ const UNSIGNED_INT = 'unsigned-int';
/**
 * @typedef {'float'} FLOAT
 * @property {FLOAT} FLOAT
 * @final
 */ const FLOAT = 'float';
/**
 * @typedef {'half-float'} HALF_FLOAT
 * @property {HALF_FLOAT} HALF_FLOAT
 * @final
 */ const HALF_FLOAT = 'half-float';
/**
 * The `splineProperty('ends')` mode where splines curve through
 * their first and last points.
 * @typedef {unique symbol} INCLUDE
 * @property {INCLUDE} INCLUDE
 * @final
 */ const INCLUDE = Symbol('include');
/**
 * The `splineProperty('ends')` mode where the first and last points in a spline
 * affect the direction of the curve, but are not rendered.
 * @typedef {unique symbol} EXCLUDE
 * @property {EXCLUDE} EXCLUDE
 * @final
 */ const EXCLUDE = Symbol('exclude');
/**
 * The `splineProperty('ends')` mode where the spline loops back to its first point.
 * Only used internally.
 * @typedef {unique symbol} JOIN
 * @property {JOIN} JOIN
 * @final
 * @private
 */ const JOIN = Symbol('join');
var constants = /*#__PURE__*/ Object.freeze({
    __proto__: null,
    ADD: ADD,
    ALT: ALT,
    ARROW: ARROW,
    AUTO: AUTO,
    AXES: AXES,
    BACKSPACE: BACKSPACE,
    BASELINE: BASELINE,
    BEVEL: BEVEL,
    BEZIER: BEZIER,
    BLEND: BLEND,
    BLUR: BLUR,
    BOLD: BOLD,
    BOLDITALIC: BOLDITALIC,
    BOTTOM: BOTTOM,
    BURN: BURN,
    CENTER: CENTER,
    CHAR: CHAR,
    CHORD: CHORD,
    CLAMP: CLAMP,
    CLOSE: CLOSE,
    CONTAIN: CONTAIN,
    CONTROL: CONTROL,
    CORNER: CORNER,
    CORNERS: CORNERS,
    COVER: COVER,
    CROSS: CROSS,
    CURVE: CURVE,
    DARKEST: DARKEST,
    DEG_TO_RAD: DEG_TO_RAD,
    DELETE: DELETE,
    DIFFERENCE: DIFFERENCE,
    DILATE: DILATE,
    DODGE: DODGE,
    DOWN_ARROW: DOWN_ARROW,
    EMPTY_PATH: EMPTY_PATH,
    ENTER: ENTER,
    ERODE: ERODE,
    ESCAPE: ESCAPE,
    EXCLUDE: EXCLUDE,
    EXCLUSION: EXCLUSION,
    FALLBACK: FALLBACK,
    FILL: FILL,
    FLAT: FLAT,
    FLOAT: FLOAT,
    FULL: FULL,
    GRAY: GRAY,
    GRID: GRID,
    HALF_FLOAT: HALF_FLOAT,
    HALF_PI: HALF_PI,
    HAND: HAND,
    HARD_LIGHT: HARD_LIGHT,
    IMAGE: IMAGE,
    IMMEDIATE: IMMEDIATE,
    INCLUDE: INCLUDE,
    INVERT: INVERT,
    ITALIC: ITALIC,
    JOIN: JOIN,
    LABEL: LABEL,
    LANDSCAPE: LANDSCAPE,
    LEFT: LEFT,
    LEFT_ARROW: LEFT_ARROW,
    LIGHTEST: LIGHTEST,
    LINEAR: LINEAR,
    LINES: LINES,
    LINE_LOOP: LINE_LOOP,
    LINE_STRIP: LINE_STRIP,
    MIRROR: MIRROR,
    MITER: MITER,
    MOVE: MOVE,
    MULTIPLY: MULTIPLY,
    NEAREST: NEAREST,
    NORMAL: NORMAL,
    OPAQUE: OPAQUE,
    OPEN: OPEN,
    OPTION: OPTION,
    OVERLAY: OVERLAY,
    P2D: P2D,
    P2DHDR: P2DHDR,
    PATH: PATH,
    PI: PI,
    PIE: PIE,
    POINTS: POINTS,
    PORTRAIT: PORTRAIT,
    POSTERIZE: POSTERIZE,
    PROJECT: PROJECT,
    QUADRATIC: QUADRATIC,
    QUADS: QUADS,
    QUAD_STRIP: QUAD_STRIP,
    QUARTER_PI: QUARTER_PI,
    RADIUS: RADIUS,
    RAD_TO_DEG: RAD_TO_DEG,
    REMOVE: REMOVE,
    REPEAT: REPEAT,
    REPLACE: REPLACE,
    RETURN: RETURN,
    RIGHT: RIGHT,
    RIGHT_ARROW: RIGHT_ARROW,
    ROUND: ROUND,
    SCREEN: SCREEN,
    SHIFT: SHIFT,
    SIMPLE: SIMPLE,
    SMOOTH: SMOOTH,
    SOFT_LIGHT: SOFT_LIGHT,
    SQUARE: SQUARE,
    STROKE: STROKE,
    SUBTRACT: SUBTRACT,
    TAB: TAB,
    TAU: TAU,
    TESS: TESS,
    TEXT: TEXT,
    TEXTURE: TEXTURE,
    THRESHOLD: THRESHOLD,
    TOP: TOP,
    TRIANGLES: TRIANGLES,
    TRIANGLE_FAN: TRIANGLE_FAN,
    TRIANGLE_STRIP: TRIANGLE_STRIP,
    TWO_PI: TWO_PI,
    UNSIGNED_BYTE: UNSIGNED_BYTE,
    UNSIGNED_INT: UNSIGNED_INT,
    UP_ARROW: UP_ARROW,
    VERSION: VERSION,
    WAIT: WAIT,
    WEBGL: WEBGL,
    WEBGL2: WEBGL2,
    WORD: WORD,
    _CTX_MIDDLE: _CTX_MIDDLE,
    _DEFAULT_FILL: _DEFAULT_FILL,
    _DEFAULT_LEADMULT: _DEFAULT_LEADMULT,
    _DEFAULT_STROKE: _DEFAULT_STROKE,
    _DEFAULT_TEXT_FILL: _DEFAULT_TEXT_FILL
});
;
}),
"[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>HSBSpace
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$space$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__ColorSpace$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/space.js [app-ssr] (ecmascript) <export default as ColorSpace>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$srgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__sRGB$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/srgb.js [app-ssr] (ecmascript) <export default as sRGB>");
;
var HSBSpace = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$space$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__ColorSpace$3e$__["ColorSpace"]({
    id: 'hsb',
    name: 'HSB',
    coords: {
        h: {
            refRange: [
                0,
                360
            ],
            type: 'angle',
            name: 'Hue'
        },
        s: {
            range: [
                0,
                100
            ],
            name: 'Saturation'
        },
        b: {
            range: [
                0,
                100
            ],
            name: 'Brightness'
        }
    },
    base: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$srgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__sRGB$3e$__["sRGB"],
    fromBase: (rgb)=>{
        const val = Math.max(...rgb);
        const chroma = val - Math.min(...rgb);
        let [red, green, blue] = rgb;
        let hue, sat;
        if (chroma === 0) {
            // Return early if grayscale.
            hue = 0;
            sat = 0;
        } else {
            sat = chroma / val;
            if (red === val) {
                // Magenta to yellow.
                hue = (green - blue) / chroma;
            } else if (green === val) {
                // Yellow to cyan.
                hue = 2 + (blue - red) / chroma;
            } else if (blue === val) {
                // Cyan to magenta.
                hue = 4 + (red - green) / chroma;
            }
            if (hue < 0) {
                // Confine hue to the interval [0, 1).
                hue += 6;
            } else if (hue >= 6) {
                hue -= 6;
            }
        }
        return [
            hue / 6 * 360,
            sat * 100,
            val * 100
        ];
    },
    toBase,
    formats: {
        default: {
            type: 'custom',
            serialize: (coords, alpha)=>{
                const rgb = toBase(coords);
                let ret = `rgb(${Math.round(rgb[0] * 100 * 100) / 100}% ${Math.round(rgb[1] * 100 * 100) / 100}% ${Math.round(rgb[2] * 100 * 100) / 100}%`;
                if (alpha < 1) {
                    ret += ` / ${alpha}`;
                }
                ret += ')';
                return ret;
            }
        },
        'hsb': {
            coords: [
                '<number> | <angle>',
                '<percentage>',
                '<percentage>'
            ]
        },
        'hsba': {
            coords: [
                '<number> | <angle>',
                '<percentage>',
                '<percentage>'
            ],
            commans: true,
            lastAlpha: true
        }
    }
});
function toBase(hsb) {
    const hue = hsb[0] / 360 * 6; // We will split hue into 6 sectors.
    const sat = hsb[1] / 100;
    const val = hsb[2] / 100;
    let RGB = [];
    if (sat === 0) {
        RGB = [
            val,
            val,
            val
        ]; // Return early if grayscale.
    } else {
        const sector = Math.floor(hue);
        const tint1 = val * (1 - sat);
        const tint2 = val * (1 - sat * (hue - sector));
        const tint3 = val * (1 - sat * (1 + sector - hue));
        let red, green, blue;
        if (sector === 1) {
            // Yellow to green.
            red = tint2;
            green = val;
            blue = tint1;
        } else if (sector === 2) {
            // Green to cyan.
            red = tint1;
            green = val;
            blue = tint3;
        } else if (sector === 3) {
            // Cyan to blue.
            red = tint1;
            green = tint2;
            blue = val;
        } else if (sector === 4) {
            // Blue to magenta.
            red = tint3;
            green = tint1;
            blue = val;
        } else if (sector === 5) {
            // Magenta to red.
            red = val;
            green = tint1;
            blue = tint2;
        } else {
            // Red to yellow (sector could be 0 or 6).
            red = val;
            green = tint3;
            blue = tint1;
        }
        RGB = [
            red,
            green,
            blue
        ];
    }
    return RGB;
}
;
}),
"[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>setting
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @module Color
 * @submodule Setting
 * @for p5
 * @requires core
 * @requires constants
 */ function setting(p51, fn) {
    /**
   * Starts defining a shape that will mask any shapes drawn afterward.
   *
   * Any shapes drawn between `beginClip()` and
   * <a href="#/p5/endClip">endClip()</a> will add to the mask shape. The mask
   * will apply to anything drawn after <a href="#/p5/endClip">endClip()</a>.
   *
   * The parameter, `options`, is optional. If an object with an `invert`
   * property is passed, as in `beginClip({ invert: true })`, it will be used to
   * set the masking mode. `{ invert: true }` inverts the mask, creating holes
   * in shapes that are masked. `invert` is `false` by default.
   *
   * Masks can be contained between the
   * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions.
   * Doing so allows unmasked shapes to be drawn after masked shapes.
   *
   * Masks can also be defined in a callback function that's passed to
   * <a href="#/p5/clip">clip()</a>.
   *
   * @method beginClip
   * @param {Object} [options] an object containing clip settings.
   * @param {Boolean} [options.invert=false] Whether or not to invert the mask.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a mask.
   *   beginClip();
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   *   endClip();
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *
   *   describe('A white triangle and circle on a gray background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an inverted mask.
   *   beginClip({ invert: true });
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   *   endClip();
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *
   *   describe('A white square at the top-left corner of a gray square. The white square has a triangle and a circle cut out of it.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   noStroke();
   *
   *   // Draw a masked shape.
   *   push();
   *   // Create a mask.
   *   beginClip();
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   *   endClip();
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *   pop();
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw an inverted masked shape.
   *   push();
   *   // Create an inverted mask.
   *   beginClip({ invert: true });
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   *   endClip();
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *   pop();
   *
   *   describe('In the top left, a white triangle and circle. In the bottom right, a white square with a triangle and circle cut out of it.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A silhouette of a rotating torus colored fuchsia.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a mask.
   *   beginClip();
   *   push();
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   scale(0.5);
   *   torus(30, 15);
   *   pop();
   *   endClip();
   *
   *   // Draw a backing shape.
   *   noStroke();
   *   fill('fuchsia');
   *   plane(100);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A silhouette of a rotating torus colored with a gradient from cyan to purple.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a mask.
   *   beginClip();
   *   push();
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   scale(0.5);
   *   torus(30, 15);
   *   pop();
   *   endClip();
   *
   *   // Draw a backing shape.
   *   noStroke();
   *   beginShape(QUAD_STRIP);
   *   fill(0, 255, 255);
   *   vertex(-width / 2, -height / 2);
   *   vertex(width / 2, -height / 2);
   *   fill(100, 0, 100);
   *   vertex(-width / 2, height / 2);
   *   vertex(width / 2, height / 2);
   *   endShape();
   * }
   * </code>
   * </div>
   */ fn.beginClip = function(options = {}) {
        this._renderer.beginClip(options);
    };
    /**
   * Ends defining a mask that was started with
   * <a href="#/p5/beginClip">beginClip()</a>.
   *
   * @method endClip
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a mask.
   *   beginClip();
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   *   endClip();
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *
   *   describe('A white triangle and circle on a gray background.');
   * }
   * </code>
   * </div>
   */ fn.endClip = function() {
        this._renderer.endClip();
    };
    /**
   * Defines a shape that will mask any shapes drawn afterward.
   *
   * The first parameter, `callback`, is a function that defines the mask.
   * Any shapes drawn in  `callback` will add to the mask shape. The mask
   * will apply to anything drawn after `clip()` is called.
   *
   * The second parameter, `options`, is optional. If an object with an `invert`
   * property is passed, as in `beginClip({ invert: true })`, it will be used to
   * set the masking mode. `{ invert: true }` inverts the mask, creating holes
   * in shapes that are masked. `invert` is `false` by default.
   *
   * Masks can be contained between the
   * <a href="#/p5/push">push()</a> and <a href="#/p5/pop">pop()</a> functions.
   * Doing so allows unmasked shapes to be drawn after masked shapes.
   *
   * Masks can also be defined with <a href="#/p5/beginClip">beginClip()</a>
   * and <a href="#/p5/endClip">endClip()</a>.
   *
   * @method clip
   * @param {Function} callback a function that draws the mask shape.
   * @param {Object} [options] an object containing clip settings.
   * @param {Boolean} [options.invert=false] Whether or not to invert the mask.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a mask.
   *   clip(mask);
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *
   *   describe('A white triangle and circle on a gray background.');
   * }
   *
   * // Declare a function that defines the mask.
   * function mask() {
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an inverted mask.
   *   clip(mask, { invert: true });
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *
   *   describe('A white square at the top-left corner of a gray square. The white square has a triangle and a circle cut out of it.');
   * }
   *
   * // Declare a function that defines the mask.
   * function mask() {
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   noStroke();
   *
   *   // Draw a masked shape.
   *   push();
   *   // Create a mask.
   *   clip(mask);
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *   pop();
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Draw an inverted masked shape.
   *   push();
   *   // Create an inverted mask.
   *   clip(mask, { invert: true });
   *
   *   // Draw a backing shape.
   *   square(5, 5, 45);
   *   pop();
   *
   *   describe('In the top left, a white triangle and circle. In the bottom right, a white square with a triangle and circle cut out of it.');
   * }
   *
   * // Declare a function that defines the mask.
   * function mask() {
   *   triangle(15, 37, 30, 13, 43, 37);
   *   circle(45, 45, 7);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A silhouette of a rotating torus colored fuchsia.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a mask.
   *   clip(mask);
   *
   *   // Draw a backing shape.
   *   noStroke();
   *   fill('fuchsia');
   *   plane(100);
   * }
   *
   * // Declare a function that defines the mask.
   * function mask() {
   *   push();
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   scale(0.5);
   *   torus(30, 15);
   *   pop();
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A silhouette of a rotating torus colored with a gradient from cyan to purple.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a mask.
   *   clip(mask);
   *
   *   // Draw a backing shape.
   *   noStroke();
   *   beginShape(QUAD_STRIP);
   *   fill(0, 255, 255);
   *   vertex(-width / 2, -height / 2);
   *   vertex(width / 2, -height / 2);
   *   fill(100, 0, 100);
   *   vertex(-width / 2, height / 2);
   *   vertex(width / 2, height / 2);
   *   endShape();
   * }
   *
   * // Declare a function that defines the mask.
   * function mask() {
   *   push();
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   scale(0.5);
   *   torus(30, 15);
   *   pop();
   * }
   * </code>
   * </div>
   */ fn.clip = function(callback, options) {
        this._renderer.beginClip(options);
        callback();
        this._renderer.endClip(options);
    };
    /**
   * Sets the color used for the background of the canvas.
   *
   * By default, the background is transparent. `background()` is typically used
   * within <a href="#/p5/draw">draw()</a> to clear the display window at the
   * beginning of each frame. It can also be used inside
   * <a href="#/p5/setup">setup()</a> to set the background on the first frame
   * of animation.
   *
   * The version of `background()` with one parameter interprets the value one
   * of four ways. If the parameter is a `Number`, it's interpreted as a grayscale
   * value. If the parameter is a `String`, it's interpreted as a CSS color string.
   * RGB, RGBA, HSL, HSLA, hex, and named color strings are supported. If the
   * parameter is a <a href="#/p5.Color">p5.Color</a> object, it will be used as
   * the background color. If the parameter is a
   * <a href="#/p5.Image">p5.Image</a> object, it will be used as the background
   * image.
   *
   * The version of `background()` with two parameters interprets the first one
   * as a grayscale value. The second parameter sets the alpha (transparency)
   * value.
   *
   * The version of `background()` with three parameters interprets them as RGB,
   * HSB, or HSL colors, depending on the current
   * <a href="#/p5/colorMode">colorMode()</a>. By default, colors are specified
   * in RGB values. Calling `background(255, 204, 0)` sets the background a bright
   * yellow color.
   *
   * The version of `background()` with four parameters interprets them as RGBA,
   * HSBA, or HSLA colors, depending on the current
   * <a href="#/p5/colorMode">colorMode()</a>. The last parameter sets the alpha
   * (transparency) value.
   *
   * @method background
   * @param {p5.Color} color  any value created by the <a href="#/p5/color">color()</a> function
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // A grayscale value.
   *   background(51);
   *
   *   describe('A canvas with a dark charcoal gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // A grayscale value and an alpha value.
   *   background(51, 0.4);
   *   describe('A canvas with a transparent gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // R, G & B values.
   *   background(255, 204, 0);
   *
   *   describe('A canvas with a yellow background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   * // R, G, B, and Alpha values.
   *   background(255, 0, 0, 128);
   *
   *   describe('A canvas with a semi-transparent red background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // H, S & B values.
   *   background(255, 204, 100);
   *
   *   describe('A canvas with a royal blue background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // A CSS named color.
   *   background('red');
   *
   *   describe('A canvas with a red background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Three-digit hex RGB notation.
   *   background('#fae');
   *
   *   describe('A canvas with a pink background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Six-digit hex RGB notation.
   *   background('#222222');
   *
   *   describe('A canvas with a black background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Integer RGB notation.
   *   background('rgb(0, 255, 0)');
   *
   *   describe('A canvas with a bright green background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Integer RGBA notation.
   *   background('rgba(0, 255, 0, 0.25)');
   *
   *   describe('A canvas with a transparent green background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Percentage RGB notation.
   *   background('rgb(100%, 0%, 10%)');
   *
   *   describe('A canvas with a red background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Percentage RGBA notation.
   *   background('rgba(100%, 0%, 100%, 0.5)');
   *
   *   describe('A canvas with a transparent purple background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // A p5.Color object.
   *   let c = color(0, 0, 255);
   *   background(c);
   *
   *   describe('A canvas with a blue background.');
   * }
   * </code>
   * </div>
   *
   */ /**
   * @method background
   * @param {String} colorstring color string, possible formats include: integer
   *                         rgb() or rgba(), percentage rgb() or rgba(),
   *                         3-digit hex, 6-digit hex.
   * @param {Number} [a]         opacity of the background relative to current
   *                             color range (default is 0-255).
   * @chainable
   */ /**
   * @method background
   * @param {Number} gray   specifies a value between white and black.
   * @param {Number} [a]
   * @chainable
   */ /**
   * @method background
   * @param {Number} v1     red value if color mode is RGB, or hue value if color mode is HSB.
   * @param {Number} v2     green value if color mode is RGB, or saturation value if color mode is HSB.
   * @param {Number} v3     blue value if color mode is RGB, or brightness value if color mode is HSB.
   * @param  {Number} [a]
   * @chainable
   */ /**
   * @method background
   * @param  {Number[]}      values  an array containing the red, green, blue
   *                                 and alpha components of the color.
   * @chainable
   */ /**
   * @method background
   * @param {p5.Image} image     image created with <a href="#/p5/loadImage">loadImage()</a>
   *                             or <a href="#/p5/createImage">createImage()</a>,
   *                             to set as background.
   *                             (must be same size as the sketch window).
   * @param  {Number}  [a]
   * @chainable
   */ fn.background = function(...args) {
        this._renderer.background(...args);
        return this;
    };
    /**
   * Clears the pixels on the canvas.
   *
   * `clear()` makes every pixel 100% transparent. Calling `clear()` doesn't
   * clear objects created by `createX()` functions such as
   * <a href="#/p5/createGraphics">createGraphics()</a>,
   * <a href="#/p5/createVideo">createVideo()</a>, and
   * <a href="#/p5/createImg">createImg()</a>. These objects will remain
   * unchanged after calling `clear()` and can be redrawn.
   *
   * In WebGL mode, this function can clear the screen to a specific color. It
   * interprets four numeric parameters as normalized RGBA color values. It also
   * clears the depth buffer. If you are not using the WebGL renderer, these
   * parameters will have no effect.
   *
   * @method clear
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A gray square. White circles are drawn as the user moves the mouse. The circles disappear when the user presses the mouse.');
   * }
   *
   * function draw() {
   *   circle(mouseX, mouseY, 20);
   * }
   *
   * function mousePressed() {
   *   clear();
   *   background(200);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *
   *   pg = createGraphics(60, 60);
   *   pg.background(200);
   *   pg.noStroke();
   *   pg.circle(pg.width / 2, pg.height / 2, 15);
   *   image(pg, 20, 20);
   *
   *   describe('A white circle drawn on a gray square. The square gets smaller when the mouse is pressed.');
   * }
   *
   * function mousePressed() {
   *   clear();
   *   image(pg, 20, 20);
   * }
   * </code>
   * </div>
   *
   * @param {Number} [r] normalized red value.
   * @param {Number} [g] normalized green value.
   * @param {Number} [b] normalized blue value.
   * @param {Number} [a] normalized alpha value.
   */ fn.clear = function(...args) {
        const _r = args[0] || 0;
        const _g = args[1] || 0;
        const _b = args[2] || 0;
        const _a = args[3] || 0;
        this._renderer.clear(_r, _g, _b, _a);
        return this;
    };
    /**
   * Changes the way color values are interpreted.
   *
   * By default, the `Number` parameters for <a href="#/p5/fill">fill()</a>,
   * <a href="#/p5/stroke">stroke()</a>,
   * <a href="#/p5/background">background()</a>, and
   * <a href="#/p5/color">color()</a> are defined by values between 0 and 255
   * using the RGB color model. This is equivalent to calling
   * `colorMode(RGB, 255)`. Pure red is `color(255, 0, 0)` in this model.
   *
   * Calling `colorMode(RGB, 100)` sets colors to use RGB color values
   * between 0 and 100. Pure red is `color(100, 0, 0)` in this model.
   *
   * Calling `colorMode(HSB)` or `colorMode(HSL)` changes to HSB or HSL systems instead of RGB.
   * Pure red is `color(0, 100, 100)` in HSB and `color(0, 100, 50)` in HSL.
   *
   * Some additional color modes that p5.js supports are:
   *
   * `RGBHDR` - High Dynamic Range RGB defined within the Display P3 color space.
   *          Colors are expressed with an extended dynamic range. To render these colors
   *          accurately, you must use the HDR canvas.
   *
   * `HWB`    - Hue, Whiteness, Blackness.
   *          Similar to HSB and HSL, this mode uses a hue angle.
   *          Instead of saturation and lightness, HWB defines colors based on the percentage
   *          of whiteness and blackness. This is the color model used by Chrome's GUI color picker.
   *          Pure red in HWB is represented as `color(0, 0, 0)` (i.e., hue 0 with 0% whiteness and 0% blackness).
   *
   *          <img src="assets/hwb.png"></img>
   *
   * `LAB`    - Also known as CIE Lab, this color mode defines colors with Lightness, Alpha, and Beta.
   *          It is widely used in professional color measurement contexts due to its perceptual uniformity.
   *
   * `LCH`    - A more intuitive representation of the CIE Lab color space using Lightness, Chroma, and Hue.
   *          This mode separates the color's chromatic intensity (chroma) from its lightness,
   *          simplifying color selection and manipulation.
   *
   * `OKLAB`  - A variant of the CIE Lab color space that corrects for non-uniformities inherent in LAB.
   *          The adjustment provides a more perceptually accurate and uniform representation,
   *          which is particularly beneficial for smooth color transitions.
   *
   * `OKLCH`  - An easier-to-use representation of OKLAB, expressing colors in terms of Lightness, Chroma, and Hue.
   *          This mode retains the perceptual benefits of OKLAB while offering a more intuitive format for color manipulation.
   *
   * <a href="#/p5.Color">p5.Color</a> objects remember the mode that they were
   * created in. Changing modes doesn't affect their appearance.
   *
   *  `Single-value (Grayscale) Colors`:
   *  When a color is specified with only one parameter (e.g., `color(g)`), p5.js will interpret it
   *  as a grayscale color. However, how that single parameter translates into a grayscale value
   *  depends on the color mode:
   *
   * - `RGB, HSB, and HSL`: In RGB, the single value is interpreted using the “blue” maximum
   *   (i.e., the single parameter is mapped to the blue channel's max).
   *   In HSB and HSL, the single value is mapped to Brightness and Lightness max respectively with hue=0 .
   *   and saturation=0.
   *
   * - `LAB, LCH, OKLAB, and OKLCH`: The single value is taken to be the `lightness (L)` component,
   *   with the specified max range for that channel.
   *
   * - `HWB`: Grayscale relies on both the `whiteness (W)` and `blackness (B)` channels. Since
   *   a single value cannot directly account for two distinct channels, the library uses an
   *   average of their max values to interpret the single grayscale parameter. For instance,
   *   if W has a max of 50 and B has a max of 100, then the single grayscale parameter
   *   is mapped using (50 + 100) / 2 = 75 as its effective maximum. More complex or negative
   *   ranges are currently not handled, so results in those cases may be ambiguous.
   *
   * @method colorMode
   * @param {RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH} mode   either RGB, HSB, HSL,
   *          or one of the extended modes described above.
   * @param {Number}  [max]  range for all values.
   * @return {RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH} The current color mode.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Fill with pure red.
   *   fill(255, 0, 0);
   *
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use RGB color with values in the range 0-100.
   *   colorMode(RGB, 100);
   *
   *   // Fill with pure red.
   *   fill(100, 0, 0);
   *
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Fill with pure red.
   *   fill(0, 100, 100);
   *
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Fill with pure red.
   *   fill(0, 100, 50);
   *
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Draw a neutral gray background using the default color mode.
   *   background(200);
   *
   *   // Switch to HWB color mode.
   *   // (Assuming p5.js supports HWB with a range of:
   *   // hue: 0–360, whiteness: 0–100, blackness: 0–100.)
   *   colorMode(HWB);
   *
   *   // Set fill to pure red in HWB.
   *   // Pure red in HWB is: hue = 0°, whiteness = 0%, blackness = 0%.
   *   fill(0, 0, 0);
   *
   *   // Draw a circle at the center.
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center, drawn using HWB color mode.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Draw a neutral gray background using the default color mode.
   *   background(200);
   *
   *   // Switch to LAB color mode.
   *   // In this mode, L typically ranges from 0 to 100 while a and b span roughly -128 to 127.
   *   colorMode(LAB);
   *
   *   // Set fill to pure red in LAB.
   *   // The sRGB red (255, 0, 0) converts approximately to LAB as:
   *   // L = 53, a = 80, b = 67.
   *   fill(53, 80, 67);
   *
   *   // Draw a circle at the center.
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center, drawn using LAB color mode.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Draw a neutral gray background.
   *   background(200);
   *
   *   // Switch to LCH color mode.
   *   // In LCH, colors are defined by Lightness, Chroma, and Hue (in degrees).
   *   colorMode(LCH);
   *
   *   // Set fill to an approximation of pure red in LCH:
   *   // Lightness ≈ 53, Chroma ≈ 104, Hue ≈ 40°.
   *   fill(53, 104, 40);
   *
   *   // Draw a circle at the center.
   *   circle(50, 50, 25);
   *
   *   describe('A gray square with a red circle at its center, drawn using LCH color mode.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use RGB color with values in the range 0-100.
   *   colorMode(RGB, 100);
   *
   *   for (let x = 0; x < 100; x += 1) {
   *     for (let y = 0; y < 100; y += 1) {
   *       stroke(x, y, 0);
   *       point(x, y);
   *     }
   *   }
   *
   *   describe(
   *     'A diagonal green to red gradient from bottom-left to top-right with shading transitioning to black at top-left corner.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use HSB color with values in the range 0-100.
   *   colorMode(HSB, 100);
   *
   *   for (let x = 0; x < 100; x += 1) {
   *     for (let y = 0; y < 100; y += 1) {
   *       stroke(x, y, 100);
   *       point(x, y);
   *     }
   *   }
   *
   *   describe('A rainbow gradient from left-to-right. Brightness transitions to white at the top.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Color object.
   *   let myColor = color(180, 175, 230);
   *   background(myColor);
   *
   *   // Use RGB color with values in the range 0-1.
   *   colorMode(RGB, 1);
   *
   *   // Get the red, green, and blue color components.
   *   let redValue = red(myColor);
   *   let greenValue = green(myColor);
   *   let blueValue = blue(myColor);
   *
   *   // Round the color components for display.
   *   redValue = round(redValue, 2);
   *   greenValue = round(greenValue, 2);
   *   blueValue = round(blueValue, 2);
   *
   *   // Display the color components.
   *   text(`Red: ${redValue}`, 10, 10, 80, 80);
   *   text(`Green: ${greenValue}`, 10, 40, 80, 80);
   *   text(`Blue: ${blueValue}`, 10, 70, 80, 80);
   *
   *   describe('A purple canvas with the red, green, and blue decimal values of the color written on it.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(255);
   *
   *   // Use RGB color with alpha values in the range 0-1.
   *   colorMode(RGB, 255, 255, 255, 1);
   *
   *   noFill();
   *   strokeWeight(4);
   *   stroke(255, 0, 10, 0.3);
   *   circle(40, 40, 50);
   *   circle(50, 60, 50);
   *
   *   describe('Two overlapping translucent pink circle outlines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * let hslGraphic, lchGraphic, oklchGraphic;
   *
   * function setup() {
   *   createCanvas(600, 200);
   *   noLoop();
   *
   *   // Create three graphics objects for HSL, LCH, and OKLCH color modes
   *   hslGraphic = createGraphics(200, 200);
   *   lchGraphic = createGraphics(200, 200);
   *   oklchGraphic = createGraphics(200, 200);
   *
   *   // Draw HSL color wheel
   *   colorMode(HSL);
   *   hslGraphic.translate(100, 100);
   *   for (let i = 0; i < 1000; i++) {
   *     hslGraphic.stroke(360 / 1000 * i, 70, 50);
   *     hslGraphic.line(0, 0, hslGraphic.width / 2, 0);
   *     hslGraphic.rotate(TAU / 1000);
   *   }
   *
   *   // Draw LCH color wheel
   *   colorMode(LCH);
   *   lchGraphic.translate(100, 100);
   *   for (let i = 0; i < 1000; i++) {
   *     lchGraphic.stroke(54, 106, 360 / 1000 * i);
   *     lchGraphic.line(0, 0, lchGraphic.width / 2, 0);
   *     lchGraphic.rotate(TAU / 1000);
   *   }
   *
   *   // Draw OKLCH color wheel
   *   colorMode(OKLCH);
   *   oklchGraphic.translate(100, 100);
   *   for (let i = 0; i < 1000; i++) {
   *     oklchGraphic.stroke(54, 106, 360 / 1000 * i);
   *     oklchGraphic.line(0, 0, oklchGraphic.width / 2, 0);
   *     oklchGraphic.rotate(TAU / 1000);
   *   }
   * }
   *
   * function draw() {
   *   // Set the styles
   *   colorMode(RGB);
   *   background(220);
   *
   *   // Display the color wheels
   *   image(hslGraphic, 0, 0);
   *   image(lchGraphic, 200, 0);
   *   image(oklchGraphic, 400, 0);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * // Example: Single-value (Grayscale) colors in different color modes.
   * // The rectangle is filled with one parameter, but its final color depends
   * // on how that parameter is interpreted by the current color mode.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *   noStroke();
   *   noLoop();
   * }
   *
   * function draw() {
   *   // Set color mode to RGB with range 0-255
   *   colorMode(RGB, 255);
   *
   *   // Fill with single grayscale value
   *   fill(128);
   *   rect(0, 0, 100, 100);
   *
   *   // Add text label
   *   fill(0); // Switch to black text for clarity
   *   textSize(14);
   *   text("RGB (128)", 10, 20);
   * }
   * </code>
   * </div>
   */ /**
   * @method colorMode
   * @param {RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH} mode
   * @param {Number} max1     range for the red or hue depending on the
   *                              current color mode.
   * @param {Number} max2     range for the green or saturation depending
   *                              on the current color mode.
   * @param {Number} max3     range for the blue or brightness/lightness
   *                              depending on the current color mode.
   * @param {Number} [maxA]   range for the alpha.
   *
   * @return {RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH} The current color mode.
   */ /**
   * @method colorMode
   * @return {RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH} The current color mode.
   */ fn.colorMode = function(mode, max1, max2, max3, maxA) {
        // p5._validateParameters('colorMode', arguments);
        if ([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["H"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["L"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["O"],
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]
        ].includes(mode)) {
            // Set color mode.
            this._renderer.states.setValue('colorMode', mode);
            // Set color maxes.
            this._renderer.states.setValue('colorMaxes', this._renderer.states.colorMaxes.clone());
            const maxes = this._renderer.states.colorMaxes[mode];
            if (arguments.length === 2) {
                maxes[0] = max1; // Red
                maxes[1] = max1; // Green
                maxes[2] = max1; // Blue
                maxes[3] = max1; // Alpha
            } else if (arguments.length === 4) {
                maxes[0] = max1; // Red
                maxes[1] = max2; // Green
                maxes[2] = max3; // Blue
            } else if (arguments.length === 5) {
                maxes[0] = max1; // Red
                maxes[1] = max2; // Green
                maxes[2] = max3; // Blue
                maxes[3] = maxA; // Alpha
            }
        }
        return this._renderer.states.colorMode;
    };
    /**
   * Sets the color used to fill shapes.
   *
   * Calling `fill(255, 165, 0)` or `fill('orange')` means all shapes drawn
   * after the fill command will be filled with the color orange.
   *
   * The version of `fill()` with one parameter interprets the value one of
   * three ways. If the parameter is a `Number`, it's interpreted as a grayscale
   * value. If the parameter is a `String`, it's interpreted as a CSS color
   * string. A <a href="#/p5.Color">p5.Color</a> object can also be provided to
   * set the fill color.
   *
   * The version of `fill()` with three parameters interprets them as RGB, HSB,
   * or HSL colors, depending on the current
   * <a href="#/p5/colorMode">colorMode()</a>. The default color space is RGB,
   * with each value in the range from 0 to 255.
   *
   * The version of `fill()` with four parameters interprets them as `RGBA`, `HSBA`,
   * or `HSLA` colors, depending on the current <a href="#/p5/colorMode">colorMode()</a>. The last parameter
   * sets the alpha (transparency) value.
   *
   * @method fill
   * @param  {Number}        v1      red value if color mode is RGB or hue value if color mode is HSB.
   * @param  {Number}        v2      green value if color mode is RGB or saturation value if color mode is HSB.
   * @param  {Number}        v3      blue value if color mode is RGB or brightness value if color mode is HSB.
   * @param  {Number}        [alpha] alpha value, controls transparency (0 - transparent, 255 - opaque).
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A grayscale value.
   *   fill(51);
   *   square(20, 20, 60);
   *
   *   describe('A dark charcoal gray square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // R, G & B values.
   *   fill(255, 204, 0);
   *   square(20, 20, 60);
   *
   *   describe('A yellow square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // R, G, B, and Alpha values.
   *   fill(255, 0, 0, 128);
   *   square(20, 20, 60);
   *
   *   describe('A semi-transparent red square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(100);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // H, S & B values.
   *   fill(255, 204, 100);
   *   square(20, 20, 60);
   *
   *   describe('A royal blue square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A CSS named color.
   *   fill('red');
   *   square(20, 20, 60);
   *
   *   describe('A red square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Three-digit hex RGB notation.
   *   fill('#fae');
   *   square(20, 20, 60);
   *
   *   describe('A pink square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Six-digit hex RGB notation.
   *   fill('#A251FA');
   *   square(20, 20, 60);
   *
   *   describe('A purple square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Integer RGB notation.
   *   fill('rgb(0, 255, 0)');
   *   square(20, 20, 60);
   *
   *   describe('A bright green square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Integer RGBA notation.
   *   fill('rgba(0, 255, 0, 0.25)');
   *   square(20, 20, 60);
   *
   *   describe('A soft green rectange with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Percentage RGB notation.
   *   fill('rgb(100%, 0%, 10%)');
   *   square(20, 20, 60);
   *
   *   describe('A red square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Percentage RGBA notation.
   *   fill('rgba(100%, 0%, 100%, 0.5)');
   *   square(20, 20, 60);
   *
   *   describe('A dark fuchsia square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A p5.Color object.
   *   let c = color(0, 0, 255);
   *   fill(c);
   *   square(20, 20, 60);
   *
   *   describe('A blue square with a black outline.');
   * }
   * </code>
   * </div>
   */ /**
   * @method fill
   * @param  {String}        value   a color string.
   * @chainable
   */ /**
   * @method fill
   * @param  {Number}        gray   a grayscale value.
   * @param  {Number}        [alpha]
   * @chainable
   */ /**
   * @method fill
   * @param  {Number[]}      values  an array containing the red, green, blue &
   *                                 and alpha components of the color.
   * @chainable
   */ /**
   * @method fill
   * @param  {p5.Color}      color   the fill color.
   * @chainable
   */ fn.fill = function(...args) {
        this._renderer.fill(...args);
        return this;
    };
    /**
   * Disables setting the fill color for shapes.
   *
   * Calling `noFill()` is the same as making the fill completely transparent,
   * as in `fill(0, 0)`. If both <a href="#/p5/noStroke">noStroke()</a> and
   * `noFill()` are called, nothing will be drawn to the screen.
   *
   * @method noFill
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw the top square.
   *   square(32, 10, 35);
   *
   *   // Draw the bottom square.
   *   noFill();
   *   square(32, 55, 35);
   *
   *   describe('A white square on above an empty square. Both squares have black outlines.');
   * }
   * </code>
   * </div>
   *
   * <div modernizr='webgl'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A purple cube wireframe spinning on a black canvas.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Style the box.
   *   noFill();
   *   stroke(100, 100, 240);
   *
   *   // Rotate the coordinates.
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the box.
   *   box(45);
   * }
   * </code>
   * </div>
   */ fn.noFill = function() {
        this._renderer.noFill();
        return this;
    };
    /**
   * Disables drawing points, lines, and the outlines of shapes.
   *
   * Calling `noStroke()` is the same as making the stroke completely transparent,
   * as in `stroke(0, 0)`. If both `noStroke()` and
   * <a href="#/p5/noFill">noFill()</a> are called, nothing will be drawn to the
   * screen.
   *
   * @method noStroke
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   noStroke();
   *   square(20, 20, 60);
   *
   *   describe('A white square with no outline.');
   * }
   * </code>
   * </div>
   *
   * <div modernizr='webgl'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A pink cube with no edge outlines spinning on a black canvas.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Style the box.
   *   noStroke();
   *   fill(240, 150, 150);
   *
   *   // Rotate the coordinates.
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the box.
   *   box(45);
   * }
   * </code>
   * </div>
   */ fn.noStroke = function() {
        this._renderer.states.setValue('strokeColor', null);
        return this;
    };
    /**
   * Sets the color used to draw points, lines, and the outlines of shapes.
   *
   * Calling `stroke(255, 165, 0)` or `stroke('orange')` means all shapes drawn
   * after calling `stroke()` will be outlined with the color orange. The way
   * these parameters are interpreted may be changed with the
   * <a href="#/p5/colorMode">colorMode()</a> function.
   *
   * The version of `stroke()` with one parameter interprets the value one of
   * three ways. If the parameter is a `Number`, it's interpreted as a grayscale
   * value. If the parameter is a `String`, it's interpreted as a CSS color
   * string. A <a href="#/p5.Color">p5.Color</a> object can also be provided to
   * set the stroke color.
   *
   * The version of `stroke()` with two parameters interprets the first one as a
   * grayscale value. The second parameter sets the alpha (transparency) value.
   *
   * The version of `stroke()` with three parameters interprets them as RGB, HSB,
   * or HSL colors, depending on the current `colorMode()`.
   *
   * The version of `stroke()` with four parameters interprets them as RGBA, HSBA,
   * or HSLA colors, depending on the current `colorMode()`. The last parameter
   * sets the alpha (transparency) value.
   *
   * @method stroke
   * @param  {Number}        v1      red value if color mode is RGB or hue value if color mode is HSB.
   * @param  {Number}        v2      green value if color mode is RGB or saturation value if color mode is HSB.
   * @param  {Number}        v3      blue value if color mode is RGB or brightness value if color mode is HSB.
   * @param  {Number}        [alpha] alpha value, controls transparency (0 - transparent, 255 - opaque).
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A grayscale value.
   *   strokeWeight(4);
   *   stroke(51);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a dark charcoal gray outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // R, G & B values.
   *   stroke(255, 204, 0);
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a yellow outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // H, S & B values.
   *   strokeWeight(4);
   *   stroke(255, 204, 100);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a royal blue outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A CSS named color.
   *   stroke('red');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a red outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Three-digit hex RGB notation.
   *   stroke('#fae');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a pink outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Six-digit hex RGB notation.
   *   stroke('#222222');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a black outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Integer RGB notation.
   *   stroke('rgb(0, 255, 0)');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a bright green outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Integer RGBA notation.
   *   stroke('rgba(0, 255, 0, 0.25)');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a soft green outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Percentage RGB notation.
   *   stroke('rgb(100%, 0%, 10%)');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a red outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Percentage RGBA notation.
   *   stroke('rgba(100%, 0%, 100%, 0.5)');
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a dark fuchsia outline.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // A p5.Color object.
   *   stroke(color(0, 0, 255));
   *   strokeWeight(4);
   *   square(20, 20, 60);
   *
   *   describe('A white square with a blue outline.');
   * }
   * </code>
   * </div>
   */ /**
   * @method stroke
   * @param  {String}        value   a color string.
   * @chainable
   */ /**
   * @method stroke
   * @param  {Number}        gray   a grayscale value.
   * @param  {Number}        [alpha]
   * @chainable
   */ /**
   * @method stroke
   * @param  {Number[]}      values  an array containing the red, green, blue,
   *                                 and alpha components of the color.
   * @chainable
   */ /**
   * @method stroke
   * @param  {p5.Color}      color   the stroke color.
   * @chainable
   */ fn.stroke = function(...args) {
        this._renderer.stroke(...args);
        return this;
    };
    /**
   * Starts using shapes to erase parts of the canvas.
   *
   * All drawing that follows `erase()` will subtract from the canvas, revealing
   * the web page underneath. The erased areas will become transparent, allowing
   * the content behind the canvas to show through. The
   * <a href="#/p5/fill">fill()</a>, <a href="#/p5/stroke">stroke()</a>, and
   * <a href="#/p5/blendMode">blendMode()</a> have no effect once `erase()` is
   * called.
   *
   * The `erase()` function has two optional parameters. The first parameter
   * sets the strength of erasing by the shape's interior. A value of 0 means
   * that no erasing will occur. A value of 255 means that the shape's interior
   * will fully erase the content underneath. The default value is 255
   * (full strength).
   *
   * The second parameter sets the strength of erasing by the shape's edge. A
   * value of 0 means that no erasing will occur. A value of 255 means that the
   * shape's edge will fully erase the content underneath. The default value is
   * 255 (full strength).
   *
   * To cancel the erasing effect, use the <a href="#/p5/noErase">noErase()</a>
   * function.
   *
   * `erase()` has no effect on drawing done with the
   * <a href="#/p5/image">image()</a> and
   * <a href="#/p5/background">background()</a> functions.
   *
   * @method erase
   * @param  {Number}   [strengthFill]      a number (0-255) for the strength of erasing under a shape's interior.
   *                                        Defaults to 255, which is full strength.
   * @param  {Number}   [strengthStroke]    a number (0-255) for the strength of erasing under a shape's edge.
   *                                        Defaults to 255, which is full strength.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(100, 100, 250);
   *
   *   // Draw a pink square.
   *   fill(250, 100, 100);
   *   square(20, 20, 60);
   *
   *   // Erase a circular area.
   *   erase();
   *   circle(25, 30, 30);
   *   noErase();
   *
   *   describe('A purple canvas with a pink square in the middle. A circle is erased from the top-left, leaving a hole.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(100, 100, 250);
   *
   *   // Draw a pink square.
   *   fill(250, 100, 100);
   *   square(20, 20, 60);
   *
   *   // Erase a circular area.
   *   strokeWeight(5);
   *   erase(150, 255);
   *   circle(25, 30, 30);
   *   noErase();
   *
   *   describe('A purple canvas with a pink square in the middle. A circle at the top-left partially erases its interior and a fully erases its outline.');
   * }
   * </code>
   * </div>
   */ fn.erase = function(opacityFill = 255, opacityStroke = 255) {
        this._renderer.erase(opacityFill, opacityStroke);
        return this;
    };
    /**
   * Ends erasing that was started with <a href="#/p5/erase">erase()</a>.
   *
   * The <a href="#/p5/fill">fill()</a>, <a href="#/p5/stroke">stroke()</a>, and
   * <a href="#/p5/blendMode">blendMode()</a> settings will return to what they
   * were prior to calling <a href="#/p5/erase">erase()</a>.
   *
   * @method noErase
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(235, 145, 15);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(30, 45, 220);
   *   rect(30, 10, 10, 80);
   *
   *   // Erase a circle.
   *   erase();
   *   circle(50, 50, 60);
   *   noErase();
   *
   *   // Draw the right rectangle.
   *   rect(70, 10, 10, 80);
   *
   *   describe('An orange canvas with two tall blue rectangles. A circular hole in the center erases the rectangle on the left but not the one on the right.');
   * }
   * </code>
   * </div>
   */ fn.noErase = function() {
        this._renderer.noErase();
        return this;
    };
    /**
   * Sets the way colors blend when added to the canvas.
   *
   * By default, drawing with a solid color paints over the current pixel values
   * on the canvas. `blendMode()` offers many options for blending colors.
   *
   * Shapes, images, and text can be used as sources for drawing to the canvas.
   * A source pixel changes the color of the canvas pixel where it's drawn. The
   * final color results from blending the source pixel's color with the canvas
   * pixel's color. RGB color values from the source and canvas pixels are
   * compared, added, subtracted, multiplied, and divided to create different
   * effects. Red values with red values, greens with greens, and blues with
   * blues.
   *
   * The parameter, `mode`, sets the blend mode. For example, calling
   * `blendMode(ADD)` sets the blend mode to `ADD`. The following blend modes
   * are available in both 2D and WebGL mode:
   *
   * - `BLEND`: color values from the source overwrite the canvas. This is the default mode.
   * - `ADD`: color values from the source are added to values from the canvas.
   * - `DARKEST`: keeps the darkest color value.
   * - `LIGHTEST`: keeps the lightest color value.
   * - `EXCLUSION`: similar to `DIFFERENCE` but with less contrast.
   * - `MULTIPLY`: color values from the source are multiplied with values from the canvas. The result is always darker.
   * - `SCREEN`: all color values are inverted, then multiplied, then inverted again. The result is always lighter. (Opposite of `MULTIPLY`)
   * - `REPLACE`: the last source drawn completely replaces the rest of the canvas.
   * - `REMOVE`: overlapping pixels are removed by making them completely transparent.
   *
   * The following blend modes are only available in 2D mode:
   *
   * - `DIFFERENCE`: color values from the source are subtracted from the values from the canvas. If the difference is a negative number, it's made positive.
   * - `OVERLAY`: combines `MULTIPLY` and `SCREEN`. Dark values in the canvas get darker and light values get lighter.
   * - `HARD_LIGHT`: combines `MULTIPLY` and `SCREEN`. Dark values in the source get darker and light values get lighter.
   * - `SOFT_LIGHT`: a softer version of `HARD_LIGHT`.
   * - `DODGE`: lightens light tones and increases contrast. Divides the canvas color values by the inverted color values from the source.
   * - `BURN`: darkens dark tones and increases contrast. Divides the source color values by the inverted color values from the canvas, then inverts the result.
   *
   * The following blend modes are only available in WebGL mode:
   *
   * - `SUBTRACT`: RGB values from the source are subtracted from the values from the canvas. If the difference is a negative number, it's made positive. Alpha (transparency) values from the source and canvas are added.
   *
   * @method blendMode
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT)} mode blend mode to set.
   *                either BLEND, DARKEST, LIGHTEST, DIFFERENCE, MULTIPLY,
   *                EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,
   *                SOFT_LIGHT, DODGE, BURN, ADD, REMOVE or SUBTRACT
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use the default blend mode.
   *   blendMode(BLEND);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A blue line and a red line form an X on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(ADD);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is faint magenta.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(DARKEST);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A blue line and a red line form an X on a gray background. The area where they overlap is black.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(LIGHTEST);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is faint magenta.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(EXCLUSION);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A yellow line and a cyan line form an X on a gray background. The area where they overlap is green.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(MULTIPLY);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A blue line and a red line form an X on a gray background. The area where they overlap is black.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(SCREEN);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is faint magenta.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(REPLACE);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A diagonal red line.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(REMOVE);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('The silhouette of an X is missing from a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(DIFFERENCE);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A yellow line and a cyan line form an X on a gray background. The area where they overlap is green.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(OVERLAY);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is bright magenta.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(HARD_LIGHT);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A blue line and a red line form an X on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(SOFT_LIGHT);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is violet.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(DODGE);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A faint blue line and a faint red line form an X on a gray background. The area where they overlap is faint violet.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(BURN);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A blue line and a red line form an X on a gray background. The area where they overlap is black.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the blend mode.
   *   blendMode(SUBTRACT);
   *
   *   // Style the lines.
   *   strokeWeight(30);
   *
   *   // Draw the blue line.
   *   stroke('blue');
   *   line(25, 25, 75, 75);
   *
   *   // Draw the red line.
   *   stroke('red');
   *   line(75, 25, 25, 75);
   *
   *   describe('A yellow line and a turquoise line form an X on a gray background. The area where they overlap is green.');
   * }
   * </code>
   * </div>
   */ fn.blendMode = function(mode) {
        // p5._validateParameters('blendMode', arguments);
        if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"]) {
            // Warning added 3/26/19, can be deleted in future (1.0 release?)
            console.warn('NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead.');
            mode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"];
        }
        this._renderer.blendMode(mode);
    };
}
if (typeof p5 !== 'undefined') {
    setting(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/color/color_conversion.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>color_conversion
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/structure.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/environment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Color
 * @submodule Color Conversion
 * @for p5
 * @requires core
 */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"].ColorConversion = {
    /**
   * Convert an HSBA array to HSLA.
   */ _hsbaToHSLA (hsba) {
        const hue = hsba[0];
        let sat = hsba[1];
        const val = hsba[2];
        // Calculate lightness.
        const li = (2 - sat) * val / 2;
        // Convert saturation.
        if (li !== 0) {
            if (li === 1) {
                sat = 0;
            } else if (li < 0.5) {
                sat = sat / (2 - sat);
            } else {
                sat = sat * val / (2 - li * 2);
            }
        }
        // Hue and alpha stay the same.
        return [
            hue,
            sat,
            li,
            hsba[3]
        ];
    },
    /**
   * Convert an HSBA array to RGBA.
   */ _hsbaToRGBA (hsba) {
        const hue = hsba[0] * 6; // We will split hue into 6 sectors.
        const sat = hsba[1];
        const val = hsba[2];
        let RGBA = [];
        if (sat === 0) {
            RGBA = [
                val,
                val,
                val,
                hsba[3]
            ]; // Return early if grayscale.
        } else {
            const sector = Math.floor(hue);
            const tint1 = val * (1 - sat);
            const tint2 = val * (1 - sat * (hue - sector));
            const tint3 = val * (1 - sat * (1 + sector - hue));
            let red, green, blue;
            if (sector === 1) {
                // Yellow to green.
                red = tint2;
                green = val;
                blue = tint1;
            } else if (sector === 2) {
                // Green to cyan.
                red = tint1;
                green = val;
                blue = tint3;
            } else if (sector === 3) {
                // Cyan to blue.
                red = tint1;
                green = tint2;
                blue = val;
            } else if (sector === 4) {
                // Blue to magenta.
                red = tint3;
                green = tint1;
                blue = val;
            } else if (sector === 5) {
                // Magenta to red.
                red = val;
                green = tint1;
                blue = tint2;
            } else {
                // Red to yellow (sector could be 0 or 6).
                red = val;
                green = tint3;
                blue = tint1;
            }
            RGBA = [
                red,
                green,
                blue,
                hsba[3]
            ];
        }
        return RGBA;
    },
    /**
   * Convert an HSLA array to HSBA.
   */ _hslaToHSBA (hsla) {
        const hue = hsla[0];
        let sat = hsla[1];
        const li = hsla[2];
        // Calculate brightness.
        let val;
        if (li < 0.5) {
            val = (1 + sat) * li;
        } else {
            val = li + sat - li * sat;
        }
        // Convert saturation.
        sat = 2 * (val - li) / val;
        // Hue and alpha stay the same.
        return [
            hue,
            sat,
            val,
            hsla[3]
        ];
    },
    /**
   * Convert an HSLA array to RGBA.
   *
   * We need to change basis from HSLA to something that can be more easily be
   * projected onto RGBA. We will choose hue and brightness as our first two
   * components, and pick a convenient third one ('zest') so that we don't need
   * to calculate formal HSBA saturation.
   */ _hslaToRGBA (hsla) {
        const hue = hsla[0] * 6; // We will split hue into 6 sectors.
        const sat = hsla[1];
        const li = hsla[2];
        let RGBA = [];
        if (sat === 0) {
            RGBA = [
                li,
                li,
                li,
                hsla[3]
            ]; // Return early if grayscale.
        } else {
            // Calculate brightness.
            let val;
            if (li < 0.5) {
                val = (1 + sat) * li;
            } else {
                val = li + sat - li * sat;
            }
            // Define zest.
            const zest = 2 * li - val;
            // Implement projection (project onto green by default).
            const hzvToRGB = (hue, zest, val)=>{
                if (hue < 0) {
                    // Hue must wrap to allow projection onto red and blue.
                    hue += 6;
                } else if (hue >= 6) {
                    hue -= 6;
                }
                if (hue < 1) {
                    // Red to yellow (increasing green).
                    return zest + (val - zest) * hue;
                } else if (hue < 3) {
                    // Yellow to cyan (greatest green).
                    return val;
                } else if (hue < 4) {
                    // Cyan to blue (decreasing green).
                    return zest + (val - zest) * (4 - hue);
                } else {
                    // Blue to red (least green).
                    return zest;
                }
            };
            // Perform projections, offsetting hue as necessary.
            RGBA = [
                hzvToRGB(hue + 2, zest, val),
                hzvToRGB(hue, zest, val),
                hzvToRGB(hue - 2, zest, val),
                hsla[3]
            ];
        }
        return RGBA;
    },
    /**
   * Convert an RGBA array to HSBA.
   */ _rgbaToHSBA (rgba) {
        const red = rgba[0];
        const green = rgba[1];
        const blue = rgba[2];
        const val = Math.max(red, green, blue);
        const chroma = val - Math.min(red, green, blue);
        let hue, sat;
        if (chroma === 0) {
            // Return early if grayscale.
            hue = 0;
            sat = 0;
        } else {
            sat = chroma / val;
            if (red === val) {
                // Magenta to yellow.
                hue = (green - blue) / chroma;
            } else if (green === val) {
                // Yellow to cyan.
                hue = 2 + (blue - red) / chroma;
            } else if (blue === val) {
                // Cyan to magenta.
                hue = 4 + (red - green) / chroma;
            }
            if (hue < 0) {
                // Confine hue to the interval [0, 1).
                hue += 6;
            } else if (hue >= 6) {
                hue -= 6;
            }
        }
        return [
            hue / 6,
            sat,
            val,
            rgba[3]
        ];
    },
    /**
   * Convert an RGBA array to HSLA.
   */ _rgbaToHSLA (rgba) {
        const red = rgba[0];
        const green = rgba[1];
        const blue = rgba[2];
        const val = Math.max(red, green, blue);
        const min = Math.min(red, green, blue);
        const li = val + min; // We will halve this later.
        const chroma = val - min;
        let hue, sat;
        if (chroma === 0) {
            // Return early if grayscale.
            hue = 0;
            sat = 0;
        } else {
            if (li < 1) {
                sat = chroma / li;
            } else {
                sat = chroma / (2 - li);
            }
            if (red === val) {
                // Magenta to yellow.
                hue = (green - blue) / chroma;
            } else if (green === val) {
                // Yellow to cyan.
                hue = 2 + (blue - red) / chroma;
            } else if (blue === val) {
                // Cyan to magenta.
                hue = 4 + (red - green) / chroma;
            }
            if (hue < 0) {
                // Confine hue to the interval [0, 1).
                hue += 6;
            } else if (hue >= 6) {
                hue -= 6;
            }
        }
        return [
            hue / 6,
            sat,
            li / 2,
            rgba[3]
        ];
    }
};
var color_conversion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"].ColorConversion;
;
}),
"[project]/node_modules/p5/dist/color/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>color
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
;
;
;
;
;
function color(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "C",
    ()=>Color,
    "H",
    ()=>HSB,
    "L",
    ()=>LAB,
    "O",
    ()=>OKLAB,
    "R",
    ()=>RGB,
    "a",
    ()=>color,
    "b",
    ()=>RGBHDR,
    "c",
    ()=>creatingReading,
    "d",
    ()=>HSL,
    "e",
    ()=>HWB,
    "f",
    ()=>LCH,
    "g",
    ()=>OKLCH,
    "h",
    ()=>RGBA
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$srgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__sRGB$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/srgb.js [app-ssr] (ecmascript) <export default as sRGB>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$p3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__P3$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/p3.js [app-ssr] (ecmascript) <export default as P3>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HSL$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/hsl.js [app-ssr] (ecmascript) <export default as HSL>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hwb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HWB$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/hwb.js [app-ssr] (ecmascript) <export default as HWB>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Lab$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/lab.js [app-ssr] (ecmascript) <export default as Lab>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__LCH$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/lch.js [app-ssr] (ecmascript) <export default as LCH>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLab$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/oklab.js [app-ssr] (ecmascript) <export default as OKLab>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLCH$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/spaces/oklch.js [app-ssr] (ecmascript) <export default as OKLCH>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$space$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__ColorSpace$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/space.js [app-ssr] (ecmascript) <export default as ColorSpace>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/to.js [app-ssr] (ecmascript) <export default as to>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__parse$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/parse.js [app-ssr] (ecmascript) <export default as parse>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$interpolation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/interpolation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$serialize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__serialize$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/serialize.js [app-ssr] (ecmascript) <export default as serialize>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$APCA$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastAPCA$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/contrast/APCA.js [app-ssr] (ecmascript) <export default as contrastAPCA>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$WCAG21$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastWCAG21$3e$__ = __turbopack_context__.i("[project]/node_modules/colorjs.io/src/contrast/WCAG21.js [app-ssr] (ecmascript) <export default as contrastWCAG21>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
;
;
/**
 * @module Color
 * @submodule Creating & Reading
 * @for p5
 * @requires core
 * @requires color_conversion
 */ const map = (n, start1, stop1, start2, stop2, clamp)=>{
    let result = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    if (clamp) {
        result = Math.max(result, Math.min(start2, stop2));
        result = Math.min(result, Math.max(start2, stop2));
    }
    return result;
};
const serializationMap = {};
class Color {
    // Reference to underlying color object depending on implementation
    // Not meant to be used publicly unless the implementation is known for sure
    _color;
    // Color mode of the Color object, uses p5 color modes
    mode;
    static colorMap = {};
    static #colorjsMaxes = {};
    static #grayscaleMap = {};
    // Used to add additional color modes to p5.js
    // Uses underlying library's definition
    static addColorMode(mode, definition) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$space$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__ColorSpace$3e$__["ColorSpace"].register(definition);
        Color.colorMap[mode] = definition.id;
        // Get colorjs maxes
        Color.#colorjsMaxes[mode] = Object.values(definition.coords).reduce((acc, v)=>{
            acc.push(v.refRange || v.range);
            return acc;
        }, []);
        Color.#colorjsMaxes[mode].push([
            0,
            1
        ]);
        // Get grayscale mapping
        Color.#grayscaleMap[mode] = definition.fromGray;
    }
    constructor(vals, colorMode, colorMaxes, { clamp = false } = {}){
        // This changes with the color object
        this.mode = colorMode || RGB;
        if (vals instanceof Color) {
            // Received Color object to be used for color mode conversion
            const mode = colorMode ? Color.colorMap[colorMode] : Color.colorMap[vals.mode];
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(vals._color, mode);
            this.mode = mode;
        } else if (typeof vals === 'object' && !Array.isArray(vals) && vals !== null) {
            // Received color.js object to be used internally
            const mode = colorMode ? Color.colorMap[colorMode] : vals.spaceId;
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(vals, mode);
            this.mode = colorMode || Object.entries(Color.colorMap).find(([key, val])=>{
                return val === this._color.spaceId;
            });
        } else if (typeof vals[0] === 'string') {
            // Received string
            try {
                this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$parse$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__parse$3e$__["parse"])(vals[0]);
                const [mode] = Object.entries(Color.colorMap).find(([key, val])=>{
                    return val === this._color.spaceId;
                });
                this.mode = mode;
                this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, this._color.spaceId);
            } catch (err) {
                // TODO: Invalid color string
                throw new Error('Invalid color string');
            }
        } else {
            // Received individual channel values
            let mappedVals;
            if (colorMaxes) {
                // NOTE: need to consider different number of arguments (eg. CMYK)
                if (vals.length === 4) {
                    mappedVals = Color.mapColorRange(vals, this.mode, colorMaxes, clamp);
                } else if (vals.length === 3) {
                    mappedVals = Color.mapColorRange([
                        vals[0],
                        vals[1],
                        vals[2]
                    ], this.mode, colorMaxes, clamp);
                    mappedVals.push(1);
                } else if (vals.length === 2) {
                    // Grayscale with alpha
                    if (Color.#grayscaleMap[this.mode]) {
                        mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp);
                    } else {
                        mappedVals = Color.mapColorRange([
                            vals[0],
                            vals[0],
                            vals[0]
                        ], this.mode, colorMaxes, clamp);
                    }
                    const alphaMaxes = Array.isArray(colorMaxes[colorMaxes.length - 1]) ? colorMaxes[colorMaxes.length - 1] : [
                        0,
                        colorMaxes[colorMaxes.length - 1]
                    ];
                    mappedVals.push(map(vals[1], alphaMaxes[0], alphaMaxes[1], 0, 1, clamp));
                } else if (vals.length === 1) {
                    // Grayscale only
                    if (Color.#grayscaleMap[this.mode]) {
                        mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp);
                    } else {
                        mappedVals = Color.mapColorRange([
                            vals[0],
                            vals[0],
                            vals[0]
                        ], this.mode, colorMaxes, clamp);
                    }
                    mappedVals.push(1);
                } else {
                    throw new Error('Invalid color');
                }
            } else {
                mappedVals = vals;
            }
            const space = Color.colorMap[this.mode] || console.error('Invalid color mode');
            const coords = mappedVals.slice(0, 3);
            const color = {
                space,
                coords,
                alpha: mappedVals[3]
            };
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(color, space);
        }
    }
    // Convert from p5 color range to color.js color range
    static mapColorRange(origin, mode, maxes, clamp) {
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const colorjsMaxes = Color.#colorjsMaxes[mode];
        return origin.map((channel, i)=>{
            const newval = map(channel, p5Maxes[i][0], p5Maxes[i][1], colorjsMaxes[i][0], colorjsMaxes[i][1], clamp);
            return newval;
        });
    }
    // Convert from color.js color range to p5 color range
    static unmapColorRange(origin, mode, maxes) {
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const colorjsMaxes = Color.#colorjsMaxes[mode];
        return origin.map((channel, i)=>{
            const newval = map(channel, colorjsMaxes[i][0], colorjsMaxes[i][1], p5Maxes[i][0], p5Maxes[i][1]);
            return newval;
        });
    }
    // Will do conversion in-Gamut as out of Gamut conversion is only really useful for futher conversions
    #toColorMode(mode) {
        return new Color(this._color, mode);
    }
    // Get raw coordinates of underlying library, can differ between libraries
    get _array() {
        return this._getRGBA();
    }
    array() {
        return this._array;
    }
    lerp(color, amt, mode) {
        // Find the closest common ancestor color space
        let spaceIndex = -1;
        while((spaceIndex + 1 < this._color.space.path.length || spaceIndex + 1 < color._color.space.path.length) && this._color.space.path[spaceIndex + 1] === color._color.space.path[spaceIndex + 1]){
            spaceIndex += 1;
        }
        if (spaceIndex === -1) {
            // This probably will not occur in practice
            throw new Error('Cannot lerp colors. No common color space found');
        }
        const obj = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$interpolation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["range"])(this._color, color._color, {
            space: this._color.space.path[spaceIndex].id
        })(amt);
        return new Color(obj, mode || this.mode);
    }
    /**
   * Returns the color formatted as a `String`.
   *
   * Calling `myColor.toString()` can be useful for debugging, as in
   * `print(myColor.toString())`. It's also helpful for using p5.js with other
   * libraries.
   *
   * The parameter, `format`, is optional. If a format string is passed, as in
   * `myColor.toString('#rrggbb')`, it will determine how the color string is
   * formatted. By default, color strings are formatted as `'rgba(r, g, b, a)'`.
   *
   * @param {String} [format] how the color string will be formatted.
   * Leaving this empty formats the string as rgba(r, g, b, a).
   * '#rgb' '#rgba' '#rrggbb' and '#rrggbbaa' format as hexadecimal color codes.
   * 'rgb' 'hsb' and 'hsl' return the color formatted in the specified color mode.
   * 'rgba' 'hsba' and 'hsla' are the same as above but with alpha channels.
   * 'rgb%' 'hsb%' 'hsl%' 'rgba%' 'hsba%' and 'hsla%' format as percentages.
   * @return {String} the formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let myColor = color('darkorchid');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the text.
   *   text(myColor.toString('#rrggbb'), 50, 50);
   *
   *   describe('The text "#9932cc" written in purple on a gray background.');
   * }
   * </code>
   * </div>
   */ toString(format) {
        const key = `${this._color.space.id}-${this._color.coords.join(',')}-${this._color.alpha}-${format}`;
        let colorString = serializationMap[key];
        if (!colorString) {
            colorString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$serialize$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__serialize$3e$__["serialize"])(this._color, {
                format
            });
            serializationMap[key] = colorString;
        }
        return colorString;
    }
    /**
   * Checks the contrast between two colors. This method returns a boolean
   * value to indicate if the two color has enough contrast. `true` means that
   * the colors has enough contrast to be used as background color and body
   * text color. `false` means there is not enough contrast.
   *
   * A second argument can be passed to the method, `options` , which defines
   * the algorithm to be used. The algorithms currently supported are
   * WCAG 2.1 (`'WCAG21'`) or APCA (`'APCA'`). The default is WCAG 2.1. If a
   * value of `'all'` is passed to the `options` argument, an object containing
   * more details is returned. The details object will include the calculated
   * contrast value of the colors and different passing criteria.
   *
   * For more details about color contrast, you can check out
   * <a href="https://colorjs.io/docs/contrast">this page from color.js</a>, and the
   * <a href="https://webaim.org/resources/contrastchecker/">WebAIM color contrast checker.</a>
   *
   * @param {Color} other
   * @returns {boolean|object}
   * @example
   * <div>
   * <code>
   * let bgColor, fg1Color, fg2Color, msg1, msg2;
   * function setup() {
   *   createCanvas(100, 100);
   *   bgColor = color(0);
   *   fg1Color = color(100);
   *   fg2Color = color(220);
   *
   *   if(bgColor.contrast(fg1Color)){
   *     msg1 = 'good';
   *   }else{
   *     msg1 = 'bad';
   *   }
   *
   *   if(bgColor.contrast(fg2Color)){
   *     msg2 = 'good';
   *   }else{
   *     msg2 = 'bad';
   *   }
   *
   *   describe('A black canvas with a faint grey word saying "bad" at the top left and a brighter light grey word saying "good" in the middle of the canvas.');
   * }
   *
   * function draw(){
   *   background(bgColor);
   *
   *   textSize(18);
   *
   *   fill(fg1Color);
   *   text(msg1, 10, 30);
   *
   *   fill(fg2Color);
   *   text(msg2, 10, 60);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let bgColor, fgColor, contrast;
   * function setup() {
   *   createCanvas(100, 100);
   *   bgColor = color(0);
   *   fgColor = color(200);
   *   contrast = bgColor.contrast(fgColor, 'all');
   *
   *   describe('A black canvas with four short lines of grey text that respectively says: "WCAG 2.1", "12.55", "APCA", and "-73.30".');
   * }
   *
   * function draw(){
   *   background(bgColor);
   *
   *   textSize(14);
   *
   *   fill(fgColor);
   *   text('WCAG 2.1', 10, 25);
   *   text(nf(contrast.WCAG21.value, 0, 2), 10, 40);
   *
   *   text('APCA', 10, 70);
   *   text(nf(contrast.APCA.value, 0, 2), 10, 85);
   * }
   * </code>
   * </div>
   */ contrast(other_color, options = 'WCAG21') {
        if (options !== 'all') {
            let contrastVal, minimum;
            switch(options){
                case 'WCAG21':
                    contrastVal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$WCAG21$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastWCAG21$3e$__["contrastWCAG21"])(this._color, other_color._color);
                    minimum = 4.5;
                    break;
                case 'APCA':
                    contrastVal = Math.abs((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$APCA$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastAPCA$3e$__["contrastAPCA"])(this._color, other_color._color));
                    minimum = 75;
                    break;
                default:
                    return null;
            }
            return contrastVal >= minimum;
        } else {
            const wcag21Value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$WCAG21$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastWCAG21$3e$__["contrastWCAG21"])(this._color, other_color._color);
            const apcaValue = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$contrast$2f$APCA$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__contrastAPCA$3e$__["contrastAPCA"])(this._color, other_color._color);
            return {
                WCAG21: {
                    value: wcag21Value,
                    passedMinimum: wcag21Value >= 4.5,
                    passedAAA: wcag21Value >= 7
                },
                APCA: {
                    value: apcaValue,
                    passedMinimum: Math.abs(apcaValue) >= 75
                }
            };
        }
    }
    /**
   * Sets the red component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} red the new red value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the red value.
   *   c.setRed(64);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is teal.');
   * }
   * </code>
   * </div>
   */ setRed(new_red, max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        const colorjsMax = Color.#colorjsMaxes[RGB][0];
        const newval = map(new_red, max[0], max[1], colorjsMax[0], colorjsMax[1]);
        if (this.mode === RGB || this.mode === RGBHDR) {
            this._color.coords[0] = newval;
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const space = this._color.space.id;
            const representation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb');
            representation.coords[0] = newval;
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(representation, space);
        }
    }
    /**
   * Sets the green component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} green the new green value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the green value.
   *   c.setGreen(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is yellow.');
   * }
   * </code>
   * </div>
   */ setGreen(new_green, max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        const colorjsMax = Color.#colorjsMaxes[RGB][1];
        const newval = map(new_green, max[0], max[1], colorjsMax[0], colorjsMax[1]);
        if (this.mode === RGB || this.mode === RGBHDR) {
            this._color.coords[1] = newval;
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const space = this._color.space.id;
            const representation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb');
            representation.coords[1] = newval;
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(representation, space);
        }
    }
    /**
   * Sets the blue component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} blue the new blue value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the blue value.
   *   c.setBlue(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is pale fuchsia.');
   * }
   * </code>
   * </div>
   */ setBlue(new_blue, max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        const colorjsMax = Color.#colorjsMaxes[RGB][2];
        const newval = map(new_blue, max[0], max[1], colorjsMax[0], colorjsMax[1]);
        if (this.mode === RGB || this.mode === RGBHDR) {
            this._color.coords[2] = newval;
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const space = this._color.space.id;
            const representation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb');
            representation.coords[2] = newval;
            this._color = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(representation, space);
        }
    }
    /**
   * Sets the alpha (transparency) value of a color.
   *
   * The range depends on the
   * <a href="#/p5/colorMode">colorMode()</a>. In the default RGB mode it's
   * between 0 and 255.
   *
   * @param {Number} alpha the new alpha value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the alpha value.
   *   c.setAlpha(128);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is faded pink.');
   * }
   * </code>
   * </div>
   */ setAlpha(new_alpha, max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        const colorjsMax = Color.#colorjsMaxes[this.mode][3];
        const newval = map(new_alpha, max[0], max[1], colorjsMax[0], colorjsMax[1]);
        this._color.alpha = newval;
    }
    _getRGBA(maxes = [
        1,
        1,
        1,
        1
    ]) {
        // Get colorjs maxes
        const colorjsMaxes = Color.#colorjsMaxes[RGB];
        // Normalize everything to 0,1 or the provided range (map)
        let coords = structuredClone((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb').coords);
        coords.push(this._color.alpha);
        const rangeMaxes = maxes.map((v)=>{
            if (!Array.isArray(v)) {
                return [
                    0,
                    v
                ];
            } else {
                return v;
            }
        });
        coords = coords.map((coord, i)=>{
            return map(coord, colorjsMaxes[i][0], colorjsMaxes[i][1], rangeMaxes[i][0], rangeMaxes[i][1]);
        });
        return coords;
    }
    _getMode() {
        return this.mode;
    }
    _getRed(max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === RGB || this.mode === RGBHDR) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][0];
            return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const colorjsMax = Color.#colorjsMaxes[RGB][0];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb').coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    /**
   * This function extracts the green value from a color object and
   * returns it in the range 0–255 by default. When `colorMode()` is given to an
   * RBG value, the green value within the givin range is returned
   */ _getGreen(max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === RGB || this.mode === RGBHDR) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][1];
            return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const colorjsMax = Color.#colorjsMaxes[RGB][1];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb').coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    _getBlue(max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === RGB || this.mode === RGBHDR) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][2];
            return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'srgb', not recommended
            const colorjsMax = Color.#colorjsMaxes[RGB][2];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'srgb').coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    _getAlpha(max = [
        0,
        1
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        const colorjsMax = Color.#colorjsMaxes[this.mode][3];
        return map(this._color.alpha, colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
    /**
   * Hue is the same in HSB and HSL, but the maximum value may be different.
   * This function will return the HSB-normalized saturation when supplied with
   * an HSB color object, but will default to the HSL-normalized saturation
   * otherwise.
   */ _getHue(max = [
        0,
        360
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === HSB || this.mode === HSL) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][0];
            return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'HSL', not recommended
            const colorjsMax = Color.#colorjsMaxes[HSL][0];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'hsl').coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    /**
   * Saturation is scaled differently in HSB and HSL. This function will return
   * the HSB saturation when supplied with an HSB color object, but will default
   * to the HSL saturation otherwise.
   */ _getSaturation(max = [
        0,
        100
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === HSB || this.mode === HSL) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][1];
            return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'HSL', not recommended
            const colorjsMax = Color.#colorjsMaxes[HSL][1];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'hsl').coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    /**
   * Brightness obtains the HSB brightness value from either a p5.Color object,
   * an array of color components, or a CSS color string.Depending on value,
   * when `colorMode()` is set to HSB, this function will return the
   * brightness value in the range. By default, this function will return
   * the HSB brightness within the range 0 - 100.
   */ _getBrightness(max = [
        0,
        100
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === HSB) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][2];
            return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'HSB', not recommended
            const colorjsMax = Color.#colorjsMaxes[HSB][2];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'hsb').coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
    _getLightness(max = [
        0,
        100
    ]) {
        if (!Array.isArray(max)) {
            max = [
                0,
                max
            ];
        }
        if (this.mode === HSL) {
            const colorjsMax = Color.#colorjsMaxes[this.mode][2];
            return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        } else {
            // Will do an imprecise conversion to 'HSL', not recommended
            const colorjsMax = Color.#colorjsMaxes[HSL][2];
            return map((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$to$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__to$3e$__["to"])(this._color, 'hsl').coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
        }
    }
}
function color(p51, fn, lifecycles) {
    /**
   * A class to describe a color.
   *
   * Each `p5.Color` object stores the color mode
   * and level maxes that were active during its construction. These values are
   * used to interpret the arguments passed to the object's constructor. They
   * also determine output formatting such as when
   * <a href="#/p5/saturation">saturation()</a> is called.
   *
   * Color is stored internally as an array of ideal RGBA values in floating
   * point form, normalized from 0 to 1. These values are used to calculate the
   * closest screen colors, which are RGBA levels from 0 to 255. Screen colors
   * are sent to the renderer.
   *
   * When different color representations are calculated, the results are cached
   * for performance. These values are normalized, floating-point numbers.
   *
   * Note: <a href="#/p5/color">color()</a> is the recommended way to create an
   * instance of this class.
   *
   * @class p5.Color
   * @param {p5} pInst                      pointer to p5 instance.
   *
   * @param {Number[]|String} vals            an array containing the color values
   *                                          for red, green, blue and alpha channel
   *                                          or CSS color.
   */ /**
   * @class p5.Color
   * @param {Number[]|String} vals
   */ p51.Color = Color;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$srgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__sRGB$3e$__["sRGB"].fromGray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$p3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__P3$3e$__["P3"].fromGray = function(val, maxes, clamp) {
        // Use blue max
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 1, clamp);
        return [
            v,
            v,
            v
        ];
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].fromGray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HSL$3e$__["HSL"].fromGray = function(val, maxes, clamp) {
        // Use brightness max
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 100, clamp);
        return [
            0,
            0,
            v
        ];
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hwb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HWB$3e$__["HWB"].fromGray = function(val, maxes, clamp) {
        // Use Whiteness and Blackness to create number line
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const wbMax = Math.abs(p5Maxes[1][0] - p5Maxes[1][1]) / 2 + Math.abs(p5Maxes[2][0] - p5Maxes[2][1]) / 2;
        const nVal = map(val, 0, wbMax, 0, 100);
        let white, black;
        if (nVal < 50) {
            black = nVal;
            white = 100 - nVal;
        } else if (nVal >= 50) {
            white = nVal;
            black = 100 - nVal;
        }
        return [
            0,
            white,
            black
        ];
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Lab$3e$__["Lab"].fromGray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__LCH$3e$__["LCH"].fromGray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLab$3e$__["OKLab"].fromGray = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLCH$3e$__["OKLCH"].fromGray = function(val, maxes, clamp) {
        // Use lightness max
        const p5Maxes = maxes.map((max)=>{
            if (!Array.isArray(max)) {
                return [
                    0,
                    max
                ];
            } else {
                return max;
            }
        });
        const v = map(val, p5Maxes[0][0], p5Maxes[0][1], 0, 100, clamp);
        return [
            v,
            0,
            0
        ];
    };
    // Register color modes and initialize Color maxes to what p5 has set for itself
    p51.Color.addColorMode(RGB, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$srgb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__sRGB$3e$__["sRGB"]);
    p51.Color.addColorMode(RGBHDR, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$p3$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__P3$3e$__["P3"]);
    p51.Color.addColorMode(HSB, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p51.Color.addColorMode(HSL, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hsl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HSL$3e$__["HSL"]);
    p51.Color.addColorMode(HWB, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$hwb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__HWB$3e$__["HWB"]);
    p51.Color.addColorMode(LAB, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__Lab$3e$__["Lab"]);
    p51.Color.addColorMode(LCH, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$lch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__LCH$3e$__["LCH"]);
    p51.Color.addColorMode(OKLAB, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklab$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLab$3e$__["OKLab"]);
    p51.Color.addColorMode(OKLCH, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$colorjs$2e$io$2f$src$2f$spaces$2f$oklch$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__OKLCH$3e$__["OKLCH"]);
    lifecycles.presetup = function() {
        const pInst = this;
        // Decorate set methods
        const setMethods = [
            'Red',
            'Green',
            'Blue',
            'Alpha'
        ];
        for(let i in setMethods){
            const method = setMethods[i];
            const setCopy = p51.Color.prototype['set' + method];
            p51.Color.prototype['set' + method] = function(newval, max) {
                max = max || pInst?._renderer?.states?.colorMaxes?.[RGB][i];
                return setCopy.call(this, newval, max);
            };
        }
        // Decorate get methods
        function decorateGet(channel, modes) {
            const getCopy = p51.Color.prototype['_get' + channel];
            p51.Color.prototype['_get' + channel] = function(max) {
                if (Object.keys(modes).includes(this.mode)) {
                    max = max || pInst?._renderer?.states?.colorMaxes?.[this.mode][modes[this.mode]];
                } else {
                    const defaultMode = Object.keys(modes)[0];
                    max = max || pInst?._renderer?.states?.colorMaxes?.[defaultMode][modes[defaultMode]];
                }
                return getCopy.call(this, max);
            };
        }
        decorateGet('Red', {
            [RGB]: 0,
            [RGBHDR]: 0
        });
        decorateGet('Green', {
            [RGB]: 1,
            [RGBHDR]: 1
        });
        decorateGet('Blue', {
            [RGB]: 2,
            [RGBHDR]: 2
        });
        decorateGet('Alpha', {
            [RGB]: 3,
            [RGBHDR]: 3,
            [HSB]: 3,
            [HSL]: 3,
            [HWB]: 3,
            [LAB]: 3,
            [LCH]: 3,
            [OKLAB]: 3,
            [OKLCH]: 3
        });
        decorateGet('Hue', {
            [HSL]: 0,
            [HSB]: 0,
            [HWB]: 0,
            [LCH]: 2,
            [OKLCH]: 2
        });
        decorateGet('Saturation', {
            [HSL]: 1,
            [HSB]: 1
        });
        decorateGet('Brightness', {
            [HSB]: 2
        });
        decorateGet('Lightness', {
            [HSL]: 2
        });
    };
}
if (typeof p5 !== 'undefined') {
    color(p5, p5.prototype);
}
/**
 * @module Color
 * @submodule Creating & Reading
 * @for p5
 * @requires core
 * @requires constants
 */ /**
 * @typedef {'rgb'} RGB
 * @property {RGB} RGB
 * @final
 */ const RGB = 'rgb';
/**
 * @typedef {'rgbhdr'} RGBHDR
 * @property {RGBHDR} RGBHDR
 * @final
 */ const RGBHDR = 'rgbhdr';
/**
 * HSB (hue, saturation, brightness) is a type of color model.
 * You can learn more about it at
 * <a href="https://learnui.design/blog/the-hsb-color-system-practicioners-primer.html">HSB</a>.
 *
 * @typedef {'hsb'} HSB
 * @property {HSB} HSB
 * @final
 */ const HSB = 'hsb';
/**
 * @typedef {'hsl'} HSL
 * @property {HSL} HSL
 * @final
 */ const HSL = 'hsl';
/**
 * @typedef {'hwb'} HWB
 * @property {HWB} HWB
 * @final
 */ const HWB = 'hwb';
/**
 * @typedef {'lab'} LAB
 * @property {LAB} LAB
 * @final
 */ const LAB = 'lab';
/**
 * @typedef {'lch'} LCH
 * @property {LCH} LCH
 * @final
 */ const LCH = 'lch';
/**
 * @typedef {'oklab'} OKLAB
 * @property {OKLAB} OKLAB
 * @final
 */ const OKLAB = 'oklab';
/**
 * @typedef {'oklch'} OKLCH
 * @property {OKLCH} OKLCH
 * @final
 */ const OKLCH = 'oklch';
/**
 * @typedef {'rgba'} RGBA
 * @property {RGBA} RGBA
 * @final
 */ const RGBA = 'rgba';
function creatingReading(p51, fn) {
    fn.RGB = RGB;
    fn.RGBHDR = RGBHDR;
    fn.HSB = HSB;
    fn.HSL = HSL;
    fn.HWB = HWB;
    fn.LAB = LAB;
    fn.LCH = LCH;
    fn.OKLAB = OKLAB;
    fn.OKLCH = OKLCH;
    fn.RGBA = RGBA;
    // Add color states to renderer state machine
    p51.Renderer.states.colorMode = RGB;
    p51.Renderer.states.colorMaxes = {
        [RGB]: [
            255,
            255,
            255,
            255
        ],
        [RGBHDR]: [
            255,
            255,
            255,
            255
        ],
        [HSB]: [
            360,
            100,
            100,
            1
        ],
        [HSL]: [
            360,
            100,
            100,
            1
        ],
        [HWB]: [
            360,
            100,
            100,
            1
        ],
        [LAB]: [
            100,
            [
                -125,
                125
            ],
            [
                -125,
                125
            ],
            1
        ],
        [LCH]: [
            100,
            150,
            360,
            1
        ],
        [OKLAB]: [
            100,
            [
                -125,
                125
            ],
            [
                -125,
                125
            ],
            1
        ],
        [OKLCH]: [
            100,
            150,
            360,
            1
        ],
        clone: function() {
            const cloned = {
                ...this
            };
            for(const key in cloned){
                if (cloned[key] instanceof Array) {
                    cloned[key] = [
                        ...cloned[key]
                    ];
                }
            }
            return cloned;
        }
    };
    /**
   * Creates a <a href="#/p5/p5.Color">p5.Color</a> object.
   *
   * By default, the parameters are interpreted as RGB values. Calling
   * `color(255, 204, 0)` will return a bright yellow color. The way these
   * parameters are interpreted may be changed with the
   * <a href="#/p5/colorMode">colorMode()</a> function.
   *
   * The version of `color()` with one parameter interprets the value one of two
   * ways. If the parameter is a number, it's interpreted as a grayscale value.
   * If the parameter is a string, it's interpreted as a CSS color string.
   *
   * The version of `color()` with two parameters interprets the first one as a
   * grayscale value. The second parameter sets the alpha (transparency) value.
   *
   * The version of `color()` with three parameters interprets them as RGB, HSB,
   * or HSL colors, depending on the current `colorMode()`.
   *
   * The version of `color()` with four parameters interprets them as RGBA, HSBA,
   * or HSLA colors, depending on the current `colorMode()`. The last parameter
   * sets the alpha (transparency) value.
   *
   * @method color
   * @param  {Number} gray number specifying value between white and black.
   * @param  {Number} [alpha] alpha value relative to current color range
   *                                 (default is 0-255).
   * @return {p5.Color} resulting color.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c = color(255, 204, 0);
   *
   *   // Draw the square.
   *   fill(c);
   *   noStroke();
   *   square(30, 20, 55);
   *
   *   describe('A yellow square on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c1 = color(255, 204, 0);
   *
   *   // Draw the left circle.
   *   fill(c1);
   *   noStroke();
   *   circle(25, 25, 80);
   *
   *   // Create a p5.Color object using a grayscale value.
   *   let c2 = color(65);
   *
   *   // Draw the right circle.
   *   fill(c2);
   *   circle(75, 75, 80);
   *
   *   describe(
   *     'Two circles on a gray canvas. The circle in the top-left corner is yellow and the one at the bottom-right is gray.'
   *   );
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using a named color.
   *   let c = color('magenta');
   *
   *   // Draw the square.
   *   fill(c);
   *   noStroke();
   *   square(20, 20, 60);
   *
   *   describe('A magenta square on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using a hex color code.
   *   let c1 = color('#0f0');
   *
   *   // Draw the left rectangle.
   *   fill(c1);
   *   noStroke();
   *   rect(0, 10, 45, 80);
   *
   *   // Create a p5.Color object using a hex color code.
   *   let c2 = color('#00ff00');
   *
   *   // Draw the right rectangle.
   *   fill(c2);
   *   rect(55, 10, 45, 80);
   *
   *   describe('Two bright green rectangles on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using a RGB color string.
   *   let c1 = color('rgb(0, 0, 255)');
   *
   *   // Draw the top-left square.
   *   fill(c1);
   *   square(10, 10, 35);
   *
   *   // Create a p5.Color object using a RGB color string.
   *   let c2 = color('rgb(0%, 0%, 100%)');
   *
   *   // Draw the top-right square.
   *   fill(c2);
   *   square(55, 10, 35);
   *
   *   // Create a p5.Color object using a RGBA color string.
   *   let c3 = color('rgba(0, 0, 255, 1)');
   *
   *   // Draw the bottom-left square.
   *   fill(c3);
   *   square(10, 55, 35);
   *
   *   // Create a p5.Color object using a RGBA color string.
   *   let c4 = color('rgba(0%, 0%, 100%, 1)');
   *
   *   // Draw the bottom-right square.
   *   fill(c4);
   *   square(55, 55, 35);
   *
   *   describe('Four blue squares in the corners of a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using a HSL color string.
   *   let c1 = color('hsl(160, 100%, 50%)');
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c1);
   *   rect(0, 10, 45, 80);
   *
   *   // Create a p5.Color object using a HSLA color string.
   *   let c2 = color('hsla(160, 100%, 50%, 0.5)');
   *
   *   // Draw the right rectangle.
   *   fill(c2);
   *   rect(55, 10, 45, 80);
   *
   *   describe('Two sea green rectangles. A darker rectangle on the left and a brighter one on the right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using a HSB color string.
   *   let c1 = color('hsb(160, 100%, 50%)');
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c1);
   *   rect(0, 10, 45, 80);
   *
   *   // Create a p5.Color object using a HSBA color string.
   *   let c2 = color('hsba(160, 100%, 50%, 0.5)');
   *
   *   // Draw the right rectangle.
   *   fill(c2);
   *   rect(55, 10, 45, 80);
   *
   *   describe('Two green rectangles. A darker rectangle on the left and a brighter one on the right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c1 = color(50, 55, 100);
   *
   *   // Draw the left rectangle.
   *   fill(c1);
   *   rect(0, 10, 45, 80);
   *
   *   // Switch the color mode to HSB.
   *   colorMode(HSB, 100);
   *
   *   // Create a p5.Color object using HSB values.
   *   let c2 = color(50, 55, 100);
   *
   *   // Draw the right rectangle.
   *   fill(c2);
   *   rect(55, 10, 45, 80);
   *
   *   describe('Two blue rectangles. A darker rectangle on the left and a brighter one on the right.');
   * }
   * </code>
   * </div>
   */ /**
   * @method color
   * @param  {Number}        v1      red or hue value relative to
   *                                 the current color range.
   * @param  {Number}        v2      green or saturation value
   *                                 relative to the current color range.
   * @param  {Number}        v3      blue or brightness value
   *                                 relative to the current color range.
   * @param  {Number}        [alpha]
   * @return {p5.Color}
   */ /**
   * @method color
   * @param  {String}        value   a color string.
   * @return {p5.Color}
   */ /**
   * @method color
   * @param  {Number[]}      values  an array containing the red, green, blue,
   *                                 and alpha components of the color.
   * @return {p5.Color}
   */ /**
   * @method color
   * @param  {p5.Color}     color
   * @return {p5.Color}
   */ fn.color = function(...args) {
        // p5._validateParameters('color', args);
        if (args[0] instanceof Color) {
            // TODO: perhaps change color mode to match instance mode?
            return args[0]; // Do nothing if argument is already a color object.
        }
        const arg = Array.isArray(args[0]) ? args[0] : args;
        return new Color(arg, this._renderer.states.colorMode, this._renderer.states.colorMaxes[this._renderer.states.colorMode], {
            clamp: true
        });
    };
    /**
   * Gets the red value of a color.
   *
   * `red()` extracts the red value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * By default, `red()` returns a color's red value in the range 0
   * to 255. If the <a href="/reference/p5/colorMode/">colorMode()</a> is set to RGB, it
   * returns the red value in the given range.
   *
   * @method red
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the red value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(175, 100, 220);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'redValue' to 175.
   *   let redValue = red(c);
   *
   *   // Draw the right rectangle.
   *   fill(redValue, 0, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is red.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a color array.
   *   let c = [175, 100, 220];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'redValue' to 175.
   *   let redValue = red(c);
   *
   *   // Draw the right rectangle.
   *   fill(redValue, 0, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is red.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(175, 100, 220)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'redValue' to 175.
   *   let redValue = red(c);
   *
   *   // Draw the right rectangle.
   *   fill(redValue, 0, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is red.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use RGB color with values in the range 0-100.
   *   colorMode(RGB, 100);
   *
   *   // Create a p5.Color object.
   *   let c = color(69, 39, 86);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'redValue' to 69.
   *   let redValue = red(c);
   *
   *   // Draw the right rectangle.
   *   fill(redValue, 0, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is red.');
   * }
   * </code>
   * </div>
   */ fn.red = function(c) {
        // p5._validateParameters('red', arguments);
        // Get current red max
        return this.color(c)._getRed();
    };
    /**
   * Gets the green value of a color.
   *
   * `green()` extracts the green value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * By default, `green()` returns a color's green value in the range 0
   * to 255. If the <a href="/reference/p5/colorMode/">colorMode()</a> is set to RGB, it
   * returns the green value in the given range.
   *
   * @method green
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the green value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(175, 100, 220);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'greenValue' to 100.
   *   let greenValue = green(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, greenValue, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is dark green.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a color array.
   *   let c = [175, 100, 220];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'greenValue' to 100.
   *   let greenValue = green(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, greenValue, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is dark green.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(175, 100, 220)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'greenValue' to 100.
   *   let greenValue = green(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, greenValue, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is dark green.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use RGB color with values in the range 0-100.
   *   colorMode(RGB, 100);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c = color(69, 39, 86);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'greenValue' to 39.
   *   let greenValue = green(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, greenValue, 0);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is dark green.');
   * }
   * </code>
   * </div>
   */ fn.green = function(c) {
        // p5._validateParameters('green', arguments);
        // Get current green max
        return this.color(c)._getGreen();
    };
    /**
   * Gets the blue value of a color.
   *
   * `blue()` extracts the blue value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * By default, `blue()` returns a color's blue value in the range 0
   * to 255. If the <a href="/reference/p5/colorMode/">colorMode()</a> is set to RGB, it
   * returns the blue value in the given range.
   *
   * @method blue
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the blue value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c = color(175, 100, 220);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'blueValue' to 220.
   *   let blueValue = blue(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, 0, blueValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is royal blue.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a color array.
   *   let c = [175, 100, 220];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'blueValue' to 220.
   *   let blueValue = blue(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, 0, blueValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is royal blue.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(175, 100, 220)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'blueValue' to 220.
   *   let blueValue = blue(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, 0, blueValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is royal blue.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use RGB color with values in the range 0-100.
   *   colorMode(RGB, 100);
   *
   *   // Create a p5.Color object using RGB values.
   *   let c = color(69, 39, 86);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'blueValue' to 86.
   *   let blueValue = blue(c);
   *
   *   // Draw the right rectangle.
   *   fill(0, 0, blueValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light purple and the right one is royal blue.');
   * }
   * </code>
   * </div>
   */ fn.blue = function(c) {
        // p5._validateParameters('blue', arguments);
        // Get current blue max
        return this.color(c)._getBlue();
    };
    /**
   * Gets the alpha (transparency) value of a color.
   *
   * `alpha()` extracts the alpha value from a
   * <a href="#/p5.Color">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * @method alpha
   * @param {p5.Color|Number[]|String} color <a href="#/p5.Color">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the alpha value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 126, 255, 102);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'alphaValue' to 102.
   *   let alphaValue = alpha(c);
   *
   *   // Draw the right rectangle.
   *   fill(alphaValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light blue and the right one is charcoal gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a color array.
   *   let c = [0, 126, 255, 102];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'alphaValue' to 102.
   *   let alphaValue = alpha(c);
   *
   *   // Draw the left rectangle.
   *   fill(alphaValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light blue and the right one is charcoal gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a CSS color string.
   *   let c = 'rgba(0, 126, 255, 0.4)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'alphaValue' to 102.
   *   let alphaValue = alpha(c);
   *
   *   // Draw the right rectangle.
   *   fill(alphaValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is light blue and the right one is charcoal gray.');
   * }
   * </code>
   * </div>
   */ fn.alpha = function(c) {
        // p5._validateParameters('alpha', arguments);
        // Get current alpha max
        return this.color(c)._getAlpha();
    };
    /**
   * Gets the hue value of a color.
   *
   * `hue()` extracts the hue value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * Hue describes a color's position on the color wheel. By default, `hue()`
   * returns a color's HSL hue in the range 0 to 360. If the
   * <a href="/reference/p5/colorMode/">colorMode()</a> is set to HSB or HSL, it returns the hue
   * value in the given mode.
   *
   * @method hue
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the hue value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 50, 100);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Set 'hueValue' to 0.
   *   let hueValue = hue(c);
   *
   *   // Draw the right rectangle.
   *   fill(hueValue);
   *   rect(50, 20, 35, 60);
   *
   *   describe(
   *     'Two rectangles. The rectangle on the left is salmon pink and the one on the right is black.'
   *   );
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a color array.
   *   let c = [0, 50, 100];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Set 'hueValue' to 0.
   *   let hueValue = hue(c);
   *
   *   // Draw the right rectangle.
   *   fill(hueValue);
   *   rect(50, 20, 35, 60);
   *
   *   describe(
   *     'Two rectangles. The rectangle on the left is salmon pink and the one on the right is black.'
   *   );
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(255, 128, 128)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Set 'hueValue' to 0.
   *   let hueValue = hue(c);
   *
   *   // Draw the right rectangle.
   *   fill(hueValue);
   *   rect(50, 20, 35, 60);
   *
   *   describe(
   *     'Two rectangles. The rectangle on the left is salmon pink and the one on the right is black.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.hue = function(c) {
        let colorMode = HSL;
        let i = 0;
        if (this._renderer.states.colorMode === HSB || this._renderer.states.colorMode === HSL) {
            colorMode = this._renderer.states.colorMode;
        } else if (this._renderer.states.colorMode === LCH || this._renderer.states.colorMode === OKLCH) {
            colorMode = this._renderer.states.colorMode;
            i = 2;
        }
        return this.color(c)._getHue(this._renderer.states.colorMaxes[colorMode][i]);
    };
    /**
   * Gets the saturation value of a color.
   *
   * `saturation()` extracts the saturation value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * Saturation is scaled differently in HSB and HSL. By default, `saturation()`
   * returns a color's HSL saturation in the range 0 to 100. If the
   * <a href="/reference/p5/colorMode/">colorMode()</a> is set to HSB or HSL, it returns the
   * saturation value in the given mode.
   *
   * @method saturation
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the saturation value
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 50, 100);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'satValue' to 50.
   *   let satValue = saturation(c);
   *
   *   // Draw the right rectangle.
   *   fill(satValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is dark gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a color array.
   *   let c = [0, 50, 100];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'satValue' to 100.
   *   let satValue = saturation(c);
   *
   *   // Draw the right rectangle.
   *   fill(satValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(255, 128, 128)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'satValue' to 100.
   *   let satValue = saturation(c);
   *
   *   // Draw the right rectangle.
   *   fill(satValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 100, 75);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'satValue' to 100.
   *   let satValue = saturation(c);
   *
   *   // Draw the right rectangle.
   *   fill(satValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color with values in the range 0-255.
   *   colorMode(HSL, 255);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 255, 191.5);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'satValue' to 255.
   *   let satValue = saturation(c);
   *
   *   // Draw the right rectangle.
   *   fill(satValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   */ fn.saturation = function(c) {
        const colorMode = this._renderer.states.colorMode === HSB ? HSB : HSL;
        return this.color(c)._getSaturation(this._renderer.states.colorMaxes[colorMode][1]);
    };
    /**
   * Gets the brightness value of a color.
   *
   * `brightness()` extracts the HSB brightness value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * By default, `brightness()` returns a color's HSB brightness in the range 0
   * to 100. If the <a href="/reference/p5/colorMode/">colorMode()</a> is set to HSB, it
   * returns the brightness value in the given range.
   *
   * @method brightness
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the brightness value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 50, 100);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'brightValue' to 100.
   *   let brightValue = brightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(brightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a color array.
   *   let c = [0, 50, 100];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'brightValue' to 100.
   *   let brightValue = brightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(brightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color.
   *   colorMode(HSB);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(255, 128, 128)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'brightValue' to 100.
   *   let brightValue = brightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(brightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use HSB color with values in the range 0-255.
   *   colorMode(HSB, 255);
   *
   *   // Create a p5.Color object.
   *   let c = color(0, 127, 255);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'brightValue' to 255.
   *   let brightValue = brightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(brightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is white.');
   * }
   * </code>
   * </div>
   */ fn.brightness = function(c) {
        return this.color(c)._getBrightness(this._renderer.states.colorMaxes.hsb[2]);
    };
    /**
   * Gets the lightness value of a color.
   *
   * `lightness()` extracts the HSL lightness value from a
   * <a href="/reference/p5/p5.Color/">p5.Color</a> object, an array of color components, or
   * a CSS color string.
   *
   * By default, `lightness()` returns a color's HSL lightness in the range 0
   * to 100. If the <a href="/reference/p5/colorMode/">colorMode()</a> is set to HSL, it
   * returns the lightness value in the given range.
   *
   * @method lightness
   * @param {p5.Color|Number[]|String} color <a href="/reference/p5/p5.Color/">p5.Color</a> object, array of
   *                                         color components, or CSS color string.
   * @return {Number} the lightness value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a p5.Color object using HSL values.
   *   let c = color(0, 100, 75);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'lightValue' to 75.
   *   let lightValue = lightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(lightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a color array.
   *   let c = [0, 100, 75];
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'lightValue' to 75.
   *   let lightValue = lightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(lightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color.
   *   colorMode(HSL);
   *
   *   // Create a CSS color string.
   *   let c = 'rgb(255, 128, 128)';
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'lightValue' to 75.
   *   let lightValue = lightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(lightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use HSL color with values in the range 0-255.
   *   colorMode(HSL, 255);
   *
   *   // Create a p5.Color object using HSL values.
   *   let c = color(0, 255, 191.5);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 15, 35, 70);
   *
   *   // Set 'lightValue' to 191.5.
   *   let lightValue = lightness(c);
   *
   *   // Draw the right rectangle.
   *   fill(lightValue);
   *   rect(50, 15, 35, 70);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is gray.');
   * }
   * </code>
   * </div>
   */ fn.lightness = function(c) {
        return this.color(c)._getLightness(this._renderer.states.colorMaxes.hsl[2]);
    };
    /**
   * Blends two colors to find a third color between them.
   *
   * The `amt` parameter specifies the amount to interpolate between the two
   * values. 0 is equal to the first color, 0.1 is very near the first color,
   * 0.5 is halfway between the two colors, and so on. Negative numbers are set
   * to 0. Numbers greater than 1 are set to 1. This differs from the behavior of
   * <a href="#/lerp">lerp</a>. It's necessary because numbers outside of the
   * interval [0, 1] will produce strange and unexpected colors.
   *
   * The way that colors are interpolated depends on the current
   * <a href="#/colorMode">colorMode()</a>.
   *
   * @method lerpColor
   * @param  {p5.Color} c1  interpolate from this color.
   * @param  {p5.Color} c2  interpolate to this color.
   * @param  {Number}   amt number between 0 and 1.
   * @return {p5.Color}     interpolated color.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Color objects to interpolate between.
   *   let from = color(218, 165, 32);
   *   let to = color(72, 61, 139);
   *
   *   // Create intermediate colors.
   *   let interA = lerpColor(from, to, 0.33);
   *   let interB = lerpColor(from, to, 0.66);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(from);
   *   rect(10, 20, 20, 60);
   *
   *   // Draw the left-center rectangle.
   *   fill(interA);
   *   rect(30, 20, 20, 60);
   *
   *   // Draw the right-center rectangle.
   *   fill(interB);
   *   rect(50, 20, 20, 60);
   *
   *   // Draw the right rectangle.
   *   fill(to);
   *   rect(70, 20, 20, 60);
   *
   *   describe(
   *     'Four rectangles. From left to right, the rectangles are tan, brown, brownish purple, and purple.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.lerpColor = function(c1, c2, amt) {
        // p5._validateParameters('lerpColor', arguments);
        return c1.lerp(c2, amt, this._renderer.states.colorMode);
    };
    /**
   * Blends multiple colors to find a color between them.
   *
   * The `amt` parameter specifies the amount to interpolate between the color
   * stops which are colors at each `amt` value "location" with `amt` values
   * that are between 2 color stops interpolating between them based on its relative
   * distance to both.
   *
   * The way that colors are interpolated depends on the current
   * <a href="/reference/p5/colorMode/">colorMode()</a>.
   *
   * @method paletteLerp
   * @param {Array<[(p5.Color|String|Number|Number[]), Number]>} colors_stops color stops to interpolate from
   * @param {Number} amt number to use to interpolate relative to color stops
   * @return {p5.Color} interpolated color.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(400, 400);
   * }
   *
   * function draw() {
   *   // The background goes from white to red to green to blue fill
   *   background(paletteLerp([
   *     ['white', 0],
   *     ['red', 0.05],
   *     ['green', 0.25],
   *     ['blue', 1]
   *   ], millis() / 10000 % 1));
   * }
   * </code>
   * </div>
   */ fn.paletteLerp = function(color_stops, amt) {
        const first_color_stop = color_stops[0];
        if (amt < first_color_stop[1]) return this.color(first_color_stop[0]);
        for(let i = 1; i < color_stops.length; i++){
            const color_stop = color_stops[i];
            if (amt < color_stop[1]) {
                const prev_color_stop = color_stops[i - 1];
                return this.lerpColor(this.color(prev_color_stop[0]), this.color(color_stop[0]), (amt - prev_color_stop[1]) / (color_stop[1] - prev_color_stop[1]));
            }
        }
        return this.color(color_stops[color_stops.length - 1][0]);
    };
}
if (typeof p5 !== 'undefined') {
    creatingReading(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "XML",
    ()=>XML,
    "default",
    ()=>xml
]);
/**
 * @module IO
 * @submodule Input
 * @requires core
 */ class XML {
    constructor(DOM){
        if (!DOM) {
            const xmlDoc = document.implementation.createDocument(null, 'doc');
            this.DOM = xmlDoc.createElement('root');
        } else {
            this.DOM = DOM;
        }
    }
    /**
   * Returns the element's parent element as a new <a href="#/p5.XML">p5.XML</a>
   * object.
   *
   * @return {p5.XML} parent element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the parent element.
   *   let parent = firstMammal.getParent();
   *
   *   // Get the parent element's name.
   *   let name = parent.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the parent element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "animals" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ getParent() {
        return new XML(this.DOM.parentElement);
    }
    /**
   * Returns the element's name as a `String`.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * @return {String} name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the mammal element's name.
   *   let name = firstMammal.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "mammal" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ getName() {
        return this.DOM.tagName;
    }
    /**
   * Sets the element's tag name.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * The parameter, `name`, is the element's new name as a string. For example,
   * calling `myXML.setName('planet')` will make the element's new tag name
   * `&lt;planet&gt;&lt;/planet&gt;`.
   *
   * @param {String} name new tag name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the element's original name.
   *   let oldName = myXML.getName();
   *
   *   // Set the element's name.
   *   myXML.setName('monsters');
   *
   *   // Get the element's new name.
   *   let newName = myXML.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's names.
   *   text(oldName, 50, 33);
   *   text(newName, 50, 67);
   *
   *   describe(
   *     'The words "animals" and "monsters" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code></div>
   */ setName(name) {
        const content = this.DOM.innerHTML;
        const attributes = this.DOM.attributes;
        const xmlDoc = document.implementation.createDocument(null, 'default');
        const newDOM = xmlDoc.createElement(name);
        newDOM.innerHTML = content;
        for(let i = 0; i < attributes.length; i++){
            newDOM.setAttribute(attributes[i].nodeName, attributes[i].nodeValue);
        }
        this.DOM = newDOM;
    }
    /**
   * Returns `true` if the element has child elements and `false` if not.
   *
   * @return {boolean} whether the element has children.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Check whether the element has child elements.
   *   let isParent = myXML.hasChildren();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Style the text.
   *   if (isParent === true) {
   *     text('Parent', 50, 50);
   *   } else {
   *     text('Not Parent', 50, 50);
   *   }
   *
   *   describe('The word "Parent" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ hasChildren() {
        return this.DOM.children.length > 0;
    }
    /**
   * Returns an array with the names of the element's child elements as
   * `String`s.
   *
   * @return {String[]} names of the child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the names of the element's children as an array.
   *   let children = myXML.listChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the child element's name.
   *     text(children[i], 10, y);
   *   }
   *
   *   describe(
   *     'The words "mammal", "mammal", "mammal", and "reptile" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ listChildren() {
        const arr = [];
        for(let i = 0; i < this.DOM.childNodes.length; i++){
            arr.push(this.DOM.childNodes[i].nodeName);
        }
        return arr;
    }
    /**
   * Returns an array with the element's child elements as new
   * <a href="#/p5.XML">p5.XML</a> objects.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChildren('cat')`, then the method will only return child elements
   * with the tag `&lt;cat&gt;`.
   *
   * @param {String} [name] name of the elements to return.
   * @return {p5.XML[]} child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements
   *   // that are mammals.
   *   let children = myXML.getChildren('mammal');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Zebra" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ getChildren(param) {
        if (param) {
            return elementsToP5XML(this.DOM.getElementsByTagName(param));
        } else {
            return elementsToP5XML(this.DOM.children);
        }
    }
    /**
   * Returns the first matching child element as a new
   * <a href="#/p5.XML">p5.XML</a> object.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChild('cat')`, then the first child element with the tag
   * `&lt;cat&gt;` will be returned. If a number is passed, as in
   * `myXML.getChild(1)`, then the child element at that index will be returned.
   *
   * @param {String|Integer} name element name or index.
   * @return {p5.XML} child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element that is a mammal.
   *   let goat = myXML.getChild('mammal');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = goat.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Goat" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the child element at index 1.
   *   let leopard = myXML.getChild(1);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = leopard.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Leopard" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ getChild(param) {
        if (typeof param === 'string') {
            for (const child of this.DOM.children){
                if (child.tagName === param) return new XML(child);
            }
        } else {
            return new XML(this.DOM.children[param]);
        }
    }
    /**
   * Adds a new child element and returns a reference to it.
   *
   * The parameter, `child`, is the <a href="#/p5.XML">p5.XML</a> object to add
   * as a child element. For example, calling `myXML.addChild(otherXML)` inserts
   * `otherXML` as a child element of `myXML`.
   *
   * @param {p5.XML} child child element to add.
   * @return {p5.XML} added child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a new p5.XML object.
   *   let newAnimal = new p5.XML();
   *
   *   // Set its properties.
   *   newAnimal.setName('hydrozoa');
   *   newAnimal.setAttribute('id', 4);
   *   newAnimal.setAttribute('species', 'Physalia physalis');
   *   newAnimal.setContent('Bluebottle');
   *
   *   // Add the child element.
   *   myXML.addChild(newAnimal);
   *
   *   // Get the first child element that is a hydrozoa.
   *   let blueBottle = myXML.getChild('hydrozoa');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = blueBottle.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Bluebottle" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ addChild(node) {
        if (node instanceof XML) {
            this.DOM.appendChild(node.DOM);
        }
    }
    /**
   * Removes the first matching child element.
   *
   * The parameter, `name`, is the child element to remove. If a string is
   * passed, as in `myXML.removeChild('cat')`, then the first child element
   * with the tag `&lt;cat&gt;` will be removed. If a number is passed, as in
   * `myXML.removeChild(1)`, then the child element at that index will be
   * removed.
   *
   * @param {String|Integer} name name or index of the child element to remove.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the first mammal element.
   *   myXML.removeChild('mammal');
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the element at index 2.
   *   myXML.removeChild(2);
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ removeChild(param) {
        let ind = -1;
        if (typeof param === 'string') {
            for(let i = 0; i < this.DOM.children.length; i++){
                if (this.DOM.children[i].tagName === param) {
                    ind = i;
                    break;
                }
            }
        } else {
            ind = param;
        }
        if (ind !== -1) {
            this.DOM.removeChild(this.DOM.children[ind]);
        }
    }
    /**
   * Returns the number of attributes the element has.
   *
   * @return {Integer} number of attributes.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let numAttributes = first.getAttributeCount();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the number of attributes.
   *   text(numAttributes, 50, 50);
   *
   *   describe('The number "2" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ getAttributeCount() {
        return this.DOM.attributes.length;
    }
    /**
   * Returns an `Array` with the names of the element's attributes.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @return {String[]} attribute names.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let attributes = first.listAttributes();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's attributes.
   *   text(attributes, 50, 50);
   *
   *   describe('The text "id,species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ listAttributes() {
        const arr = [];
        for (const attribute of this.DOM.attributes){
            arr.push(attribute.nodeName);
        }
        return arr;
    }
    /**
   * Returns `true` if the element has a given attribute and `false` if not.
   *
   * The parameter, `name`, is a string with the name of the attribute being
   * checked.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @return {boolean} whether the element has the attribute.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first mammal child element.
   *   let mammal = myXML.getChild('mammal');
   *
   *   // Check whether the element has an
   *   // species attribute.
   *   let hasSpecies = mammal.hasAttribute('species');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display whether the element has a species attribute.
   *   if (hasSpecies === true) {
   *     text('Species', 50, 50);
   *   } else {
   *     text('No species', 50, 50);
   *   }
   *
   *   describe('The text "Species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ hasAttribute(name) {
        const obj = {};
        for (const attribute of this.DOM.attributes){
            obj[attribute.nodeName] = attribute.nodeValue;
        }
        return obj[name] ? true : false;
    }
    /**
   * Return an attribute's value as a `Number`.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getNum('id')` returns the
   * element's `id` attribute as a number.
   *
   * The second parameter, `defaultValue`, is optional. If a number is passed,
   * as in `myXML.getNum('id', -1)`, it will be returned if the attribute
   * doesn't exist or can't be converted to a number.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {Number} attribute value as a number.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's ID.
   *   let id = reptile.getNum('id');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${id + 1}th`, 5, 50, 90);
   *
   *   describe(`The text "${content} is ${id + 1}th" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's size.
   *   let weight = reptile.getNum('weight', 135);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${weight}kg`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${weight}kg" written in black on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */ getNum(name, defaultValue) {
        const obj = {};
        for (const attribute of this.DOM.attributes){
            obj[attribute.nodeName] = attribute.nodeValue;
        }
        return Number(obj[name]) || defaultValue || 0;
    }
    /**
   * Return an attribute's value as a string.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getString('color')` returns the
   * element's `id` attribute as a string.
   *
   * The second parameter, `defaultValue`, is optional. If a string is passed,
   * as in `myXML.getString('color', 'deeppink')`, it will be returned if the
   * attribute doesn't exist.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {String} attribute value as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's species.
   *   let species = reptile.getString('species');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the species attribute.
   *   text(`${content}: ${species}`, 5, 50, 90);
   *
   *   describe(`The text "${content}: ${species}" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color', 'green');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *   fill(attribute);
   *
   *   // Display the element's content.
   *   text(content, 50, 50);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */ getString(name, defaultValue) {
        const obj = {};
        for (const attribute of this.DOM.attributes){
            obj[attribute.nodeName] = attribute.nodeValue;
        }
        return obj[name] ? String(obj[name]) : defaultValue || null;
    }
    /**
   * Sets an attribute to a given value.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being set.
   *
   * The second parameter, `value`, is the attribute's new value. For example,
   * calling `myXML.setAttribute('id', 123)` sets the `id` attribute to the
   * value 123.
   *
   * @param {String} name name of the attribute to be set.
   * @param {Number|String|Boolean} value attribute's new value.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Set the reptile's color.
   *   reptile.setAttribute('color', 'green');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(`${content} is ${attribute}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${attribute}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */ setAttribute(name, value) {
        this.DOM.setAttribute(name, value);
    }
    /**
   * Returns the element's content as a `String`.
   *
   * The parameter, `defaultValue`, is optional. If a string is passed, as in
   * `myXML.getContent('???')`, it will be returned if the element has no
   * content.
   *
   * @param {String} [defaultValue] value to return if the element has no
   *                                content.
   * @return {String} element's content as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.XML object.
   *   let blankSpace = new p5.XML();
   *
   *   // Get the element's content and use a default value.
   *   let content = blankSpace.getContent('Your name');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */ getContent(defaultValue) {
        let str;
        str = this.DOM.textContent;
        str = str.replace(/\s\s+/g, ',');
        return str || defaultValue || null;
    }
    /**
   * Sets the element's content.
   *
   * An element's content is the text between its tags. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the content `JavaScript`.
   *
   * The parameter, `content`, is a string with the element's new content.
   *
   * @method setContent
   * @param {String} content new content for the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's original content.
   *   let oldContent = reptile.getContent();
   *
   *   // Set the reptile's content.
   *   reptile.setContent('Loggerhead');
   *
   *   // Get the reptile's new content.
   *   let newContent = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's old and new content.
   *   text(`${oldContent}: ${newContent}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${oldContent}: ${newContent}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */ setContent(content) {
        if (!this.DOM.children.length) {
            this.DOM.textContent = content;
        }
    }
    /**
   * Returns the element as a `String`.
   *
   * `myXML.serialize()` is useful for sending the element over the network or
   * saving it to a file.
   *
   * @return {String} element as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Display instructions.
   *   text('Double-click to save', 5, 50, 90);
   *
   *   describe('The text "Double-click to save" written in black on a gray background.');
   * }
   *
   * // Save the file when the user double-clicks.
   * function doubleClicked() {
   *   // Create a p5.PrintWriter object.
   *   // Use the file format .xml.
   *   let myWriter = createWriter('animals', 'xml');
   *
   *   // Serialize the XML data to a string.
   *   let data = myXML.serialize();
   *
   *   // Write the data to the print stream.
   *   myWriter.write(data);
   *
   *   // Save the file and close the print stream.
   *   myWriter.close();
   * }
   * </code>
   * </div>
   */ serialize() {
        const xmlSerializer = new XMLSerializer();
        return xmlSerializer.serializeToString(this.DOM);
    }
}
function elementsToP5XML(elements) {
    const arr = [];
    for(let i = 0; i < elements.length; i++){
        arr.push(new XML(elements[i]));
    }
    return arr;
}
function xml(p51, fn) {
    /**
   * A class to describe an XML object.
   *
   * Each `p5.XML` object provides an easy way to interact with XML data.
   * Extensible Markup Language
   * (<a href="https://developer.mozilla.org/en-US/docs/Web/XML/XML_introduction" target="_blank">XML</a>)
   * is a standard format for sending data between applications. Like HTML, the
   * XML format is based on tags and attributes, as in
   * `&lt;time units="s"&gt;1234&lt;/time&gt;`.
   *
   * Note: Use <a href="#/p5/loadXML">loadXML()</a> to load external XML files.
   *
   * @class p5.XML
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal tags.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the mammals array.
   *   for (let i = 0; i < mammals.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the mammal's common name.
   *     let name = mammals[i].getContent();
   *
   *     // Display the mammal's name.
   *     text(name, 20, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Zebra" written on three separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ p51.XML = XML;
}
if (typeof p5 !== 'undefined') {
    xml(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "_checkFileExtension",
    ()=>_checkFileExtension,
    "downloadFile",
    ()=>downloadFile
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
function downloadFile(data, fName, extension) {
    const fx = _checkFileExtension(fName, extension);
    const filename = fx[0];
    let saveData = data;
    if (!(saveData instanceof Blob)) {
        saveData = new Blob([
            data
        ]);
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["saveAs"](saveData, filename);
}
function _checkFileExtension(filename, extension) {
    if (!extension || extension === true || extension === 'true') {
        extension = '';
    }
    if (!filename) {
        filename = 'untitled';
    }
    let ext = '';
    // make sure the file will have a name, see if filename needs extension
    if (filename && filename.includes('.')) {
        ext = filename.split('.').pop();
    }
    // append extension if it doesn't exist
    if (extension) {
        if (ext !== extension) {
            ext = extension;
            filename = `${filename}.${ext}`;
        }
    }
    return [
        filename,
        ext
    ];
}
;
}),
"[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "stringify",
    ()=>stringify
]);
/*
The MIT License (MIT)

Copyright (c) 2019 Evan Plaice <evanplaice@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ function parse(csv, options, reviver = (v)=>v) {
    const ctx = Object.create(null);
    ctx.options = options || {};
    ctx.reviver = reviver;
    ctx.value = '';
    ctx.entry = [];
    ctx.output = [];
    ctx.col = 1;
    ctx.row = 1;
    ctx.options.delimiter = ctx.options.delimiter === undefined ? '"' : options.delimiter;
    if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0) throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
    ctx.options.separator = ctx.options.separator === undefined ? ',' : options.separator;
    if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0) throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
    const lexer = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r\n|\n|\r|[^${escapeRegExp(ctx.options.delimiter)}${escapeRegExp(ctx.options.separator)}\r\n]+`, 'y');
    const isNewline = /^(\r\n|\n|\r)$/;
    let matches = [];
    let match = '';
    let state = 0;
    while((matches = lexer.exec(csv)) !== null){
        match = matches[0];
        switch(state){
            case 0:
                switch(true){
                    case match === ctx.options.delimiter:
                        state = 3;
                        break;
                    case match === ctx.options.separator:
                        state = 0;
                        valueEnd(ctx);
                        break;
                    case isNewline.test(match):
                        state = 0;
                        valueEnd(ctx);
                        entryEnd(ctx);
                        break;
                    default:
                        ctx.value += match;
                        state = 2;
                        break;
                }
                break;
            case 2:
                switch(true){
                    case match === ctx.options.separator:
                        state = 0;
                        valueEnd(ctx);
                        break;
                    case isNewline.test(match):
                        state = 0;
                        valueEnd(ctx);
                        entryEnd(ctx);
                        break;
                    default:
                        state = 4;
                        throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
                }
                break;
            case 3:
                switch(true){
                    case match === ctx.options.delimiter:
                        state = 4;
                        break;
                    default:
                        state = 3;
                        ctx.value += match;
                        break;
                }
                break;
            case 4:
                switch(true){
                    case match === ctx.options.delimiter:
                        state = 3;
                        ctx.value += match;
                        break;
                    case match === ctx.options.separator:
                        state = 0;
                        valueEnd(ctx);
                        break;
                    case isNewline.test(match):
                        state = 0;
                        valueEnd(ctx);
                        entryEnd(ctx);
                        break;
                    default:
                        throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
                }
                break;
        }
    }
    // flush the last value
    if (ctx.entry.length !== 0) {
        valueEnd(ctx);
        entryEnd(ctx);
    }
    return ctx.output;
}
function stringify(array, options = {}, replacer = (v)=>v) {
    const ctx = Object.create(null);
    ctx.options = options;
    ctx.options.eof = ctx.options.eof !== undefined ? ctx.options.eof : true;
    ctx.row = 1;
    ctx.col = 1;
    ctx.output = '';
    ctx.options.delimiter = ctx.options.delimiter === undefined ? '"' : options.delimiter;
    if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0) throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
    ctx.options.separator = ctx.options.separator === undefined ? ',' : options.separator;
    if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0) throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
    const needsDelimiters = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r\n|\n|\r`);
    array.forEach((row, rIdx)=>{
        let entry = '';
        ctx.col = 1;
        row.forEach((col, cIdx)=>{
            if (typeof col === 'string') {
                col = col.replace(new RegExp(ctx.options.delimiter, 'g'), `${ctx.options.delimiter}${ctx.options.delimiter}`);
                col = needsDelimiters.test(col) ? `${ctx.options.delimiter}${col}${ctx.options.delimiter}` : col;
            }
            entry += replacer(col, ctx.row, ctx.col);
            if (cIdx !== row.length - 1) {
                entry += ctx.options.separator;
            }
            ctx.col++;
        });
        switch(true){
            case ctx.options.eof:
            case !ctx.options.eof && rIdx !== array.length - 1:
                ctx.output += `${entry}\n`;
                break;
            default:
                ctx.output += `${entry}`;
                break;
        }
        ctx.row++;
    });
    return ctx.output;
}
function valueEnd(ctx) {
    const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;
    ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));
    ctx.value = '';
    ctx.col++;
}
function entryEnd(ctx) {
    ctx.output.push(ctx.entry);
    ctx.entry = [];
    ctx.row++;
    ctx.col = 1;
}
function inferType(value) {
    const isNumber = /.\./;
    switch(true){
        case value === 'true':
        case value === 'false':
            return value === 'true';
        case isNumber.test(value):
            return parseFloat(value);
        case isFinite(value):
            return parseInt(value);
        default:
            return value;
    }
}
function escapeRegExp(str) {
    return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
;
}),
"[project]/node_modules/p5/dist/io/p5.Table.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>table
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
;
/**
 * @module IO
 * @submodule Table
 * @requires core
 */ class Table {
    constructor(rows){
        this.columns = [];
        this.rows = [];
    }
    toString(separator = ',') {
        let rows = this.rows.map((row)=>row.arr);
        if (!this.columns.some((column)=>column === null)) {
            rows = [
                this.columns,
                ...rows
            ];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringify"])(rows, {
            separator
        });
    }
    /**
   *  Use <a href="/reference/p5.Table/addRow/">addRow()</a> to add a new row of data to a <a href="#/p5.Table">p5.Table</a> object. By default,
   *  an empty row is created. Typically, you would store a reference to
   *  the new row in a TableRow object (see newRow in the example above),
   *  and then set individual values using <a href="#/p5/set">set()</a>.
   *
   *  If a <a href="#/p5.TableRow">p5.TableRow</a> object is included as a parameter, then that row is
   *  duplicated and added to the table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param   {p5.TableRow} [row] row to be added to the table
   *  @return  {p5.TableRow} the row that was added
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 300x300 canvas
   *   createCanvas(300, 300);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row for "Wolf"
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *     newRow.setString('name', 'Wolf');
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *    textSize(12);  // Adjust text size as needed
   *
   *   // Display the table data on the canvas
   *   // Each cell is positioned based on its row and column
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       let x = c * 50 + 10;  // Horizontal spacing for each column
   *       let y = r * 30 + 20;  // Vertical spacing for each row
   *       text(table.getString(r, c), x * c, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ addRow(row) {
        // make sure it is a valid TableRow
        const r = row || new p5.TableRow();
        if (typeof r.arr === 'undefined' || typeof r.obj === 'undefined') {
            //r = new p5.prototype.TableRow(r);
            throw new Error(`invalid TableRow: ${r}`);
        }
        r.table = this;
        this.rows.push(r);
        return r;
    }
    /**
   * Removes a row from the table object.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param   {Integer} id ID number of the row to remove
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Remove the first row from the table
   *   table.removeRow(0);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's cell values are joined into a single string and drawn on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 18, y * 3);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ removeRow(id) {
        this.rows[id].table = null; // remove reference to table
        const chunk = this.rows.splice(id + 1, this.rows.length);
        this.rows.pop();
        this.rows = this.rows.concat(chunk);
    }
    /**
   * Returns a reference to the specified <a href="#/p5.TableRow">p5.TableRow</a>. The reference
   * can then be used to get and set values of the selected row.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {Integer}   rowID ID number of the row to get
   * @return {p5.TableRow} <a href="#/p5.TableRow">p5.TableRow</a> object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the row at index 1 (second row)
   *   let row = table.getRow(1);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set the text size
   *
   *   // Loop over each column in the row and display its value on the canvas
   *   for (let c = 0; c < table.getColumnCount(); c++) {
   *     text(row.getString(c), 10, 20 + c * 50 + 20);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getRow(r) {
        return this.rows[r];
    }
    /**
   *  Gets all rows from the table. Returns an array of <a href="#/p5.TableRow">p5.TableRow</a>s.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {p5.TableRow[]}   Array of <a href="#/p5.TableRow">p5.TableRow</a>s
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *
   *   // Warning: rows is an array of objects.
   *   // Set the 'name' of each row to 'Unicorn'
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the modified table values on the canvas
   *   // We'll join each row's values with a space and display each row on a new line.
   *   let y = 20; // Starting y position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2);
   *     y += 20; // Move to next line
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getRows() {
        return this.rows;
    }
    /**
   *  Finds the first row in the Table that contains the value
   *  provided, and returns a reference to that row. Even if
   *  multiple rows are possible matches, only the first matching
   *  row is returned. The column to search may be specified by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Find the row with the animal named "Zebra"
   *   let row = table.findRow('Zebra', 'name');
   *
   *   // Get the species from the found row
   *   let species = row.getString('species');
   *
   *   // Set text properties and display the species on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ findRow(value, column) {
        // try the Object
        if (typeof column === 'string') {
            for(let i = 0; i < this.rows.length; i++){
                if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
                    return this.rows[i];
                }
            }
        } else {
            // try the Array
            for(let j = 0; j < this.rows.length; j++){
                if (this.rows[j].arr[column] === value) {
                    return this.rows[j];
                }
            }
        }
        // otherwise...
        return null;
    }
    /**
   *  Finds the rows in the Table that contain the value
   *  provided, and returns references to those rows. Returns an
   *  Array, so for must be used to iterate through all the rows,
   *  as shown in the example above. The column to search may be
   *  specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow[]}        An Array of TableRow objects
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add another goat entry
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Scape Goat');
   *   newRow.setString('name', 'Goat');
   *
   *   // Find rows where the name is "Goat"
   *   let rows = table.findRows('Goat', 'name');
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the result on the canvas
   *   text(rows.length + ' Goats found', 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ findRows(value, column) {
        const ret = [];
        if (typeof column === 'string') {
            for(let i = 0; i < this.rows.length; i++){
                if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
                    ret.push(this.rows[i]);
                }
            }
        } else {
            // try the Array
            for(let j = 0; j < this.rows.length; j++){
                if (this.rows[j].arr[column] === value) {
                    ret.push(this.rows[j]);
                }
            }
        }
        return ret;
    }
    /**
   * Finds the first row in the Table that matches the regular
   * expression provided, and returns a reference to that row.
   * Even if multiple rows are possible matches, only the first
   * matching row is returned. The column to search may be
   * specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String|RegExp} regexp The regular expression to match
   * @param  {String|Integer} column The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow}        TableRow object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Search using the specified regex on column index 1 (species)
   *   let mammal = table.matchRow(new RegExp('ant'), 1);
   *   let species = mammal.getString(1);  // "Panthera pardus"
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the species on the canvas
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ matchRow(regexp, column) {
        if (typeof column === 'number') {
            for(let j = 0; j < this.rows.length; j++){
                if (this.rows[j].arr[column].match(regexp)) {
                    return this.rows[j];
                }
            }
        } else {
            for(let i = 0; i < this.rows.length; i++){
                if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
                    return this.rows[i];
                }
            }
        }
        return null;
    }
    /**
   * Finds the rows in the Table that match the regular expression provided,
   * and returns references to those rows. Returns an array, so for must be
   * used to iterate through all the rows, as shown in the example. The
   * column to search may be specified by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String} regexp The regular expression to match
   * @param  {String|Integer} [column] The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow[]}          An Array of TableRow objects
   * @example
   * <div>
   * <code>
   * let table;
   *
   * function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Create a new p5.Table and add columns
   *   table = new p5.Table();
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   // Add rows to the table
   *    let newRow = table.addRow();
   *   newRow.setString('name', 'Lion');
   *    newRow.setString('type', 'Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Snake');
   *   newRow.setString('type', 'Reptile');
   *
   *    newRow = table.addRow();
   *   newRow.setString('name', 'Mosquito');
   *   newRow.setString('type', 'Insect');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Lizard');
   *   newRow.setString('type', 'Reptile');
   *
   *   // Search for rows where the "type" starts with "R"
   *   let rows = table.matchRows('R.*', 'type');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Text size
   *
   *   // Display each matching row on the canvas
   *   let y = 20;
   *   for (let i = 0; i < rows.length; i++) {
   *     let output = rows[i].getString('name') + ': ' + rows[i].getString('type');
   *     text(output, 10, y);
   *     y += 20;
   *   }
   * }
   * </code>
   * </div>
   */ matchRows(regexp, column) {
        const ret = [];
        if (typeof column === 'number') {
            for(let j = 0; j < this.rows.length; j++){
                if (this.rows[j].arr[column].match(regexp)) {
                    ret.push(this.rows[j]);
                }
            }
        } else {
            for(let i = 0; i < this.rows.length; i++){
                if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
                    ret.push(this.rows[i]);
                }
            }
        }
        return ret;
    }
    /**
   *  Retrieves all values in the specified column, and returns them
   *  as an array. The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Number} column String or Number of the column to return
   *  @return {Array}       Array of column values
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   //getColumn returns an array that can be printed directly
   *   print(table.getColumn('species'));
   *   //outputs ["Capra hircus", "Panthera pardus", "Equus zebra"]
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getColumn(value) {
        const ret = [];
        if (typeof value === 'string') {
            for(let i = 0; i < this.rows.length; i++){
                ret.push(this.rows[i].obj[this.columns.indexOf(value)]);
            }
        } else {
            for(let j = 0; j < this.rows.length; j++){
                ret.push(this.rows[j].arr[value]);
            }
        }
        return ret;
    }
    /**
   *  Removes all rows from a Table. While all rows are removed,
   *  columns and column titles are maintained.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Clear all rows from the table
   *   table.clearRows();
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the number of rows and columns on the canvas
   *   text(table.getRowCount() + ' total rows in table', 10, 30);
   *   text(table.getColumnCount() + ' total columns in table', 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ clearRows() {
        delete this.rows;
        this.rows = [];
    }
    /**
   *  Use <a href="/reference/p5.Table/addColumn/">addColumn()</a> to add a new column to a <a href="#/p5.Table">Table</a> object.
   *  Typically, you will want to specify a title, so the column
   *  may be easily referenced later by name. (If no title is
   *  specified, the new column's title will be null.)
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String} [title] title of the given column
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   createCanvas(300, 300);
   *   table = await loadTable('/assets/mammals.csv', ',', 'header');
   *
   *   table.addColumn('carnivore');
   *   table.set(0, 'carnivore', 'no');
   *   table.set(1, 'carnivore', 'yes');
   *   table.set(2, 'carnivore', 'no');
   *
   *   fill(0);      // Set text color to black
   *   textSize(11); // Adjust text size as needed
   *
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       // Keep column spacing consistent (e.g. 80 pixels apart).
   *       let x = c * 80 + 10;
   *       let y = r * 30 + 20;
   *       // Use x directly, rather than multiplying by c again
   *       text(table.getString(r, c), x, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ addColumn(title) {
        const t = title || null;
        this.columns.push(t);
    }
    /**
   *  Returns the total number of columns in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of columns in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   let numOfColumn = table.getColumnCount();
   *   text('There are ' + numOfColumn + ' columns in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */ getColumnCount() {
        return this.columns.length;
    }
    /**
   *  Returns the total number of rows in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of rows in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * //
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   text('There are ' + table.getRowCount() + ' rows in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */ getRowCount() {
        return this.rows.length;
    }
    /**
   *  Removes any of the specified characters (or "tokens").
   *
   *  If no column is specified, then the values in all columns and
   *  rows are processed. A specific column may be referenced by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} chars  String listing characters to be removed
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   $Lion  ,');
   *   newRow.setString('type', ',,,Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '$Snake  ');
   *   newRow.setString('type', ',,,Reptile');
   *
   *   table.removeTokens(',$ ');
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */ removeTokens(chars, column) {
        const escape = (s)=>s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
        const charArray = [];
        for(let i = 0; i < chars.length; i++){
            charArray.push(escape(chars.charAt(i)));
        }
        const regex = new RegExp(charArray.join('|'), 'g');
        if (typeof column === 'undefined') {
            for(let c = 0; c < this.columns.length; c++){
                for(let d = 0; d < this.rows.length; d++){
                    let s = this.rows[d].arr[c];
                    s = s.replace(regex, '');
                    this.rows[d].arr[c] = s;
                    this.rows[d].obj[this.columns[c]] = s;
                }
            }
        } else if (typeof column === 'string') {
            for(let j = 0; j < this.rows.length; j++){
                let val = this.rows[j].obj[column];
                val = val.replace(regex, '');
                this.rows[j].obj[column] = val;
                const pos = this.columns.indexOf(column);
                this.rows[j].arr[pos] = val;
            }
        } else {
            for(let k = 0; k < this.rows.length; k++){
                let str = this.rows[k].arr[column];
                str = str.replace(regex, '');
                this.rows[k].arr[column] = str;
                this.rows[k].obj[this.columns[column]] = str;
            }
        }
    }
    /**
   *  Trims leading and trailing whitespace, such as spaces and tabs,
   *  from String table values. If no column is specified, then the
   *  values in all columns and rows are trimmed. A specific column
   *  may be referenced by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   Lion  ,');
   *   newRow.setString('type', ' Mammal  ');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '  Snake  ');
   *   newRow.setString('type', '  Reptile  ');
   *
   *   table.trim();
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */ trim(column) {
        const regex = new RegExp(' ', 'g');
        if (typeof column === 'undefined') {
            for(let c = 0; c < this.columns.length; c++){
                for(let d = 0; d < this.rows.length; d++){
                    let s = this.rows[d].arr[c];
                    s = s.replace(regex, '');
                    this.rows[d].arr[c] = s;
                    this.rows[d].obj[this.columns[c]] = s;
                }
            }
        } else if (typeof column === 'string') {
            for(let j = 0; j < this.rows.length; j++){
                let val = this.rows[j].obj[column];
                val = val.replace(regex, '');
                this.rows[j].obj[column] = val;
                const pos = this.columns.indexOf(column);
                this.rows[j].arr[pos] = val;
            }
        } else {
            for(let k = 0; k < this.rows.length; k++){
                let str = this.rows[k].arr[column];
                str = str.replace(regex, '');
                this.rows[k].arr[column] = str;
                this.rows[k].obj[this.columns[column]] = str;
            }
        }
    }
    /**
   *  Use <a href="/reference/p5.Table/removeColumn/">removeColumn()</a> to remove an existing column from a Table
   *  object. The column to be removed may be identified by either
   *  its title (a String) or its index value (an int).
   *  removeColumn(0) would remove the first column, removeColumn(1)
   *  would remove the second column, and so on.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or ID (number)
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Remove the "id" column
   *    table.removeColumn('id');
   *
   *   // Get the remaining column count
   *   let colCount = table.getColumnCount();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the column count on the canvas
   *   text(colCount, 40, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ removeColumn(c) {
        let cString;
        let cNumber;
        if (typeof c === 'string') {
            // find the position of c in the columns
            cString = c;
            cNumber = this.columns.indexOf(c);
        } else {
            cNumber = c;
            cString = this.columns[c];
        }
        const chunk = this.columns.splice(cNumber + 1, this.columns.length);
        this.columns.pop();
        this.columns = this.columns.concat(chunk);
        for(let i = 0; i < this.rows.length; i++){
            const tempR = this.rows[i].arr;
            const chip = tempR.splice(cNumber + 1, tempR.length);
            tempR.pop();
            this.rows[i].arr = tempR.concat(chip);
            delete this.rows[i].obj[cString];
        }
    }
    /**
   * Stores a value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String|Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update the first row: change species to "Canis Lupus" and name to "Wolf"
   *   table.set(0, 'species', 'Canis Lupus');
   *   table.set(0, 'name', 'Wolf');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *    textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's values are concatenated into a single string and displayed on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2.5);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ set(row, column, value) {
        this.rows[row].set(column, value);
    }
    /**
   * Stores a Float value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas and set a white background
   *   createCanvas(100, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set the value in row 1, column "id" to the number 1
   *   table.setNum(1, 'id', 1);
   *
   *   // Get the first column as an array and join its values into a string for display.
   *   let col0 = table.getColumn(0);  // Expected output: ["0", 1, "2"]
   *   let output = col0.join(", ");
   *
   *   // Set text properties and display the output on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *   text(output, 30, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ setNum(row, column, value) {
        this.rows[row].setNum(column, value);
    }
    /**
   * Stores a String value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String} value  value to assign
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row with the new animal data
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *   newRow.setString('name', 'Wolf');
   *
   *   // Convert the table to a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);       // Set text color to black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;  // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join the values of each row with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 15, y * 2);
   *     y += 20;  // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ setString(row, column, value) {
        this.rows[row].setString(column, value);
    }
    /**
   * Retrieves a value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Get the values from the table
   *   let value1 = table.get(0, 1);       // Using column index (1) => "Capra hircus"
   *   let value2 = table.get(0, 'species'); // Using column name => "Capra hircus"
   *
   *   // Display the values on the canvas
   *   text(value1, 10, 30);
   *   text(value2, 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ get(row, column) {
        if (typeof column === 'string') {
            return this.rows[row].get(this.columns.indexOf(column));
        } else {
            return this.rows[row].get(column);
        }
    }
    /**
   * Retrieves a Float value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Compute the result: id at row 1, column 0 plus 100 (i.e. 1 + 100 = 101)
   *   let result = table.getNum(1, 0) + 100;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(result, 10, 30);  // Display the result at position (10, 30)
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getNum(row, column) {
        return this.rows[row].getNum(column);
    }
    /**
   * Retrieves a String value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each table cell value on the canvas one below the other.
   *   // We use a variable 'y' to increment the vertical position.
   *   let y = 20;
   *   text(table.getString(0, 0), 10, y); // 0
   *   y += 20;
   *   text(table.getString(0, 1), 10, y); // Capra hircus
   *   y += 20;
   *   text(table.getString(0, 2), 10, y); // Goat
   *   y += 20;
   *   text(table.getString(1, 0), 10, y); // 1
   *   y += 20;
   *   text(table.getString(1, 1), 10, y); // Panthera pardus
   *   y += 20;
   *   text(table.getString(1, 2), 10, y); // Leopard
   *   y += 20;
   *   text(table.getString(2, 0), 10, y); // 2
   *   y += 20;
   *   text(table.getString(2, 1), 10, y); // Equus zebra
   *   y += 20;
   *   text(table.getString(2, 2), 10, y); // Zebra
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getString(row, column) {
        return this.rows[row].getString(column);
    }
    /**
   * Retrieves all table data and returns as an object. If a column name is
   * passed in, each row object will be stored with that attribute as its
   * title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {String} [headerColumn] Name of the column which should be used to
   *                              title each row object (optional)
   * @return {Object}
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   let tableObject = table.getObject();
   *
   *   print(tableObject);
   *   //outputs an object
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getObject(headerColumn) {
        const tableObject = {};
        let obj, cPos, index;
        for(let i = 0; i < this.rows.length; i++){
            obj = this.rows[i].obj;
            if (typeof headerColumn === 'string') {
                cPos = this.columns.indexOf(headerColumn); // index of columnID
                if (cPos >= 0) {
                    index = obj[headerColumn];
                    tableObject[index] = obj;
                } else {
                    throw new Error(`This table has no column named "${headerColumn}"`);
                }
            } else {
                tableObject[i] = this.rows[i].obj;
            }
        }
        return tableObject;
    }
    /**
   * Retrieves all table data and returns it as a multidimensional array.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @return {Array}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the CSV data as a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the CSV on the canvas
   *   // Each row is displayed on a separate line
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(", ");
   *     text(rowText, 10, 20 + i * 50 + 30);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getArray() {
        const tableArray = [];
        for(let i = 0; i < this.rows.length; i++){
            tableArray.push(this.rows[i].arr);
        }
        return tableArray;
    }
}
function table(p51, fn) {
    /**
   *  Table Options
   *  Generic class for handling tabular data, typically from a
   *  CSV, TSV, or other sort of spreadsheet file.
   *  CSV files are
   *  <a href="http://en.wikipedia.org/wiki/Comma-separated_values">
   *  comma separated values</a>, often with the data in quotes. TSV
   *  files use tabs as separators, and usually don't bother with the
   *  quotes.
   *  File names should end with .csv if they're comma separated.
   *  A rough "spec" for CSV can be found
   *  <a href="http://tools.ietf.org/html/rfc4180">here</a>.
   *  To load files, use the <a href="#/p5/loadTable">loadTable</a> method.
   *  To save tables to your computer, use the <a href="#/p5/save">save</a> method
   *   or the <a href="#/p5/saveTable">saveTable</a> method.
   *
   *  Possible options include:
   *  <ul>
   *  <li>csv - parse the table as comma-separated values
   *  <li>tsv - parse the table as tab-separated values
   *  <li>header - this table has a header (title) row
   *  </ul>
   */ /**
   *  <a href="#/p5.Table">Table</a> objects store data with multiple rows and columns, much
   *  like in a traditional spreadsheet. Tables can be generated from
   *  scratch, dynamically, or using data from an existing file.
   *
   *  @class p5.Table
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {p5.TableRow[]}     [rows] An array of p5.TableRow objects
   */ p51.Table = Table;
/**
   * An array containing the names of the columns in the table, if the "header" the table is
   * loaded with the "header" parameter.
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @type {String[]}
   * @property columns
   * @for p5.Table
   * @name columns
   * @example
   * <div >
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Set text color to black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the column names on the canvas
   *   for (let c = 0; c < table.getColumnCount(); c++) {
   *     text('column ' + c + ' is named ' + table.columns[c], 10, 30 + c * 20);
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * An array containing the <a href="#/p5.Table">p5.TableRow</a> objects that make up the
   * rows of the table. The same result as calling <a href="/reference/p5.Table/getRows/">getRows()</a>
   * @type {p5.TableRow[]}
   * @property rows
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @for p5.Table
   * @name rows
   */ }
if (typeof p5 !== 'undefined') {
    table(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/io/p5.TableRow.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>tableRow
]);
/**
 * @module IO
 * @submodule Table
 * @requires core
 */ class TableRow {
    constructor(row = []){
        let arr = row;
        this.arr = arr;
        this.obj = Object.fromEntries(arr.entries());
        this.table = null;
    }
    /**
   *  Stores a value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number} value  The value to be stored
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set every row's "name" to "Unicorn"
   *    let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Convert the table to an array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Display each row of the table on the canvas
   *   let y = 20; // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20; // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ set(column, value) {
        // if typeof column is string, use .obj
        if (typeof column === 'string') {
            const cPos = this.table.columns.indexOf(column); // index of columnID
            if (cPos >= 0) {
                this.obj[column] = value;
                this.arr[cPos] = value;
            } else {
                throw new Error(`This table has no column named "${column}"`);
            }
        } else {
            // if typeof column is number, use .arr
            if (column < this.table.columns.length) {
                this.arr[column] = value;
                const cTitle = this.table.columns[column];
                this.obj[cTitle] = value;
            } else {
                throw new Error(`Column #${column} is out of the range of this table`);
            }
        }
    }
    /**
   *  Stores a Float value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {Number|String} value  The value to be stored
   *                                as a Float
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "id" to (row index + 10)
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].setNum('id', r + 10);
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join each row's values with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;  // Increment y for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ setNum(column, value) {
        const floatVal = parseFloat(value);
        this.set(column, floatVal);
    }
    /**
   *  Stores a String value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number|Boolean|Object} value  The value to be stored
   *                                as a String
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x200 canvas and set a white background
   *   createCanvas(300, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "name" field
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     let name = rows[r].getString('name');
   *     rows[r].setString('name', 'A ' + name + ' named George');
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;    // Increment y for the next row
   *   }
   *
   *   // describe('no image displayed');
   * }
   * </code>
   */ setString(column, value) {
        const stringVal = value.toString();
        this.set(column, stringVal);
    }
    /**
   *  Retrieves a value from the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x100 canvas and set a white background
   *   createCanvas(200, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Extract the names from each row and store them in an array
   *   let names = [];
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     names.push(rows[r].get('name'));
   *   }
   *
   *   // Set text properties and display the names on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Join names into a single string separated by commas
   *   let namesText = names.join(', ');
   *   text(namesText, 35, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ get(column) {
        if (typeof column === 'string') {
            return this.obj[this.table.columns.indexOf(column)];
        } else {
            return this.arr[column];
        }
    }
    /**
   *  Retrieves a Float value from the TableRow's specified
   *  column. The column may be specified by either its ID or
   *  title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {Number}  Float Floating point number
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x100 canvas and set a white background
   *   createCanvas(300, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *   let minId = Infinity;
   *   let maxId = -Infinity;
   *
   *   for (let r = 0; r < rows.length; r++) {
   *     let id = rows[r].getNum('id');
   *     minId = min(minId, id);
   *     maxId = max(maxId, id);
   *    }
   *
   *   let result = 'minimum id = ' + minId + ', maximum id = ' + maxId;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *   text(result, 10, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getNum(column) {
        let ret;
        if (typeof column === 'string') {
            ret = parseFloat(this.obj[this.table.columns.indexOf(column)]);
        } else {
            ret = parseFloat(this.arr[column]);
        }
        if (ret.toString() === 'NaN') {
            throw `Error: ${this.obj[column]} is NaN (Not a Number)`;
        }
        return ret;
    }
    /**
   *  Retrieves an String value from the TableRow's specified
   *  column. The column may be specified by either its ID or
   *  title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {String}  String
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x100 canvas and set a white background
   *   createCanvas(200, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *   let longest = '';
   *   for (let r = 0; r < rows.length; r++) {
   *      let species = rows[r].getString('species');
   *      if (longest.length < species.length) {
   *       longest = species;
   *     }
   *   }
   *
   *   let result = 'longest: ' + longest;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *   text(result, 30, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */ getString(column) {
        if (typeof column === 'string') {
            return this.obj[this.table.columns.indexOf(column)].toString();
        } else {
            return this.arr[column].toString();
        }
    }
}
function tableRow(p51, fn) {
    /**
   *  A TableRow object represents a single row of data values,
   *  stored in columns, from a table.
   *
   *  A Table Row contains both an ordered array, and an unordered
   *  JSON object.
   *
   *  @class p5.TableRow
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @constructor
   *  @param {any[]} row         optional: populate the row with an
   *                              array of values
   */ p51.TableRow = TableRow;
}
if (typeof p5 !== 'undefined') {
    tableRow(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/io/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>io
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$Table$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.Table.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$TableRow$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.TableRow.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function io(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$Table$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$TableRow$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Filters
]);
/*
 * This module defines the filters for use with image buffers.
 *
 * This module is basically a collection of functions stored in an object
 * as opposed to modules. The functions are destructive, modifying
 * the passed in canvas rather than creating a copy.
 *
 * Generally speaking users of this module will use the Filters.apply method
 * on a canvas to create an effect.
 *
 * A number of functions are borrowed/adapted from
 * http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
 * or the java processing implementation.
 *
 * @private
 */ const Filters = {
    /*
   * Helper functions
   */ /**
   * Returns the pixel buffer for a canvas.
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas the canvas to get pixels from
   * @return {Uint8ClampedArray}       a one-dimensional array containing
   *                                   the data in the RGBA order, with integer
   *                                   values between 0 and 255.
   */ _toPixels (canvas) {
        // Return pixel data if 'canvas' is an ImageData object.
        if (canvas instanceof ImageData) {
            return canvas.data;
        } else {
            // Check 2D context support.
            if (canvas.getContext('2d')) {
                // Retrieve pixel data.
                return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height).data;
            } else if (canvas.getContext('webgl')) {
                const gl = canvas.getContext('webgl');
                // Calculate the size of pixel data
                // (4 bytes per pixel - one byte for each RGBA channel).
                const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;
                const data = new Uint8Array(len);
                // Use gl.readPixels to fetch pixel data from the WebGL
                // canvas, storing it in the data array as UNSIGNED_BYTE integers.
                gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, data);
                return data;
            }
        }
    },
    /**
   * Returns a 32-bit number containing ARGB data at the ith pixel in the
   * 1D array containing pixels data.
   *
   * @private
   *
   * @param  {Uint8ClampedArray} data array returned by _toPixels()
   * @param  {Integer}           i    index of a 1D Image Array
   * @return {Integer}                32-bit integer value representing
   *                                  ARGB value.
   */ _getARGB (data, i) {
        // Determine the starting position in the 'data' array for the 'i'-th pixel.
        const offset = i * 4;
        return(// Combining the extracted components using bitwise OR operations to form the final ARGB value.
        data[offset + 3] << 24 & 0xff000000 | data[offset] << 16 & 0x00ff0000 | data[offset + 1] << 8 & 0x0000ff00 | data[offset + 2] & 0x000000ff //Extract blue component
        );
    },
    /**
   * Modifies pixels RGBA values to values contained in the data object.
   *
   * @private
   *
   * @param {Uint8ClampedArray} pixels array returned by _toPixels()
   * @param {Int32Array}        data   source 1D array where each value
   *                                   represents ARGB values
   */ _setPixels (pixels, data) {
        let offset = 0;
        for(let i = 0, al = pixels.length; i < al; i++){
            offset = i * 4;
            pixels[offset + 0] = (data[i] & 0x00ff0000) >>> 16;
            pixels[offset + 1] = (data[i] & 0x0000ff00) >>> 8;
            pixels[offset + 2] = data[i] & 0x000000ff;
            pixels[offset + 3] = (data[i] & 0xff000000) >>> 24;
        }
    },
    /**
   * Returns the ImageData object for a canvas.
   * https://developer.mozilla.org/en-US/docs/Web/API/ImageData
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas canvas to get image data from
   * @return {ImageData}               Holder of pixel data (and width and
   *                                   height) for a canvas
   */ _toImageData (canvas) {
        if (canvas instanceof ImageData) {
            return canvas;
        } else {
            return canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        }
    },
    /**
   * Returns a blank ImageData object.
   *
   * @private
   *
   * @param  {Integer} width
   * @param  {Integer} height
   * @return {ImageData}
   */ _createImageData (width, height) {
        Filters._tmpCanvas = document.createElement('canvas');
        Filters._tmpCtx = Filters._tmpCanvas.getContext('2d');
        return this._tmpCtx.createImageData(width, height);
    },
    /**
   * Applys a filter function to a canvas.
   *
   * The difference between this and the actual filter functions defined below
   * is that the filter functions generally modify the pixel buffer but do
   * not actually put that data back to the canvas (where it would actually
   * update what is visible). By contrast this method does make the changes
   * actually visible in the canvas.
   *
   * The apply method is the method that callers of this module would generally
   * use. It has been separated from the actual filters to support an advanced
   * use case of creating a filter chain that executes without actually updating
   * the canvas in between everystep.
   *
   * @private
   * @param  {HTMLCanvasElement} canvas The input canvas to apply the filter on.
   * @param  {function(ImageData,Object)} func The filter function to apply to the canvas's pixel data.
   * @param  {Object} filterParam An optional parameter to pass to the filter function.
   */ apply (canvas, func, filterParam) {
        const pixelsState = canvas.getContext('2d');
        const imageData = pixelsState.getImageData(0, 0, canvas.width, canvas.height);
        //Filters can either return a new ImageData object, or just modify
        //the one they received.
        const newImageData = func(imageData, filterParam);
        //If new ImageData is returned, replace the canvas's pixel data with it.
        if (newImageData instanceof ImageData) {
            pixelsState.putImageData(newImageData, 0, 0, 0, 0, canvas.width, canvas.height);
        } else {
            pixelsState.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);
        }
    },
    /*
   * Filters
   */ /**
   * Converts the image to black and white pixels depending if they are above or
   * below the threshold defined by the level parameter. The parameter must be
   * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param  {Canvas} canvas Canvas to apply thershold filter on.
   * @param  {Float} level Threshold level (0-1).
   */ threshold (canvas, level = 0.5) {
        const pixels = Filters._toPixels(canvas);
        // Calculate threshold value on a (0-255) scale.
        const thresh = Math.floor(level * 255);
        for(let i = 0; i < pixels.length; i += 4){
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            // CIE luminance for RGB
            const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            let val;
            if (gray >= thresh) {
                val = 255;
            } else {
                val = 0;
            }
            pixels[i] = pixels[i + 1] = pixels[i + 2] = val; //set pixel to val.
        }
    },
    /**
   * Converts any colors in the image to grayscale equivalents.
   * No parameter is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param {Canvas} canvas Canvas to apply gray filter on.
   */ gray (canvas) {
        const pixels = Filters._toPixels(canvas);
        for(let i = 0; i < pixels.length; i += 4){
            const r = pixels[i];
            const g = pixels[i + 1];
            const b = pixels[i + 2];
            // CIE luminance for RGB
            const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            pixels[i] = pixels[i + 1] = pixels[i + 2] = gray; // set pixel to gray.
        }
    },
    /**
   * Sets the alpha channel to entirely opaque. No parameter is used.
   *
   * @private
   * @param {Canvas} canvas
   */ opaque (canvas) {
        const pixels = Filters._toPixels(canvas);
        for(let i = 0; i < pixels.length; i += 4){
            pixels[i + 3] = 255;
        }
        return pixels;
    },
    /**
   * Sets each pixel to its inverse value. No parameter is used.
   * @private
   * @param  {Canvas} canvas
   */ invert (canvas) {
        const pixels = Filters._toPixels(canvas);
        for(let i = 0; i < pixels.length; i += 4){
            pixels[i] = 255 - pixels[i];
            pixels[i + 1] = 255 - pixels[i + 1];
            pixels[i + 2] = 255 - pixels[i + 2];
        }
    },
    /**
   * Limits each channel of the image to the number of colors specified as
   * the parameter. The parameter can be set to values between 2 and 255, but
   * results are most noticeable in the lower ranges.
   *
   * Adapted from java based processing implementation
   *
   * @private
   * @param  {Canvas} canvas
   * @param  {Integer} level
   */ posterize (canvas, level = 4) {
        const pixels = Filters._toPixels(canvas);
        if (level < 2 || level > 255) {
            throw new Error('Level must be greater than 2 and less than 255 for posterize');
        }
        const levels1 = level - 1;
        for(let i = 0; i < pixels.length; i += 4){
            const rlevel = pixels[i];
            const glevel = pixels[i + 1];
            const blevel = pixels[i + 2];
            // New pixel value by posterizing each color.
            pixels[i] = (rlevel * level >> 8) * 255 / levels1;
            pixels[i + 1] = (glevel * level >> 8) * 255 / levels1;
            pixels[i + 2] = (blevel * level >> 8) * 255 / levels1;
        }
    },
    /**
   * Increases the bright areas in an image.
   * @private
   * @param  {Canvas} canvas
   */ dilate (canvas) {
        const pixels = Filters._toPixels(canvas);
        let currIdx = 0;
        const maxIdx = pixels.length ? pixels.length / 4 : 0;
        const out = new Int32Array(maxIdx);
        let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
        let idxRight, idxLeft, idxUp, idxDown;
        let colRight, colLeft, colUp, colDown;
        let lumRight, lumLeft, lumUp, lumDown;
        // Iterates through rows of pixels.
        while(currIdx < maxIdx){
            currRowIdx = currIdx;
            maxRowIdx = currIdx + canvas.width;
            // Iterates through pixels within the current row.
            while(currIdx < maxRowIdx){
                // Get original color of current pixel.
                colOrig = colOut = Filters._getARGB(pixels, currIdx);
                idxLeft = currIdx - 1;
                idxRight = currIdx + 1;
                idxUp = currIdx - canvas.width;
                idxDown = currIdx + canvas.width;
                // Adjust the indices to avoid going out of bounds.
                if (idxLeft < currRowIdx) {
                    idxLeft = currIdx;
                }
                if (idxRight >= maxRowIdx) {
                    idxRight = currIdx;
                }
                if (idxUp < 0) {
                    idxUp = 0;
                }
                if (idxDown >= maxIdx) {
                    idxDown = currIdx;
                }
                colUp = Filters._getARGB(pixels, idxUp);
                colLeft = Filters._getARGB(pixels, idxLeft);
                colDown = Filters._getARGB(pixels, idxDown);
                colRight = Filters._getARGB(pixels, idxRight);
                // Compute luminance
                currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);
                lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);
                lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);
                lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);
                lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);
                // Update the output color based on the highest luminance value
                if (lumLeft > currLum) {
                    colOut = colLeft;
                    currLum = lumLeft;
                }
                if (lumRight > currLum) {
                    colOut = colRight;
                    currLum = lumRight;
                }
                if (lumUp > currLum) {
                    colOut = colUp;
                    currLum = lumUp;
                }
                if (lumDown > currLum) {
                    colOut = colDown;
                    currLum = lumDown;
                }
                // Store the updated color.
                out[currIdx++] = colOut;
            }
        }
        Filters._setPixels(pixels, out);
    },
    /**
   * Reduces the bright areas in an image.
   * Similar to `dilate()`, but updates the output color based on the lowest luminance value.
   * @private
   * @param  {Canvas} canvas
   */ erode (canvas) {
        const pixels = Filters._toPixels(canvas);
        let currIdx = 0;
        const maxIdx = pixels.length ? pixels.length / 4 : 0;
        const out = new Int32Array(maxIdx);
        let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
        let idxRight, idxLeft, idxUp, idxDown;
        let colRight, colLeft, colUp, colDown;
        let lumRight, lumLeft, lumUp, lumDown;
        while(currIdx < maxIdx){
            currRowIdx = currIdx;
            maxRowIdx = currIdx + canvas.width;
            while(currIdx < maxRowIdx){
                colOrig = colOut = Filters._getARGB(pixels, currIdx);
                idxLeft = currIdx - 1;
                idxRight = currIdx + 1;
                idxUp = currIdx - canvas.width;
                idxDown = currIdx + canvas.width;
                if (idxLeft < currRowIdx) {
                    idxLeft = currIdx;
                }
                if (idxRight >= maxRowIdx) {
                    idxRight = currIdx;
                }
                if (idxUp < 0) {
                    idxUp = 0;
                }
                if (idxDown >= maxIdx) {
                    idxDown = currIdx;
                }
                colUp = Filters._getARGB(pixels, idxUp);
                colLeft = Filters._getARGB(pixels, idxLeft);
                colDown = Filters._getARGB(pixels, idxDown);
                colRight = Filters._getARGB(pixels, idxRight);
                //compute luminance
                currLum = 77 * (colOrig >> 16 & 0xff) + 151 * (colOrig >> 8 & 0xff) + 28 * (colOrig & 0xff);
                lumLeft = 77 * (colLeft >> 16 & 0xff) + 151 * (colLeft >> 8 & 0xff) + 28 * (colLeft & 0xff);
                lumRight = 77 * (colRight >> 16 & 0xff) + 151 * (colRight >> 8 & 0xff) + 28 * (colRight & 0xff);
                lumUp = 77 * (colUp >> 16 & 0xff) + 151 * (colUp >> 8 & 0xff) + 28 * (colUp & 0xff);
                lumDown = 77 * (colDown >> 16 & 0xff) + 151 * (colDown >> 8 & 0xff) + 28 * (colDown & 0xff);
                if (lumLeft < currLum) {
                    colOut = colLeft;
                    currLum = lumLeft;
                }
                if (lumRight < currLum) {
                    colOut = colRight;
                    currLum = lumRight;
                }
                if (lumUp < currLum) {
                    colOut = colUp;
                    currLum = lumUp;
                }
                if (lumDown < currLum) {
                    colOut = colDown;
                    currLum = lumDown;
                }
                // Store the updated color.
                out[currIdx++] = colOut;
            }
        }
        Filters._setPixels(pixels, out);
    },
    blur (canvas, radius) {
        blurARGB(canvas, radius);
    }
};
// BLUR
// Internal kernel stuff for the gaussian blur filter.
let blurRadius;
let blurKernelSize;
let blurKernel;
let blurMult;
/*
 * Port of https://github.com/processing/processing/blob/
 * main/core/src/processing/core/PImage.java#L1250
 *
 * Optimized code for building the blur kernel.
 * further optimized blur code (approx. 15% for radius=20)
 * bigger speed gains for larger radii (~30%)
 * added support for various image types (ALPHA, RGB, ARGB)
 * [toxi 050728]
 */ function buildBlurKernel(r) {
    let radius = r * 3.5 | 0;
    radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
    if (blurRadius !== radius) {
        blurRadius = radius;
        // Calculating the size of the blur kernel
        blurKernelSize = 1 + blurRadius << 1;
        blurKernel = new Int32Array(blurKernelSize);
        blurMult = new Array(blurKernelSize);
        for(let l = 0; l < blurKernelSize; l++){
            blurMult[l] = new Int32Array(256);
        }
        let bk, bki;
        let bm, bmi;
        // Generating blur kernel values.
        for(let i = 1, radiusi = radius - 1; i < radius; i++){
            blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;
            bm = blurMult[radius + i];
            bmi = blurMult[radiusi--];
            for(let j = 0; j < 256; j++){
                bm[j] = bmi[j] = bki * j;
            }
        }
        bk = blurKernel[radius] = radius * radius;
        bm = blurMult[radius];
        for(let k = 0; k < 256; k++){
            bm[k] = bk * k;
        }
    }
}
// Port of https://github.com/processing/processing/blob/
// main/core/src/processing/core/PImage.java#L1433
function blurARGB(canvas, radius) {
    // Get pixel data.
    const pixels = Filters._toPixels(canvas);
    const width = canvas.width;
    const height = canvas.height;
    const numPackedPixels = width * height;
    const argb = new Int32Array(numPackedPixels);
    for(let j = 0; j < numPackedPixels; j++){
        argb[j] = Filters._getARGB(pixels, j);
    }
    let sum, cr, cg, cb, ca;
    let read, ri, ym, ymi, bk0;
    const a2 = new Int32Array(numPackedPixels);
    const r2 = new Int32Array(numPackedPixels);
    const g2 = new Int32Array(numPackedPixels);
    const b2 = new Int32Array(numPackedPixels);
    let yi = 0;
    buildBlurKernel(radius);
    let x, y, i;
    let bm;
    // Horizontal pass.
    for(y = 0; y < height; y++){
        for(x = 0; x < width; x++){
            cb = cg = cr = ca = sum = 0;
            read = x - blurRadius;
            // Handle edge cases.
            if (read < 0) {
                bk0 = -read;
                read = 0;
            } else {
                if (read >= width) {
                    break;
                }
                bk0 = 0;
            }
            for(i = bk0; i < blurKernelSize; i++){
                if (read >= width) {
                    break;
                }
                const c = argb[read + yi];
                bm = blurMult[i];
                ca += bm[(c & -16777216) >>> 24];
                cr += bm[(c & 16711680) >> 16];
                cg += bm[(c & 65280) >> 8];
                cb += bm[c & 255];
                sum += blurKernel[i];
                read++;
            }
            ri = yi + x;
            a2[ri] = ca / sum;
            r2[ri] = cr / sum;
            g2[ri] = cg / sum;
            b2[ri] = cb / sum;
        }
        yi += width;
    }
    yi = 0;
    ym = -blurRadius;
    ymi = ym * width;
    //  Vertical pass.
    for(y = 0; y < height; y++){
        for(x = 0; x < width; x++){
            cb = cg = cr = ca = sum = 0;
            // Handle edge cases.
            if (ym < 0) {
                bk0 = ri = -ym;
                read = x;
            } else {
                if (ym >= height) {
                    break;
                }
                bk0 = 0;
                ri = ym;
                read = x + ymi;
            }
            for(i = bk0; i < blurKernelSize; i++){
                if (ri >= height) {
                    break;
                }
                bm = blurMult[i];
                ca += bm[a2[read]];
                cr += bm[r2[read]];
                cg += bm[g2[read]];
                cb += bm[b2[read]];
                sum += blurKernel[i];
                ri++;
                read += width;
            }
            // Set final ARGB value
            argb[x + yi] = ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;
        }
        yi += width;
        ymi += width;
        ym++;
    }
    Filters._setPixels(pixels, argb);
}
;
}),
"[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>pixels
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
;
/**
 * @module Image
 * @submodule Pixels
 * @for p5
 * @requires core
 */ function pixels(p51, fn) {
    /**
   * Copies a region of pixels from one image to another.
   *
   * The first parameter, `srcImage`, is the
   * <a href="#/p5.Image">p5.Image</a> object to blend.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to blend from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the regions width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the regions width and height.
   *
   * The tenth parameter, `blendMode`, sets the effect used to blend the images'
   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,
   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,
   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`
   *
   * @method blend
   * @param  {p5.Image} srcImage source image.
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either
   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,
   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,
   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.
   *
   * @example
   * <div>
   * <code>
   * let img0;
   * let img1;
   *
   * async function setup() {
   *   // Load the images.
   *   img0 = await loadImage('assets/rockies.jpg');
   *   img1 = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Use the mountains as the background.
   *   background(img0);
   *
   *   // Display the bricks.
   *   image(img1, 0, 0);
   *
   *   // Display the bricks faded into the landscape.
   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img0;
   * let img1;
   *
   * async function setup() {
   *   // Load the images.
   *   img0 = await loadImage('assets/rockies.jpg');
   *   img1 = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Use the mountains as the background.
   *   background(img0);
   *
   *   // Display the bricks.
   *   image(img1, 0, 0);
   *
   *   // Display the bricks partially transparent.
   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img0;
   * let img1;
   *
   * async function setup() {
   *   // Load the images.
   *   img0 = await loadImage('assets/rockies.jpg');
   *   img1 = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Use the mountains as the background.
   *   background(img0);
   *
   *   // Display the bricks.
   *   image(img1, 0, 0);
   *
   *   // Display the bricks washed out into the landscape.
   *   blend(img1, 0, 0, 33, 100, 67, 0, 33, 100, ADD);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');
   * }
   * </code>
   * </div>
   */ /**
   * @method blend
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode
   */ fn.blend = function(...args) {
        // p5._validateParameters('blend', args);
        if (this._renderer) {
            this._renderer.blend(...args);
        } else {
            p51.Renderer2D.prototype.blend.apply(this, args);
        }
    };
    /**
   * Copies pixels from a source image to a region of the canvas.
   *
   * The first parameter, `srcImage`, is the
   * <a href="#/p5.Image">p5.Image</a> object to blend. The source image can be
   * the canvas itself or a
   * <a href="#/p5.Image">p5.Image</a> object. `copy()` will scale pixels from
   * the source region if it isn't the same size as the destination region.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to copy from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the region's width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of the canvas to copy into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the region's width and height.
   *
   * @method copy
   * @param  {p5.Image|p5.Element} srcImage source image.
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Use the mountains as the background.
   *   background(img);
   *
   *   // Copy a region of pixels to another spot.
   *   copy(img, 7, 22, 10, 10, 35, 25, 50, 50);
   *
   *   // Outline the copied region.
   *   stroke(255);
   *   noFill();
   *   square(7, 22, 10);
   *
   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');
   * }
   * </code>
   * </div>
   */ /**
   * @method copy
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   */ fn.copy = function(...args) {
        let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
        if (args.length === 9) {
            srcImage = args[0];
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else if (args.length === 8) {
            srcImage = this;
            sx = args[0];
            sy = args[1];
            sw = args[2];
            sh = args[3];
            dx = args[4];
            dy = args[5];
            dw = args[6];
            dh = args[7];
        } else {
            throw new Error('Signature not supported');
        }
        fn._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
    };
    fn._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh)=>{
        const s = srcImage.canvas.width / srcImage.width;
        // adjust coord system for 3D when renderer
        // ie top-left = -width/2, -height/2
        let sxMod = 0;
        let syMod = 0;
        if (srcImage._renderer && srcImage._renderer.isP3D) {
            sxMod = srcImage.width / 2;
            syMod = srcImage.height / 2;
        }
        if (dstImage._renderer && dstImage._renderer.isP3D) {
            dstImage.push();
            dstImage.resetMatrix();
            dstImage.noLights();
            dstImage.blendMode(dstImage.BLEND);
            dstImage.imageMode(dstImage.CORNER);
            dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
            dstImage.pop();
        } else {
            dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
        }
    };
    /**
   * Applies an image filter to the canvas.
   *
   * The preset options are:
   *
   * `INVERT`
   * Inverts the colors in the image. No parameter is used.
   *
   * `GRAY`
   * Converts the image to grayscale. No parameter is used.
   *
   * `THRESHOLD`
   * Converts the image to black and white. Pixels with a grayscale value
   * above a given threshold are converted to white. The rest are converted to
   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no
   * value is specified, 0.5 is used.
   *
   * `OPAQUE`
   * Sets the alpha channel to entirely opaque. No parameter is used.
   *
   * `POSTERIZE`
   * Limits the number of colors in the image. Each color channel is limited to
   * the number of colors specified. Values between 2 and 255 are valid, but
   * results are most noticeable with lower values. The default value is 4.
   *
   * `BLUR`
   * Blurs the image. The level of blurring is specified by a blur radius. Larger
   * values increase the blur. The default value is 4. A gaussian blur is used
   * in `P2D` mode. A box blur is used in `WEBGL` mode.
   *
   * `ERODE`
   * Reduces the light areas. No parameter is used.
   *
   * `DILATE`
   * Increases the light areas. No parameter is used.
   *
   * `filter()` uses WebGL in the background by default because it's faster.
   * This can be disabled in `P2D` mode by adding a `false` argument, as in
   * `filter(BLUR, false)`. This may be useful to keep computation off the GPU
   * or to work around a lack of WebGL support.
   *
   * In WebgL mode, `filter()` can also use custom shaders. See
   * <a href="#/p5/createFilterShader">createFilterShader()</a> for more
   * information.
   *
   *
   * @method filter
   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,
   *                                POSTERIZE, BLUR, ERODE, DILATE or BLUR.
   * @param  {Number} [filterParam] parameter unique to each filter.
   * @param  {Boolean} [useWebGL=true]   flag to control whether to use fast
   *                                WebGL filters (GPU) or original image
   *                                filters (CPU); defaults to `true`.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the INVERT filter.
   *   filter(INVERT);
   *
   *   describe('A blue brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the GRAY filter.
   *   filter(GRAY);
   *
   *   describe('A brick wall drawn in grayscale.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the THRESHOLD filter.
   *   filter(THRESHOLD);
   *
   *   describe('A brick wall drawn in black and white.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the OPAQUE filter.
   *   filter(OPAQUE);
   *
   *   describe('A red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the POSTERIZE filter.
   *   filter(POSTERIZE, 3);
   *
   *   describe('An image of a red brick wall drawn with limited color palette.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the BLUR filter.
   *   filter(BLUR, 3);
   *
   *   describe('A blurry image of a red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the DILATE filter.
   *   filter(DILATE);
   *
   *   describe('A red brick wall with bright lines between each brick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the ERODE filter.
   *   filter(ERODE);
   *
   *   describe('A red brick wall with faint lines between each brick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Apply the BLUR filter.
   *   // Don't use WebGL.
   *   filter(BLUR, 3, false);
   *
   *   describe('A blurry image of a red brick wall.');
   * }
   * </code>
   * </div>
   */ /**
   * @method getFilterGraphicsLayer
   * @private
   * @returns {p5.Graphics}
   */ fn.getFilterGraphicsLayer = function() {
        return this._renderer.getFilterGraphicsLayer();
    };
    /**
   * @method filter
   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR)} filterType
   * @param  {Number} [filterParam]
   * @param  {Boolean} [useWebGL=true]
   */ /**
   * @method filter
   * @param {p5.Shader}  shaderFilter  shader that's been loaded, with the
   *                                   frag shader using a `tex0` uniform.
   */ fn.filter = function(...args) {
        // p5._validateParameters('filter', args);
        let { shader, operation, value, useWebGL } = parseFilterArgs(...args);
        // when passed a shader, use it directly
        if (this._renderer.isP3D && shader) {
            this._renderer.filter(shader);
            return;
        }
        // when opting out of webgl, use old pixels method
        if (!useWebGL && !this._renderer.isP3D) {
            if (this.canvas !== undefined) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].apply(this.canvas, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"][operation], value);
            } else {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].apply(this.elt, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"][operation], value);
            }
            return;
        }
        if (!useWebGL && this._renderer.isP3D) {
            console.warn('filter() with useWebGL=false is not supported in WEBGL');
        }
        // when this is a webgl renderer, apply constant shader filter
        if (this._renderer.isP3D) {
            this._renderer.filter(operation, value);
        } else {
            if (shader) {
                this._renderer.filterRenderer.setOperation(operation, value, shader);
            } else {
                this._renderer.filterRenderer.setOperation(operation, value);
            }
            this._renderer.filterRenderer.applyFilter();
        }
    };
    function parseFilterArgs(...args) {
        // args could be:
        // - operation, value, [useWebGL]
        // - operation, [useWebGL]
        // - shader
        let result = {
            shader: undefined,
            operation: undefined,
            value: undefined,
            useWebGL: true
        };
        if (args[0] instanceof p51.Shader) {
            result.shader = args[0];
            return result;
        } else {
            result.operation = args[0];
        }
        if (args.length > 1 && typeof args[1] === 'number') {
            result.value = args[1];
        }
        if (args[args.length - 1] === false) {
            result.useWebGL = false;
        }
        return result;
    }
    /**
   * Gets a pixel or a region of pixels from the canvas.
   *
   * `get()` is easy to use but it's not as fast as
   * <a href="#/p5/pixels">pixels</a>. Use <a href="#/p5/pixels">pixels</a>
   * to read many pixel values.
   *
   * The version of `get()` with no parameters returns the entire canvas.
   *
   * The version of `get()` with two parameters interprets them as
   * coordinates. It returns an array with the `[R, G, B, A]` values of the
   * pixel at the given point.
   *
   * The version of `get()` with four parameters interprets them as coordinates
   * and dimensions. It returns a subsection of the canvas as a
   * <a href="#/p5.Image">p5.Image</a> object. The first two parameters are the
   * coordinates for the upper-left corner of the subsection. The last two
   * parameters are the width and height of the subsection.
   *
   * Use <a href="#/p5.Image/get">p5.Image.get()</a> to work directly with
   * <a href="#/p5.Image">p5.Image</a> objects.
   *
   * @method get
   * @param  {Number}         x x-coordinate of the pixel.
   * @param  {Number}         y y-coordinate of the pixel.
   * @param  {Number}         w width of the subsection to be returned.
   * @param  {Number}         h height of the subsection to be returned.
   * @return {p5.Image}       subsection as a <a href="#/p5.Image">p5.Image</a> object.
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get the entire canvas.
   *   let c = get();
   *
   *   // Display half the canvas.
   *   image(c, 50, 0);
   *
   *   describe('Two identical mountain landscapes shown side-by-side.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get the color of a pixel.
   *   let c = get(50, 90);
   *
   *   // Style the square with the pixel's color.
   *   fill(c);
   *   noStroke();
   *
   *   // Display the square.
   *   square(25, 25, 50);
   *
   *   describe('A mountain landscape with an olive green square in its center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get a region of the image.
   *   let c = get(0, 0, 50, 50);
   *
   *   // Display the region.
   *   image(c, 50, 50);
   *
   *   describe('A mountain landscape drawn on top of another mountain landscape.');
   * }
   * </code>
   * </div>
   */ /**
   * @method get
   * @return {p5.Image}      whole canvas as a <a href="#/p5.Image">p5.Image</a>.
   */ /**
   * @method get
   * @param  {Number}        x
   * @param  {Number}        y
   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.
   */ fn.get = function(x, y, w, h) {
        // p5._validateParameters('get', arguments);
        return this._renderer.get(...arguments);
    };
    /**
   * Loads the current value of each pixel on the canvas into the
   * <a href="#/p5/pixels">pixels</a> array.
   *
   * `loadPixels()` must be called before reading from or writing to
   * <a href="#/p5/pixels">pixels</a>.
   *
   * @method loadPixels
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0, 100, 100);
   *
   *   // Get the pixel density.
   *   let d = pixelDensity();
   *
   *   // Calculate the halfway index in the pixels array.
   *   let halfImage = 4 * (d * width) * (d * height / 2);
   *
   *   // Load the pixels array.
   *   loadPixels();
   *
   *   // Copy the top half of the canvas to the bottom.
   *   for (let i = 0; i < halfImage; i += 1) {
   *     pixels[i + halfImage] = pixels[i];
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('Two identical images of mountain landscapes, one on top of the other.');
   * }
   * </code>
   * </div>
   */ fn.loadPixels = function(...args) {
        // p5._validateParameters('loadPixels', args);
        this._renderer.loadPixels();
    };
    /**
   * Sets the color of a pixel or draws an image to the canvas.
   *
   * `set()` is easy to use but it's not as fast as
   * <a href="#/p5/pixels">pixels</a>. Use <a href="#/p5/pixels">pixels</a>
   * to set many pixel values.
   *
   * `set()` interprets the first two parameters as x- and y-coordinates. It
   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel
   * array, a <a href="#/p5.Color">p5.Color</a> object, or a
   * <a href="#/p5.Image">p5.Image</a> object. If an image is passed, the first
   * two parameters set the coordinates for the image's upper-left corner,
   * regardless of the current <a href="#/p5/imageMode">imageMode()</a>.
   *
   * <a href="#/p5/updatePixels">updatePixels()</a> must be called after using
   * `set()` for changes to appear.
   *
   * @method set
   * @param {Number}              x x-coordinate of the pixel.
   * @param {Number}              y y-coordinate of the pixel.
   * @param {Number|Number[]|Object} c grayscale value | pixel array |
   *                                <a href="#/p5.Color">p5.Color</a> object | <a href="#/p5.Image">p5.Image</a> to copy.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set four pixels to black.
   *   set(30, 20, 0);
   *   set(85, 20, 0);
   *   set(85, 75, 0);
   *   set(30, 75, 0);
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let black = color(0);
   *
   *   // Set four pixels to black.
   *   set(30, 20, black);
   *   set(85, 20, black);
   *   set(85, 75, black);
   *   set(30, 75, black);
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(255);
   *
   *   // Draw a horizontal color gradient.
   *   for (let x = 0; x < 100; x += 1) {
   *     for (let y = 0; y < 100; y += 1) {
   *       // Calculate the grayscale value.
   *       let c = map(x, 0, 100, 0, 255);
   *
   *       // Set the pixel using the grayscale value.
   *       set(x, y, c);
   *     }
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('A horiztonal color gradient from black to white.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Use the image to set all pixels.
   *   set(0, 0, img);
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('An image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */ fn.set = function(x, y, imgOrCol) {
        this._renderer.set(x, y, imgOrCol);
    };
    /**
   * Updates the canvas with the RGBA values in the
   * <a href="#/p5/pixels">pixels</a> array.
   *
   * `updatePixels()` only needs to be called after changing values in the
   * <a href="#/p5/pixels">pixels</a> array. Such changes can be made directly
   * after calling <a href="#/p5/loadPixels">loadPixels()</a> or by calling
   * <a href="#/p5/set">set()</a>.
   *
   * @method updatePixels
   * @param  {Number} [x]    x-coordinate of the upper-left corner of region
   *                         to update.
   * @param  {Number} [y]    y-coordinate of the upper-left corner of region
   *                         to update.
   * @param  {Number} [w]    width of region to update.
   * @param  {Number} [h]    height of region to update.
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0, 100, 100);
   *
   *   // Get the pixel density.
   *   let d = pixelDensity();
   *
   *   // Calculate the halfway index in the pixels array.
   *   let halfImage = 4 * (d * width) * (d * height / 2);
   *
   *   // Load the pixels array.
   *   loadPixels();
   *
   *   // Copy the top half of the canvas to the bottom.
   *   for (let i = 0; i < halfImage; i += 1) {
   *     pixels[i + halfImage] = pixels[i];
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('Two identical images of mountain landscapes, one on top of the other.');
   * }
   * </code>
   * </div>
   */ fn.updatePixels = function(x, y, w, h) {
        // p5._validateParameters('updatePixels', arguments);
        // graceful fail - if loadPixels() or set() has not been called, pixel
        // array will be empty, ignore call to updatePixels()
        if (this.pixels.length === 0) {
            return;
        }
        this._renderer.updatePixels(x, y, w, h);
    };
/**
   * An array containing the color of each pixel on the canvas.
   *
   * Colors are stored as numbers representing red, green, blue, and alpha
   * (RGBA) values. `pixels` is a one-dimensional array for performance reasons.
   *
   * Each pixel occupies four elements in the `pixels` array, one for each RGBA
   * value. For example, the pixel at coordinates (0, 0) stores its RGBA values
   * at `pixels[0]`, `pixels[1]`, `pixels[2]`, and `pixels[3]`, respectively.
   * The next pixel at coordinates (1, 0) stores its RGBA values at `pixels[4]`,
   * `pixels[5]`, `pixels[6]`, and `pixels[7]`. And so on. The `pixels` array
   * for a 100&times;100 canvas has 100 &times; 100 &times; 4 = 40,000 elements.
   *
   * Some displays use several smaller pixels to set the color at a single
   * point. The <a href="#/p5/pixelDensity">pixelDensity()</a> function returns
   * the pixel density of the canvas. High density displays often have a
   * <a href="#/p5/pixelDensity">pixelDensity()</a> of 2. On such a display, the
   * `pixels` array for a 100&times;100 canvas has 200 &times; 200 &times; 4 =
   * 160,000 elements.
   *
   * Accessing the RGBA values for a point on the canvas requires a little math
   * as shown below. The <a href="#/p5/loadPixels">loadPixels()</a> function
   * must be called before accessing the `pixels` array. The
   * <a href="#/p5/updatePixels">updatePixels()</a> function must be called
   * after any changes are made.
   *
   * @property {Number[]} pixels
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(128);
   *
   *   // Load the pixels array.
   *   loadPixels();
   *
   *   // Set the dot's coordinates.
   *   let x = 50;
   *   let y = 50;
   *
   *   // Get the pixel density.
   *   let d = pixelDensity();
   *
   *   // Set the pixel(s) at the center of the canvas black.
   *   for (let i = 0; i < d; i += 1) {
   *     for (let j = 0; j < d; j += 1) {
   *       let index = 4 * ((y * d + j) * width * d + (x * d + i));
   *       // Red.
   *       pixels[index] = 0;
   *       // Green.
   *       pixels[index + 1] = 0;
   *       // Blue.
   *       pixels[index + 2] = 0;
   *       // Alpha.
   *       pixels[index + 3] = 255;
   *     }
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('A black dot in the middle of a gray rectangle.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Load the pixels array.
   *   loadPixels();
   *
   *   // Get the pixel density.
   *   let d = pixelDensity();
   *
   *   // Calculate the halfway index in the pixels array.
   *   let halfImage = 4 * (d * width) * (d * height / 2);
   *
   *   // Make the top half of the canvas red.
   *   for (let i = 0; i < halfImage; i += 4) {
   *     // Red.
   *     pixels[i] = 255;
   *     // Green.
   *     pixels[i + 1] = 0;
   *     // Blue.
   *     pixels[i + 2] = 0;
   *     // Alpha.
   *     pixels[i + 3] = 255;
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('A red rectangle drawn above a gray rectangle.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Color object.
   *   let pink = color(255, 102, 204);
   *
   *   // Load the pixels array.
   *   loadPixels();
   *
   *   // Get the pixel density.
   *   let d = pixelDensity();
   *
   *   // Calculate the halfway index in the pixels array.
   *   let halfImage = 4 * (d * width) * (d * height / 2);
   *
   *   // Make the top half of the canvas red.
   *   for (let i = 0; i < halfImage; i += 4) {
   *     pixels[i] = red(pink);
   *     pixels[i + 1] = green(pink);
   *     pixels[i + 2] = blue(pink);
   *     pixels[i + 3] = alpha(pink);
   *   }
   *
   *   // Update the canvas.
   *   updatePixels();
   *
   *   describe('A pink rectangle drawn above a gray rectangle.');
   * }
   * </code>
   * </div>
   */ }
if (typeof p5 !== 'undefined') {
    pixels(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "filterParamDefaults",
    ()=>filterParamDefaults
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
;
const filterParamDefaults = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["$"]]: 3,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"]]: 4,
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Z"]]: 0.5
};
;
}),
"[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>FilterRenderer2D
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class FilterRenderer2D {
    /**
   * Creates a new FilterRenderer2D instance.
   * @param {p5} pInst - The p5.js instance.
   */ constructor(pInst){
        this.pInst = pInst;
        // Create a canvas for applying WebGL-based filters
        this.canvas = document.createElement('canvas');
        this.canvas.width = pInst.width;
        this.canvas.height = pInst.height;
        // Initialize the WebGL context
        let webglVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["z"];
        this.gl = this.canvas.getContext('webgl2');
        if (!this.gl) {
            webglVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a0"];
            this.gl = this.canvas.getContext('webgl');
        }
        if (!this.gl) {
            console.error('WebGL not supported, cannot apply filter.');
            return;
        }
        // Minimal renderer object required by p5.Shader and p5.Texture
        this._renderer = {
            GL: this.gl,
            registerEnabled: new Set(),
            _curShader: null,
            _emptyTexture: null,
            webglVersion,
            states: {
                textureWrapX: this.gl.CLAMP_TO_EDGE,
                textureWrapY: this.gl.CLAMP_TO_EDGE
            },
            _arraysEqual: (a, b)=>JSON.stringify(a) === JSON.stringify(b),
            _getEmptyTexture: ()=>{
                if (!this._emptyTexture) {
                    const im = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"](1, 1);
                    im.set(0, 0, 255);
                    this._emptyTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["T"](this._renderer, im);
                }
                return this._emptyTexture;
            }
        };
        this._baseFilterShader = undefined;
        // Store the fragment shader sources
        this.filterShaderSources = {
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["$"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Z"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Y"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["k"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["X"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["V"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["U"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"],
            [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["K"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"]
        };
        // Store initialized shaders for each operation
        this.filterShaders = {};
        // These will be set by setOperation
        this.operation = null;
        this.filterParameter = 1;
        this.customShader = null;
        this._shader = null;
        // Create buffers once
        this.vertexBuffer = this.gl.createBuffer();
        this.texcoordBuffer = this.gl.createBuffer();
        // Set up the vertices and texture coordinates for a full-screen quad
        this.vertices = new Float32Array([
            -1,
            -1,
            1,
            -1,
            -1,
            1,
            1,
            1
        ]);
        this.texcoords = new Float32Array([
            0,
            1,
            1,
            1,
            0,
            0,
            1,
            0
        ]);
        // Upload vertex data once
        this._bindBufferData(this.vertexBuffer, this.gl.ARRAY_BUFFER, this.vertices);
        // Upload texcoord data once
        this._bindBufferData(this.texcoordBuffer, this.gl.ARRAY_BUFFER, this.texcoords);
    }
    _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
        let code = '';
        if (this._renderer.webglVersion === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["z"]) {
            code += '#version 300 es\n#define WEBGL2\n';
        }
        if (shaderType === 'vert') {
            code += '#define VERTEX_SHADER\n';
        } else if (shaderType === 'frag') {
            code += '#define FRAGMENT_SHADER\n';
        }
        if (floatPrecision) {
            code += `precision ${floatPrecision} float;\n`;
        }
        return code;
    }
    baseFilterShader() {
        if (!this._baseFilterShader) {
            this._baseFilterShader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"](this._renderer, this._webGL2CompatibilityPrefix('vert', 'highp') + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"], this._webGL2CompatibilityPrefix('frag', 'highp') + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["w"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"], {
                vertex: {},
                fragment: {
                    'vec4 getColor': `(FilterInputs inputs, in sampler2D canvasContent) {
              return getTexture(canvasContent, inputs.texCoord);
            }`
                }
            });
        }
        return this._baseFilterShader;
    }
    /**
   * Set the current filter operation and parameter. If a customShader is provided,
   * that overrides the operation-based shader.
   * @param {String} operation - The filter operation type (e.g., constants.BLUR).
   * @param {Number} filterParameter - The strength of the filter.
   * @param {p5.Shader} customShader - Optional custom shader.
   */ setOperation(operation, filterParameter, customShader = null) {
        this.operation = operation;
        this.filterParameter = filterParameter;
        let useDefaultParam = operation in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterParamDefaults"] && filterParameter === undefined;
        if (useDefaultParam) {
            this.filterParameter = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterParamDefaults"][operation];
        }
        this.customShader = customShader;
        this._initializeShader();
    }
    /**
   * Initializes or retrieves the shader program for the current operation.
   * If a customShader is provided, that is used.
   * Otherwise, returns a cached shader if available, or creates a new one, caches it, and sets it as current.
   */ _initializeShader() {
        if (this.customShader) {
            this._shader = this.customShader;
            return;
        }
        if (!this.operation) {
            console.error('No operation set for FilterRenderer2D, cannot initialize shader.');
            return;
        }
        // If we already have a compiled shader for this operation, reuse it
        if (this.filterShaders[this.operation]) {
            this._shader = this.filterShaders[this.operation];
            return;
        }
        const fragShaderSrc = this.filterShaderSources[this.operation];
        if (!fragShaderSrc) {
            console.error('No shader available for this operation:', this.operation);
            return;
        }
        // Create and store the new shader
        const newShader = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"](this._renderer, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["x"], fragShaderSrc);
        this.filterShaders[this.operation] = newShader;
        this._shader = newShader;
    }
    /**
   * Binds a buffer to the drawing context
   * when passed more than two arguments it also updates or initializes
   * the data associated with the buffer
   */ _bindBufferData(buffer, target, values) {
        const gl = this.gl;
        gl.bindBuffer(target, buffer);
        gl.bufferData(target, values, gl.STATIC_DRAW);
    }
    get canvasTexture() {
        if (!this._canvasTexture) {
            this._canvasTexture = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["T"](this._renderer, this.pInst.wrappedElt);
        }
        return this._canvasTexture;
    }
    /**
   * Prepares and runs the full-screen quad draw call.
   */ _renderPass() {
        const gl = this.gl;
        this._shader.bindShader();
        const pixelDensity = this.pInst.pixelDensity ? this.pInst.pixelDensity() : 1;
        const texelSize = [
            1 / (this.pInst.width * pixelDensity),
            1 / (this.pInst.height * pixelDensity)
        ];
        const canvasTexture = this.canvasTexture;
        // Set uniforms for the shader
        this._shader.setUniform('tex0', canvasTexture);
        this._shader.setUniform('texelSize', texelSize);
        this._shader.setUniform('canvasSize', [
            this.pInst.width,
            this.pInst.height
        ]);
        this._shader.setUniform('radius', Math.max(1, this.filterParameter));
        this._shader.setUniform('filterParameter', this.filterParameter);
        this._shader.setDefaultUniforms();
        this.pInst.states.setValue('rectMode', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"]);
        this.pInst.states.setValue('imageMode', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"]);
        this.pInst.blendMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"]);
        this.pInst.resetMatrix();
        const identityMatrix = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
        this._shader.setUniform('uModelViewMatrix', identityMatrix);
        this._shader.setUniform('uProjectionMatrix', identityMatrix);
        // Bind and enable vertex attributes
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        this._shader.enableAttrib(this._shader.attributes.aPosition, 2);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
        this._shader.enableAttrib(this._shader.attributes.aTexCoord, 2);
        this._shader.bindTextures();
        this._shader.disableRemainingAttributes();
        // Draw the quad
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        // Unbind the shader
        this._shader.unbindShader();
    }
    /**
   * Applies the current filter operation. If the filter requires multiple passes (e.g. blur),
   * it handles those internally. Make sure setOperation() has been called before applyFilter().
   */ applyFilter() {
        if (!this._shader) {
            console.error('Cannot apply filter: shader not initialized.');
            return;
        }
        this.pInst.push();
        this.pInst.resetMatrix();
        // For blur, we typically do two passes: one horizontal, one vertical.
        if (this.operation === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["$"] && !this.customShader) {
            // Horizontal pass
            this._shader.setUniform('direction', [
                1,
                0
            ]);
            this._renderPass();
            // Draw the result onto itself
            this.pInst.clear();
            this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
            // Vertical pass
            this._shader.setUniform('direction', [
                0,
                1
            ]);
            this._renderPass();
            this.pInst.clear();
            this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
        } else {
            // Single-pass filters
            this._renderPass();
            this.pInst.clear();
            // con
            this.pInst.blendMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"]);
            this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
        }
        this.pInst.pop();
    }
}
;
}),
"[project]/node_modules/p5/dist/image/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>image
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function image(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"]);
}
;
}),
"[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "I",
    ()=>Image,
    "R",
    ()=>Renderer,
    "i",
    ()=>image,
    "r",
    ()=>renderer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
/**
 * @module Image
 * @submodule Image
 * @requires core
 * @requires constants
 * @requires filters
 */ class Image {
    constructor(width, height){
        this.width = width;
        this.height = height;
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.drawingContext = this.canvas.getContext('2d');
        this._pixelsState = this;
        this._pixelDensity = 1;
        //Object for working with GIFs, defaults to null
        this.gifProperties = null;
        //For WebGL Texturing only: used to determine whether to reupload texture to GPU
        this._modified = false;
        this.pixels = [];
    }
    /**
   * Gets or sets the pixel density for high pixel density displays.
   *
   * By default, the density will be set to 1.
   *
   * Call this method with no arguments to get the default density, or pass
   * in a number to set the density. If a non-positive number is provided,
   * it defaults to 1.
   *
   * @param {Number} [density] A scaling factor for the number of pixels per
   * side
   * @returns {Number} The current density if called without arguments, or the instance for chaining if setting density.
   */ pixelDensity(density) {
        if (typeof density !== 'undefined') {
            // Setter: set the density and handle resize
            if (density <= 0) {
                // p5._friendlyParamError(errorObj, 'pixelDensity');
                // Default to 1 in case of an invalid value
                density = 1;
            }
            this._pixelDensity = density;
            // Adjust canvas dimensions based on pixel density
            this.width /= density;
            this.height /= density;
            return this; // Return the image instance for chaining if needed
        } else {
            // Getter: return the default density
            return this._pixelDensity;
        }
    }
    /**
   * Helper function for animating GIF-based images with time
   */ _animateGif(pInst) {
        const props = this.gifProperties;
        const curTime = pInst._lastRealFrameTime || window.performance.now();
        if (props.lastChangeTime === 0) {
            props.lastChangeTime = curTime;
        }
        if (props.playing) {
            props.timeDisplayed = curTime - props.lastChangeTime;
            const curDelay = props.frames[props.displayIndex].delay;
            if (props.timeDisplayed >= curDelay) {
                //GIF is bound to 'realtime' so can skip frames
                const skips = Math.floor(props.timeDisplayed / curDelay);
                props.timeDisplayed = 0;
                props.lastChangeTime = curTime;
                props.displayIndex += skips;
                props.loopCount = Math.floor(props.displayIndex / props.numFrames);
                if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {
                    props.playing = false;
                } else {
                    const ind = props.displayIndex % props.numFrames;
                    this.drawingContext.putImageData(props.frames[ind].image, 0, 0);
                    props.displayIndex = ind;
                    this.setModified(true);
                }
            }
        }
    }
    /**
   * Loads the current value of each pixel in the image into the `img.pixels`
   * array.
   *
   * `img.loadPixels()` must be called before reading or modifying pixel
   * values.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ loadPixels() {
        // Renderer2D.prototype.loadPixels.call(this);
        const pixelsState = this._pixelsState;
        const pd = this._pixelDensity;
        const w = this.width * pd;
        const h = this.height * pd;
        const imageData = this.drawingContext.getImageData(0, 0, w, h);
        // @todo this should actually set pixels per object, so diff buffers can
        // have diff pixel arrays.
        pixelsState.imageData = imageData;
        this.pixels = pixelsState.pixels = imageData.data;
        this.setModified(true);
    }
    /**
   * Updates the canvas with the RGBA values in the
   * <a href="#/p5.Image/pixels">img.pixels</a> array.
   *
   * `img.updatePixels()` only needs to be called after changing values in
   * the <a href="#/p5.Image/pixels">img.pixels</a> array. Such changes can be
   * made directly after calling
   * <a href="#/p5.Image/loadPixels">img.loadPixels()</a> or by calling
   * <a href="#/p5.Image/set">img.set()</a>.
   *
   * The optional parameters `x`, `y`, `width`, and `height` define a
   * subsection of the image to update. Doing so can improve performance in
   * some cases.
   *
   * If the image was loaded from a GIF, then calling `img.updatePixels()`
   * will update the pixels in current frame.
   *
   * @param {Integer} [x] x-coordinate of the upper-left corner
   *                      of the subsection to update.
   * @param {Integer} [y] y-coordinate of the upper-left corner
   *                      of the subsection to update.
   * @param {Integer} [w] width of the subsection to update.
   * @param {Integer} [h] height of the subsection to update.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ updatePixels(x, y, w, h) {
        // Renderer2D.prototype.updatePixels.call(this, x, y, w, h);
        const pixelsState = this._pixelsState;
        const pd = this._pixelDensity;
        if (x === undefined && y === undefined && w === undefined && h === undefined) {
            x = 0;
            y = 0;
            w = this.width;
            h = this.height;
        }
        x *= pd;
        y *= pd;
        w *= pd;
        h *= pd;
        if (this.gifProperties) {
            this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;
        }
        this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);
        this.setModified(true);
    }
    /**
   * Gets a pixel or a region of pixels from the image.
   *
   * `img.get()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to read many pixel values.
   *
   * The version of `img.get()` with no parameters returns the entire image.
   *
   * The version of `img.get()` with two parameters, as in `img.get(10, 20)`,
   * interprets them as coordinates. It returns an array with the
   * `[R, G, B, A]` values of the pixel at the given point.
   *
   * The version of `img.get()` with four parameters, as in
   * `img,get(10, 20, 50, 90)`, interprets them as
   * coordinates and dimensions. The first two parameters are the coordinates
   * of the upper-left corner of the subsection. The last two parameters are
   * the width and height of the subsection. It returns a subsection of the
   * canvas in a new <a href="#/p5.Image">p5.Image</a> object.
   *
   * Use `img.get()` instead of <a href="#/p5/get">get()</a> to work directly
   * with images.
   *
   * @param  {Number}               x x-coordinate of the pixel.
   * @param  {Number}               y y-coordinate of the pixel.
   * @param  {Number}               w width of the subsection to be returned.
   * @param  {Number}               h height of the subsection to be returned.
   * @return {p5.Image}             subsection as a <a href="#/p5.Image">p5.Image</a> object.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy the image.
   *   let img2 = get();
   *
   *   // Display the copied image on the right.
   *   image(img2, 50, 0);
   *
   *   describe('Two identical mountain landscapes shown side-by-side.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get a pixel's color.
   *   let c = img.get(50, 90);
   *
   *   // Style the square using the pixel's color.
   *   fill(c);
   *   noStroke();
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   *
   *   describe('A mountain landscape with an olive green square in its center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy half of the image.
   *   let img2 = img.get(0, 0, img.width / 2, img.height / 2);
   *
   *   // Display half of the image.
   *   image(img2, 50, 50);
   *
   *   describe('A mountain landscape drawn on top of another mountain landscape.');
   * }
   * </code>
   * </div>
   */ /**
   * @return {p5.Image}      whole <a href="#/p5.Image">p5.Image</a>
   */ /**
   * @param  {Number}        x
   * @param  {Number}        y
   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.
   */ get(x, y, w, h) {
        // p5._validateParameters('p5.Image.get', arguments);
        // return Renderer2D.prototype.get.apply(this, arguments);
        const pixelsState = this._pixelsState;
        const pd = this._pixelDensity;
        const canvas = this.canvas;
        if (typeof x === 'undefined' && typeof y === 'undefined') {
            // get()
            x = y = 0;
            w = pixelsState.width;
            h = pixelsState.height;
        } else {
            x *= pd;
            y *= pd;
            if (typeof w === 'undefined' && typeof h === 'undefined') {
                // get(x,y)
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
                    return [
                        0,
                        0,
                        0,
                        0
                    ];
                }
                return this._getPixel(x, y);
            }
        // get(x,y,w,h)
        }
        const region = new Image(w * pd, h * pd);
        region.pixelDensity(pd);
        region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
        return region;
    }
    _getPixel(x, y) {
        let imageData, index;
        imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
        index = 0;
        return [
            imageData[index + 0],
            imageData[index + 1],
            imageData[index + 2],
            imageData[index + 3]
        ];
    // return Renderer2D.prototype._getPixel.apply(this, args);
    }
    /**
   * Sets the color of one or more pixels within an image.
   *
   * `img.set()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to set many pixel values.
   *
   * `img.set()` interprets the first two parameters as x- and y-coordinates. It
   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel
   * array, a <a href="#/p5.Color">p5.Color</a> object, or another
   * <a href="#/p5.Image">p5.Image</a> object.
   *
   * <a href="#/p5.Image/updatePixels">img.updatePixels()</a> must be called
   * after using `img.set()` for changes to appear.
   *
   * @param {Number}              x x-coordinate of the pixel.
   * @param {Number}              y y-coordinate of the pixel.
   * @param {Number|Number[]|Object}   a grayscale value | pixel array |
   *                                   <a href="#/p5.Color">p5.Color</a> object |
   *                                   <a href="#/p5.Image">p5.Image</a> to copy.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, 0);
   *   img.set(85, 20, 0);
   *   img.set(85, 75, 0);
   *   img.set(30, 75, 0);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Create a p5.Color object.
   *   let black = color(0);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, black);
   *   img.set(85, 20, black);
   *   img.set(85, 75, black);
   *   img.set(30, 75, black);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Draw a color gradient.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       let c = map(x, 0, img.width, 0, 255);
   *       img.set(x, y, c);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A square with a horiztonal color gradient from black to white drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Image object.
   *   let img2 = createImage(100, 100);
   *
   *   // Set the blank image's pixels using the landscape.
   *   img2.set(0, 0, img);
   *
   *   // Display the second image.
   *   image(img2, 0, 0);
   *
   *   describe('An image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */ set(x, y, imgOrCol) {
        // Renderer2D.prototype.set.call(this, x, y, imgOrCol);
        // round down to get integer numbers
        x = Math.floor(x);
        y = Math.floor(y);
        const pixelsState = this._pixelsState;
        if (imgOrCol instanceof Image) {
            this.drawingContext.save();
            this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
            this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
            this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
            this.drawingContext.drawImage(imgOrCol.canvas, x, y);
            this.drawingContext.restore();
        } else {
            let r = 0, g = 0, b = 0, a = 0;
            let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
            if (!pixelsState.imageData) {
                pixelsState.loadPixels();
            }
            if (typeof imgOrCol === 'number') {
                if (idx < pixelsState.pixels.length) {
                    r = imgOrCol;
                    g = imgOrCol;
                    b = imgOrCol;
                    a = 255;
                //this.updatePixels.call(this);
                }
            } else if (Array.isArray(imgOrCol)) {
                if (imgOrCol.length < 4) {
                    throw new Error('pixel array must be of the form [R, G, B, A]');
                }
                if (idx < pixelsState.pixels.length) {
                    r = imgOrCol[0];
                    g = imgOrCol[1];
                    b = imgOrCol[2];
                    a = imgOrCol[3];
                //this.updatePixels.call(this);
                }
            } else if (imgOrCol instanceof p5.Color) {
                if (idx < pixelsState.pixels.length) {
                    [r, g, b, a] = imgOrCol._getRGBA([
                        255,
                        255,
                        255,
                        255
                    ]);
                //this.updatePixels.call(this);
                }
            }
            // loop over pixelDensity * pixelDensity
            for(let i = 0; i < this._pixelDensity; i++){
                for(let j = 0; j < this._pixelDensity; j++){
                    // loop over
                    idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
                    pixelsState.pixels[idx] = r;
                    pixelsState.pixels[idx + 1] = g;
                    pixelsState.pixels[idx + 2] = b;
                    pixelsState.pixels[idx + 3] = a;
                }
            }
        }
        this.setModified(true);
    }
    /**
   * Resizes the image to a given width and height.
   *
   * The image's original aspect ratio can be kept by passing 0 for either
   * `width` or `height`. For example, calling `img.resize(50, 0)` on an image
   * that was 500 &times; 300 pixels will resize it to 50 &times; 30 pixels.
   *
   * @param {Number} width resized image width.
   * @param {Number} height resized image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image.
   *   img.resize(50, 100);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. One copy of the image is squeezed horizontally.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(0, 30);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(60, 0);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   */ resize(width, height) {
        // Copy contents to a temporary canvas, resize the original
        // and then copy back.
        //
        // There is a faster approach that involves just one copy and swapping the
        // this.canvas reference. We could switch to that approach if (as i think
        // is the case) there an expectation that the user would not hold a
        // reference to the backing canvas of a p5.Image. But since we do not
        // enforce that at the moment, I am leaving in the slower, but safer
        // implementation.
        // auto-resize
        if (width === 0 && height === 0) {
            width = this.canvas.width;
            height = this.canvas.height;
        } else if (width === 0) {
            width = this.canvas.width * height / this.canvas.height;
        } else if (height === 0) {
            height = this.canvas.height * width / this.canvas.width;
        }
        width = Math.floor(width);
        height = Math.floor(height);
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        if (this.gifProperties) {
            const props = this.gifProperties;
            //adapted from github.com/LinusU/resize-image-data
            const nearestNeighbor = (src, dst)=>{
                let pos = 0;
                for(let y = 0; y < dst.height; y++){
                    for(let x = 0; x < dst.width; x++){
                        const srcX = Math.floor(x * src.width / dst.width);
                        const srcY = Math.floor(y * src.height / dst.height);
                        let srcPos = (srcY * src.width + srcX) * 4;
                        dst.data[pos++] = src.data[srcPos++]; // R
                        dst.data[pos++] = src.data[srcPos++]; // G
                        dst.data[pos++] = src.data[srcPos++]; // B
                        dst.data[pos++] = src.data[srcPos++]; // A
                    }
                }
            };
            for(let i = 0; i < props.numFrames; i++){
                const resizedImageData = this.drawingContext.createImageData(width, height);
                nearestNeighbor(props.frames[i].image, resizedImageData);
                props.frames[i].image = resizedImageData;
            }
        }
        tempCanvas.getContext('2d').drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
        // Resize the original canvas, which will clear its contents
        this.canvas.width = this.width = width;
        this.canvas.height = this.height = height;
        //Copy the image back
        this.drawingContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, width, height);
        if (this.pixels.length > 0) {
            this.loadPixels();
        }
        this.setModified(true);
    }
    /**
   * Copies pixels from a source image to this image.
   *
   * The first parameter, `srcImage`, is an optional
   * <a href="#/p5.Image">p5.Image</a> object to copy. If a source image isn't
   * passed, then `img.copy()` can copy a region of this image to another
   * region.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to copy from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the region's width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of this image to copy into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the region's width and height.
   *
   * Calling `img.copy()` will scale pixels from the source region if it isn't
   * the same size as the destination region.
   *
   * @param  {p5.Image|p5.Element} srcImage source image.
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Copy one region of the image to another.
   *   img.copy(7, 22, 10, 10, 35, 25, 50, 50);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Outline the copied region.
   *   stroke(255);
   *   noFill();
   *   square(7, 22, 10);
   *
   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks.jpg');
   *   createCanvas(100, 100);
   *
   *   // Calculate the center of the bricks image.
   *   let x = bricks.width / 2;
   *   let y = bricks.height / 2;
   *
   *   // Copy the bricks to the mountains image.
   *   mountains.copy(bricks, 0, 0, x, y, 0, 0, x, y);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   describe('An image of a brick wall drawn at the top-left of an image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */ /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   */ copy(...args) {
        // NOTE: Duplicate implementation here and pixels.js
        let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
        if (args.length === 9) {
            srcImage = args[0];
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
        } else if (args.length === 8) {
            srcImage = this;
            sx = args[0];
            sy = args[1];
            sw = args[2];
            sh = args[3];
            dx = args[4];
            dy = args[5];
            dw = args[6];
            dh = args[7];
        } else {
            throw new Error('Signature not supported');
        }
        this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
    }
    _copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
        const s = srcImage.canvas.width / srcImage.width;
        // adjust coord system for 3D when renderer
        // ie top-left = -width/2, -height/2
        let sxMod = 0;
        let syMod = 0;
        if (srcImage._renderer && srcImage._renderer.isP3D) {
            sxMod = srcImage.width / 2;
            syMod = srcImage.height / 2;
        }
        if (dstImage._renderer && dstImage._renderer.isP3D) {
            dstImage.push();
            dstImage.resetMatrix();
            dstImage.noLights();
            dstImage.blendMode(dstImage.BLEND);
            dstImage.imageMode(dstImage.CORNER);
            dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
            dstImage.pop();
        } else {
            dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
        }
    }
    /**
   * Masks part of the image with another.
   *
   * `img.mask()` uses another <a href="#/p5.Image">p5.Image</a> object's
   * alpha channel as the alpha channel for this image. Masks are cumulative
   * and can't be removed once applied. If the mask has a different
   * pixel density from this image, the mask will be scaled.
   *
   * @param {p5.Image} srcImage source image.
   *
   * @example
   * <div>
   * <code>
   * let photo;
   * let maskImage;
   *
   * async function setup() {
   *   // Load the images.
   *   photo = await loadImage('assets/rockies.jpg');
   *   maskImage = await loadImage('assets/mask2.png');
   *   createCanvas(100, 100);
   *
   *   // Apply the mask.
   *   photo.mask(maskImage);
   *
   *   // Display the image.
   *   image(photo, 0, 0);
   *
   *   describe('An image of a mountain landscape. The right side of the image has a faded patch of white.');
   * }
   * </code>
   * </div>
   */ // TODO: - Accept an array of alpha values.
    mask(p5Image) {
        if (p5Image === undefined) {
            p5Image = this;
        }
        const currBlend = this.drawingContext.globalCompositeOperation;
        let imgScaleFactor = this._pixelDensity;
        let maskScaleFactor = 1;
        if (p5Image instanceof Renderer) {
            maskScaleFactor = p5Image._pInst._renderer._pixelDensity;
        }
        const copyArgs = [
            p5Image,
            0,
            0,
            maskScaleFactor * p5Image.width,
            maskScaleFactor * p5Image.height,
            0,
            0,
            imgScaleFactor * this.width,
            imgScaleFactor * this.height
        ];
        this.drawingContext.globalCompositeOperation = 'destination-in';
        if (this.gifProperties) {
            for(let i = 0; i < this.gifProperties.frames.length; i++){
                this.drawingContext.putImageData(this.gifProperties.frames[i].image, 0, 0);
                this.copy(...copyArgs);
                this.gifProperties.frames[i].image = this.drawingContext.getImageData(0, 0, imgScaleFactor * this.width, imgScaleFactor * this.height);
            }
            this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);
        } else {
            this.copy(...copyArgs);
        }
        this.drawingContext.globalCompositeOperation = currBlend;
        this.setModified(true);
    }
    /**
   * Applies an image filter to the image.
   *
   * The preset options are:
   *
   * `INVERT`
   * Inverts the colors in the image. No parameter is used.
   *
   * `GRAY`
   * Converts the image to grayscale. No parameter is used.
   *
   * `THRESHOLD`
   * Converts the image to black and white. Pixels with a grayscale value
   * above a given threshold are converted to white. The rest are converted to
   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no
   * value is specified, 0.5 is used.
   *
   * `OPAQUE`
   * Sets the alpha channel to be entirely opaque. No parameter is used.
   *
   * `POSTERIZE`
   * Limits the number of colors in the image. Each color channel is limited to
   * the number of colors specified. Values between 2 and 255 are valid, but
   * results are most noticeable with lower values. The default value is 4.
   *
   * `BLUR`
   * Blurs the image. The level of blurring is specified by a blur radius. Larger
   * values increase the blur. The default value is 4. A gaussian blur is used
   * in `P2D` mode. A box blur is used in `WEBGL` mode.
   *
   * `ERODE`
   * Reduces the light areas. No parameter is used.
   *
   * `DILATE`
   * Increases the light areas. No parameter is used.
   *
   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,
   *                                POSTERIZE, ERODE, DILATE or BLUR.
   * @param  {Number} [filterParam] parameter unique to each filter.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the INVERT filter.
   *   img.filter(INVERT);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blue brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the GRAY filter.
   *   img.filter(GRAY);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in grayscale.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the THRESHOLD filter.
   *   img.filter(THRESHOLD);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in black and white.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the OPAQUE filter.
   *   img.filter(OPAQUE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the POSTERIZE filter.
   *   img.filter(POSTERIZE, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a red brick wall drawn with a limited color palette.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the BLUR filter.
   *   img.filter(BLUR, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blurry image of a red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the DILATE filter.
   *   img.filter(DILATE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with bright lines between each brick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the ERODE filter.
   *   img.filter(ERODE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with faint lines between each brick.');
   * }
   * </code>
   * </div>
   */ filter(operation, value) {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].apply(this.canvas, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"][operation], value);
        this.setModified(true);
    }
    /**
   * Copies a region of pixels from another image into this one.
   *
   * The first parameter, `srcImage`, is the
   * <a href="#/p5.Image">p5.Image</a> object to blend.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to blend from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the regions width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the regions width and height.
   *
   * The tenth parameter, `blendMode`, sets the effect used to blend the images'
   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,
   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,
   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`.
   *
   * @param  {p5.Image} srcImage source image
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either
   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,
   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,
   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.
   *
   * Available blend modes are: normal | multiply | screen | overlay |
   *            darken | lighten | color-dodge | color-burn | hard-light |
   *            soft-light | difference | exclusion | hue | saturation |
   *            color | luminosity
   *
   * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
   *
   * @example
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, ADD);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');
   * }
   * </code>
   * </div>
   */ /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode
   */ blend(...args) {
        const currBlend = this.drawingContext.globalCompositeOperation;
        const blendMode = args[args.length - 1];
        const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
        this.drawingContext.globalCompositeOperation = blendMode;
        this.copy(...copyArgs);
        this.drawingContext.globalCompositeOperation = currBlend;
        this.setModified(true);
    }
    /**
   * helper method for web GL mode to indicate that an image has been
   * changed or unchanged since last upload. gl texture upload will
   * set this value to false after uploading the texture.
   * @param {Boolean} val sets whether or not the image has been
   * modified.
   * @private
   */ setModified(val) {
        this._modified = val; //enforce boolean?
    }
    /**
   * helper method for web GL mode to figure out if the image
   * has been modified and might need to be re-uploaded to texture
   * memory between frames.
   * @private
   * @return {boolean} a boolean indicating whether or not the
   * image has been updated or modified since last texture upload.
   */ isModified() {
        return this._modified;
    }
    /**
   * Saves the image to a file.
   *
   * By default, `img.save()` saves the image as a PNG image called
   * `untitled.png`.
   *
   * The first parameter, `filename`, is optional. It's a string that sets the
   * file's name. If a file extension is included, as in
   * `img.save('drawing.png')`, then the image will be saved using that
   * format.
   *
   * The second parameter, `extension`, is also optional. It sets the files format.
   * Either `'png'` or `'jpg'` can be used. For example, `img.save('drawing', 'jpg')`
   * saves the canvas to a file called `drawing.jpg`.
   *
   * Note: The browser will either save the file immediately or prompt the user
   * with a dialogue window.
   *
   * The image will only be downloaded as an animated GIF if it was loaded
   * from a GIF file. See <a href="#/p5/saveGif">saveGif()</a> to create new
   * GIFs.
   *
   * @param {String} filename filename. Defaults to 'untitled'.
   * @param  {String} [extension] file extension, either 'png' or 'jpg'.
   *                            Defaults to 'png'.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a mountain landscape. The image is downloaded when the user presses the "s", "j", or "p" key.');
   * }
   *
   * // Save the image with different options when the user presses a key.
   * function keyPressed() {
   *   if (key === 's') {
   *     img.save();
   *   } else if (key === 'j') {
   *     img.save('rockies.jpg');
   *   } else if (key === 'p') {
   *     img.save('rockies', 'png');
   *   }
   * }
   * </code>
   * </div>
   */ save(filename, extension) {
        if (this.gifProperties) {
            encodeAndDownloadGif(this, filename);
        } else {
            let htmlCanvas = this.canvas;
            extension = extension || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_checkFileExtension"])(filename, extension)[1] || 'png';
            let mimeType;
            switch(extension){
                default:
                    //case 'png':
                    mimeType = 'image/png';
                    break;
                case 'webp':
                    mimeType = 'image/webp';
                    break;
                case 'jpeg':
                case 'jpg':
                    mimeType = 'image/jpeg';
                    break;
            }
            htmlCanvas.toBlob((blob)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["downloadFile"])(blob, filename, extension);
            }, mimeType);
        }
    }
    async toBlob() {
        return new Promise((resolve)=>{
            this.canvas.toBlob(resolve);
        });
    }
    // GIF Section
    /**
   * Restarts an animated GIF at its first frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-wink-loop-once.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon face winks once and then freezes. Clicking resets the face and makes it wink again.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Reset the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.reset();
   * }
   * </code>
   * </div>
   */ reset() {
        if (this.gifProperties) {
            const props = this.gifProperties;
            props.playing = true;
            props.timeSinceStart = 0;
            props.timeDisplayed = 0;
            props.lastChangeTime = 0;
            props.loopCount = 0;
            props.displayIndex = 0;
            this.drawingContext.putImageData(props.frames[0].image, 0, 0);
        }
    }
    /**
   * Gets the index of the current frame in an animated GIF.
   *
   * @return {Number}       index of the GIF's current frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye repeatedly looks around, then outwards. A number displayed in the bottom-left corner increases from 0 to 124, then repeats.');
   * }
   *
   * function draw() {
   *   // Get the index of the current GIF frame.
   *   let index = gif.getCurrentFrame();
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current frame.
   *   text(index, 10, 90);
   * }
   * </code>
   * </div>
   */ getCurrentFrame() {
        if (this.gifProperties) {
            const props = this.gifProperties;
            return props.displayIndex % props.numFrames;
        }
    }
    /**
   * Sets the current frame in an animated GIF.
   *
   * @param {Number} index index of the frame to display.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   * let frameSlider;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Get the index of the last frame.
   *   let maxFrame = gif.numFrames() - 1;
   *
   *   // Create a slider to control which frame is drawn.
   *   frameSlider = createSlider(0, maxFrame);
   *   frameSlider.position(10, 80);
   *   frameSlider.size(80);
   *
   *   describe('A cartoon eye looks around when a slider is moved.');
   * }
   *
   * function draw() {
   *   // Get the slider's value.
   *   let index = frameSlider.value();
   *
   *   // Set the GIF's frame.
   *   gif.setFrame(index);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */ setFrame(index) {
        if (this.gifProperties) {
            const props = this.gifProperties;
            if (index < props.numFrames && index >= 0) {
                props.timeDisplayed = 0;
                props.lastChangeTime = 0;
                props.displayIndex = index;
                this.drawingContext.putImageData(props.frames[index].image, 0, 0);
            } else {
                console.log('Cannot set GIF to a frame number that is higher than total number of frames or below zero.');
            }
        }
    }
    /**
   * Returns the number of frames in an animated GIF.
   *
   * @return {Number} number of frames in the GIF.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye looks around. The text "n / 125" is shown at the bottom of the canvas.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current state of playback.
   *   let total = gif.numFrames();
   *   let index = gif.getCurrentFrame();
   *   text(`${index} / ${total}`, 30, 90);
   * }
   * </code>
   * </div>
   */ numFrames() {
        if (this.gifProperties) {
            return this.gifProperties.numFrames;
        }
    }
    /**
   * Plays an animated GIF that was paused with
   * <a href="#/p5.Image/pause">img.pause()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user releases the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */ play() {
        if (this.gifProperties) {
            this.gifProperties.playing = true;
        }
    }
    /**
   * Pauses an animated GIF.
   *
   * The GIF can be resumed by calling
   * <a href="#/p5.Image/play">img.play()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user presses the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */ pause() {
        if (this.gifProperties) {
            this.gifProperties.playing = false;
        }
    }
    /**
   * Changes the delay between frames in an animated GIF.
   *
   * The first parameter, `delay`, is the length of the delay in milliseconds.
   *
   * The second parameter, `index`, is optional. If provided, only the frame
   * at `index` will have its delay modified. All other frames will keep
   * their default delay.
   *
   * @param {Number} d delay in milliseconds between switching frames.
   * @param {Number} [index] index of the frame that will have its delay modified.
   *
   * @example
   * <div>
   * <code>
   * let gifFast;
   * let gifSlow;
   *
   * async function setup() {
   *   // Load the images.
   *   gifFast = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *   gifSlow = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Resize the images.
   *   gifFast.resize(50, 50);
   *   gifSlow.resize(50, 50);
   *
   *   // Set the delay lengths.
   *   gifFast.delay(10);
   *   gifSlow.delay(100);
   *
   *   describe('Two animated eyes looking around. The eye on the left moves faster than the eye on the right.');
   * }
   *
   * function draw() {
   *   // Display the images.
   *   image(gifFast, 0, 0);
   *   image(gifSlow, 50, 0);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Set the delay of frame 67.
   *   gif.delay(3000, 67);
   *
   *   describe('An animated eye looking around. It pauses for three seconds while it looks down.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */ delay(d, index) {
        if (this.gifProperties) {
            const props = this.gifProperties;
            if (index < props.numFrames && index >= 0) {
                props.frames[index].delay = d;
            } else {
                // change all frames
                for (const frame of props.frames){
                    frame.delay = d;
                }
            }
        }
    }
}
function encodeAndDownloadGif(pImg, filename) {
    const props = pImg.gifProperties;
    //convert loopLimit back into Netscape Block formatting
    let loopLimit = props.loopLimit;
    if (loopLimit === 1) {
        loopLimit = null;
    } else if (loopLimit === null) {
        loopLimit = 0;
    }
    const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
    const allFramesPixelColors = [];
    // Used to determine the occurrence of unique palettes and the frames
    // which use them
    const paletteFreqsAndFrames = {};
    // Pass 1:
    //loop over frames and get the frequency of each palette
    for(let i = 0; i < props.numFrames; i++){
        const paletteSet = new Set();
        const data = props.frames[i].image.data;
        const dataLength = data.length;
        // The color for each pixel in this frame ( for easier lookup later )
        const pixelColors = new Uint32Array(pImg.width * pImg.height);
        for(let j = 0, k = 0; j < dataLength; j += 4, k++){
            const r = data[j + 0];
            const g = data[j + 1];
            const b = data[j + 2];
            const color = r << 16 | g << 8 | b << 0;
            paletteSet.add(color);
            // What color does this pixel have in this frame ?
            pixelColors[k] = color;
        }
        // A way to put use the entire palette as an object key
        const paletteStr = [
            ...paletteSet
        ].sort().toString();
        if (paletteFreqsAndFrames[paletteStr] === undefined) {
            paletteFreqsAndFrames[paletteStr] = {
                freq: 1,
                frames: [
                    i
                ]
            };
        } else {
            paletteFreqsAndFrames[paletteStr].freq += 1;
            paletteFreqsAndFrames[paletteStr].frames.push(i);
        }
        allFramesPixelColors.push(pixelColors);
    }
    let framesUsingGlobalPalette = [];
    // Now to build the global palette
    // Sort all the unique palettes in descending order of their occurrence
    const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b) {
        return paletteFreqsAndFrames[b].freq - paletteFreqsAndFrames[a].freq;
    });
    // The initial global palette is the one with the most occurrence
    const globalPalette = palettesSortedByFreq[0].split(',').map((a)=>parseInt(a));
    framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);
    const globalPaletteSet = new Set(globalPalette);
    // Build a more complete global palette
    // Iterate over the remaining palettes in the order of
    // their occurrence and see if the colors in this palette which are
    // not in the global palette can be added there, while keeping the length
    // of the global palette <= 256
    for(let i = 1; i < palettesSortedByFreq.length; i++){
        const palette = palettesSortedByFreq[i].split(',').map((a)=>parseInt(a));
        const difference = palette.filter((x)=>!globalPaletteSet.has(x));
        if (globalPalette.length + difference.length <= 256) {
            for(let j = 0; j < difference.length; j++){
                globalPalette.push(difference[j]);
                globalPaletteSet.add(difference[j]);
            }
            // All frames using this palette now use the global palette
            framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i]].frames);
        }
    }
    framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
    // Build a lookup table of the index of each color in the global palette
    // Maps a color to its index
    const globalIndicesLookup = {};
    for(let i = 0; i < globalPalette.length; i++){
        if (!globalIndicesLookup[globalPalette[i]]) {
            globalIndicesLookup[globalPalette[i]] = i;
        }
    }
    // force palette to be power of 2
    let powof2 = 1;
    while(powof2 < globalPalette.length){
        powof2 <<= 1;
    }
    globalPalette.length = powof2;
    // global opts
    const opts = {
        loop: loopLimit,
        palette: new Uint32Array(globalPalette)
    };
    const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
    let previousFrame = {};
    // Pass 2
    // Determine if the frame needs a local palette
    // Also apply transparency optimization. This function will often blow up
    // the size of a GIF if not for transparency. If a pixel in one frame has
    // the same color in the previous frame, that pixel can be marked as
    // transparent. We decide one particular color as transparent and make all
    // transparent pixels take this color. This helps in later in compression.
    for(let i = 0; i < props.numFrames; i++){
        const localPaletteRequired = !framesUsingGlobalPalette.has(i);
        const palette = localPaletteRequired ? [] : globalPalette;
        const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
        // Lookup table mapping color to its indices
        const colorIndicesLookup = {};
        // All the colors that cannot be marked transparent in this frame
        const cannotBeTransparent = new Set();
        allFramesPixelColors[i].forEach((color, k)=>{
            if (localPaletteRequired) {
                if (colorIndicesLookup[color] === undefined) {
                    colorIndicesLookup[color] = palette.length;
                    palette.push(color);
                }
                pixelPaletteIndex[k] = colorIndicesLookup[color];
            } else {
                pixelPaletteIndex[k] = globalIndicesLookup[color];
            }
            if (i > 0) {
                // If even one pixel of this color has changed in this frame
                // from the previous frame, we cannot mark it as transparent
                if (allFramesPixelColors[i - 1][k] !== color) {
                    cannotBeTransparent.add(color);
                }
            }
        });
        const frameOpts = {};
        // Transparency optimization
        const canBeTransparent = palette.filter((a)=>!cannotBeTransparent.has(a));
        if (canBeTransparent.length > 0) {
            // Select a color to mark as transparent
            const transparent = canBeTransparent[0];
            const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
            if (i > 0) {
                for(let k = 0; k < allFramesPixelColors[i].length; k++){
                    // If this pixel in this frame has the same color in previous frame
                    if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
                        pixelPaletteIndex[k] = transparentIndex;
                    }
                }
                frameOpts.transparent = transparentIndex;
                // If this frame has any transparency, do not dispose the previous frame
                previousFrame.frameOpts.disposal = 1;
            }
        }
        frameOpts.delay = props.frames[i].delay / 10; // Move timing back into GIF formatting
        if (localPaletteRequired) {
            // force palette to be power of 2
            let powof2 = 1;
            while(powof2 < palette.length){
                powof2 <<= 1;
            }
            palette.length = powof2;
            frameOpts.palette = new Uint32Array(palette);
        }
        if (i > 0) {
            // add the frame that came before the current one
            gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
        }
        // previous frame object should now have details of this frame
        previousFrame = {
            pixelPaletteIndex,
            frameOpts
        };
    }
    previousFrame.frameOpts.disposal = 1;
    // add the last frame
    gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
    const extension = 'gif';
    const blob = new Blob([
        buffer.slice(0, gifWriter.end())
    ], {
        type: 'image/gif'
    });
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["downloadFile"])(blob, filename, extension);
}
function image(p51, fn) {
    /**
   * A class to describe an image.
   *
   * Images are rectangular grids of pixels that can be displayed and modified.
   *
   * Existing images can be loaded by calling
   * <a href="#/p5/loadImage">loadImage()</a>. Blank images can be created by
   * calling <a href="#/p5/createImage">createImage()</a>. `p5.Image` objects
   * have methods for common tasks such as applying filters and modifying
   * pixel values.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the GRAY filter.
   *   img.filter(GRAY);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A grayscale image of a brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * @class p5.Image
   * @param {Number} width
   * @param {Number} height
   */ p51.Image = Image;
/**
   * The image's width in pixels.
   *
   * @type {Number}
   * @property {Number} width
   * @for p5.Image
   * @name width
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Calculate the center coordinates.
   *   let x = img.width / 2;
   *   let y = img.height / 2;
   *
   *   // Draw a circle at the image's center.
   *   circle(x, y, 20);
   *
   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');
   * }
   * </code>
   * </div>
   */ /**
   * The image's height in pixels.
   *
   * @type {Number}
   * @property height
   * @for p5.Image
   * @name height
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Calculate the center coordinates.
   *   let x = img.width / 2;
   *   let y = img.height / 2;
   *
   *   // Draw a circle at the image's center.
   *   circle(x, y, 20);
   *
   *   describe('An image of a mountain landscape with a white circle drawn in the middle.');
   * }
   * </code>
   * </div>
   */ /**
   * An array containing the color of each pixel in the image.
   *
   * Colors are stored as numbers representing red, green, blue, and alpha
   * (RGBA) values. `img.pixels` is a one-dimensional array for performance
   * reasons.
   *
   * Each pixel occupies four elements in the pixels array, one for each
   * RGBA value. For example, the pixel at coordinates (0, 0) stores its
   * RGBA values at `img.pixels[0]`, `img.pixels[1]`, `img.pixels[2]`,
   * and `img.pixels[3]`, respectively. The next pixel at coordinates (1, 0)
   * stores its RGBA values at `img.pixels[4]`, `img.pixels[5]`,
   * `img.pixels[6]`, and `img.pixels[7]`. And so on. The `img.pixels` array
   * for a 100×100 <a href="#/p5.Image">p5.Image</a> object has
   * 100 × 100 × 4 = 40,000 elements.
   *
   * Accessing the RGBA values for a pixel in the image requires a little
   * math as shown in the examples below. The
   * <a href="#/p5.Image/loadPixels">img.loadPixels()</a>
   * method must be called before accessing the `img.pixels` array. The
   * <a href="#/p5.Image/updatePixels">img.updatePixels()</a> method must be
   * called after any changes are made.
   *
   * @property {Number[]} pixels
   * @for p5.Image
   * @name pixels
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to red.
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 255;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A red square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ }
if (typeof p5 !== 'undefined') {
    image(p5, p5.prototype);
}
/**
 * @module Rendering
 * @submodule Rendering
 * @for p5
 */ class ClonableObject {
    constructor(obj = {}){
        for(const key in obj){
            this[key] = obj[key];
        }
    }
    clone() {
        return new ClonableObject(this);
    }
}
class Renderer {
    static states = {
        strokeColor: null,
        strokeSet: false,
        fillColor: null,
        fillSet: false,
        tint: null,
        imageMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"],
        rectMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"],
        ellipseMode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"],
        strokeWeight: 1,
        textFont: {
            family: 'sans-serif'
        },
        textLeading: 15,
        leadingSet: false,
        textSize: 12,
        textAlign: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ao"],
        textBaseline: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["an"],
        bezierOrder: 3,
        splineProperties: new ClonableObject({
            ends: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"],
            tightness: 0
        }),
        textWrap: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["am"],
        // added v2.0
        fontStyle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"],
        fontStretch: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"],
        fontWeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"],
        lineHeight: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"],
        fontVariant: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["N"],
        direction: 'inherit'
    };
    constructor(pInst, w, h, isMainCanvas){
        this._pInst = pInst;
        this._isMainCanvas = isMainCanvas;
        this.pixels = [];
        this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
        this.width = w;
        this.height = h;
        this._events = {};
        if (isMainCanvas) {
            this._isMainCanvas = true;
        }
        // Renderer state machine
        this.states = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["States"](Renderer.states);
        this.states.strokeColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]([
            0,
            0,
            0
        ]);
        this.states.fillColor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]([
            1,
            1,
            1
        ]);
        this._pushPopStack = [];
        // NOTE: can use the length of the push pop stack instead
        this._pushPopDepth = 0;
        this._clipping = false;
        this._clipInvert = false;
        this._currentShape = undefined; // Lazily generate current shape
    }
    get currentShape() {
        if (!this._currentShape) {
            this._currentShape = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Shape"](this.getCommonVertexProperties());
        }
        return this._currentShape;
    }
    remove() {}
    pixelDensity(val) {
        let returnValue;
        if (typeof val === 'number') {
            if (val !== this._pixelDensity) {
                this._pixelDensity = val;
            }
            returnValue = this;
            this.resize(this.width, this.height);
        } else {
            returnValue = this._pixelDensity;
        }
        return returnValue;
    }
    // Makes a shallow copy of the current states
    // and push it into the push pop stack
    push() {
        this._pushPopDepth++;
        this._pushPopStack.push(this.states.getDiff());
    }
    // Pop the previous states out of the push pop stack and
    // assign it back to the current state
    pop() {
        this._pushPopDepth--;
        const diff = this._pushPopStack.pop() || {};
        const modified = this.states.getModified();
        this.states.applyDiff(diff);
        this.updateShapeVertexProperties(modified);
        this.updateShapeProperties(modified);
    }
    bezierOrder(order) {
        if (order === undefined) {
            return this.states.bezierOrder;
        } else {
            this.states.setValue('bezierOrder', order);
            this.updateShapeProperties();
        }
    }
    bezierVertex(x, y, z = 0, u = 0, v = 0) {
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x, y, z);
        const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](u, v) : undefined;
        this.currentShape.bezierVertex(position, textureCoordinates);
    }
    splineProperty(key, value) {
        if (value === undefined) {
            return this.states.splineProperties[key];
        } else {
            this.states.setValue('splineProperties', this.states.splineProperties.clone());
            this.states.splineProperties[key] = value;
        }
        this.updateShapeProperties();
    }
    splineProperties(values) {
        if (values) {
            for(const key in values){
                this.splineProperty(key, values[key]);
            }
        } else {
            return {
                ...this.states.splineProperties
            };
        }
    }
    splineVertex(x, y, z = 0, u = 0, v = 0) {
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x, y, z);
        const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](u, v) : undefined;
        this.currentShape.splineVertex(position, textureCoordinates);
    }
    curveDetail(d) {
        if (d === undefined) {
            return this.states.curveDetail;
        } else {
            this.states.setValue('curveDetail', d);
        }
    }
    beginShape(...args) {
        this.currentShape.reset();
        this.updateShapeVertexProperties();
        this.currentShape.beginShape(...args);
    }
    endShape(...args) {
        this.currentShape.endShape(...args);
        this.drawShape(this.currentShape);
    }
    beginContour(shapeKind) {
        this.currentShape.beginContour(shapeKind);
    }
    endContour(mode) {
        this.currentShape.endContour(mode);
    }
    drawShape(shape, count) {
        throw new Error('Unimplemented');
    }
    vertex(x, y, z = 0, u = 0, v = 0) {
        const position = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x, y, z);
        const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](u, v) : undefined;
        this.currentShape.vertex(position, textureCoordinates);
    }
    bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
        const oldOrder = this._pInst.bezierOrder();
        this._pInst.bezierOrder(oldOrder);
        this._pInst.beginShape();
        this._pInst.bezierVertex(x1, y1);
        this._pInst.bezierVertex(x2, y2);
        this._pInst.bezierVertex(x3, y3);
        this._pInst.bezierVertex(x4, y4);
        this._pInst.endShape();
        return this;
    }
    spline(...args) {
        if (args.length === 2 * 4) {
            const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
            this._pInst.beginShape();
            this._pInst.splineVertex(x1, y1);
            this._pInst.splineVertex(x2, y2);
            this._pInst.splineVertex(x3, y3);
            this._pInst.splineVertex(x4, y4);
            this._pInst.endShape();
        } else if (args.length === 3 * 4) {
            const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;
            this._pInst.beginShape();
            this._pInst.splineVertex(x1, y1, z1);
            this._pInst.splineVertex(x2, y2, z2);
            this._pInst.splineVertex(x3, y3, z3);
            this._pInst.splineVertex(x4, y4, z4);
            this._pInst.endShape();
        }
        return this;
    }
    beginClip(options = {}) {
        if (this._clipping) {
            throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");
        }
        this._clipping = true;
        this._clipInvert = options.invert;
    }
    endClip() {
        if (!this._clipping) {
            throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");
        }
        this._clipping = false;
    }
    /**
   * Resize our canvas element.
   */ resize(w, h) {
        this.width = w;
        this.height = h;
    }
    get(x, y, w, h) {
        const pd = this._pixelDensity;
        const canvas = this.canvas;
        if (typeof x === 'undefined' && typeof y === 'undefined') {
            // get()
            x = y = 0;
            w = this.width;
            h = this.height;
        } else {
            x *= pd;
            y *= pd;
            if (typeof w === 'undefined' && typeof h === 'undefined') {
                // get(x,y)
                if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
                    return [
                        0,
                        0,
                        0,
                        0
                    ];
                }
                return this._getPixel(x, y);
            }
        // get(x,y,w,h)
        }
        const region = new Image(w * pd, h * pd);
        region.pixelDensity(pd);
        region.canvas.getContext('2d').drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
        return region;
    }
    scale(x, y) {}
    fill(...args) {
        this.states.setValue('fillSet', true);
        this.states.setValue('fillColor', this._pInst.color(...args));
        this.updateShapeVertexProperties();
    }
    noFill() {
        this.states.setValue('fillColor', null);
    }
    strokeWeight(w) {
        if (w === undefined) {
            return this.states.strokeWeight;
        } else {
            this.states.setValue('strokeWeight', w);
        }
    }
    stroke(...args) {
        this.states.setValue('strokeSet', true);
        this.states.setValue('strokeColor', this._pInst.color(...args));
        this.updateShapeVertexProperties();
    }
    noStroke() {
        this.states.setValue('strokeColor', null);
    }
    getCommonVertexProperties() {
        return {};
    }
    getSupportedIndividualVertexProperties() {
        return {
            textureCoordinates: false
        };
    }
    updateShapeProperties(modified) {
        if (!modified || modified.bezierOrder || modified.splineProperties) {
            const shape = this.currentShape;
            shape.bezierOrder(this.states.bezierOrder);
            shape.splineProperty('ends', this.states.splineProperties.ends);
            shape.splineProperty('tightness', this.states.splineProperties.tightness);
        }
    }
    updateShapeVertexProperties(modified) {
        const props = this.getCommonVertexProperties();
        if (!modified || Object.keys(modified).some((k)=>k in props)) {
            const shape = this.currentShape;
            for(const key in props){
                shape[key](props[key]);
            }
        }
    }
    _applyDefaults() {
        return this;
    }
}
function renderer(p51, fn) {
    /**
   * Main graphics and rendering context, as well as the base API
   * implementation for p5.js "core". To be used as the superclass for
   * Renderer2D and Renderer3D classes, respectively.
   *
   * @class p5.Renderer
   * @param {HTMLElement} elt DOM node that is wrapped
   * @param {p5} [pInst] pointer to p5 instance
   * @param {Boolean} [isMainCanvas] whether we're using it as main canvas
   * @private
   */ p51.Renderer = Renderer;
}
;
}),
"[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "R",
    ()=>Renderer2D,
    "p",
    ()=>p5,
    "r",
    ()=>renderer2D
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/structure.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/environment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
const styleEmpty = 'rgba(0,0,0,0)';
// const alphaThreshold = 0.00125; // minimum visible
class Renderer2D extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"] {
    constructor(pInst, w, h, isMainCanvas, elt, attributes = {}){
        super(pInst, w, h, isMainCanvas);
        this.canvas = this.elt = elt || document.createElement('canvas');
        if (isMainCanvas) {
            // for pixel method sharing with pimage
            this._pInst._curElement = this;
            this._pInst.canvas = this.canvas;
        } else {
            // hide if offscreen buffer by default
            this.canvas.style.display = 'none';
        }
        this.elt.id = 'defaultCanvas0';
        this.elt.classList.add('p5Canvas');
        // Extend renderer with methods of p5.Element with getters
        for (const p of Object.getOwnPropertyNames(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Element"].prototype)){
            if (p !== 'constructor' && p[0] !== '_') {
                Object.defineProperty(this, p, {
                    get () {
                        return this.wrappedElt[p];
                    }
                });
            }
        }
        // Set canvas size
        this.elt.width = w * this._pixelDensity;
        this.elt.height = h * this._pixelDensity;
        this.elt.style.width = `${w}px`;
        this.elt.style.height = `${h}px`;
        // Attach canvas element to DOM
        if (this._pInst._userNode) {
            // user input node case
            this._pInst._userNode.appendChild(this.elt);
        } else {
            //create main element
            if (document.getElementsByTagName('main').length === 0) {
                let m = document.createElement('main');
                document.body.appendChild(m);
            }
            //append canvas to main
            document.getElementsByTagName('main')[0].appendChild(this.elt);
        }
        // Get and store drawing context
        this.drawingContext = this.canvas.getContext('2d', attributes);
        if (attributes.colorSpace === 'display-p3') {
            this.states.colorMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"];
        }
        this.scale(this._pixelDensity, this._pixelDensity);
        // Set and return p5.Element
        this.wrappedElt = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Element"](this.elt, this._pInst);
        this.clipPath = null;
    }
    get filterRenderer() {
        if (!this._filterRenderer) {
            this._filterRenderer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"](this);
        }
        return this._filterRenderer;
    }
    remove() {
        this.wrappedElt.remove();
        this.wrappedElt = null;
        this.canvas = null;
        this.elt = null;
    }
    getFilterGraphicsLayer() {
        // create hidden webgl renderer if it doesn't exist
        if (!this.filterGraphicsLayer) {
            const pInst = this._pInst;
            // create secondary layer
            this.filterGraphicsLayer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["G"](this.width, this.height, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a0"], pInst);
        }
        if (this.filterGraphicsLayer.width !== this.width || this.filterGraphicsLayer.height !== this.height) {
            // Resize the graphics layer
            this.filterGraphicsLayer.resizeCanvas(this.width, this.height);
        }
        if (this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity()) {
            this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity());
        }
        return this.filterGraphicsLayer;
    }
    _applyDefaults() {
        this.states.setValue('_cachedFillStyle', undefined);
        this.states.setValue('_cachedStrokeStyle', undefined);
        this._cachedBlendMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"];
        this._setFill(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a2"]);
        this._setStroke(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a3"]);
        this.drawingContext.lineCap = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"];
        this.drawingContext.font = 'normal 12px sans-serif';
    }
    resize(w, h) {
        super.resize(w, h);
        // save canvas properties
        const props = {};
        for(const key in this.drawingContext){
            const val = this.drawingContext[key];
            if (typeof val !== 'object' && typeof val !== 'function') {
                props[key] = val;
            }
        }
        this.canvas.width = w * this._pixelDensity;
        this.canvas.height = h * this._pixelDensity;
        this.canvas.style.width = `${w}px`;
        this.canvas.style.height = `${h}px`;
        this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
        // reset canvas properties
        for(const savedKey in props){
            try {
                this.drawingContext[savedKey] = props[savedKey];
            } catch (err) {
            // ignore read-only property errors
            }
        }
    }
    //////////////////////////////////////////////
    // COLOR | Setting
    //////////////////////////////////////////////
    background(...args) {
        this.push();
        this.resetMatrix();
        if (args[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"]) {
            if (args[1] >= 0) {
                // set transparency of background
                const img = args[0];
                this.drawingContext.globalAlpha = args[1] / 255;
                this._pInst.image(img, 0, 0, this.width, this.height);
            } else {
                this._pInst.image(args[0], 0, 0, this.width, this.height);
            }
        } else {
            // create background rect
            const color = this._pInst.color(...args);
            // Add accessible outputs if the method exists; on success,
            // set the accessible output background to white.
            if (this._pInst._addAccsOutput?.()) {
                this._pInst._accsBackground?.(color._getRGBA([
                    255,
                    255,
                    255,
                    255
                ]));
            }
            const newFill = color.toString();
            this._setFill(newFill);
            if (this._isErasing) {
                this.blendMode(this._cachedBlendMode);
            }
            this.drawingContext.fillRect(0, 0, this.width, this.height);
            if (this._isErasing) {
                this._pInst.erase();
            }
        }
        this.pop();
    }
    clear() {
        this.drawingContext.save();
        this.resetMatrix();
        this.drawingContext.clearRect(0, 0, this.width, this.height);
        this.drawingContext.restore();
    }
    fill(...args) {
        super.fill(...args);
        const color = this.states.fillColor;
        this._setFill(color.toString());
        // Add accessible outputs if the method exists; on success,
        // set the accessible output background to white.
        if (this._pInst._addAccsOutput?.()) {
            this._pInst._accsCanvasColors?.('fill', color._getRGBA([
                255,
                255,
                255,
                255
            ]));
        }
    }
    stroke(...args) {
        super.stroke(...args);
        const color = this.states.strokeColor;
        this._setStroke(color.toString());
        // Add accessible outputs if the method exists; on success,
        // set the accessible output background to white.
        if (this._pInst._addAccsOutput?.()) {
            this._pInst._accsCanvasColors?.('stroke', color._getRGBA([
                255,
                255,
                255,
                255
            ]));
        }
    }
    erase(opacityFill, opacityStroke) {
        if (!this._isErasing) {
            // cache the fill style
            this.states.setValue('_cachedFillStyle', this.drawingContext.fillStyle);
            const newFill = this._pInst.color(255, opacityFill).toString();
            this.drawingContext.fillStyle = newFill;
            // cache the stroke style
            this.states.setValue('_cachedStrokeStyle', this.drawingContext.strokeStyle);
            const newStroke = this._pInst.color(255, opacityStroke).toString();
            this.drawingContext.strokeStyle = newStroke;
            // cache blendMode
            const tempBlendMode = this._cachedBlendMode;
            this.blendMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a4"]);
            this._cachedBlendMode = tempBlendMode;
            this._isErasing = true;
        }
    }
    noErase() {
        if (this._isErasing) {
            this.drawingContext.fillStyle = this.states._cachedFillStyle;
            this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
            this.blendMode(this._cachedBlendMode);
            this._isErasing = false;
        }
    }
    drawShape(shape) {
        const visitor = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["PrimitiveToPath2DConverter"]({
            strokeWeight: this.states.strokeWeight
        });
        shape.accept(visitor);
        if (this._clipping) {
            this.clipPath.addPath(visitor.path);
            this.clipPath.closePath();
        } else {
            if (this.states.fillColor) {
                this.drawingContext.fill(visitor.path);
            }
            if (this.states.strokeColor) {
                this.drawingContext.stroke(visitor.path);
            }
        }
    }
    beginClip(options = {}) {
        super.beginClip(options);
        // cache the fill style
        this.states.setValue('_cachedFillStyle', this.drawingContext.fillStyle);
        const newFill = this._pInst.color(255, 0).toString();
        this.drawingContext.fillStyle = newFill;
        // cache the stroke style
        this.states.setValue('_cachedStrokeStyle', this.drawingContext.strokeStyle);
        const newStroke = this._pInst.color(255, 0).toString();
        this.drawingContext.strokeStyle = newStroke;
        // cache blendMode
        const tempBlendMode = this._cachedBlendMode;
        this.blendMode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"]);
        this._cachedBlendMode = tempBlendMode;
        // Since everything must be in one path, create a new single Path2D to chain all shapes onto.
        // Start a new path. Everything from here on out should become part of this
        // one path so that we can clip to the whole thing.
        this.clipPath = new Path2D();
        if (this._clipInvert) {
            // Slight hack: draw a big rectangle over everything with reverse winding
            // order. This is hopefully large enough to cover most things.
            this.clipPath.moveTo(-2 * this.width, -2 * this.height);
            this.clipPath.lineTo(-2 * this.width, 2 * this.height);
            this.clipPath.lineTo(2 * this.width, 2 * this.height);
            this.clipPath.lineTo(2 * this.width, -2 * this.height);
            this.clipPath.closePath();
        }
    }
    endClip() {
        this.drawingContext.clip(this.clipPath);
        this.clipPath = null;
        super.endClip();
        this.drawingContext.fillStyle = this.states._cachedFillStyle;
        this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
        this.blendMode(this._cachedBlendMode);
    }
    //////////////////////////////////////////////
    // IMAGE | Loading & Displaying
    //////////////////////////////////////////////
    image(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
        let cnv;
        if (img.gifProperties) {
            img._animateGif(this._pInst);
        }
        try {
            if (img instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["MediaElement"]) {
                img._ensureCanvas();
            }
            if (this.states.tint && img.canvas) {
                cnv = this._getTintedImageCanvas(img);
            }
            if (!cnv) {
                cnv = img.canvas || img.elt;
            }
            let s = 1;
            if (img.width && img.width > 0) {
                s = cnv.width / img.width;
            }
            if (this._isErasing) {
                this.blendMode(this._cachedBlendMode);
            }
            this.drawingContext.drawImage(cnv, s * sx, s * sy, s * sWidth, s * sHeight, dx, dy, dWidth, dHeight);
            if (this._isErasing) {
                this._pInst.erase();
            }
        } catch (e) {
            if (e.name !== 'NS_ERROR_NOT_AVAILABLE') {
                throw e;
            }
        }
    }
    _getTintedImageCanvas(img) {
        if (!img.canvas) {
            return img;
        }
        if (!img.tintCanvas) {
            // Once an image has been tinted, keep its tint canvas
            // around so we don't need to re-incur the cost of
            // creating a new one for each tint
            img.tintCanvas = document.createElement('canvas');
        }
        // Keep the size of the tint canvas up-to-date
        if (img.tintCanvas.width !== img.canvas.width) {
            img.tintCanvas.width = img.canvas.width;
        }
        if (img.tintCanvas.height !== img.canvas.height) {
            img.tintCanvas.height = img.canvas.height;
        }
        // Goal: multiply the r,g,b,a values of the source by
        // the r,g,b,a values of the tint color
        const ctx = img.tintCanvas.getContext('2d');
        ctx.save();
        ctx.clearRect(0, 0, img.canvas.width, img.canvas.height);
        if (this.states.tint[0] < 255 || this.states.tint[1] < 255 || this.states.tint[2] < 255) {
            // Color tint: we need to use the multiply blend mode to change the colors.
            // However, the canvas implementation of this destroys the alpha channel of
            // the image. To accommodate, we first get a version of the image with full
            // opacity everywhere, tint using multiply, and then use the destination-in
            // blend mode to restore the alpha channel again.
            // Start with the original image
            ctx.drawImage(img.canvas, 0, 0);
            // This blend mode makes everything opaque but forces the luma to match
            // the original image again
            ctx.globalCompositeOperation = 'luminosity';
            ctx.drawImage(img.canvas, 0, 0);
            // This blend mode forces the hue and chroma to match the original image.
            // After this we should have the original again, but with full opacity.
            ctx.globalCompositeOperation = 'color';
            ctx.drawImage(img.canvas, 0, 0);
            // Apply color tint
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = `rgb(${this.states.tint.slice(0, 3).join(', ')})`;
            ctx.fillRect(0, 0, img.canvas.width, img.canvas.height);
            // Replace the alpha channel with the original alpha * the alpha tint
            ctx.globalCompositeOperation = 'destination-in';
            ctx.globalAlpha = this.states.tint[3] / 255;
            ctx.drawImage(img.canvas, 0, 0);
        } else {
            // If we only need to change the alpha, we can skip all the extra work!
            ctx.globalAlpha = this.states.tint[3] / 255;
            ctx.drawImage(img.canvas, 0, 0);
        }
        ctx.restore();
        return img.tintCanvas;
    }
    //////////////////////////////////////////////
    // IMAGE | Pixels
    //////////////////////////////////////////////
    blendMode(mode) {
        if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a5"]) {
            console.warn('blendMode(SUBTRACT) only works in WEBGL mode.');
        } else if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a4"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a6"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a7"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a8"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a9"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["aa"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ab"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ac"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ad"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ae"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["af"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ag"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ah"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ai"]) {
            this._cachedBlendMode = mode;
            this.drawingContext.globalCompositeOperation = mode;
        } else {
            throw new Error(`Mode ${mode} not recognized.`);
        }
    }
    blend(...args) {
        const currBlend = this.drawingContext.globalCompositeOperation;
        const blendMode = args[args.length - 1];
        const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
        this.drawingContext.globalCompositeOperation = blendMode;
        p5.prototype.copy.apply(this, copyArgs);
        this.drawingContext.globalCompositeOperation = currBlend;
    }
    // p5.Renderer2D.prototype.get = p5.Renderer.prototype.get;
    // .get() is not overridden
    // x,y are canvas-relative (pre-scaled by _pixelDensity)
    _getPixel(x, y) {
        let imageData, index;
        imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
        index = 0;
        return [
            imageData[index + 0],
            imageData[index + 1],
            imageData[index + 2],
            imageData[index + 3]
        ];
    }
    loadPixels() {
        const pd = this._pixelDensity;
        const w = this.width * pd;
        const h = this.height * pd;
        const imageData = this.drawingContext.getImageData(0, 0, w, h);
        // @todo this should actually set pixels per object, so diff buffers can
        // have diff pixel arrays.
        this.imageData = imageData;
        this.pixels = imageData.data;
    }
    set(x, y, imgOrCol) {
        // round down to get integer numbers
        x = Math.floor(x);
        y = Math.floor(y);
        if (imgOrCol instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"]) {
            this.drawingContext.save();
            this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
            this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
            this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
            this.drawingContext.drawImage(imgOrCol.canvas, x, y);
            this.drawingContext.restore();
        } else {
            let r = 0, g = 0, b = 0, a = 0;
            let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
            if (!this.imageData) {
                this.loadPixels();
            }
            if (typeof imgOrCol === 'number') {
                if (idx < this.pixels.length) {
                    r = imgOrCol;
                    g = imgOrCol;
                    b = imgOrCol;
                    a = 255;
                //this.updatePixels.call(this);
                }
            } else if (Array.isArray(imgOrCol)) {
                if (imgOrCol.length < 4) {
                    throw new Error('pixel array must be of the form [R, G, B, A]');
                }
                if (idx < this.pixels.length) {
                    r = imgOrCol[0];
                    g = imgOrCol[1];
                    b = imgOrCol[2];
                    a = imgOrCol[3];
                //this.updatePixels.call(this);
                }
            } else if (imgOrCol instanceof p5.Color) {
                if (idx < this.pixels.length) {
                    [r, g, b, a] = imgOrCol._getRGBA([
                        255,
                        255,
                        255,
                        255
                    ]);
                //this.updatePixels.call(this);
                }
            }
            // loop over pixelDensity * pixelDensity
            for(let i = 0; i < this._pixelDensity; i++){
                for(let j = 0; j < this._pixelDensity; j++){
                    // loop over
                    idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
                    this.pixels[idx] = r;
                    this.pixels[idx + 1] = g;
                    this.pixels[idx + 2] = b;
                    this.pixels[idx + 3] = a;
                }
            }
        }
    }
    updatePixels(x, y, w, h) {
        const pd = this._pixelDensity;
        if (x === undefined && y === undefined && w === undefined && h === undefined) {
            x = 0;
            y = 0;
            w = this.width;
            h = this.height;
        }
        x *= pd;
        y *= pd;
        w *= pd;
        h *= pd;
        if (this.gifProperties) {
            this.gifProperties.frames[this.gifProperties.displayIndex].image = this.imageData;
        }
        this.drawingContext.putImageData(this.imageData, 0, 0, x, y, w, h);
    }
    //////////////////////////////////////////////
    // SHAPE | 2D Primitives
    //////////////////////////////////////////////
    /*
   * This function requires that:
   *
   *   0 <= start < TWO_PI
   *
   *   start <= stop < start + TWO_PI
   */ arc(x, y, w, h, start, stop, mode) {
        const ctx = this.clipPa || this.drawingContext;
        const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
        // Determines whether to add a line to the center, which should be done
        // when the mode is PIE or default; as well as when the start and end
        // angles do not form a full circle.
        const createPieSlice = !(mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ak"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["O"] || (stop - start) % __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"] === 0);
        // Fill curves
        if (this.states.fillColor) {
            if (!this._clipping) ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
            if (createPieSlice) ctx.lineTo(centerX, centerY);
            ctx.closePath();
            if (!this._clipping) ctx.fill();
        }
        // Stroke curves
        if (this.states.strokeColor) {
            if (!this._clipping) ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
            if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["aj"] && createPieSlice) {
                // In PIE mode, stroke is added to the center and back to path,
                // unless the pie forms a complete ellipse (see: createPieSlice)
                ctx.lineTo(centerX, centerY);
            }
            if (mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["aj"] || mode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ak"]) {
                // Stroke connects back to path begin for both PIE and CHORD
                ctx.closePath();
            }
            if (!this._clipping) ctx.stroke();
        }
        return this;
    }
    ellipse(args) {
        const ctx = this.clipPath || this.drawingContext;
        const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
        const x = parseFloat(args[0]), y = parseFloat(args[1]), w = parseFloat(args[2]), h = parseFloat(args[3]);
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        } else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
        if (!this._clipping) ctx.beginPath();
        ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
        ctx.closePath();
        if (!this._clipping && doFill) {
            ctx.fill();
        }
        if (!this._clipping && doStroke) {
            ctx.stroke();
        }
    }
    line(x1, y1, x2, y2) {
        const ctx = this.clipPath || this.drawingContext;
        if (!this.states.strokeColor) {
            return this;
        } else if (this._getStroke() === styleEmpty) {
            return this;
        }
        if (!this._clipping) ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        return this;
    }
    point(x, y) {
        const ctx = this.clipPath || this.drawingContext;
        if (!this.states.strokeColor) {
            return this;
        } else if (this._getStroke() === styleEmpty) {
            return this;
        }
        const s = this._getStroke();
        const f = this._getFill();
        if (!this._clipping) {
            // swapping fill color to stroke and back after for correct point rendering
            this._setFill(s);
        }
        if (!this._clipping) ctx.beginPath();
        ctx.arc(x, y, ctx.lineWidth / 2, 0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"], false);
        if (!this._clipping) {
            ctx.fill();
            this._setFill(f);
        }
    }
    quad(x1, y1, x2, y2, x3, y3, x4, y4) {
        const ctx = this.clipPath || this.drawingContext;
        const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        } else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        if (!this._clipping) ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.lineTo(x4, y4);
        ctx.closePath();
        if (!this._clipping && doFill) {
            ctx.fill();
        }
        if (!this._clipping && doStroke) {
            ctx.stroke();
        }
        return this;
    }
    rect(args) {
        const x = args[0];
        const y = args[1];
        const w = args[2];
        const h = args[3];
        let tl = args[4];
        let tr = args[5];
        let br = args[6];
        let bl = args[7];
        const ctx = this.clipPath || this.drawingContext;
        const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        } else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        if (!this._clipping) ctx.beginPath();
        if (typeof tl === 'undefined') {
            // No rounded corners
            ctx.rect(x, y, w, h);
        } else {
            // At least one rounded corner
            // Set defaults when not specified
            if (typeof tr === 'undefined') {
                tr = tl;
            }
            if (typeof br === 'undefined') {
                br = tr;
            }
            if (typeof bl === 'undefined') {
                bl = br;
            }
            // corner rounding must always be positive
            const absW = Math.abs(w);
            const absH = Math.abs(h);
            const hw = absW / 2;
            const hh = absH / 2;
            // Clip radii
            if (absW < 2 * tl) {
                tl = hw;
            }
            if (absH < 2 * tl) {
                tl = hh;
            }
            if (absW < 2 * tr) {
                tr = hw;
            }
            if (absH < 2 * tr) {
                tr = hh;
            }
            if (absW < 2 * br) {
                br = hw;
            }
            if (absH < 2 * br) {
                br = hh;
            }
            if (absW < 2 * bl) {
                bl = hw;
            }
            if (absH < 2 * bl) {
                bl = hh;
            }
            ctx.roundRect(x, y, w, h, [
                tl,
                tr,
                br,
                bl
            ]);
        }
        if (!this._clipping && this.states.fillColor) {
            ctx.fill();
        }
        if (!this._clipping && this.states.strokeColor) {
            ctx.stroke();
        }
        return this;
    }
    triangle(args) {
        const ctx = this.clipPath || this.drawingContext;
        const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
        const x1 = args[0], y1 = args[1];
        const x2 = args[2], y2 = args[3];
        const x3 = args[4], y3 = args[5];
        if (doFill && !doStroke) {
            if (this._getFill() === styleEmpty) {
                return this;
            }
        } else if (!doFill && doStroke) {
            if (this._getStroke() === styleEmpty) {
                return this;
            }
        }
        if (!this._clipping) ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();
        if (!this._clipping && doFill) {
            ctx.fill();
        }
        if (!this._clipping && doStroke) {
            ctx.stroke();
        }
    }
    //////////////////////////////////////////////
    // SHAPE | Attributes
    //////////////////////////////////////////////
    strokeCap(cap) {
        if (cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"] || cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"] || cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["k"]) {
            this.drawingContext.lineCap = cap;
        }
        return this;
    }
    strokeJoin(join) {
        if (join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"] || join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"] || join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"]) {
            this.drawingContext.lineJoin = join;
        }
        return this;
    }
    strokeWeight(w) {
        super.strokeWeight(w);
        if (typeof w === 'undefined' || w === 0) {
            // hack because lineWidth 0 doesn't work
            this.drawingContext.lineWidth = 0.0001;
        } else {
            this.drawingContext.lineWidth = w;
        }
        return this;
    }
    _getFill() {
        if (!this.states._cachedFillStyle) {
            this.states.setValue('_cachedFillStyle', this.drawingContext.fillStyle);
        }
        return this.states._cachedFillStyle;
    }
    _setFill(fillStyle) {
        if (fillStyle !== this.states._cachedFillStyle) {
            this.drawingContext.fillStyle = fillStyle;
            this.states.setValue('_cachedFillStyle', fillStyle);
        }
    }
    _getStroke() {
        if (!this.states._cachedStrokeStyle) {
            this.states.setValue('_cachedStrokeStyle', this.drawingContext.strokeStyle);
        }
        return this.states._cachedStrokeStyle;
    }
    _setStroke(strokeStyle) {
        if (strokeStyle !== this.states._cachedStrokeStyle) {
            this.drawingContext.strokeStyle = strokeStyle;
            this.states.setValue('_cachedStrokeStyle', strokeStyle);
        }
    }
    //////////////////////////////////////////////
    // TRANSFORM
    //////////////////////////////////////////////
    applyMatrix(a, b, c, d, e, f) {
        this.drawingContext.transform(a, b, c, d, e, f);
    }
    getWorldToScreenMatrix() {
        let domMatrix = new DOMMatrix().scale(1 / this._pixelDensity).multiply(this.drawingContext.getTransform());
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](domMatrix.toFloat32Array());
    }
    resetMatrix() {
        this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
        this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
        return this;
    }
    rotate(rad) {
        this.drawingContext.rotate(rad);
    }
    scale(x, y) {
        this.drawingContext.scale(x, y);
        return this;
    }
    translate(x, y) {
        // support passing a vector as the 1st parameter
        if (x instanceof p5.Vector) {
            y = x.y;
            x = x.x;
        }
        this.drawingContext.translate(x, y);
        return this;
    }
    //////////////////////////////////////////////
    // TYPOGRAPHY (see src/type/textCore.js)
    //////////////////////////////////////////////
    //////////////////////////////////////////////
    // STRUCTURE
    //////////////////////////////////////////////
    // a push() operation is in progress.
    // the renderer should return a 'style' object that it wishes to
    // store on the push stack.
    // derived renderers should call the base class' push() method
    // to fetch the base style object.
    push() {
        this.drawingContext.save();
        // get the base renderer style
        return super.push();
    }
    // a pop() operation is in progress
    // the renderer is passed the 'style' object that it returned
    // from its push() method.
    // derived renderers should pass this object to their base
    // class' pop method
    pop(style) {
        this.drawingContext.restore();
        super.pop(style);
    }
}
function renderer2D(p5, fn) {
    /**
   * p5.Renderer2D
   * The 2D graphics canvas renderer class.
   * extends p5.Renderer
   * @private
   */ p5.Renderer2D = Renderer2D;
    p5.renderers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["P"]] = Renderer2D;
    p5.renderers['p2d-hdr'] = new Proxy(Renderer2D, {
        construct (target, [pInst, w, h, isMainCanvas, elt]) {
            return new target(pInst, w, h, isMainCanvas, elt, {
                colorSpace: 'display-p3'
            });
        }
    });
}
/**
 * @module Structure
 * @submodule Structure
 * @for p5
 * @requires constants
 */ /**
 * This is the p5 instance constructor.
 *
 * A p5 instance holds all the properties and methods related to
 * a p5 sketch.  It expects an incoming sketch closure and it can also
 * take an optional node parameter for attaching the generated p5 canvas
 * to a node.  The sketch closure takes the newly created p5 instance as
 * its sole argument and may optionally set an asynchronous function
 * using `async/await`, along with the standard <a href="#/p5/setup">setup()</a>,
 *  and/or <a href="#/p5/setup">setup()</a>, and/or <a href="#/p5/draw">draw()</a>
 *  properties on it for running a sketch.
 *
 * A p5 sketch can run in "global" or "instance" mode:
 * "global"   - all properties and methods are attached to the window
 * "instance" - all properties and methods are bound to this p5 object
 *
 * @class p5
 * @param  {function(p5)}       sketch a closure that can set optional <a href="#/p5/preload">preload()</a>,
 *                              <a href="#/p5/setup">setup()</a>, and/or <a href="#/p5/draw">draw()</a> properties on the
 *                              given p5 instance
 * @param  {String|HTMLElement}        [node] element to attach canvas to
 * @return {p5}                 a p5 instance
 */ class p5 {
    static VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["al"];
    // This is a pointer to our global mode p5 instance, if we're in
    // global mode.
    static instance = null;
    static lifecycleHooks = {
        presetup: [],
        postsetup: [],
        predraw: [],
        postdraw: [],
        remove: []
    };
    // FES stub
    static _checkForUserDefinedFunctions = ()=>{};
    static _friendlyFileLoadError = ()=>{};
    constructor(sketch, node){
        // Apply addon defined decorations
        if (p5.decorations.size > 0) {
            for (const [patternArray, decoration] of p5.decorations){
                for(const member in p5.prototype){
                    // Member must be a function
                    if (typeof p5.prototype[member] !== 'function') continue;
                    if (!patternArray.some((pattern)=>{
                        if (typeof pattern === 'string') {
                            return pattern === member;
                        } else if (pattern instanceof RegExp) {
                            return pattern.test(member);
                        }
                    })) continue;
                    p5.prototype[member] = decoration(p5.prototype[member], {
                        kind: 'method',
                        name: member,
                        access: {},
                        static: false,
                        private: false,
                        addInitializer (initializer) {}
                    });
                }
            }
            p5.decorations.clear();
        }
        //////////////////////////////////////////////
        // PRIVATE p5 PROPERTIES AND METHODS
        //////////////////////////////////////////////
        this.hitCriticalError = false;
        this._setupDone = false;
        this._userNode = node;
        this._curElement = null;
        this._elements = [];
        this._glAttributes = null;
        this._requestAnimId = 0;
        this._isGlobal = false;
        this._loop = true;
        this._startListener = null;
        this._initializeInstanceVariables();
        this._events = {};
        this._removeAbortController = new AbortController();
        this._removeSignal = this._removeAbortController.signal;
        this._millisStart = -1;
        this._recording = false;
        // States used in the custom random generators
        this._lcg_random_state = null; // NOTE: move to random.js
        this._gaussian_previous = false; // NOTE: move to random.js
        // ensure correct reporting of window dimensions
        this._updateWindowSize();
        const bindGlobal = createBindGlobal(this);
        // If the user has created a global setup or draw function,
        // assume "global" mode and make everything global (i.e. on the window)
        if (!sketch) {
            this._isGlobal = true;
            if (window.hitCriticalError) {
                return;
            }
            p5.instance = this;
            // Loop through methods on the prototype and attach them to the window
            // All methods and properties with name starting with '_' will be skipped
            for (const p of Object.getOwnPropertyNames(p5.prototype)){
                if (p[0] === '_') continue;
                bindGlobal(p);
            }
            const protectedProperties = [
                'constructor',
                'length'
            ];
            // Attach its properties to the window
            for(const p in this){
                if (this.hasOwnProperty(p)) {
                    if (p[0] === '_' || protectedProperties.includes(p)) continue;
                    bindGlobal(p);
                }
            }
        } else {
            // Else, the user has passed in a sketch closure that may set
            // user-provided 'setup', 'draw', etc. properties on this instance of p5
            sketch(this);
            // Run a check to see if the user has misspelled 'setup', 'draw', etc
            // detects capitalization mistakes only ( Setup, SETUP, MouseClicked, etc)
            p5._checkForUserDefinedFunctions(this);
        }
        const focusHandler = ()=>{
            this.focused = true;
        };
        const blurHandler = ()=>{
            this.focused = false;
        };
        window.addEventListener('focus', focusHandler);
        window.addEventListener('blur', blurHandler);
        p5.lifecycleHooks.remove.push(function() {
            window.removeEventListener('focus', focusHandler);
            window.removeEventListener('blur', blurHandler);
        });
        // Initialization complete, start runtime
        if (document.readyState === 'complete') {
            this.#_start();
        } else {
            this._startListener = this.#_start.bind(this);
            window.addEventListener('load', this._startListener, false);
        }
    }
    get pixels() {
        return this._renderer.pixels;
    }
    get drawingContext() {
        return this._renderer.drawingContext;
    }
    static registerAddon(addon) {
        const lifecycles = {};
        addon(p5, p5.prototype, lifecycles);
        const validLifecycles = Object.keys(p5.lifecycleHooks);
        for (const name of validLifecycles){
            if (typeof lifecycles[name] === 'function') {
                p5.lifecycleHooks[name].push(lifecycles[name]);
            }
        }
    }
    static decorations = new Map();
    static decorateHelper(pattern, decoration) {
        let patternArray = pattern;
        if (!Array.isArray(pattern)) patternArray = [
            pattern
        ];
        p5.decorations.set(patternArray, decoration);
    }
    #customActions = {};
    _customActions = new Proxy({}, {
        get: (target, prop)=>{
            if (!this.#customActions[prop]) {
                const context = this._isGlobal ? window : this;
                if (typeof context[prop] === 'function') {
                    this.#customActions[prop] = context[prop].bind(this);
                }
            }
            return this.#customActions[prop];
        }
    });
    async #_start() {
        if (this.hitCriticalError) return;
        // Find node if id given
        if (this._userNode) {
            if (typeof this._userNode === 'string') {
                this._userNode = document.getElementById(this._userNode);
            }
        }
        await this.#_setup();
        if (this.hitCriticalError) return;
        if (!this._recording) {
            this._draw();
        }
    }
    async #_setup() {
        // Run `presetup` hooks
        await this._runLifecycleHook('presetup');
        if (this.hitCriticalError) return;
        // Always create a default canvas.
        // Later on if the user calls createCanvas, this default one
        // will be replaced
        this.createCanvas(100, 100, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["P"]);
        // Record the time when setup starts. millis() will start at 0 within
        // setup, but this isn't documented, locked-in behavior yet.
        this._millisStart = window.performance.now();
        const context = this._isGlobal ? window : this;
        if (typeof context.setup === 'function') {
            await context.setup();
        }
        if (this.hitCriticalError) return;
        const canvases = document.getElementsByTagName('canvas');
        for (const k of canvases){
            // Apply touchAction = 'none' to canvases to prevent scrolling
            // when dragging on canvas elements
            k.style.touchAction = 'none';
            // unhide any hidden canvases that were created
            if (k.dataset.hidden === 'true') {
                k.style.visibility = '';
                delete k.dataset.hidden;
            }
        }
        this._lastTargetFrameTime = window.performance.now();
        this._lastRealFrameTime = window.performance.now();
        this._setupDone = true;
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
            this._updateAccsOutput();
        }
        // Run `postsetup` hooks
        await this._runLifecycleHook('postsetup');
        // Record the time when the draw loop starts so that millis() starts at 0
        // when the draw loop begins.
        this._millisStart = window.performance.now();
    }
    // While '#_draw' here is async, it is not awaited as 'requestAnimationFrame'
    // does not await its callback. Thus it is not recommended for 'draw()` to be
    // async and use await within as the next frame may start rendering before the
    // current frame finish awaiting. The same goes for lifecycle hooks 'predraw'
    // and 'postdraw'.
    async _draw(requestAnimationFrameTimestamp) {
        if (this.hitCriticalError) return;
        const now = requestAnimationFrameTimestamp || window.performance.now();
        const timeSinceLastFrame = now - this._lastTargetFrameTime;
        const targetTimeBetweenFrames = 1000 / this._targetFrameRate;
        // only draw if we really need to; don't overextend the browser.
        // draw if we're within 5ms of when our next frame should paint
        // (this will prevent us from giving up opportunities to draw
        // again when it's really about time for us to do so). fixes an
        // issue where the frameRate is too low if our refresh loop isn't
        // in sync with the browser. note that we have to draw once even
        // if looping is off, so we bypass the time delay if that
        // is the case.
        const epsilon = 5;
        if (!this._loop || timeSinceLastFrame >= targetTimeBetweenFrames - epsilon) {
            //mandatory update values(matrixes and stack)
            this.deltaTime = now - this._lastRealFrameTime;
            this._frameRate = 1000.0 / this.deltaTime;
            await this.redraw();
            this._lastTargetFrameTime = Math.max(this._lastTargetFrameTime + targetTimeBetweenFrames, now);
            this._lastRealFrameTime = now;
            // If the user is actually using mouse module, then update
            // coordinates, otherwise skip. We can test this by simply
            // checking if any of the mouse functions are available or not.
            // NOTE : This reflects only in complete build or modular build.
            if (typeof this._updateMouseCoords !== 'undefined') {
                this._updateMouseCoords();
                //reset delta values so they reset even if there is no mouse event to set them
                // for example if the mouse is outside the screen
                this.movedX = 0;
                this.movedY = 0;
            }
        }
        // get notified the next time the browser gives us
        // an opportunity to draw.
        if (this._loop) {
            this._requestAnimId = window.requestAnimationFrame(this._draw.bind(this));
        }
    }
    /**
   * Removes the sketch from the web page.
   *
   * Calling `remove()` stops the draw loop and removes any HTML elements
   * created by the sketch, including the canvas. A new sketch can be
   * created by using the <a href="#/p5/p5">p5()</a> constructor, as in
   * `new p5()`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the canvas.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A white circle on a gray background. The circle follows the mouse as the user moves. The sketch disappears when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   // Paint the background repeatedly.
   *   background(200);
   *
   *   // Draw circles repeatedly.
   *   circle(mouseX, mouseY, 40);
   * }
   *
   * // Remove the sketch when the user double-clicks.
   * function doubleClicked() {
   *   remove();
   * }
   * </code>
   * </div>
   */ async remove() {
        // Remove start listener to prevent orphan canvas being created
        if (this._startListener) {
            window.removeEventListener('load', this._startListener, false);
        }
        if (this._curElement) {
            // stop draw
            this._loop = false;
            if (this._requestAnimId) {
                window.cancelAnimationFrame(this._requestAnimId);
            }
            // Send sketch remove signal
            this._removeAbortController.abort();
            // remove DOM elements created by p5
            for (const e of this._elements){
                if (e.elt && e.elt.parentNode) {
                    e.elt.parentNode.removeChild(e.elt);
                }
            }
            // Run `remove` hooks
            await this._runLifecycleHook('remove');
        }
        // remove window bound properties and methods
        if (this._isGlobal) {
            for(const p in p5.prototype){
                try {
                    delete window[p];
                } catch (x) {
                    window[p] = undefined;
                }
            }
            for(const p2 in this){
                if (this.hasOwnProperty(p2)) {
                    try {
                        delete window[p2];
                    } catch (x) {
                        window[p2] = undefined;
                    }
                }
            }
            p5.instance = null;
        }
    }
    async _runLifecycleHook(hookName) {
        await Promise.all(p5.lifecycleHooks[hookName].map((hook)=>{
            return hook.call(this);
        }));
    }
    _initializeInstanceVariables() {
        this._accessibleOutputs = {
            text: false,
            grid: false,
            textLabel: false,
            gridLabel: false
        };
        this._styles = [];
        this._downKeys = {}; //Holds the key codes of currently pressed keys
        this._downKeyCodes = {};
    }
}
// Global helper function for binding properties to window in global mode
function createBindGlobal(instance) {
    return function bindGlobal(property) {
        if (property === 'constructor') return;
        // Check if this property has a getter on the instance or prototype
        const instanceDescriptor = Object.getOwnPropertyDescriptor(instance, property);
        const prototypeDescriptor = Object.getOwnPropertyDescriptor(p5.prototype, property);
        const hasGetter = instanceDescriptor && instanceDescriptor.get || prototypeDescriptor && prototypeDescriptor.get;
        // Only check if it's a function if it doesn't have a getter
        // to avoid actually evaluating getters before things like the
        // renderer are fully constructed
        let isPrototypeFunction = false;
        let isConstant = false;
        let constantValue;
        if (!hasGetter) {
            const prototypeValue = p5.prototype[property];
            isPrototypeFunction = typeof prototypeValue === 'function';
            // Check if this is a true constant from the constants module
            if (!isPrototypeFunction && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"][property] !== undefined) {
                isConstant = true;
                constantValue = prototypeValue;
            }
        }
        if (isPrototypeFunction) {
            // For regular functions, cache the bound function
            const boundFunction = p5.prototype[property].bind(instance);
            Object.defineProperty(window, property, {
                configurable: true,
                enumerable: true,
                value: boundFunction
            });
        } else if (isConstant) {
            // For constants, cache the value directly
            Object.defineProperty(window, property, {
                configurable: true,
                enumerable: true,
                value: constantValue
            });
        } else if (hasGetter || !isPrototypeFunction) {
            // For properties with getters or non-function properties, use lazy optimization
            // On first access, determine the type and optimize subsequent accesses
            let lastFunction = null;
            let boundFunction = null;
            let isFunction = null; // null = unknown, true = function, false = not function
            Object.defineProperty(window, property, {
                configurable: true,
                enumerable: true,
                get: ()=>{
                    const currentValue = instance[property];
                    if (isFunction === null) {
                        // First access - determine type and optimize
                        isFunction = typeof currentValue === 'function';
                        if (isFunction) {
                            lastFunction = currentValue;
                            boundFunction = currentValue.bind(instance);
                            return boundFunction;
                        } else {
                            return currentValue;
                        }
                    } else if (isFunction) {
                        // Optimized function path - only rebind if function changed
                        if (currentValue !== lastFunction) {
                            lastFunction = currentValue;
                            boundFunction = currentValue.bind(instance);
                        }
                        return boundFunction;
                    } else {
                        // Optimized non-function path
                        return currentValue;
                    }
                }
            });
        }
    };
}
// Attach constants to p5 prototype
for(const k in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"]){
    p5.prototype[k] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"][k];
}
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["y"]);
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]);
p5.registerAddon(renderer2D);
p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["z"]);
;
}),
"[project]/node_modules/p5/dist/accessibility/describe.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>describe
]);
/**
 * @module Environment
 * @submodule Environment
 * @for p5
 * @requires core
 */ function describe(p51, fn) {
    const descContainer = '_Description'; //Fallback container
    const fallbackDescId = '_fallbackDesc'; //Fallback description
    const fallbackTableId = '_fallbackTable'; //Fallback Table
    const fallbackTableElId = '_fte_'; //Fallback Table Element
    const labelContainer = '_Label'; //Label container
    const labelDescId = '_labelDesc'; //Label description
    const labelTableId = '_labelTable'; //Label Table
    const labelTableElId = '_lte_'; //Label Table Element
    /**
   * Creates a screen reader-accessible description of the canvas.
   *
   * The first parameter, `text`, is the description of the canvas.
   *
   * The second parameter, `display`, is optional. It determines how the
   * description is displayed. If `LABEL` is passed, as in
   * `describe('A description.', LABEL)`, the description will be visible in
   * a div element next to the canvas. If `FALLBACK` is passed, as in
   * `describe('A description.', FALLBACK)`, the description will only be
   * visible to screen readers. This is the default mode.
   *
   * Read
   * <a href="/learn/accessible-labels.html">Writing accessible canvas descriptions</a>
   * to learn more about making sketches accessible.
   *
   * @method describe
   * @param  {String} text        description of the canvas.
   * @param  {(FALLBACK|LABEL)} [display] either LABEL or FALLBACK.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   background('pink');
   *
   *   // Draw a heart.
   *   fill('red');
   *   noStroke();
   *   circle(67, 67, 20);
   *   circle(83, 67, 20);
   *   triangle(91, 73, 75, 95, 59, 73);
   *
   *   // Add a general description of the canvas.
   *   describe('A pink square with a red heart in the bottom-right corner.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   background('pink');
   *
   *   // Draw a heart.
   *   fill('red');
   *   noStroke();
   *   circle(67, 67, 20);
   *   circle(83, 67, 20);
   *   triangle(91, 73, 75, 95, 59, 73);
   *
   *   // Add a general description of the canvas
   *   // and display it for debugging.
   *   describe('A pink square with a red heart in the bottom-right corner.', LABEL);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup(){
   *  createCanvas(100, 100);
   * };
   *
   * function draw() {
   *   background(200);
   *
   *   // The expression
   *   // frameCount % 100
   *   // causes x to increase from 0
   *   // to 99, then restart from 0.
   *   let x = frameCount % 100;
   *
   *   // Draw the circle.
   *   fill(0, 255, 0);
   *   circle(x, 50, 40);
   *
   *   // Add a general description of the canvas.
   *   describe(`A green circle at (${x}, 50) moves from left to right on a gray square.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup(){
   * createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // The expression
   *   // frameCount % 100
   *   // causes x to increase from 0
   *   // to 99, then restart from 0.
   *   let x = frameCount % 100;
   *
   *   // Draw the circle.
   *   fill(0, 255, 0);
   *   circle(x, 50, 40);
   *
   *   // Add a general description of the canvas
   *   // and display it for debugging.
   *   describe(`A green circle at (${x}, 50) moves from left to right on a gray square.`, LABEL);
   * }
   * </code>
   * </div>
   */ fn.describe = function(text, display) {
        // p5._validateParameters('describe', arguments);
        if (typeof text !== 'string') {
            return;
        }
        const cnvId = this.canvas.id;
        //calls function that adds punctuation for better screen reading
        text = _descriptionText(text);
        //if there is no dummyDOM
        if (!this.dummyDOM) {
            this.dummyDOM = document.getElementById(cnvId).parentNode;
        }
        if (!this.descriptions) {
            this.descriptions = {};
        }
        //check if html structure for description is ready
        if (this.descriptions.fallback) {
            //check if text is different from current description
            if (this.descriptions.fallback.innerHTML !== text) {
                //update description
                this.descriptions.fallback.innerHTML = text;
            }
        } else {
            //create fallback html structure
            this._describeHTML('fallback', text);
        }
        //if display is LABEL
        if (display === this.LABEL) {
            //check if html structure for label is ready
            if (this.descriptions.label) {
                //check if text is different from current label
                if (this.descriptions.label.innerHTML !== text) {
                    //update label description
                    this.descriptions.label.innerHTML = text;
                }
            } else {
                //create label html structure
                this._describeHTML('label', text);
            }
        }
    };
    /**
   * Creates a screen reader-accessible description of elements in the canvas.
   *
   * Elements are shapes or groups of shapes that create meaning together. For
   * example, a few overlapping circles could make an "eye" element.
   *
   * The first parameter, `name`, is the name of the element.
   *
   * The second parameter, `text`, is the description of the element.
   *
   * The third parameter, `display`, is optional. It determines how the
   * description is displayed. If `LABEL` is passed, as in
   * `describe('A description.', LABEL)`, the description will be visible in
   * a div element next to the canvas. Using `LABEL` creates unhelpful
   * duplicates for screen readers. Only use `LABEL` during development. If
   * `FALLBACK` is passed, as in `describe('A description.', FALLBACK)`, the
   * description will only be visible to screen readers. This is the default
   * mode.
   *
   * Read
   * <a href="/learn/accessible-labels.html">Writing accessible canvas descriptions</a>
   * to learn more about making sketches accessible.
   *
   * @method describeElement
   * @param  {String} name        name of the element.
   * @param  {String} text        description of the element.
   * @param  {(FALLBACK|LABEL)} [display] either LABEL or FALLBACK.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   background('pink');
   *
   *   // Describe the first element
   *   // and draw it.
   *   describeElement('Circle', 'A yellow circle in the top-left corner.');
   *   noStroke();
   *   fill('yellow');
   *   circle(25, 25, 40);
   *
   *   // Describe the second element
   *   // and draw it.
   *   describeElement('Heart', 'A red heart in the bottom-right corner.');
   *   fill('red');
   *   circle(66.6, 66.6, 20);
   *   circle(83.2, 66.6, 20);
   *   triangle(91.2, 72.6, 75, 95, 58.6, 72.6);
   *
   *   // Add a general description of the canvas.
   *   describe('A red heart and yellow circle over a pink background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   background('pink');
   *
   *   // Describe the first element
   *   // and draw it. Display the
   *   // description for debugging.
   *   describeElement('Circle', 'A yellow circle in the top-left corner.', LABEL);
   *   noStroke();
   *   fill('yellow');
   *   circle(25, 25, 40);
   *
   *   // Describe the second element
   *   // and draw it. Display the
   *   // description for debugging.
   *   describeElement('Heart', 'A red heart in the bottom-right corner.', LABEL);
   *   fill('red');
   *   circle(66.6, 66.6, 20);
   *   circle(83.2, 66.6, 20);
   *   triangle(91.2, 72.6, 75, 95, 58.6, 72.6);
   *
   *   // Add a general description of the canvas.
   *   describe('A red heart and yellow circle over a pink background.');
   * }
   * </code>
   * </div>
   */ fn.describeElement = function(name, text, display) {
        // p5._validateParameters('describeElement', arguments);
        if (typeof text !== 'string' || typeof name !== 'string') {
            return;
        }
        const cnvId = this.canvas.id;
        //calls function that adds punctuation for better screen reading
        text = _descriptionText(text);
        //calls function that adds punctuation for better screen reading
        let elementName = _elementName(name);
        //remove any special characters from name to use it as html id
        name = name.replace(/[^a-zA-Z0-9]/g, '');
        //store element description
        let inner = `<th scope="row">${elementName}</th><td>${text}</td>`;
        //if there is no dummyDOM
        if (!this.dummyDOM) {
            this.dummyDOM = document.getElementById(cnvId).parentNode;
        }
        if (!this.descriptions) {
            this.descriptions = {
                fallbackElements: {}
            };
        } else if (!this.descriptions.fallbackElements) {
            this.descriptions.fallbackElements = {};
        }
        //check if html structure for element description is ready
        if (this.descriptions.fallbackElements[name]) {
            //if current element description is not the same as inner
            if (this.descriptions.fallbackElements[name].innerHTML !== inner) {
                //update element description
                this.descriptions.fallbackElements[name].innerHTML = inner;
            }
        } else {
            //create fallback html structure
            this._describeElementHTML('fallback', name, inner);
        }
        //if display is LABEL
        if (display === this.LABEL) {
            if (!this.descriptions.labelElements) {
                this.descriptions.labelElements = {};
            }
            //if html structure for label element description is ready
            if (this.descriptions.labelElements[name]) {
                //if label element description is different
                if (this.descriptions.labelElements[name].innerHTML !== inner) {
                    //update label element description
                    this.descriptions.labelElements[name].innerHTML = inner;
                }
            } else {
                //create label element html structure
                this._describeElementHTML('label', name, inner);
            }
        }
    };
    /*
   *
   * Helper functions for describe() and describeElement().
   *
   */ // check that text is not LABEL or FALLBACK and ensure text ends with punctuation mark
    function _descriptionText(text) {
        if (text === 'label' || text === 'fallback') {
            throw new Error('description should not be LABEL or FALLBACK');
        }
        //if string does not end with '.'
        if (!text.endsWith('.') && !text.endsWith(';') && !text.endsWith(',') && !text.endsWith('?') && !text.endsWith('!')) {
            //add '.' to the end of string
            text = text + '.';
        }
        return text;
    }
    /*
   * Helper functions for describe()
   */ //creates HTML structure for canvas descriptions
    fn._describeHTML = function(type, text) {
        const cnvId = this.canvas.id;
        if (type === 'fallback') {
            //if there is no description container
            if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
                //if there are no accessible outputs (see textOutput() and gridOutput())
                let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><p id="${cnvId}${fallbackDescId}"></p></div>`;
                if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
                    //create description container + <p> for fallback description
                    this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = html;
                } else {
                    //create description container + <p> for fallback description before outputs
                    this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML('beforebegin', html);
                }
            } else {
                //if describeElement() has already created the container and added a table of elements
                //create fallback description <p> before the table
                this.dummyDOM.querySelector('#' + cnvId + fallbackTableId).insertAdjacentHTML('beforebegin', `<p id="${cnvId + fallbackDescId}"></p>`);
            }
            //if the container for the description exists
            this.descriptions.fallback = this.dummyDOM.querySelector(`#${cnvId}${fallbackDescId}`);
            this.descriptions.fallback.innerHTML = text;
            return;
        } else if (type === 'label') {
            //if there is no label container
            if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
                let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><p id="${cnvId}${labelDescId}"></p></div>`;
                //if there are no accessible outputs (see textOutput() and gridOutput())
                if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
                    //create label container + <p> for label description
                    this.dummyDOM.querySelector('#' + cnvId).insertAdjacentHTML('afterend', html);
                } else {
                    //create label container + <p> for label description before outputs
                    this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML('beforebegin', html);
                }
            } else if (this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
                //if describeElement() has already created the container and added a table of elements
                //create label description <p> before the table
                this.dummyDOM.querySelector(`#${cnvId + labelTableId}`).insertAdjacentHTML('beforebegin', `<p id="${cnvId}${labelDescId}"></p>`);
            }
            this.descriptions.label = this.dummyDOM.querySelector('#' + cnvId + labelDescId);
            this.descriptions.label.innerHTML = text;
            return;
        }
    };
    /*
   * Helper functions for describeElement().
   */ //check that name is not LABEL or FALLBACK and ensure text ends with colon
    function _elementName(name) {
        if (name === 'label' || name === 'fallback') {
            throw new Error('element name should not be LABEL or FALLBACK');
        }
        //check if last character of string n is '.', ';', or ','
        if (name.endsWith('.') || name.endsWith(';') || name.endsWith(',')) {
            //replace last character with ':'
            name = name.replace(/.$/, ':');
        } else if (!name.endsWith(':')) {
            //if string n does not end with ':'
            //add ':'' at the end of string
            name = name + ':';
        }
        return name;
    }
    //creates HTML structure for element descriptions
    fn._describeElementHTML = function(type, name, text) {
        const cnvId = this.canvas.id;
        if (type === 'fallback') {
            //if there is no description container
            if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
                //if there are no accessible outputs (see textOutput() and gridOutput())
                let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table></div>`;
                if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
                    //create container + table for element descriptions
                    this.dummyDOM.querySelector('#' + cnvId).innerHTML = html;
                } else {
                    //create container + table for element descriptions before outputs
                    this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML('beforebegin', html);
                }
            } else if (!this.dummyDOM.querySelector('#' + cnvId + fallbackTableId)) {
                //if describe() has already created the container and added a description
                //and there is no table create fallback table for element description after
                //fallback description
                this.dummyDOM.querySelector('#' + cnvId + fallbackDescId).insertAdjacentHTML('afterend', `<table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table>`);
            }
            //create a table row for the element
            let tableRow = document.createElement('tr');
            tableRow.id = cnvId + fallbackTableElId + name;
            this.dummyDOM.querySelector('#' + cnvId + fallbackTableId).appendChild(tableRow);
            //update element description
            this.descriptions.fallbackElements[name] = this.dummyDOM.querySelector(`#${cnvId}${fallbackTableElId}${name}`);
            this.descriptions.fallbackElements[name].innerHTML = text;
            return;
        } else if (type === 'label') {
            //If display is LABEL creates a div adjacent to the canvas element with
            //a table, a row header cell with the name of the elements,
            //and adds the description of the element in adjacent cell.
            //if there is no label description container
            if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
                //if there are no accessible outputs (see textOutput() and gridOutput())
                let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><table id="${cnvId}${labelTableId}"></table></div>`;
                if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
                    //create container + table for element descriptions
                    this.dummyDOM.querySelector('#' + cnvId).insertAdjacentHTML('afterend', html);
                } else {
                    //create container + table for element descriptions before outputs
                    this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML('beforebegin', html);
                }
            } else if (!this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
                //if describe() has already created the label container and added a description
                //and there is no table create label table for element description after
                //label description
                this.dummyDOM.querySelector('#' + cnvId + labelDescId).insertAdjacentHTML('afterend', `<table id="${cnvId + labelTableId}"></table>`);
            }
            //create a table row for the element label description
            let tableRow = document.createElement('tr');
            tableRow.id = cnvId + labelTableElId + name;
            this.dummyDOM.querySelector('#' + cnvId + labelTableId).appendChild(tableRow);
            //update element label description
            this.descriptions.labelElements[name] = this.dummyDOM.querySelector(`#${cnvId}${labelTableElId}${name}`);
            this.descriptions.labelElements[name].innerHTML = text;
        }
    };
}
if (typeof p5 !== 'undefined') {
    describe(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/accessibility/gridOutput.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>gridOutput
]);
/**
 * @module Environment
 * @submodule Environment
 * @for p5
 * @requires core
 */ function gridOutput(p51, fn) {
    //the functions in this file support updating the grid output
    //updates gridOutput
    fn._updateGridOutput = function(idT) {
        if (this._renderer && this._renderer instanceof p51.RendererGL) {
            if (!this._didOutputGridWebGLMessage) {
                this._didOutputGridWebGLMessage = true;
                console.error('gridOutput() does not yet work in WebGL mode.');
            }
            return;
        }
        //if html structure is not there yet
        if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
            return;
        }
        let current = this._accessibleOutputs[idT];
        //create shape details list
        let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);
        //create summary
        let innerSummary = _gridSummary(innerShapeDetails.numShapes, this.ingredients.colors.background, this.width, this.height);
        //create grid map
        let innerMap = _gridMap(idT, this.ingredients.shapes);
        //if it is different from current summary
        if (innerSummary !== current.summary.innerHTML) {
            //update
            current.summary.innerHTML = innerSummary;
        }
        //if it is different from current map
        if (innerMap !== current.map.innerHTML) {
            //update
            current.map.innerHTML = innerMap;
        }
        //if it is different from current shape details
        if (innerShapeDetails.details !== current.shapeDetails.innerHTML) {
            //update
            current.shapeDetails.innerHTML = innerShapeDetails.details;
        }
        this._accessibleOutputs[idT] = current;
    };
    //creates spatial grid that maps the location of shapes
    function _gridMap(idT, ingredients) {
        let shapeNumber = 0;
        let table = '';
        //create an array of arrays 10*10 of empty cells
        let cells = Array.from(Array(10), ()=>Array(10));
        for(let x in ingredients){
            for(let y in ingredients[x]){
                let fill;
                if (x !== 'line') {
                    fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
                } else {
                    fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x} midpoint</a>`;
                }
                // Check if shape is in canvas, skip if not
                if (ingredients[x][y].loc.locY < cells.length && ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length) {
                    //if empty cell of location of shape is undefined
                    if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {
                        //fill it with shape info
                        cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;
                    //if a shape is already in that location
                    } else {
                        //add it
                        cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] + '  ' + fill;
                    }
                    shapeNumber++;
                }
            }
        }
        //make table based on array
        for(let _r in cells){
            let row = '<tr>';
            for(let c in cells[_r]){
                row = row + '<td>';
                if (cells[_r][c] !== undefined) {
                    row = row + cells[_r][c];
                }
                row = row + '</td>';
            }
            table = table + row + '</tr>';
        }
        return table;
    }
    //creates grid summary
    function _gridSummary(numShapes, background, width, height) {
        let text = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;
        if (numShapes[0] === 1) {
            text = `${text} shape: ${numShapes[1]}`;
        } else {
            text = `${text} shapes: ${numShapes[1]}`;
        }
        return text;
    }
    //creates list of shapes
    function _gridShapeDetails(idT, ingredients) {
        let shapeDetails = '';
        let shapes = '';
        let totalShapes = 0;
        //goes trhough every shape type in ingredients
        for(let x in ingredients){
            let shapeNum = 0;
            for(let y in ingredients[x]){
                //it creates a line in a list
                let line = `<li id="${idT}shape${totalShapes}">${ingredients[x][y].color} ${x},`;
                if (x === 'line') {
                    line = line + ` location = ${ingredients[x][y].pos}, length = ${ingredients[x][y].length} pixels`;
                } else {
                    line = line + ` location = ${ingredients[x][y].pos}`;
                    if (x !== 'point') {
                        line = line + `, area = ${ingredients[x][y].area} %`;
                    }
                    line = line + '</li>';
                }
                shapeDetails = shapeDetails + line;
                shapeNum++;
                totalShapes++;
            }
            if (shapeNum > 1) {
                shapes = `${shapes} ${shapeNum} ${x}s`;
            } else {
                shapes = `${shapes} ${shapeNum} ${x}`;
            }
        }
        return {
            numShapes: [
                totalShapes,
                shapes
            ],
            details: shapeDetails
        };
    }
}
if (typeof p5 !== 'undefined') {
    gridOutput(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/accessibility/textOutput.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>textOutput
]);
/**
 * @module Environment
 * @submodule Environment
 * @for p5
 * @requires core
 */ function textOutput(p51, fn) {
    //the functions in this file support updating the text output
    //updates textOutput
    fn._updateTextOutput = function(idT) {
        if (this._renderer && this._renderer instanceof p51.RendererGL) {
            if (!this._didOutputTextWebGLMessage) {
                this._didOutputTextWebGLMessage = true;
                console.error('textOutput() does not yet work in WebGL mode.');
            }
            return;
        }
        //if html structure is not there yet
        if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
            return;
        }
        let current = this._accessibleOutputs[idT];
        //create shape list
        let innerList = _shapeList(idT, this.ingredients.shapes);
        //create output summary
        let innerSummary = _textSummary(innerList.numShapes, this.ingredients.colors.background, this.width, this.height);
        //create shape details
        let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);
        //if it is different from current summary
        if (innerSummary !== current.summary.innerHTML) {
            //update
            current.summary.innerHTML = innerSummary;
        }
        //if it is different from current shape list
        if (innerList.listShapes !== current.list.innerHTML) {
            //update
            current.list.innerHTML = innerList.listShapes;
        }
        //if it is different from current shape details
        if (innerShapeDetails !== current.shapeDetails.innerHTML) {
            //update
            current.shapeDetails.innerHTML = innerShapeDetails;
        }
        this._accessibleOutputs[idT] = current;
    };
    //Builds textOutput summary
    function _textSummary(numShapes, background, width, height) {
        let text = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;
        if (numShapes === 1) {
            text = `${text} shape:`;
        } else {
            text = `${text} ${numShapes} shapes:`;
        }
        return text;
    }
    //Builds textOutput table with shape details
    function _shapeDetails(idT, ingredients) {
        let shapeDetails = '';
        let shapeNumber = 0;
        //goes trhough every shape type in ingredients
        for(let x in ingredients){
            //and for every shape
            for(let y in ingredients[x]){
                //it creates a table row
                let row = `<tr id="${idT}shape${shapeNumber}"><th>${ingredients[x][y].color} ${x}</th>`;
                if (x === 'line') {
                    row = row + `<td>location = ${ingredients[x][y].pos}</td><td>length = ${ingredients[x][y].length} pixels</td></tr>`;
                } else {
                    row = row + `<td>location = ${ingredients[x][y].pos}</td>`;
                    if (x !== 'point') {
                        row = row + `<td> area = ${ingredients[x][y].area}%</td>`;
                    }
                    row = row + '</tr>';
                }
                shapeDetails = shapeDetails + row;
                shapeNumber++;
            }
        }
        return shapeDetails;
    }
    //Builds textOutput shape list
    function _shapeList(idT, ingredients) {
        let shapeList = '';
        let shapeNumber = 0;
        //goes trhough every shape type in ingredients
        for(let x in ingredients){
            for(let y in ingredients[x]){
                //it creates a line in a list
                let _line = `<li><a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
                if (x === 'line') {
                    _line = _line + `, ${ingredients[x][y].pos}, ${ingredients[x][y].length} pixels long.</li>`;
                } else {
                    _line = _line + `, at ${ingredients[x][y].pos}`;
                    if (x !== 'point') {
                        _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;
                    }
                    _line = _line + '.</li>';
                }
                shapeList = shapeList + _line;
                shapeNumber++;
            }
        }
        return {
            numShapes: shapeNumber,
            listShapes: shapeList
        };
    }
}
if (typeof p5 !== 'undefined') {
    textOutput(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/accessibility/outputs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>outputs
]);
/**
 * @module Environment
 * @submodule Environment
 * @for p5
 * @requires core
 */ function outputs(p51, fn) {
    /**
   * Creates a screen reader-accessible description of shapes on the canvas.
   *
   * `textOutput()` adds a general description, list of shapes, and
   * table of shapes to the web page. The general description includes the
   * canvas size, canvas color, and number of shapes. For example,
   * `Your output is a, 100 by 100 pixels, gray canvas containing the following 2 shapes:`.
   *
   * A list of shapes follows the general description. The list describes the
   * color, location, and area of each shape. For example,
   * `a red circle at middle covering 3% of the canvas`. Each shape can be
   * selected to get more details.
   *
   * `textOutput()` uses its table of shapes as a list. The table describes the
   * shape, color, location, coordinates and area. For example,
   * `red circle location = middle area = 3%`. This is different from
   * <a href="#/p5/gridOutput">gridOutput()</a>, which uses its table as a grid.
   *
   * The `display` parameter is optional. It determines how the description is
   * displayed. If `LABEL` is passed, as in `textOutput(LABEL)`, the description
   * will be visible in a div element next to the canvas. Using `LABEL` creates
   * unhelpful duplicates for screen readers. Only use `LABEL` during
   * development. If `FALLBACK` is passed, as in `textOutput(FALLBACK)`, the
   * description will only be visible to screen readers. This is the default
   * mode.
   *
   * Read
   * <a href="/learn/accessible-labels.html">Writing accessible canvas descriptions</a>
   * to learn more about making sketches accessible.
   *
   * @method textOutput
   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Add the text description.
   *   textOutput();
   *
   *   // Draw a couple of shapes.
   *   background(200);
   *   fill(255, 0, 0);
   *   circle(20, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle and a blue square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Add the text description and
   *   // display it for debugging.
   *   textOutput(LABEL);
   *
   *   // Draw a couple of shapes.
   *   background(200);
   *   fill(255, 0, 0);
   *   circle(20, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle and a blue square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup(){
   *  createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   // Add the text description.
   *   textOutput();
   *
   *   // Draw a moving circle.
   *   background(200);
   *   let x = frameCount * 0.1;
   *   fill(255, 0, 0);
   *   circle(x, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle moves from left to right above a blue square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup(){
   *  createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   // Add the text description and
   *   // display it for debugging.
   *   textOutput(LABEL);
   *
   *   // Draw a moving circle.
   *   background(200);
   *   let x = frameCount * 0.1;
   *   fill(255, 0, 0);
   *   circle(x, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle moves from left to right above a blue square.');
   * }
   * </code>
   * </div>
   */ fn.textOutput = function(display) {
        // p5._validateParameters('textOutput', arguments);
        //if textOutput is already true
        if (this._accessibleOutputs.text) {
            return;
        } else {
            //make textOutput true
            this._accessibleOutputs.text = true;
            //create output for fallback
            this._createOutput('textOutput', 'Fallback');
            if (display === this.LABEL) {
                //make textOutput label true
                this._accessibleOutputs.textLabel = true;
                //create output for label
                this._createOutput('textOutput', 'Label');
            }
        }
    };
    /**
   * Creates a screen reader-accessible description of shapes on the canvas.
   *
   * `gridOutput()` adds a general description, table of shapes, and list of
   * shapes to the web page. The general description includes the canvas size,
   * canvas color, and number of shapes. For example,
   * `gray canvas, 100 by 100 pixels, contains 2 shapes:  1 circle 1 square`.
   *
   * `gridOutput()` uses its table of shapes as a grid. Each shape in the grid
   * is placed in a cell whose row and column correspond to the shape's location
   * on the canvas. The grid cells describe the color and type of shape at that
   * location. For example, `red circle`. These descriptions can be selected
   * individually to get more details. This is different from
   * <a href="#/p5/textOutput">textOutput()</a>, which uses its table as a list.
   *
   * A list of shapes follows the table. The list describes the color, type,
   * location, and area of each shape. For example,
   * `red circle, location = middle, area = 3 %`.
   *
   * The `display` parameter is optional. It determines how the description is
   * displayed. If `LABEL` is passed, as in `gridOutput(LABEL)`, the description
   * will be visible in a div element next to the canvas. Using `LABEL` creates
   * unhelpful duplicates for screen readers. Only use `LABEL` during
   * development. If `FALLBACK` is passed, as in `gridOutput(FALLBACK)`, the
   * description will only be visible to screen readers. This is the default
   * mode.
   *
   * Read
   * <a href="/learn/accessible-labels.html">Writing accessible canvas descriptions</a>
   * to learn more about making sketches accessible.
   *
   * @method gridOutput
   * @param  {(FALLBACK|LABEL)} [display] either FALLBACK or LABEL.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Add the grid description.
   *   gridOutput();
   *
   *   // Draw a couple of shapes.
   *   background(200);
   *   fill(255, 0, 0);
   *   circle(20, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle and a blue square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Add the grid description and
   *   // display it for debugging.
   *   gridOutput(LABEL);
   *
   *   // Draw a couple of shapes.
   *   background(200);
   *   fill(255, 0, 0);
   *   circle(20, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle and a blue square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup() {
   *   createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   // Add the grid description.
   *   gridOutput();
   *
   *   // Draw a moving circle.
   *   background(200);
   *   let x = frameCount * 0.1;
   *   fill(255, 0, 0);
   *   circle(x, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle moves from left to right above a blue square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   *
   * function setup(){
   *  createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   // Add the grid description and
   *   // display it for debugging.
   *   gridOutput(LABEL);
   *
   *   // Draw a moving circle.
   *   background(200);
   *   let x = frameCount * 0.1;
   *   fill(255, 0, 0);
   *   circle(x, 20, 20);
   *   fill(0, 0, 255);
   *   square(50, 50, 50);
   *
   *   // Add a general description of the canvas.
   *   describe('A red circle moves from left to right above a blue square.');
   * }
   * </code>
   * </div>
   */ fn.gridOutput = function(display) {
        // p5._validateParameters('gridOutput', arguments);
        //if gridOutput is already true
        if (this._accessibleOutputs.grid) {
            return;
        } else {
            //make gridOutput true
            this._accessibleOutputs.grid = true;
            //create output for fallback
            this._createOutput('gridOutput', 'Fallback');
            if (display === this.LABEL) {
                //make gridOutput label true
                this._accessibleOutputs.gridLabel = true;
                //create output for label
                this._createOutput('gridOutput', 'Label');
            }
        }
    };
    //helper function returns true when accessible outputs are true
    fn._addAccsOutput = function() {
        //if there are no accessible outputs create object with all false
        if (!this._accessibleOutputs) {
            this._accessibleOutputs = {
                text: false,
                grid: false,
                textLabel: false,
                gridLabel: false
            };
        }
        return this._accessibleOutputs.grid || this._accessibleOutputs.text;
    };
    //helper function that creates html structure for accessible outputs
    fn._createOutput = function(type, display) {
        let cnvId = this.canvas.id;
        //if there are no ingredients create object. this object stores data for the outputs
        if (!this.ingredients) {
            this.ingredients = {
                shapes: {},
                colors: {
                    background: 'white',
                    fill: 'white',
                    stroke: 'black'
                },
                pShapes: '',
                pBackground: ''
            };
        }
        //if there is no dummyDOM create it
        if (!this.dummyDOM) {
            this.dummyDOM = document.getElementById(cnvId).parentNode;
        }
        let cIdT, container, inner;
        let query = '';
        if (display === 'Fallback') {
            cIdT = cnvId + type;
            container = cnvId + 'accessibleOutput';
            if (!this.dummyDOM.querySelector(`#${container}`)) {
                //if there is no canvas description (see describe() and describeElement())
                if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {
                    //create html structure inside of canvas
                    this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`;
                } else {
                    //create html structure after canvas description container
                    this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML('afterend', `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`);
                }
            }
        } else if (display === 'Label') {
            query = display;
            cIdT = cnvId + type + display;
            container = cnvId + 'accessibleOutput' + display;
            if (!this.dummyDOM.querySelector(`#${container}`)) {
                //if there is no canvas description label (see describe() and describeElement())
                if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {
                    //create html structure adjacent to canvas
                    this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML('afterend', `<div id="${container}"></div>`);
                } else {
                    //create html structure after canvas label
                    this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML('afterend', `<div id="${container}"></div>`);
                }
            }
        }
        //create an object to store the latest output. this object is used in _updateTextOutput() and _updateGridOutput()
        this._accessibleOutputs[cIdT] = {};
        if (type === 'textOutput') {
            query = `#${cnvId}gridOutput${query}`; //query is used to check if gridOutput already exists
            inner = `<div id="${cIdT}">Text Output<div id="${cIdT}Summary" aria-label="text output summary"><p id="${cIdT}_summary"></p><ul id="${cIdT}_list"></ul></div><table id="${cIdT}_shapeDetails" summary="text output shape details"></table></div>`;
            //if gridOutput already exists
            if (this.dummyDOM.querySelector(query)) {
                //create textOutput before gridOutput
                this.dummyDOM.querySelector(query).insertAdjacentHTML('beforebegin', inner);
            } else {
                //create output inside of container
                this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
            }
            //store output html elements
            this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(`#${cIdT}_list`);
        } else if (type === 'gridOutput') {
            query = `#${cnvId}textOutput${query}`; //query is used to check if textOutput already exists
            inner = `<div id="${cIdT}">Grid Output<p id="${cIdT}_summary" aria-label="grid output summary"><table id="${cIdT}_map" summary="grid output content"></table><ul id="${cIdT}_shapeDetails" aria-label="grid output shape details"></ul></div>`;
            //if textOutput already exists
            if (this.dummyDOM.querySelector(query)) {
                //create gridOutput after textOutput
                this.dummyDOM.querySelector(query).insertAdjacentHTML('afterend', inner);
            } else {
                //create output inside of container
                this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
            }
            //store output html elements
            this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(`#${cIdT}_map`);
        }
        this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(`#${cIdT}_shapeDetails`);
        this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(`#${cIdT}_summary`);
    };
    //this function is called at the end of setup and draw if using
    //accessibleOutputs and calls update functions of outputs
    fn._updateAccsOutput = function() {
        let cnvId = this.canvas.id;
        //if the shapes are not the same as before
        if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {
            //save current shapes as string in pShapes
            this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
            if (this._accessibleOutputs.text) {
                this._updateTextOutput(cnvId + 'textOutput');
            }
            if (this._accessibleOutputs.grid) {
                this._updateGridOutput(cnvId + 'gridOutput');
            }
            if (this._accessibleOutputs.textLabel) {
                this._updateTextOutput(cnvId + 'textOutputLabel');
            }
            if (this._accessibleOutputs.gridLabel) {
                this._updateGridOutput(cnvId + 'gridOutputLabel');
            }
        }
    };
    //helper function that resets all ingredients when background is called
    //and saves background color name
    fn._accsBackground = function(args) {
        //save current shapes as string in pShapes
        this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
        this.ingredients.pBackground = this.ingredients.colors.background;
        //empty shapes JSON
        this.ingredients.shapes = {};
        //update background different
        if (this.ingredients.colors.backgroundRGBA !== args) {
            this.ingredients.colors.backgroundRGBA = args;
            this.ingredients.colors.background = this._rgbColorName(args);
        }
    };
    //helper function that gets fill and stroke of shapes
    fn._accsCanvasColors = function(f, args) {
        if (f === 'fill') {
            //update fill different
            if (this.ingredients.colors.fillRGBA !== args) {
                this.ingredients.colors.fillRGBA = args;
                this.ingredients.colors.fill = this._rgbColorName(args);
            }
        } else if (f === 'stroke') {
            //update stroke if different
            if (this.ingredients.colors.strokeRGBA !== args) {
                this.ingredients.colors.strokeRGBA = args;
                this.ingredients.colors.stroke = this._rgbColorName(args);
            }
        }
    };
    //builds ingredients.shapes used for building outputs
    fn._accsOutput = function(f, args) {
        if (f === 'ellipse' && args[2] === args[3]) {
            f = 'circle';
        } else if (f === 'rectangle' && args[2] === args[3]) {
            f = 'square';
        }
        let include = {};
        let add = true;
        let middle = _getMiddle(f, args);
        if (f === 'line') {
            //make color stroke
            include.color = this.ingredients.colors.stroke;
            //get lenght
            include.length = Math.round(Math.hypot(args[2] - args[0], args[3] - args[1]));
            //get position of end points
            let p1 = this._getPos(args[0], [
                1
            ]);
            let p2 = this._getPos(args[2], [
                3
            ]);
            include.loc = _canvasLocator(middle, this.width, this.height);
            if (p1 === p2) {
                include.pos = `at ${p1}`;
            } else {
                include.pos = `from ${p1} to ${p2}`;
            }
        } else {
            if (f === 'point') {
                //make color stroke
                include.color = this.ingredients.colors.stroke;
            } else {
                //make color fill
                include.color = this.ingredients.colors.fill;
                //get area of shape
                include.area = this._getArea(f, args);
            }
            //get middle of shapes
            //calculate position using middle of shape
            include.pos = this._getPos(...middle);
            //calculate location using middle of shape
            include.loc = _canvasLocator(middle, this.width, this.height);
        }
        //if it is the first time this shape is created
        if (!this.ingredients.shapes[f]) {
            this.ingredients.shapes[f] = [
                include
            ];
        //if other shapes of this type have been created
        } else {
            //for every shape of this type
            for(let y in this.ingredients.shapes[f]){
                //compare it with current shape and if it already exists make add false
                if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) {
                    add = false;
                }
            }
            //add shape by pushing it to the end
            if (add === true) {
                this.ingredients.shapes[f].push(include);
            }
        }
    };
    //gets middle point / centroid of shape
    function _getMiddle(f, args) {
        let x, y;
        if (f === 'rectangle' || f === 'ellipse' || f === 'arc' || f === 'circle' || f === 'square') {
            x = Math.round(args[0] + args[2] / 2);
            y = Math.round(args[1] + args[3] / 2);
        } else if (f === 'triangle') {
            x = (args[0] + args[2] + args[4]) / 3;
            y = (args[1] + args[3] + args[5]) / 3;
        } else if (f === 'quadrilateral') {
            x = (args[0] + args[2] + args[4] + args[6]) / 4;
            y = (args[1] + args[3] + args[5] + args[7]) / 4;
        } else if (f === 'line') {
            x = (args[0] + args[2]) / 2;
            y = (args[1] + args[3]) / 2;
        } else {
            x = args[0];
            y = args[1];
        }
        return [
            x,
            y
        ];
    }
    //gets position of shape in the canvas
    fn._getPos = function(x, y) {
        const { x: transformedX, y: transformedY } = this.worldToScreen(new p51.Vector(x, y));
        const canvasWidth = this.width;
        const canvasHeight = this.height;
        if (transformedX < 0.4 * canvasWidth) {
            if (transformedY < 0.4 * canvasHeight) {
                return 'top left';
            } else if (transformedY > 0.6 * canvasHeight) {
                return 'bottom left';
            } else {
                return 'mid left';
            }
        } else if (transformedX > 0.6 * canvasWidth) {
            if (transformedY < 0.4 * canvasHeight) {
                return 'top right';
            } else if (transformedY > 0.6 * canvasHeight) {
                return 'bottom right';
            } else {
                return 'mid right';
            }
        } else {
            if (transformedY < 0.4 * canvasHeight) {
                return 'top middle';
            } else if (transformedY > 0.6 * canvasHeight) {
                return 'bottom middle';
            } else {
                return 'middle';
            }
        }
    };
    //locates shape in a 10*10 grid
    function _canvasLocator(args, canvasWidth, canvasHeight) {
        const noRows = 10;
        const noCols = 10;
        let locX = Math.floor(args[0] / canvasWidth * noRows);
        let locY = Math.floor(args[1] / canvasHeight * noCols);
        if (locX === noRows) {
            locX = locX - 1;
        }
        if (locY === noCols) {
            locY = locY - 1;
        }
        return {
            locX,
            locY
        };
    }
    //calculates area of shape
    fn._getArea = function(objectType, shapeArgs) {
        let objectArea = 0;
        if (objectType === 'arc') {
            // area of full ellipse = PI * horizontal radius * vertical radius.
            // therefore, area of arc = difference bet. arc's start and end radians * horizontal radius * vertical radius.
            // the below expression is adjusted for negative values and differences in arc's start and end radians over PI*2
            const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
            objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;
            if (shapeArgs[6] === 'open' || shapeArgs[6] === 'chord') {
                // when the arc's mode is OPEN or CHORD, we need to account for the area of the triangle that is formed to close the arc
                // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ) )/2
                const Ax = shapeArgs[0];
                const Ay = shapeArgs[1];
                const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);
                const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);
                const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);
                const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);
                const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;
                if (arcSizeInRadians > Math.PI) {
                    objectArea = objectArea + areaOfExtraTriangle;
                } else {
                    objectArea = objectArea - areaOfExtraTriangle;
                }
            }
        } else if (objectType === 'ellipse' || objectType === 'circle') {
            objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;
        } else if (objectType === 'line') {
            objectArea = 0;
        } else if (objectType === 'point') {
            objectArea = 0;
        } else if (objectType === 'quadrilateral') {
            // ((x4+x1)*(y4-y1)+(x1+x2)*(y1-y2)+(x2+x3)*(y2-y3)+(x3+x4)*(y3-y4))/2
            objectArea = Math.abs((shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])) / 2;
        } else if (objectType === 'rectangle' || objectType === 'square') {
            objectArea = shapeArgs[2] * shapeArgs[3];
        } else if (objectType === 'triangle') {
            objectArea = Math.abs(shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])) / 2;
        // (Ax( By −  Cy) + Bx(Cy − Ay) + Cx(Ay − By ))/2
        }
        //  Store the positions of the canvas corners
        const canvasWidth = this.width * this._renderer._pixelDensity;
        const canvasHeight = this.height * this._renderer._pixelDensity;
        const canvasCorners = [
            new DOMPoint(0, 0),
            new DOMPoint(canvasWidth, 0),
            new DOMPoint(canvasWidth, canvasHeight),
            new DOMPoint(0, canvasHeight)
        ];
        //  Apply the inverse of the current transformations to the canvas corners
        const currentTransform = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform();
        const invertedTransform = currentTransform.inverse();
        const tc = canvasCorners.map((corner)=>corner.matrixTransform(invertedTransform));
        /*  Use same shoelace formula used for quad area (above) to calculate
    the area of the canvas with inverted transformation applied */ const transformedCanvasArea = Math.abs((tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)) / 2;
        /*  Compare area of shape (minus transformations) to area of canvas
    with inverted transformation applied.
    Return percentage  */ const untransformedArea = Math.round(objectArea * 100 / transformedCanvasArea);
        return untransformedArea;
    };
}
if (typeof p5 !== 'undefined') {
    outputs(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/accessibility/color_namer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>colorNamer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/structure.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/environment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Environment
 * @submodule Environment
 * @for p5
 * @requires core
 */ function colorNamer(p51, fn) {
    //stores the original hsb values
    let originalHSB;
    //stores values for color name exceptions
    const colorExceptions = [
        {
            h: 0,
            s: 0,
            b: 0.8275,
            name: 'gray'
        },
        {
            h: 0,
            s: 0,
            b: 0.8627,
            name: 'gray'
        },
        {
            h: 0,
            s: 0,
            b: 0.7529,
            name: 'gray'
        },
        {
            h: 0.0167,
            s: 0.1176,
            b: 1,
            name: 'light pink'
        }
    ];
    //stores values for color names
    const colorLookUp = [
        {
            h: 0,
            s: 0,
            b: 0,
            name: 'black'
        },
        {
            h: 0,
            s: 0,
            b: 0.5,
            name: 'gray'
        },
        {
            h: 0,
            s: 0,
            b: 1,
            name: 'white'
        },
        {
            h: 0,
            s: 0.5,
            b: 0.5,
            name: 'dark maroon'
        },
        {
            h: 0,
            s: 0.5,
            b: 1,
            name: 'salmon pink'
        },
        {
            h: 0,
            s: 1,
            b: 0,
            name: 'black'
        },
        {
            h: 0,
            s: 1,
            b: 0.5,
            name: 'dark red'
        },
        {
            h: 0,
            s: 1,
            b: 1,
            name: 'red'
        },
        {
            h: 5,
            s: 0,
            b: 1,
            name: 'very light peach'
        },
        {
            h: 5,
            s: 0.5,
            b: 0.5,
            name: 'brown'
        },
        {
            h: 5,
            s: 0.5,
            b: 1,
            name: 'peach'
        },
        {
            h: 5,
            s: 1,
            b: 0.5,
            name: 'brick red'
        },
        {
            h: 5,
            s: 1,
            b: 1,
            name: 'crimson'
        },
        {
            h: 10,
            s: 0,
            b: 1,
            name: 'light peach'
        },
        {
            h: 10,
            s: 0.5,
            b: 0.5,
            name: 'brown'
        },
        {
            h: 10,
            s: 0.5,
            b: 1,
            name: 'light orange'
        },
        {
            h: 10,
            s: 1,
            b: 0.5,
            name: 'brown'
        },
        {
            h: 10,
            s: 1,
            b: 1,
            name: 'orange'
        },
        {
            h: 15,
            s: 0,
            b: 1,
            name: 'very light yellow'
        },
        {
            h: 15,
            s: 0.5,
            b: 0.5,
            name: 'olive green'
        },
        {
            h: 15,
            s: 0.5,
            b: 1,
            name: 'light yellow'
        },
        {
            h: 15,
            s: 1,
            b: 0,
            name: 'dark olive green'
        },
        {
            h: 15,
            s: 1,
            b: 0.5,
            name: 'olive green'
        },
        {
            h: 15,
            s: 1,
            b: 1,
            name: 'yellow'
        },
        {
            h: 20,
            s: 0,
            b: 1,
            name: 'very light yellow'
        },
        {
            h: 20,
            s: 0.5,
            b: 0.5,
            name: 'olive green'
        },
        {
            h: 20,
            s: 0.5,
            b: 1,
            name: 'light yellow green'
        },
        {
            h: 20,
            s: 1,
            b: 0,
            name: 'dark olive green'
        },
        {
            h: 20,
            s: 1,
            b: 0.5,
            name: 'dark yellow green'
        },
        {
            h: 20,
            s: 1,
            b: 1,
            name: 'yellow green'
        },
        {
            h: 25,
            s: 0.5,
            b: 0.5,
            name: 'dark yellow green'
        },
        {
            h: 25,
            s: 0.5,
            b: 1,
            name: 'light green'
        },
        {
            h: 25,
            s: 1,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 25,
            s: 1,
            b: 1,
            name: 'green'
        },
        {
            h: 30,
            s: 0.5,
            b: 1,
            name: 'light green'
        },
        {
            h: 30,
            s: 1,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 30,
            s: 1,
            b: 1,
            name: 'green'
        },
        {
            h: 35,
            s: 0,
            b: 0.5,
            name: 'light green'
        },
        {
            h: 35,
            s: 0,
            b: 1,
            name: 'very light green'
        },
        {
            h: 35,
            s: 0.5,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 35,
            s: 0.5,
            b: 1,
            name: 'light green'
        },
        {
            h: 35,
            s: 1,
            b: 0,
            name: 'very dark green'
        },
        {
            h: 35,
            s: 1,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 35,
            s: 1,
            b: 1,
            name: 'green'
        },
        {
            h: 40,
            s: 0,
            b: 1,
            name: 'very light green'
        },
        {
            h: 40,
            s: 0.5,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 40,
            s: 0.5,
            b: 1,
            name: 'light green'
        },
        {
            h: 40,
            s: 1,
            b: 0.5,
            name: 'dark green'
        },
        {
            h: 40,
            s: 1,
            b: 1,
            name: 'green'
        },
        {
            h: 45,
            s: 0.5,
            b: 1,
            name: 'light turquoise'
        },
        {
            h: 45,
            s: 1,
            b: 0.5,
            name: 'dark turquoise'
        },
        {
            h: 45,
            s: 1,
            b: 1,
            name: 'turquoise'
        },
        {
            h: 50,
            s: 0,
            b: 1,
            name: 'light sky blue'
        },
        {
            h: 50,
            s: 0.5,
            b: 0.5,
            name: 'dark cyan'
        },
        {
            h: 50,
            s: 0.5,
            b: 1,
            name: 'light cyan'
        },
        {
            h: 50,
            s: 1,
            b: 0.5,
            name: 'dark cyan'
        },
        {
            h: 50,
            s: 1,
            b: 1,
            name: 'cyan'
        },
        {
            h: 55,
            s: 0,
            b: 1,
            name: 'light sky blue'
        },
        {
            h: 55,
            s: 0.5,
            b: 1,
            name: 'light sky blue'
        },
        {
            h: 55,
            s: 1,
            b: 0.5,
            name: 'dark blue'
        },
        {
            h: 55,
            s: 1,
            b: 1,
            name: 'sky blue'
        },
        {
            h: 60,
            s: 0,
            b: 0.5,
            name: 'gray'
        },
        {
            h: 60,
            s: 0,
            b: 1,
            name: 'very light blue'
        },
        {
            h: 60,
            s: 0.5,
            b: 0.5,
            name: 'blue'
        },
        {
            h: 60,
            s: 0.5,
            b: 1,
            name: 'light blue'
        },
        {
            h: 60,
            s: 1,
            b: 0.5,
            name: 'navy blue'
        },
        {
            h: 60,
            s: 1,
            b: 1,
            name: 'blue'
        },
        {
            h: 65,
            s: 0,
            b: 1,
            name: 'lavender'
        },
        {
            h: 65,
            s: 0.5,
            b: 0.5,
            name: 'navy blue'
        },
        {
            h: 65,
            s: 0.5,
            b: 1,
            name: 'light purple'
        },
        {
            h: 65,
            s: 1,
            b: 0.5,
            name: 'dark navy blue'
        },
        {
            h: 65,
            s: 1,
            b: 1,
            name: 'blue'
        },
        {
            h: 70,
            s: 0,
            b: 1,
            name: 'lavender'
        },
        {
            h: 70,
            s: 0.5,
            b: 0.5,
            name: 'navy blue'
        },
        {
            h: 70,
            s: 0.5,
            b: 1,
            name: 'lavender blue'
        },
        {
            h: 70,
            s: 1,
            b: 0.5,
            name: 'dark navy blue'
        },
        {
            h: 70,
            s: 1,
            b: 1,
            name: 'blue'
        },
        {
            h: 75,
            s: 0.5,
            b: 1,
            name: 'lavender'
        },
        {
            h: 75,
            s: 1,
            b: 0.5,
            name: 'dark purple'
        },
        {
            h: 75,
            s: 1,
            b: 1,
            name: 'purple'
        },
        {
            h: 80,
            s: 0.5,
            b: 1,
            name: 'pinkish purple'
        },
        {
            h: 80,
            s: 1,
            b: 0.5,
            name: 'dark purple'
        },
        {
            h: 80,
            s: 1,
            b: 1,
            name: 'purple'
        },
        {
            h: 85,
            s: 0,
            b: 1,
            name: 'light pink'
        },
        {
            h: 85,
            s: 0.5,
            b: 0.5,
            name: 'purple'
        },
        {
            h: 85,
            s: 0.5,
            b: 1,
            name: 'light fuchsia'
        },
        {
            h: 85,
            s: 1,
            b: 0.5,
            name: 'dark fuchsia'
        },
        {
            h: 85,
            s: 1,
            b: 1,
            name: 'fuchsia'
        },
        {
            h: 90,
            s: 0.5,
            b: 0.5,
            name: 'dark fuchsia'
        },
        {
            h: 90,
            s: 0.5,
            b: 1,
            name: 'hot pink'
        },
        {
            h: 90,
            s: 1,
            b: 0.5,
            name: 'dark fuchsia'
        },
        {
            h: 90,
            s: 1,
            b: 1,
            name: 'fuchsia'
        },
        {
            h: 95,
            s: 0,
            b: 1,
            name: 'pink'
        },
        {
            h: 95,
            s: 0.5,
            b: 1,
            name: 'light pink'
        },
        {
            h: 95,
            s: 1,
            b: 0.5,
            name: 'dark magenta'
        },
        {
            h: 95,
            s: 1,
            b: 1,
            name: 'magenta'
        }
    ];
    //returns text with color name
    function _calculateColor(hsb) {
        let colortext;
        //round hue
        if (hsb[0] !== 0) {
            hsb[0] = Math.round(hsb[0] * 100);
            let hue = hsb[0].toString().split('');
            const last = hue.length - 1;
            hue[last] = parseInt(hue[last]);
            //if last digit of hue is < 2.5 make it 0
            if (hue[last] < 2.5) {
                hue[last] = 0;
            //if last digit of hue is >= 2.5 and less than 7.5 make it 5
            } else if (hue[last] >= 2.5 && hue[last] < 7.5) {
                hue[last] = 5;
            }
            //if hue only has two digits
            if (hue.length === 2) {
                hue[0] = parseInt(hue[0]);
                //if last is greater than 7.5
                if (hue[last] >= 7.5) {
                    //add one to the tens
                    hue[last] = 0;
                    hue[0] = hue[0] + 1;
                }
                hsb[0] = hue[0] * 10 + hue[1];
            } else {
                if (hue[last] >= 7.5) {
                    hsb[0] = 10;
                } else {
                    hsb[0] = hue[last];
                }
            }
        }
        //map brightness from 0 to 1
        hsb[2] = hsb[2] / 255;
        //round saturation and brightness
        for(let i = hsb.length - 1; i >= 1; i--){
            if (hsb[i] <= 0.25) {
                hsb[i] = 0;
            } else if (hsb[i] > 0.25 && hsb[i] < 0.75) {
                hsb[i] = 0.5;
            } else {
                hsb[i] = 1;
            }
        }
        //after rounding, if the values are hue 0, saturation 0 and brightness 1
        //look at color exceptions which includes several tones from white to gray
        if (hsb[0] === 0 && hsb[1] === 0 && hsb[2] === 1) {
            //round original hsb values
            for(let i = 2; i >= 0; i--){
                originalHSB[i] = Math.round(originalHSB[i] * 10000) / 10000;
            }
            //compare with the values in the colorExceptions array
            for(let e = 0; e < colorExceptions.length; e++){
                if (colorExceptions[e].h === originalHSB[0] && colorExceptions[e].s === originalHSB[1] && colorExceptions[e].b === originalHSB[2]) {
                    colortext = colorExceptions[e].name;
                    break;
                } else {
                    //if there is no match return white
                    colortext = 'white';
                }
            }
        } else {
            //otherwise, compare with values in colorLookUp
            for(let i = 0; i < colorLookUp.length; i++){
                if (colorLookUp[i].h === hsb[0] && colorLookUp[i].s === hsb[1] && colorLookUp[i].b === hsb[2]) {
                    colortext = colorLookUp[i].name;
                    break;
                }
            }
        }
        return colortext;
    }
    //gets rgba and returs a color name
    fn._rgbColorName = function(arg) {
        //conversts rgba to hsb
        let hsb = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]._rgbaToHSBA(arg);
        //stores hsb in global variable
        originalHSB = hsb;
        //calculate color name
        return _calculateColor([
            hsb[0],
            hsb[1],
            hsb[2]
        ]);
    };
}
if (typeof p5 !== 'undefined') {
    colorNamer(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/accessibility/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>accessibility
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$describe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/describe.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$gridOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/gridOutput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$textOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/textOutput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$outputs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/outputs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$color_namer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/color_namer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/structure.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/environment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function accessibility(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$describe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$gridOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$textOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$outputs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$color_namer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/data/local_storage.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>storage
]);
/**
 * @module Data
 * @submodule LocalStorage
 * @requires core
 *
 * This module defines the p5 methods for working with local storage
 */ function storage(p51, fn) {
    /**
   * Stores a value in the web browser's local storage.
   *
   * Web browsers can save small amounts of data using the built-in
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank">localStorage object</a>.
   * Data stored in `localStorage` can be retrieved at any point, even after
   * refreshing a page or restarting the browser. Data are stored as key-value
   * pairs.
   *
   * `storeItem()` makes it easy to store values in `localStorage` and
   * <a href="#/p5/getItem">getItem()</a> makes it easy to retrieve them.
   *
   * The first parameter, `key`, is the name of the value to be stored as a
   * string.
   *
   * The second parameter, `value`, is the value to be stored. Values can have
   * any type.
   *
   * Note: Sensitive data such as passwords or personal information shouldn't be
   * stored in `localStorage`.
   *
   * @method storeItem
   * @for p5
   * @param {String} key name of the value.
   * @param {String|Number|Boolean|Object|Array} value value to be stored.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Store the player's name.
   *   storeItem('name', 'Feist');
   *
   *   // Store the player's score.
   *   storeItem('score', 1234);
   *
   *   describe('The text "Feist: 1234" written in black on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Retrieve the name.
   *   let name = getItem('name');
   *
   *   // Retrieve the score.
   *   let score = getItem('score');
   *
   *   // Display the score.
   *   text(`${name}: ${score}`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create an object.
   *   let p = { x: 50, y: 50 };
   *
   *   // Store the object.
   *   storeItem('position', p);
   *
   *   describe('A white circle on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Retrieve the object.
   *   let p = getItem('position');
   *
   *   // Draw the circle.
   *   circle(p.x, p.y, 30);
   * }
   * </code>
   * </div>
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Color object.
   *   let c = color('deeppink');
   *
   *   // Store the object.
   *   storeItem('color', c);
   *
   *   describe('A pink circle on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Retrieve the object.
   *   let c = getItem('color');
   *
   *   // Style the circle.
   *   fill(c);
   *
   *   // Draw the circle.
   *   circle(50, 50, 30);
   * }
   * </code>
   * </div>
   */ fn.storeItem = function(key, value) {
        if (typeof key !== 'string') {
            console.log(`The argument that you passed to storeItem() - ${key} is not a string.`);
        }
        if (key.endsWith('p5TypeID')) {
            console.log(`The argument that you passed to storeItem() - ${key} must not end with 'p5TypeID'.`);
        }
        if (typeof value === 'undefined') {
            console.log('You cannot store undefined variables using storeItem().');
        }
        let type = typeof value;
        switch(type){
            case 'number':
            case 'boolean':
                value = value.toString();
                break;
            case 'object':
                if (value instanceof p51.Color) {
                    type = 'p5.Color';
                    value = value.toString();
                } else if (value instanceof p51.Vector) {
                    type = 'p5.Vector';
                    const coord = value.values;
                    value = coord;
                }
                value = JSON.stringify(value);
                break;
        }
        localStorage.setItem(key, value);
        const typeKey = `${key}p5TypeID`;
        localStorage.setItem(typeKey, type);
    };
    /**
   * Returns a value in the web browser's local storage.
   *
   * Web browsers can save small amounts of data using the built-in
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank">localStorage object</a>.
   * Data stored in `localStorage` can be retrieved at any point, even after
   * refreshing a page or restarting the browser. Data are stored as key-value
   * pairs.
   *
   * <a href="#/p5/storeItem">storeItem()</a> makes it easy to store values in
   * `localStorage` and `getItem()` makes it easy to retrieve them.
   *
   * The first parameter, `key`, is the name of the value to be stored as a
   * string.
   *
   * The second parameter, `value`, is the value to be retrieved a string. For
   * example, calling `getItem('size')` retrieves the value with the key `size`.
   *
   * Note: Sensitive data such as passwords or personal information shouldn't be
   * stored in `localStorage`.
   *
   * @method getItem
   * @for p5
   * @param {String} key name of the value.
   * @return {String|Number|Boolean|Object|Array} stored item.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Store the player's name.
   *   storeItem('name', 'Feist');
   *
   *   // Store the player's score.
   *   storeItem('score', 1234);
   *
   *   describe('The text "Feist: 1234" written in black on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Retrieve the name.
   *   let name = getItem('name');
   *
   *   // Retrieve the score.
   *   let score = getItem('score');
   *
   *   // Display the score.
   *   text(`${name}: ${score}`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create an object.
   *   let p = { x: 50, y: 50 };
   *
   *   // Store the object.
   *   storeItem('position', p);
   *
   *   describe('A white circle on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Retrieve the object.
   *   let p = getItem('position');
   *
   *   // Draw the circle.
   *   circle(p.x, p.y, 30);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Color object.
   *   let c = color('deeppink');
   *
   *   // Store the object.
   *   storeItem('color', c);
   *
   *   describe('A pink circle on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Retrieve the object.
   *   let c = getItem('color');
   *
   *   // Style the circle.
   *   fill(c);
   *
   *   // Draw the circle.
   *   circle(50, 50, 30);
   * }
   * </code>
   * </div>
   */ fn.getItem = function(key) {
        let value = localStorage.getItem(key);
        const type = localStorage.getItem(`${key}p5TypeID`);
        if (typeof type === 'undefined') {
            console.log(`Unable to determine type of item stored under ${key}in local storage. Did you save the item with something other than setItem()?`);
        } else if (value !== null) {
            switch(type){
                case 'number':
                    value = parseFloat(value);
                    break;
                case 'boolean':
                    value = value === 'true';
                    break;
                case 'object':
                    value = JSON.parse(value);
                    break;
                case 'p5.Color':
                    value = this.color(JSON.parse(value));
                    break;
                case 'p5.Vector':
                    value = JSON.parse(value);
                    value = this.createVector(...value);
                    break;
            }
        }
        return value;
    };
    /**
   * Removes all items in the web browser's local storage.
   *
   * Web browsers can save small amounts of data using the built-in
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank">localStorage object</a>.
   * Data stored in `localStorage` can be retrieved at any point, even after
   * refreshing a page or restarting the browser. Data are stored as key-value
   * pairs. Calling `clearStorage()` removes all data from `localStorage`.
   *
   * Note: Sensitive data such as passwords or personal information shouldn't be
   * stored in `localStorage`.
   *
   * @method clearStorage
   * @for p5
   *
   * @example
   * <div>
   * <code>
   * // Double-click to clear localStorage.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Store the player's name.
   *   storeItem('name', 'Feist');
   *
   *   // Store the player's score.
   *   storeItem('score', 1234);
   *
   *   describe(
   *     'The text "Feist: 1234" written in black on a gray background. The text "null: null" appears when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Retrieve the name.
   *   let name = getItem('name');
   *
   *   // Retrieve the score.
   *   let score = getItem('score');
   *
   *   // Display the score.
   *   text(`${name}: ${score}`, 50, 50);
   * }
   *
   * // Clear localStorage when the user double-clicks.
   * function doubleClicked() {
   *   clearStorage();
   * }
   * </code>
   * </div>
   */ fn.clearStorage = function() {
        const keys = Object.keys(localStorage);
        keys.forEach((key)=>{
            if (key.endsWith('p5TypeID')) {
                this.removeItem(key.replace('p5TypeID', ''));
            }
        });
    };
    /**
   * Removes an item from the web browser's local storage.
   *
   * Web browsers can save small amounts of data using the built-in
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" target="_blank">localStorage object</a>.
   * Data stored in `localStorage` can be retrieved at any point, even after
   * refreshing a page or restarting the browser. Data are stored as key-value
   * pairs.
   *
   * <a href="#/p5/storeItem">storeItem()</a> makes it easy to store values in
   * `localStorage` and `removeItem()` makes it easy to delete them.
   *
   * The parameter, `key`, is the name of the value to remove as a string. For
   * example, calling `removeItem('size')` removes the item with the key `size`.
   *
   * Note: Sensitive data such as passwords or personal information shouldn't be
   * stored in `localStorage`.
   *
   * @method removeItem
   * @param {String} key name of the value to remove.
   * @for p5
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove an item from localStorage.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Store the player's name.
   *   storeItem('name', 'Feist');
   *
   *   // Store the player's score.
   *   storeItem('score', 1234);
   *
   *   describe(
   *     'The text "Feist: 1234" written in black on a gray background. The text "Feist: null" appears when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Retrieve the name.
   *   let name = getItem('name');
   *
   *   // Retrieve the score.
   *   let score = getItem('score');
   *
   *   // Display the score.
   *   text(`${name}: ${score}`, 50, 50);
   * }
   *
   * // Remove the word from localStorage when the user double-clicks.
   * function doubleClicked() {
   *   removeItem('score');
   * }
   * </code>
   * </div>
   */ fn.removeItem = function(key) {
        if (typeof key !== 'string') {
            console.log(`The argument that you passed to removeItem() - ${key} is not a string.`);
        }
        localStorage.removeItem(key);
        localStorage.removeItem(`${key}p5TypeID`);
    };
}
if (typeof p5 !== 'undefined') {
    storage(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/data/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>data
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$data$2f$local_storage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/data/local_storage.js [app-ssr] (ecmascript)");
;
function data(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$data$2f$local_storage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/events/acceleration.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>acceleration
]);
/**
 * @module Events
 * @submodule Acceleration
 * @for p5
 * @requires core
 * @main Events
 */ function acceleration(p51, fn, lifecycles) {
    lifecycles.presetup = function() {
        const events = [
            'deviceorientation',
            'devicemotion'
        ];
        for (const event of events){
            window.addEventListener(event, this[`_on${event}`].bind(this), {
                passive: false,
                signal: this._removeSignal
            });
        }
    };
    /**
   * The system variable deviceOrientation always contains the orientation of
   * the device. The value of this variable will either be set 'landscape'
   * or 'portrait'. If no data is available it will be set to 'undefined'.
   * either LANDSCAPE or PORTRAIT.
   *
   * @property {(LANDSCAPE|PORTRAIT)} deviceOrientation
   * @readOnly
   */ fn.deviceOrientation = window.innerWidth / window.innerHeight > 1.0 ? 'landscape' : 'portrait';
    /**
   * The system variable accelerationX always contains the acceleration of the
   * device along the x axis. Value is represented as meters per second squared.
   *
   * @property {Number} accelerationX
   * @readOnly
   * @example
   * <div>
   * <code>
   * // Move a touchscreen device to register
   * // acceleration changes.
   * function draw() {
   *   background(220, 50);
   *   fill('magenta');
   *   ellipse(width / 2, height / 2, accelerationX);
   *   describe('Magnitude of device acceleration is displayed as ellipse size.');
   * }
   * </code>
   * </div>
   */ fn.accelerationX = 0;
    /**
   * The system variable accelerationY always contains the acceleration of the
   * device along the y axis. Value is represented as meters per second squared.
   *
   * @property {Number} accelerationY
   * @readOnly
   * @example
   * <div>
   * <code>
   * // Move a touchscreen device to register
   * // acceleration changes.
   * function draw() {
   *   background(220, 50);
   *   fill('magenta');
   *   ellipse(width / 2, height / 2, accelerationY);
   *   describe('Magnitude of device acceleration is displayed as ellipse size');
   * }
   * </code>
   * </div>
   */ fn.accelerationY = 0;
    /**
   * The system variable accelerationZ always contains the acceleration of the
   * device along the z axis. Value is represented as meters per second squared.
   *
   * @property {Number} accelerationZ
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // Move a touchscreen device to register
   * // acceleration changes.
   * function draw() {
   *   background(220, 50);
   *   fill('magenta');
   *   ellipse(width / 2, height / 2, accelerationZ);
   *   describe('Magnitude of device acceleration is displayed as ellipse size');
   * }
   * </code>
   * </div>
   */ fn.accelerationZ = 0;
    /**
   * The system variable pAccelerationX always contains the acceleration of the
   * device along the x axis in the frame previous to the current frame. Value
   * is represented as meters per second squared.
   *
   * @property {Number} pAccelerationX
   * @readOnly
   */ fn.pAccelerationX = 0;
    /**
   * The system variable pAccelerationY always contains the acceleration of the
   * device along the y axis in the frame previous to the current frame. Value
   * is represented as meters per second squared.
   *
   * @property {Number} pAccelerationY
   * @readOnly
   */ fn.pAccelerationY = 0;
    /**
   * The system variable pAccelerationZ always contains the acceleration of the
   * device along the z axis in the frame previous to the current frame. Value
   * is represented as meters per second squared.
   *
   * @property {Number} pAccelerationZ
   * @readOnly
   */ fn.pAccelerationZ = 0;
    /**
   * _updatePAccelerations updates the pAcceleration values
   *
   * @private
   */ fn._updatePAccelerations = function() {
        this.pAccelerationX = this.accelerationX;
        this.pAccelerationY = this.accelerationY;
        this.pAccelerationZ = this.accelerationZ;
    };
    /**
   * The system variable rotationX always contains the rotation of the
   * device along the x axis. If the sketch <a href="#/p5/angleMode">
   * angleMode()</a> is set to DEGREES, the value will be -180 to 180. If
   * it is set to RADIANS, the value will be -PI to PI.
   *
   * Note: The order the rotations are called is important, ie. if used
   * together, it must be called in the order Z-X-Y or there might be
   * unexpected behaviour.
   *
   * @property {Number} rotationX
   * @readOnly
   * @example
   * <div>
   * <code>
   * let rotationX = 0;            // Angle in degrees
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas
   * }
   *
   * function draw() {
   *   background(220);                 // Set light gray background
   *   rotateX(radians(rotationX));     // Rotate around X-axis
   *   normalMaterial();                // Apply simple shaded material
   *   box(60);                         // Draw 3D cube (60 units wide)
   *   rotationX = (rotationX + 2) % 360; // Increment rotation (2° per frame)
   * }
   * </code>
   * </div>
   */ fn.rotationX = 0;
    /**
   * The system variable rotationY always contains the rotation of the
   * device along the y axis. If the sketch <a href="#/p5/angleMode">
   * angleMode()</a> is set to DEGREES, the value will be -90 to 90. If
   * it is set to RADIANS, the value will be -PI/2 to PI/2.
   *
   * Note: The order the rotations are called is important, ie. if used
   * together, it must be called in the order Z-X-Y or there might be
   * unexpected behaviour.
   *
   * @property {Number} rotationY
   * @readOnly
   * @example
   * <div>
   * <code>
   * let rotationY = 0;            // Angle in degrees
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas
   * }
   *
   * function draw() {
   *   background(220);                 // Set light gray background
   *   rotateY(radians(rotationY));     // Rotate around Y-axis (vertical)
   *   normalMaterial();                // Apply simple shaded material
   *   box(60);                         // Draw 3D cube (60 units wide)
   *   rotationY = (rotationY + 2) % 360; // Increment rotation (2° per frame)
   * }
   * </code>
   * </div>
   */ fn.rotationY = 0;
    /**
   * The system variable rotationZ always contains the rotation of the
   * device along the z axis. If the sketch <a href="#/p5/angleMode">
   * angleMode()</a> is set to DEGREES, the value will be 0 to 360. If
   * it is set to RADIANS, the value will be 0 to 2*PI.
   *
   * Unlike rotationX and rotationY, this variable is available for devices
   * with a built-in compass only.
   *
   * Note: The order the rotations are called is important, ie. if used
   * together, it must be called in the order Z-X-Y or there might be
   * unexpected behaviour.
   *
   * @example
   * <div>
   * <code>
   * let rotationZ = 0;          // Angle in degrees
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);   // Create 3D canvas
   * }
   *
   * function draw() {
   *   background(220);
   *   rotateZ(radians(rotationZ));     // Rotate around Z-axis
   *   normalMaterial();                // Apply simple shaded material
   *   box(60);                         // Draw 3D cube
   *   rotationZ = (rotationZ + 2) % 360; // Increment rotation angle
   * }
   * </code>
   * </div>
   *
   * @property {Number} rotationZ
   * @readOnly
   */ fn.rotationZ = 0;
    /**
   * The system variable pRotationX always contains the rotation of the
   * device along the x axis in the frame previous to the current frame.
   * If the sketch <a href="#/p5/angleMode"> angleMode()</a> is set to DEGREES,
   * the value will be -180 to 180. If it is set to RADIANS, the value will
   * be -PI to PI.
   *
   * pRotationX can also be used with rotationX to determine the rotate
   * direction of the device along the X-axis.
   * @example
   * <div class='norender'>
   * <code>
   * // A simple if statement looking at whether
   * // rotationX - pRotationX < 0 is true or not will be
   * // sufficient for determining the rotate direction
   * // in most cases.
   *
   * // Some extra logic is needed to account for cases where
   * // the angles wrap around.
   * let rotateDirection = 'clockwise';
   *
   * // Simple range conversion to make things simpler.
   * // This is not absolutely necessary but the logic
   * // will be different in that case.
   *
   * let rX = rotationX + 180;
   * let pRX = pRotationX + 180;
   *
   * if ((rX - pRX > 0 && rX - pRX < 270) || rX - pRX < -270) {
   *   rotateDirection = 'clockwise';
   * } else if (rX - pRX < 0 || rX - pRX > 270) {
   *   rotateDirection = 'counter-clockwise';
   * }
   *
   * print(rotateDirection);
   * describe('no image to display.');
   * </code>
   * </div>
   *
   * @property {Number} pRotationX
   * @readOnly
   */ fn.pRotationX = 0;
    /**
   * The system variable pRotationY always contains the rotation of the
   * device along the y axis in the frame previous to the current frame.
   * If the sketch <a href="#/p5/angleMode"> angleMode()</a> is set to DEGREES,
   * the value will be -90 to 90. If it is set to RADIANS, the value will
   * be -PI/2 to PI/2.
   *
   * pRotationY can also be used with rotationY to determine the rotate
   * direction of the device along the Y-axis.
   * @example
   * <div class='norender'>
   * <code>
   * // A simple if statement looking at whether
   * // rotationY - pRotationY < 0 is true or not will be
   * // sufficient for determining the rotate direction
   * // in most cases.
   *
   * // Some extra logic is needed to account for cases where
   * // the angles wrap around.
   * let rotateDirection = 'clockwise';
   *
   * // Simple range conversion to make things simpler.
   * // This is not absolutely necessary but the logic
   * // will be different in that case.
   *
   * let rY = rotationY + 180;
   * let pRY = pRotationY + 180;
   *
   * if ((rY - pRY > 0 && rY - pRY < 270) || rY - pRY < -270) {
   *   rotateDirection = 'clockwise';
   * } else if (rY - pRY < 0 || rY - pRY > 270) {
   *   rotateDirection = 'counter-clockwise';
   * }
   * print(rotateDirection);
   * describe('no image to display.');
   * </code>
   * </div>
   *
   * @property {Number} pRotationY
   * @readOnly
   */ fn.pRotationY = 0;
    /**
   * The system variable pRotationZ always contains the rotation of the
   * device along the z axis in the frame previous to the current frame.
   * If the sketch <a href="#/p5/angleMode"> angleMode()</a> is set to DEGREES,
   * the value will be 0 to 360. If it is set to RADIANS, the value will
   * be 0 to 2*PI.
   *
   * pRotationZ can also be used with rotationZ to determine the rotate
   * direction of the device along the Z-axis.
   * @example
   * <div class='norender'>
   * <code>
   * // A simple if statement looking at whether
   * // rotationZ - pRotationZ < 0 is true or not will be
   * // sufficient for determining the rotate direction
   * // in most cases.
   *
   * // Some extra logic is needed to account for cases where
   * // the angles wrap around.
   * let rotateDirection = 'clockwise';
   *
   * if (
   *   (rotationZ - pRotationZ > 0 && rotationZ - pRotationZ < 270) ||
   *   rotationZ - pRotationZ < -270
   * ) {
   *   rotateDirection = 'clockwise';
   * } else if (rotationZ - pRotationZ < 0 || rotationZ - pRotationZ > 270) {
   *   rotateDirection = 'counter-clockwise';
   * }
   * print(rotateDirection);
   * describe('no image to display.');
   * </code>
   * </div>
   *
   * @property {Number} pRotationZ
   * @readOnly
   */ fn.pRotationZ = 0;
    let startAngleX = 0;
    let startAngleY = 0;
    let startAngleZ = 0;
    let rotateDirectionX = 'clockwise';
    let rotateDirectionY = 'clockwise';
    let rotateDirectionZ = 'clockwise';
    fn.pRotateDirectionX = undefined;
    fn.pRotateDirectionY = undefined;
    fn.pRotateDirectionZ = undefined;
    fn._updatePRotations = function() {
        this.pRotationX = this.rotationX;
        this.pRotationY = this.rotationY;
        this.pRotationZ = this.rotationZ;
    };
    /**
   * When a device is rotated, the axis that triggers the <a href="#/p5/deviceTurned">deviceTurned()</a>
   * method is stored in the turnAxis variable. The turnAxis variable is only defined within
   * the scope of deviceTurned().
   * @property {String} turnAxis
   * @readOnly
   * @example
   * <div>
   * <code>
   * // Run this example on a mobile device
   * // Rotate the device by 90 degrees in the
   * // X-axis to change the value.
   *
   * let value = 0;
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device turns`);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when x-axis turns`);
   * }
   * function deviceTurned() {
   *   if (turnAxis === 'X') {
   *     if (value === 0) {
   *       value = 255;
   *     } else if (value === 255) {
   *       value = 0;
   *     }
   *   }
   * }
   * </code>
   * </div>
   */ fn.turnAxis = undefined;
    let move_threshold = 0.5;
    let shake_threshold = 30;
    /**
   * The <a href="#/p5/setMoveThreshold">setMoveThreshold()</a> function is used to set the movement threshold for
   * the <a href="#/p5/deviceMoved">deviceMoved()</a> function. The default threshold is set to 0.5.
   *
   * @method setMoveThreshold
   * @param {Number} value The threshold value
   * @example
   * <div class="norender">
   * <code>
   * // Run this example on a mobile device
   * // You will need to move the device incrementally further
   * // the closer the square's color gets to white in order to change the value.
   *
   * let value = 0;
   * let threshold = 0.5;
   * function setup() {
   *   setMoveThreshold(threshold);
   * }
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device moves`);
   * }
   * function deviceMoved() {
   *   value = value + 5;
   *   threshold = threshold + 0.1;
   *   if (value > 255) {
   *     value = 0;
   *     threshold = 30;
   *   }
   *   setMoveThreshold(threshold);
   * }
   * </code>
   * </div>
   */ fn.setMoveThreshold = function(val) {
        move_threshold = val;
    };
    /**
   * The <a href="#/p5/setShakeThreshold">setShakeThreshold()</a> function is used to set the movement threshold for
   * the <a href="#/p5/deviceShaken">deviceShaken()</a> function. The default threshold is set to 30.
   *
   * @method setShakeThreshold
   * @param {Number} value The threshold value
   * @example
   * <div class="norender">
   * <code>
   * // Run this example on a mobile device
   * // You will need to shake the device more firmly
   * // the closer the box's fill gets to white in order to change the value.
   *
   * let value = 0;
   * let threshold = 30;
   * function setup() {
   *   setShakeThreshold(threshold);
   * }
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device is being shaked`);
   * }
   * function deviceMoved() {
   *   value = value + 5;
   *   threshold = threshold + 5;
   *   if (value > 255) {
   *     value = 0;
   *     threshold = 30;
   *   }
   *   setShakeThreshold(threshold);
   * }
   * </code>
   * </div>
   */ fn.setShakeThreshold = function(val) {
        shake_threshold = val;
    };
    /**
   * The <a href="#/p5/deviceMoved">deviceMoved()</a> function is called when the device is moved by more than
   * the threshold value along X, Y or Z axis. The default threshold is set to 0.5.
   * The threshold value can be changed using <a href="https://p5js.org/reference/p5/setMoveThreshold">setMoveThreshold()</a>.
   *
   * @method deviceMoved
   * @example
   * <div class="norender">
   * <code>
   * // Run this example on a mobile device
   * // Move the device around
   * // to change the value.
   *
   * let value = 0;
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device moves`);
   * }
   * function deviceMoved() {
   *   value = value + 5;
   *   if (value > 255) {
   *     value = 0;
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * The <a href="#/p5/deviceTurned">deviceTurned()</a> function is called when the device rotates by
   * more than 90 degrees continuously.
   *
   * The axis that triggers the <a href="#/p5/deviceTurned">deviceTurned()</a> method is stored in the turnAxis
   * variable. The <a href="#/p5/deviceTurned">deviceTurned()</a> method can be locked to trigger on any axis:
   * X, Y or Z by comparing the turnAxis variable to 'X', 'Y' or 'Z'.
   *
   * @method deviceTurned
   * @example
   * <div class="norender">
   * <code>
   * // Run this example on a mobile device
   * // Rotate the device by 90 degrees
   * // to change the value.
   *
   * let value = 0;
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device turns`);
   * }
   * function deviceTurned() {
   *   if (value === 0) {
   *     value = 255;
   *   } else if (value === 255) {
   *     value = 0;
   *   }
   * }
   * </code>
   * </div>
   * <div>
   * <code>
   * // Run this example on a mobile device
   * // Rotate the device by 90 degrees in the
   * // X-axis to change the value.
   *
   * let value = 0;
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when x-axis turns`);
   * }
   * function deviceTurned() {
   *   if (turnAxis === 'X') {
   *     if (value === 0) {
   *       value = 255;
   *     } else if (value === 255) {
   *       value = 0;
   *     }
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * The <a href="#/p5/deviceShaken">deviceShaken()</a> function is called when the device total acceleration
   * changes of accelerationX and accelerationY values is more than
   * the threshold value. The default threshold is set to 30.
   * The threshold value can be changed using <a href="https://p5js.org/reference/p5/setShakeThreshold">setShakeThreshold()</a>.
   *
   * @method deviceShaken
   * @example
   * <div class="norender">
   * <code>
   * // Run this example on a mobile device
   * // Shake the device to change the value.
   *
   * let value = 0;
   * function draw() {
   *   fill(value);
   *   rect(25, 25, 50, 50);
   *   describe(`50-by-50 black rect in center of canvas.
   *     turns white on mobile when device shakes`);
   * }
   * function deviceShaken() {
   *   value = value + 5;
   *   if (value > 255) {
   *     value = 0;
   *   }
   * }
   * </code>
   * </div>
   */ fn._ondeviceorientation = function(e) {
        this._updatePRotations();
        // Convert from degrees into current angle mode
        this.rotationX = this._fromDegrees(e.beta);
        this.rotationY = this._fromDegrees(e.gamma);
        this.rotationZ = this._fromDegrees(e.alpha);
        this._handleMotion();
    };
    fn._ondevicemotion = function(e) {
        this._updatePAccelerations();
        this.accelerationX = e.acceleration.x * 2;
        this.accelerationY = e.acceleration.y * 2;
        this.accelerationZ = e.acceleration.z * 2;
        this._handleMotion();
    };
    fn._handleMotion = function() {
        if (screen.orientation.type === 'landscape-primary' || screen.orientation.type === 'landscape-secondary') {
            this.deviceOrientation = 'landscape';
        } else if (screen.orientation.type === 'portrait-primary' || screen.orientation.type === 'portrait-secondary') {
            this.deviceOrientation = 'portrait';
        } else {
            this.deviceOrientation = 'undefined';
        }
        if (typeof this._customActions.deviceMoved === 'function') {
            if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) {
                this._customActions.deviceMoved();
            }
        }
        if (typeof this._customActions.deviceTurned === 'function') {
            // The angles given by rotationX etc is from range [-180 to 180].
            // The following will convert them to [0 to 360] for ease of calculation
            // of cases when the angles wrapped around.
            // _startAngleX will be converted back at the end and updated.
            // Rotations are converted to degrees and all calculations are done in degrees
            const wRX = this._toDegrees(this.rotationX) + 180;
            const wPRX = this._toDegrees(this.pRotationX) + 180;
            let wSAX = startAngleX + 180;
            if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) {
                rotateDirectionX = 'clockwise';
            } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {
                rotateDirectionX = 'counter-clockwise';
            }
            if (rotateDirectionX !== this.pRotateDirectionX) {
                wSAX = wRX;
            }
            if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {
                wSAX = wRX;
                this.turnAxis = 'X';
                this._customActions.deviceTurned();
            }
            this.pRotateDirectionX = rotateDirectionX;
            startAngleX = wSAX - 180;
            // Y-axis is identical to X-axis except for changing some names.
            const wRY = this._toDegrees(this.rotationY) + 180;
            const wPRY = this._toDegrees(this.pRotationY) + 180;
            let wSAY = startAngleY + 180;
            if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) {
                rotateDirectionY = 'clockwise';
            } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {
                rotateDirectionY = 'counter-clockwise';
            }
            if (rotateDirectionY !== this.pRotateDirectionY) {
                wSAY = wRY;
            }
            if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {
                wSAY = wRY;
                this.turnAxis = 'Y';
                this._customActions.deviceTurned();
            }
            this.pRotateDirectionY = rotateDirectionY;
            startAngleY = wSAY - 180;
            // Z-axis is already in the range 0 to 360
            // so no conversion is needed.
            const rotZ = this._toDegrees(this.rotationZ);
            const pRotZ = this._toDegrees(this.pRotationZ);
            if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) {
                rotateDirectionZ = 'clockwise';
            } else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) {
                rotateDirectionZ = 'counter-clockwise';
            }
            if (rotateDirectionZ !== this.pRotateDirectionZ) {
                startAngleZ = rotZ;
            }
            if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {
                startAngleZ = rotZ;
                this.turnAxis = 'Z';
                this._customActions.deviceTurned();
            }
            this.pRotateDirectionZ = rotateDirectionZ;
            this.turnAxis = undefined;
        }
        if (typeof this._customActions.deviceShaken === 'function') {
            let accelerationChangeX;
            let accelerationChangeY;
            // Add accelerationChangeZ if acceleration change on Z is needed
            if (this.pAccelerationX !== null) {
                accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);
                accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);
            }
            if (accelerationChangeX + accelerationChangeY > shake_threshold) {
                this._customActions.deviceShaken();
            }
        }
    };
}
if (typeof p5 !== 'undefined') {
    acceleration(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/events/keyboard.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>keyboard,
    "isCode",
    ()=>isCode
]);
/**
 * @module Events
 * @submodule Keyboard
 * @for p5
 * @requires core
 */ function isCode(input) {
    const leftRightKeys = [
        'Alt',
        'Shift',
        'Control',
        'Meta'
    ];
    if (leftRightKeys.includes(input)) {
        return false;
    }
    if (typeof input !== 'string') {
        return false;
    }
    return input.length > 1;
}
function keyboard(p51, fn, lifecycles) {
    lifecycles.presetup = function() {
        const events = [
            'keydown',
            'keyup',
            'keypress',
            'blur'
        ];
        for (const event of events){
            window.addEventListener(event, this[`_on${event}`].bind(this), {
                passive: false,
                signal: this._removeSignal
            });
        }
    };
    /**
   * A `Boolean` system variable that's `true` if any key is currently pressed
   * and `false` if not.
   *
   * @property {Boolean} keyIsPressed
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The white square turns black when the user presses a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   if (keyIsPressed === true) {
   *     fill(0);
   *   } else {
   *     fill(255);
   *   }
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The white square turns black when the user presses a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   if (keyIsPressed) {
   *     fill(0);
   *   } else {
   *     fill(255);
   *   }
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with the word "false" at its center. The word switches to "true" when the user presses a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the value of keyIsPressed.
   *   text(keyIsPressed, 50, 50);
   * }
   * </code>
   * </div>
   */ fn.keyIsPressed = false;
    /**
   * A `String` system variable that contains the value of the last key typed.
   *
   * The key variable is helpful for checking whether an
   * <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank">ASCII</a>
   * key has been typed. For example, the expression `key === "a"` evaluates to
   * `true` if the `a` key was typed and `false` if not. `key` doesn’t update
   * for special keys such as `LEFT_ARROW` and `ENTER`. Use keyCode instead for
   * special keys. The <a href="#/p5/keyIsDown">keyIsDown()</a> function should
   * be used to check for multiple different key presses at the same time.
   *
   * @property {String} key
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. The last key pressed is displayed at the center.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the last key pressed.
   *   text(key, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe(
   *     'A gray square with a black circle at its center. The circle moves when the user presses the keys "w", "a", "s", or "d". It leaves a trail as it moves.'
   *   );
   * }
   *
   * function draw() {
   *   // Update x and y if a key is pressed.
   *   if (keyIsPressed === true) {
   *     if (key === 'w') {
   *       y -= 1;
   *     } else if (key === 's') {
   *       y += 1;
   *     } else if (key === 'a') {
   *       x -= 1;
   *     } else if (key === 'd') {
   *       x += 1;
   *     }
   *   }
   *
   *   // Style the circle.
   *   fill(0);
   *
   *   // Draw the circle at (x, y).
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   */ fn.key = '';
    /**
   * The `code` property represents a physical key on the keyboard (as opposed
   * to the character generated by pressing the key). In other words, this
   * property returns a value that isn't altered by keyboard layout or the state
   * of the modifier keys.
   *
   * This property is useful when you want to handle keys based on their
   * physical positions on the input device rather than the characters associated
   * with those keys;
   *
   * Unlike <a href="#/p5/key">key</a>, the `code` property differentiates between
   * physical keys that generate the same character—for example, `CtrlLeft` and
   * `CtrlRight`—so each can be handled independently.
   * Here's the MDN docs for <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank">KeyboardEvent.code</a>
   *
   *
   * Pressing the key physically labeled “A” always yields `KeyA`, regardless
   * of the current keyboard layout (QWERTY, Dvorak, AZERTY, etc.) or the character
   * that appears in a text field.
   *
   * The code property returns a plain string (e.g., 'ArrowRight'). You can
   * compare it directly with string literals:
   * ```js
   * if (keyIsDown(RIGHT_ARROW)) {
   *   // …
   * }
   * // The line above is equivalent to:
   * if (code === 'ArrowRight') {
   *   // …
   * }
   * if (key  === 'ArrowRight') {
   * // …
   * }
   * ```
   *
   * The system variables `BACKSPACE`, `DELETE`, `ENTER`, `RETURN`, `TAB`,
   * `ESCAPE`, `SHIFT`, `CONTROL`, `OPTION`, `ALT`, `UP_ARROW`, `DOWN_ARROW`,
   * `LEFT_ARROW`, and `RIGHT_ARROW` are all helpful shorthands the key codes of
   * special keys.
   * These are simply shorthands for the same string values:
   * ```js
   * if (code === RIGHT_ARROW) {
   * // ..
   * }
   * ```
   *
   *
   * <p>The table below summarizes how the main keyboard-related system variables changed between p5.js 1.x and 2.x.</p>
   * <table>
   *   <thead>
   *     <tr>
   *       <th>Variable</th>
   *       <th>p5.js 1.x </th>
   *       <th>p5.js 2.x </th>
   *     </tr>
   *   </thead>
   *   <tbody>
   *     <tr>
   *       <td><code>key</code></td>
   *       <td>Text string (e.g., <code>"ArrowUp"</code>).</td>
   *       <td>Text string (e.g., <code>"ArrowUp"</code>, <code>"f"</code> or <code>"F"</code>).</td>
   *     </tr>
   *     <tr>
   *       <td><code>code</code></td>
   *       <td><em>Not supported.</em></td>
   *       <td>Text String (e.g., <code>"ArrowUp"</code>, <code>"KeyF"</code>).</td>
   *     </tr>
   *     <tr>
   *       <td><code>keyCode</code></td>
   *       <td>Number (e.g., <code>70</code>).</td>
   *       <td>Number (unchanged; e.g., <code>70</code>).</td>
   *     </tr>
   *     <tr>
   *       <td>System variables (<code>BACKSPACE</code>, <code>UP_ARROW</code>, …)</td>
   *       <td>Number</td>
   *       <td>Text String (e.g., <code>"ArrowUp"</code>).</td>
   *     </tr>
   *   </tbody>
   * </table>
   *
   *
   * @property {String} code
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. The last key pressed is displayed at the center.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the last key pressed.
   *   text(code, 50, 50);
   * }
   * </code>
   * </div>
   * <div>
   * <code>
   *
   * function setup() {
   *   createCanvas(100, 100);
   * }
   *
   * function draw() {
   *   background(220);
   *   fill("black");
   *   if (keyIsDown(BACKSPACE) || keyIsDown(ENTER) ||
   *       keyIsDown(DELETE) || keyIsDown(RETURN) ||
   *       keyIsDown(TAB) || keyIsDown(ESCAPE) ||
   *       keyIsDown(CONTROL) || keyIsDown(OPTION) ||
   *       keyIsDown(UP_ARROW) || keyIsDown(LEFT_ARROW) ||
   *       keyIsDown(RIGHT_ARROW) || keyIsDown(DOWN_ARROW) ||
   *       keyIsDown(SHIFT)) {
   *     fill("red");
   *     text("System Variable", 7, 75);
   *   }
   *
   *   text(key, 30, 25);
   *   text(keyCode, 7, 25);
   *   text(code || " ", 30, 50);
   * }
   * </div>
   * </code>
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe(
   *     'A gray square with a black circle at its center. The circle moves when the user presses an arrow key. It leaves a trail as it moves.'
   *   );
   * }
   *
   * function draw() {
   *   // Update x and y if an arrow key is pressed.
   *   if (keyIsPressed){
   *     if (keyIsDown(LEFT_ARROW)){
   *       x -= 1;
   *     }
   *
   *     if (keyIsDown(RIGHT_ARROW)) {
   *       x += 1;
   *     }
   *
   *     if (keyIsDown(UP_ARROW)) {
   *       y -= 1;
   *     }
   *
   *     if (keyIsDown(DOWN_ARROW)) {
   *       y += 1;
   *     }
   *   }
   *
   *   // Style the circle.
   *   fill(0);
   *
   *   // Draw the circle.
   *   circle(x, y, 5);
   * }
   *
   * </code>
   * </div>
   */ fn.code = '';
    /**
   * A `Number` system variable that contains the code of the last key pressed.
   *
   * Every key has a numeric key code. For example, the letter `a` key has the key code 65.
   * Use this key code to determine which key was pressed by comparing it to the numeric value
   * of the desired key.
   *
   * For example, to detect when the Enter key is pressed:
   *
   * ```js
   * if (keyCode === 13) { // Enter key
   *   // Code to run if the Enter key was pressed.
   * }
   * ```
   *
   * Alternatively, you can use the <a href="#/p5/key">key</a> function to directly compare the key value:
   *
   * ```js
   * if (key === 'Enter') { // Enter key
   *   // Code to run if the Enter key was pressed.
   * }
   * ```
   *
   * Use the following numeric codes for the arrow keys:
   *
   *   Up Arrow: 38
   *   Down Arrow: 40
   *   Left Arrow: 37
   *   Right Arrow: 39
   *
   * More key codes can be found at websites such as
   * <a href="http://keycode.info/">keycode.info</a>.
   *
   * @property {Integer} keyCode
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. The last key pressed and its code are displayed at the center.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the last key pressed and its code.
   *   text(`${key} : ${keyCode}`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe(
   *     'A gray square with a black circle at its center. The circle moves when the user presses an arrow key. It leaves a trail as it moves.'
   *   );
   * }
   *
   * function draw() {
   *   // Update x and y if an arrow key is pressed.
   *   if (keyIsPressed === true) {
   *     if (keyCode === 38) { // Up arrow key
   *       y -= 1;
   *     } else if (keyCode === 40) { // Down arrow key
   *       y += 1;
   *     } else if (keyCode === 37) { // Left arrow key
   *       x -= 1;
   *     } else if (keyCode === 39) { // Right arrow key
   *       x += 1;
   *     }
   *   }
   *
   *   // Style the circle.
   *   fill(0);
   *
   *   // Draw the circle at (x, y).
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   */ fn.keyCode = 0;
    /**
   * A function that's called once when any key is pressed.
   *
   * Declaring the function `keyPressed()` sets a code block to run once
   * automatically when the user presses any key:
   *
   * ```js
   * function keyPressed() {
   *   // Code to run.
   * }
   * ```
   *
   * The <a href="#/p5/key">key</a> and <a href="#/p5/keyCode">keyCode</a>
   * variables will be updated with the most recently typed value when
   * `keyPressed()` is called by p5.js:
   *
   * ```js
   * function keyPressed() {
   *   if (key === 'c') {
   *     // Code to run.
   *   }
   *
   *   if (keyCode === 13) { // Enter key
   *     // Code to run.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `keyPressed()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" target="_blank">KeyboardEvent</a>
   * object with properties that describe the key press event:
   *
   * ```js
   * function keyPressed(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * Browsers may have default behaviors attached to various key events. For
   * example, some browsers may jump to the bottom of a web page when the
   * `SPACE` key is pressed. To prevent any default behavior for this event, add
   * `return false;` to the end of the function.
   *
   * @method keyPressed
   * @param  {KeyboardEvent} [event] optional `KeyboardEvent` callback argument.
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square changes color when the user presses a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the background color when the user presses a key.
   * function keyPressed() {
   *   if (value === 0) {
   *     value = 255;
   *   } else {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The inner square turns black when the user presses the "b" key. It turns white when the user presses the "a" key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Reassign value when the user presses the 'a' or 'b' key.
   * function keyPressed() {
   *   if (key === 'a') {
   *     value = 255;
   *   } else if (key === 'b') {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square turns white when the user presses the left arrow key. It turns black when the user presses the right arrow key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the background color when the user presses an arrow key.
   * function keyPressed() {
   *   if (keyCode === 37) { // Left arrow key
   *     value = 255;
   *   } else if (keyCode === 39) { // Right arrow key
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._onkeydown = function(e) {
        if (this._downKeys[e.code]) {
            return;
        }
        this.keyIsPressed = true;
        this.keyCode = e.which;
        this.key = e.key;
        this.code = e.code;
        this._downKeyCodes[e.code] = true;
        this._downKeys[e.key] = true;
        if (typeof this._customActions.keyPressed === 'function' && !e.charCode) {
            const executeDefault = this._customActions.keyPressed(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * A function that's called once when any key is released.
   *
   * Declaring the function `keyReleased()` sets a code block to run once
   * automatically when the user releases any key:
   *
   * ```js
   * function keyReleased() {
   *   // Code to run.
   * }
   * ```
   *
   * The <a href="#/p5/key">key</a> and <a href="#/p5/keyCode">keyCode</a>
   * variables will be updated with the most recently released value when
   * `keyReleased()` is called by p5.js:
   *
   * ```js
   * function keyReleased() {
   *   if (key === 'c') {
   *     // Code to run.
   *   }
   *
   *   if (keyCode === 13) { // Enter key
   *     // Code to run.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `keyReleased()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" target="_blank">KeyboardEvent</a>
   * object with properties that describe the key press event:
   *
   * ```js
   * function keyReleased(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * Browsers may have default behaviors attached to various key events. To
   * prevent any default behavior for this event, add `return false;` to the end
   * of the function.
   *
   * @method keyReleased
   * @param  {KeyboardEvent} [event] optional `KeyboardEvent` callback argument.
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square changes color when the user releases a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle value when the user releases a key.
   * function keyReleased() {
   *   if (value === 0) {
   *     value = 255;
   *   } else {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square becomes white when the user releases the "w" key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Set value to 255 the user releases the 'w' key.
   * function keyReleased() {
   *   if (key === 'w') {
   *     value = 255;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square turns white when the user presses and releases the left arrow key. It turns black when the user presses and releases the right arrow key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the background color when the user releases an arrow key.
   * function keyReleased() {
   *   if (keyCode === 37) { // Left arrow key
   *     value = 255;
   *   } else if (keyCode === 39) { // Right arrow key
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._onkeyup = function(e) {
        if (typeof this._customActions.keyReleased === 'function') {
            const executeDefault = this._customActions.keyReleased(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
        delete this._downKeyCodes[e.code];
        delete this._downKeys[e.key];
        if (!this._areDownKeys()) {
            this.keyIsPressed = false;
            this.key = '';
            this.code = '';
        } else {
            // If other keys are still pressed, update code to the last pressed key
            const lastPressedCode = Object.keys(this._downKeyCodes).pop();
            this.code = lastPressedCode;
            const lastPressedKey = Object.keys(this._downKeys).pop();
            this.key = lastPressedKey;
        }
    };
    /**
   * A function that's called once when keys with printable characters are pressed.
   *
   * Declaring the function `keyTyped()` sets a code block to run once
   * automatically when the user presses any key with a printable character such
   * as `a` or 1. Modifier keys such as `SHIFT`, `CONTROL`, and the arrow keys
   * will be ignored:
   *
   * ```js
   * function keyTyped() {
   *   // Code to run.
   * }
   * ```
   *
   * The <a href="#/p5/key">key</a> and <a href="#/p5/keyCode">keyCode</a>
   * variables will be updated with the most recently released value when
   * `keyTyped()` is called by p5.js:
   *
   * ```js
   * function keyTyped() {
   *   // Check for the "c" character using key.
   *   if (key === 'c') {
   *     // Code to run.
   *   }
   *
   *   // Check for "c" using keyCode.
   *   if (keyCode === 67) { // 67 is the ASCII code for 'c'
   *     // Code to run.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `keyTyped()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" target="_blank">KeyboardEvent</a>
   * object with properties that describe the key press event:
   *
   * ```js
   * function keyReleased(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * Note: Use the <a href="#/p5/keyPressed">keyPressed()</a> function and
   * <a href="#/p5/keyCode">keyCode</a> system variable to respond to modifier
   * keys such as `ALT`.
   *
   * Browsers may have default behaviors attached to various key events. To
   * prevent any default behavior for this event, add `return false;` to the end
   * of the function.
   *
   * @method keyTyped
   * @param  {KeyboardEvent} [event] optional `KeyboardEvent` callback argument.
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   * // Note: Pressing special keys such as SPACE have no effect.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The inner square changes color when the user presses a key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the square's color when the user types a printable key.
   * function keyTyped() {
   *   if (value === 0) {
   *     value = 255;
   *   } else {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The inner square turns black when the user types the "b" key. It turns white when the user types the "a" key.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Reassign value when the user types the 'a' or 'b' key.
   * function keyTyped() {
   *   if (key === 'a') {
   *     value = 255;
   *   } else if (key === 'b') {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._onkeypress = function(e) {
        if (e.which === this._lastKeyCodeTyped && e.repeat) {
            // prevent multiple firings
            return;
        }
        this._lastKeyCodeTyped = e.which; // track last keyCode
        this.key = e.key || String.fromCharCode(e.which) || e.which;
        if (typeof this._customActions.keyTyped === 'function') {
            const executeDefault = this._customActions.keyTyped(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * The onblur function is called when the user is no longer focused
   * on the p5 element. Because the keyup events will not fire if the user is
   * not focused on the element we must assume all keys currently down have
   * been released.
   */ fn._onblur = function(e) {
        this._downKeys = {};
    };
    /**
   * Returns `true` if the key it’s checking is pressed and `false` if not.
   *
   * `keyIsDown()` is helpful when checking for multiple different key presses.
   * For example, `keyIsDown()` can be used to check if both `LEFT_ARROW` and
   * `UP_ARROW` are pressed:
   *
   * ```js
   * if (keyIsDown(LEFT_ARROW) && keyIsDown(UP_ARROW)) {
   *   // Move diagonally.
   * }
   * ```
   *
   * `keyIsDown()` can check for key presses using strings based on
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" target="_blank">KeyboardEvent.key</a>
   * or <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" target="_blank">KeyboardEvent.code</a> values,
   * such as `keyIsDown('x')` or `keyIsDown('ArrowLeft')`.
   *
   * Note: In p5.js 2.0 and newer, numeric keycodes (such as 88 for 'X') are no longer supported.
   * This is a breaking change from previous versions.
   *
   * You can still use the p5 constants like `LEFT_ARROW` which now map to string values
   * internally rather than numeric codes.
   *
   * @method keyIsDown
   * @param {Number|String}   code key to check.
   * @return {Boolean}        whether the key is down or not.
   *
   * @example
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe(
   *     'A gray square with a black circle at its center. The circle moves when the user presses an arrow key. It leaves a trail as it moves.'
   *   );
   * }
   *
   * function draw() {
   *   // Update x and y if an arrow key is pressed.
   *   if (keyIsDown(LEFT_ARROW) === true) {
   *     x -= 1;
   *   }
   *
   *   if (keyIsDown(RIGHT_ARROW) === true) {
   *     x += 1;
   *   }
   *
   *   if (keyIsDown(UP_ARROW) === true) {
   *     y -= 1;
   *   }
   *
   *   if (keyIsDown(DOWN_ARROW) === true) {
   *     y += 1;
   *   }
   *
   *   // Style the circle.
   *   fill(0);
   *
   *   // Draw the circle.
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click on the canvas to begin detecting key presses.
   *
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe(
   *     'A gray square with a black circle at its center. The circle moves when the user presses an arrow key. It leaves a trail as it moves.'
   *   );
   * }
   *
   * function draw() {
   *   // Update x and y if an arrow key is pressed.
   *   if (keyIsDown('ArrowLeft') === true) {
   *     x -= 1;
   *   }
   *
   *   if (keyIsDown('ArrowRight') === true) {
   *     x += 1;
   *   }
   *
   *   if (keyIsDown('ArrowUp') === true) {
   *     y -= 1;
   *   }
   *
   *   if (keyIsDown('ArrowDown') === true) {
   *     y += 1;
   *   }
   *
   *   // Style the circle.
   *   fill(0);
   *
   *   // Draw the circle.
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   */ fn.keyIsDown = function(input) {
        if (isCode(input)) {
            return this._downKeyCodes[input] || this._downKeys[input] || false;
        } else {
            return this._downKeys[input] || this._downKeyCodes[input] || false;
        }
    };
    /**
   * The _areDownKeys function returns a boolean true if any keys pressed
   * and a false if no keys are currently pressed.
   *
   * Helps avoid instances where multiple keys are pressed simultaneously and
   * releasing a single key will then switch the
   * keyIsPressed property to true.
   * @private
   */ fn._areDownKeys = function() {
        for(const key in this._downKeys){
            if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) {
                return true;
            }
        }
        return false;
    };
}
if (typeof p5 !== 'undefined') {
    keyboard(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/events/pointer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>pointer
]);
/**
 * @module Events
 * @submodule Pointer
 * @for p5
 * @requires core
 * @requires constants
 */ function pointer(p51, fn, lifecycles) {
    lifecycles.presetup = function() {
        const events = [
            'pointerdown',
            'pointerup',
            'pointermove',
            'dragend',
            'dragover',
            'click',
            'dblclick',
            'wheel'
        ];
        for (const event of events){
            window.addEventListener(event, this[`_on${event}`].bind(this), {
                passive: false,
                signal: this._removeSignal
            });
        }
    };
    /**
   * A `Number` system variable that tracks the mouse's horizontal movement.
   *
   * `movedX` tracks how many pixels the mouse moves left or right between
   * frames. `movedX` will have a negative value if the mouse moves left between
   * frames and a positive value if it moves right. `movedX` can be calculated
   * as `mouseX - pmouseX`.
   *
   * Note: `movedX` continues updating even when
   * <a href="#/p5/requestPointerLock">requestPointerLock()</a> is active.
   *
   * @property {Number} movedX
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. The text ">>" appears when the user moves the mouse to the right. The text "<<" appears when the user moves the mouse to the left.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display >> when movedX is positive and
   *   // << when it's negative.
   *   if (movedX > 0) {
   *     text('>>', 50, 50);
   *   } else if (movedX < 0) {
   *     text('<<', 50, 50);
   *   }
   * }
   * </code>
   * </div>
   */ fn.movedX = 0;
    /**
   * A `Number` system variable that tracks the mouse's vertical movement.
   *
   * `movedY` tracks how many pixels the mouse moves up or down between
   * frames. `movedY` will have a negative value if the mouse moves up between
   * frames and a positive value if it moves down. `movedY` can be calculated
   * as `mouseY - pmouseY`.
   *
   * Note: `movedY` continues updating even when
   * <a href="#/p5/requestPointerLock">requestPointerLock()</a> is active.
   *
   * @property {Number} movedY
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. The text "▲" appears when the user moves the mouse upward. The text "▼" appears when the user moves the mouse downward.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display ▼ when movedY is positive and
   *   // ▲ when it's negative.
   *   if (movedY > 0) {
   *     text('▼', 50, 50);
   *   } else if (movedY < 0) {
   *     text('▲', 50, 50);
   *   }
   * }
   * </code>
   * </div>
   */ fn.movedY = 0;
    /*
   * This is a flag which is false until the first time
   * we receive a mouse event. The pmouseX and pmouseY
   * values will match the mouseX and mouseY values until
   * this interaction takes place.
   */ fn._hasMouseInteracted = false;
    /**
   * A `Number` system variable that tracks the mouse's horizontal position.
   *
   * `mouseX` keeps track of the mouse's position relative to the
   * top-left corner of the canvas. For example, if the mouse is 50 pixels from
   * the left edge of the canvas, then `mouseX` will be 50.
   *
   * If touch is used instead of the mouse, then `mouseX` will hold the
   * x-coordinate of the most recent touch point.
   *
   * @property {Number} mouseX
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A vertical black line moves left and right following the mouse's x-position.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw a vertical line that follows the mouse's x-coordinate.
   *   line(mouseX, 0, mouseX, 100);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the mouse's coordinates.
   *   text(`x: ${int(mouseX)} y: ${int(mouseY)}`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe("A vertical black line moves left and right following the mouse's x-position.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Adjust coordinates for WebGL mode.
   *   // The origin (0, 0) is at the center of the canvas.
   *   let mx = mouseX - 50;
   *
   *   // Draw the line.
   *   line(mx, -50, mx, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   // Load a font for WebGL mode.
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe(
   *     "A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse."
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the mouse's coordinates.
   *   text(`x: ${int(mouseX)} y: ${int(mouseY)}`, 0, 0);
   * }
   * </code>
   * </div>
   */ fn.mouseX = 0;
    /**
   * A `Number` system variable that tracks the mouse's vertical position.
   *
   * `mouseY` keeps track of the mouse's position relative to the
   * top-left corner of the canvas. For example, if the mouse is 50 pixels from
   * the top edge of the canvas, then `mouseY` will be 50.
   *
   * If touch is used instead of the mouse, then `mouseY` will hold the
   * y-coordinate of the most recent touch point.
   *
   * @property {Number} mouseY
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A horizontal black line moves up and down following the mouse's y-position.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw a horizontal line that follows the mouse's y-coordinate.
   *   line(0, mouseY, 100, mouseY);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the mouse's coordinates.
   *   text(`x: ${int(mouseX)} y: ${int(mouseY)}`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe("A horizontal black line moves up and down following the mouse's y-position.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Adjust coordinates for WebGL mode.
   *   // The origin (0, 0) is at the center of the canvas.
   *   let my = mouseY - 50;
   *
   *   // Draw the line.
   *   line(-50, my, 50, my);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   // Load a font for WebGL mode.
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe(
   *     "A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse."
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the mouse's coordinates.
   *   text(`x: ${int(mouseX)} y: ${int(mouseY)}`, 0, 0);
   * }
   * </code>
   * </div>
   */ fn.mouseY = 0;
    /**
   * A `Number` system variable that tracks the mouse's previous horizontal
   * position.
   *
   * `pmouseX` keeps track of the mouse's position relative to the
   * top-left corner of the canvas. Its value is
   * <a href="#/p5/mouseX">mouseX</a> from the previous frame. For example, if
   * the mouse was 50 pixels from the left edge of the canvas during the last
   * frame, then `pmouseX` will be 50.
   *
   * If touch is used instead of the mouse, then `pmouseX` will hold the
   * x-coordinate of the last touch point.
   *
   * Note: `pmouseX` is reset to the current <a href="#/p5/mouseX">mouseX</a>
   * value at the start of each touch event.
   *
   * @property {Number} pmouseX
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(10);
   *
   *   describe('A line follows the mouse as it moves. The line grows longer with faster movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   line(pmouseX, pmouseY, mouseX, mouseY);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A line follows the mouse as it moves. The line grows longer with faster movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Adjust coordinates for WebGL mode.
   *   // The origin (0, 0) is at the center of the canvas.
   *   let pmx = pmouseX - 50;
   *   let pmy = pmouseY - 50;
   *   let mx = mouseX - 50;
   *   let my = mouseY - 50;
   *
   *   // Draw the line.
   *   line(pmx, pmy, mx, my);
   * }
   * </code>
   * </div>
   */ fn.pmouseX = 0;
    /**
   * A `Number` system variable that tracks the mouse's previous vertical
   * position.
   *
   * `pmouseY` keeps track of the mouse's position relative to the
   * top-left corner of the canvas. Its value is
   * <a href="#/p5/mouseY">mouseY</a> from the previous frame. For example, if
   * the mouse was 50 pixels from the top edge of the canvas during the last
   * frame, then `pmouseY` will be 50.
   *
   * If touch is used instead of the mouse, then `pmouseY` will hold the
   * y-coordinate of the last touch point.
   *
   * Note: `pmouseY` is reset to the current <a href="#/p5/mouseY">mouseY</a>
   * value at the start of each touch event.
   *
   * @property {Number} pmouseY
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(10);
   *
   *   describe('A line follows the mouse as it moves. The line grows longer with faster movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   line(pmouseX, pmouseY, mouseX, mouseY);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A line follows the mouse as it moves. The line grows longer with faster movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Adjust coordinates for WebGL mode.
   *   // The origin (0, 0) is at the center of the canvas.
   *   let pmx = pmouseX - 50;
   *   let pmy = pmouseY - 50;
   *   let mx = mouseX - 50;
   *   let my = mouseY - 50;
   *
   *   // Draw the line.
   *   line(pmx, pmy, mx, my);
   * }
   * </code>
   * </div>
   */ fn.pmouseY = 0;
    /**
   * A `Number` variable that tracks the mouse's horizontal position within the
   * browser.
   *
   * `winMouseX` keeps track of the mouse's position relative to the top-left
   * corner of the browser window. For example, if the mouse is 50 pixels from
   * the left edge of the browser, then `winMouseX` will be 50.
   *
   * On a touchscreen device, `winMouseX` will hold the x-coordinate of the most
   * recent touch point.
   *
   * Note: Use <a href="#/p5/mouseX">mouseX</a> to track the mouse’s
   * x-coordinate within the canvas.
   *
   * @property {Number} winMouseX
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the mouse's coordinates within the browser window.
   *   text(`x: ${int(winMouseX)} y: ${int(winMouseY)}`, 50, 50);
   * }
   * </code>
   * </div>
   */ fn.winMouseX = 0;
    /**
   * A `Number` variable that tracks the mouse's vertical position within the
   * browser.
   *
   * `winMouseY` keeps track of the mouse's position relative to the top-left
   * corner of the browser window. For example, if the mouse is 50 pixels from
   * the top edge of the browser, then `winMouseY` will be 50.
   *
   * On a touchscreen device, `winMouseY` will hold the y-coordinate of the most
   * recent touch point.
   *
   * Note: Use <a href="#/p5/mouseY">mouseY</a> to track the mouse’s
   * y-coordinate within the canvas.
   *
   * @property {Number} winMouseY
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A gray square. The mouse's x- and y-coordinates are displayed as the user moves the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the mouse's coordinates within the browser window.
   *   text(`x: ${int(winMouseX)} y: ${int(winMouseY)}`, 50, 50);
   * }
   * </code>
   * </div>
   */ fn.winMouseY = 0;
    /**
   * A `Number` variable that tracks the mouse's previous horizontal position
   * within the browser.
   *
   * `pwinMouseX` keeps track of the mouse's position relative to the top-left
   * corner of the browser window. Its value is
   * <a href="#/p5/winMouseX">winMouseX</a> from the previous frame. For
   * example, if the mouse was 50 pixels from
   * the left edge of the browser during the last frame, then `pwinMouseX` will
   * be 50.
   *
   * On a touchscreen device, `pwinMouseX` will hold the x-coordinate of the most
   * recent touch point. `pwinMouseX` is reset to the current
   * <a href="#/p5/winMouseX">winMouseX</a> value at the start of each touch
   * event.
   *
   * Note: Use <a href="#/p5/pmouseX">pmouseX</a> to track the mouse’s previous
   * x-coordinate within the canvas.
   *
   * @property {Number} pwinMouseX
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(10);
   *
   *   describe('A gray square. A white circle at its center grows larger when the mouse moves horizontally.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the circle's diameter.
   *   let d = winMouseX - pwinMouseX;
   *
   *   // Draw the circle.
   *   circle(50, 50, d);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Create the canvas and set its position.
   *   let cnv = createCanvas(100, 100);
   *   cnv.position(20, 20);
   *
   *   describe('A gray square with a number at its center. The number changes as the user moves the mouse vertically.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display pwinMouseX.
   *   text(pwinMouseX, 50, 50);
   * }
   * </code>
   * </div>
   */ fn.pwinMouseX = 0;
    /**
   * A `Number` variable that tracks the mouse's previous vertical position
   * within the browser.
   *
   * `pwinMouseY` keeps track of the mouse's position relative to the top-left
   * corner of the browser window. Its value is
   * <a href="#/p5/winMouseY">winMouseY</a> from the previous frame. For
   * example, if the mouse was 50 pixels from
   * the top edge of the browser during the last frame, then `pwinMouseY` will
   * be 50.
   *
   * On a touchscreen device, `pwinMouseY` will hold the y-coordinate of the most
   * recent touch point. `pwinMouseY` is reset to the current
   * <a href="#/p5/winMouseY">winMouseY</a> value at the start of each touch
   * event.
   *
   * Note: Use <a href="#/p5/pmouseY">pmouseY</a> to track the mouse’s previous
   * y-coordinate within the canvas.
   *
   * @property {Number} pwinMouseY
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(10);
   *
   *   describe('A gray square. A white circle at its center grows larger when the mouse moves vertically.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the circle's diameter.
   *   let d = winMouseY - pwinMouseY;
   *
   *   // Draw the circle.
   *   circle(50, 50, d);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Create the canvas and set its position.
   *   let cnv = createCanvas(100, 100);
   *   cnv.position(20, 20);
   *
   *   describe('A gray square with a number at its center. The number changes as the user moves the mouse vertically.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display pwinMouseY.
   *   text(pwinMouseY, 50, 50);
   * }
   * </code>
   * </div>
   */ fn.pwinMouseY = 0;
    /**
   * An object that tracks the current state of mouse buttons, showing which
   * buttons are pressed at any given moment.
   *
   * The `mouseButton` object has three properties:
   * - `left`: A boolean indicating whether the left mouse button is pressed.
   * - `right`: A boolean indicating whether the right mouse button is pressed.
   * - `center`: A boolean indicating whether the middle mouse button (scroll wheel button) is pressed.
   *
   * Note: Different browsers may track `mouseButton` differently. See
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons" target="_blank">MDN</a>
   * for more information.
   *
   * @property {Object} mouseButton
   * @property {boolean} mouseButton.left - Whether the left mouse button is pressed.
   * @property {boolean} mouseButton.right - Whether the right mouse button is pressed.
   * @property {boolean} mouseButton.center - Whether the middle mouse button is pressed.
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200);
   *
   *   describe(
   *     'A gray square with black text at its center. The text changes from 0 to either "left" or "right" when the user clicks a mouse button.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the mouse button.
   *   text(`Left: ${mouseButton.left}`, width / 2, height / 2 - 20);
   *   text(`Right: ${mouseButton.right}`, width / 2, height / 2);
   *   text(`Center: ${mouseButton.center}`, width / 2, height / 2 + 20);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     "A gray square. Different shapes appear at its center depending on the mouse button that's clicked."
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   if (mouseIsPressed === true) {
   *     if (mouseButton.left) {
   *       circle(50, 50, 50);
   *     }
   *     if (mouseButton.right) {
   *       square(25, 25, 50);
   *     }
   *     if (mouseButton.center) {
   *       triangle(23, 75, 50, 20, 78, 75);
   *     }
   *   }
   * }
   * </code>
   * </div>
   */ fn.mouseButton = {
        left: false,
        right: false,
        center: false
    };
    /**
   * An `Array` of all the current touch points on a touchscreen device.
   *
   * The `touches` array is empty by default. When the user touches their
   * screen, a new touch point is tracked and added to the array. Touch points
   * are `Objects` with the following properties:
   *
   * ```js
   * // Iterate over the touches array.
   * for (let touch of touches) {
   *   // x-coordinate relative to the top-left
   *   // corner of the canvas.
   *   console.log(touch.x);
   *
   *   // y-coordinate relative to the top-left
   *   // corner of the canvas.
   *   console.log(touch.y);
   *
   *   // x-coordinate relative to the top-left
   *   // corner of the browser.
   *   console.log(touch.winX);
   *
   *   // y-coordinate relative to the top-left
   *   // corner of the browser.
   *   console.log(touch.winY);
   *
   *   // ID number
   *   console.log(touch.id);
   * }
   * ```
   *
   * @property {Object[]} touches
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * // On a touchscreen device, touch the canvas using one or more fingers
   * // at the same time.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. White circles appear where the user touches the square.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw a circle at each touch point.
   *   for (let touch of touches) {
   *     circle(touch.x, touch.y, 40);
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // On a touchscreen device, touch the canvas using one or more fingers
   * // at the same time.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. Labels appear where the user touches the square, displaying the coordinates.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw a label above each touch point.
   *   for (let touch of touches) {
   *     text(`${touch.x}, ${touch.y}`, touch.x, touch.y - 40);
   *   }
   * }
   * </code>
   * </div>
   */ fn.touches = [];
    fn._activePointers = new Map();
    /**
   * A `Boolean` system variable that's `true` if the mouse is pressed and
   * `false` if not.
   *
   * @property {Boolean} mouseIsPressed
   * @readOnly
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with the word "false" at its center. The word changes to "true" when the user presses a mouse button.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the mouseIsPressed variable.
   *   text(mouseIsPressed, 25, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a white square at its center. The inner square turns black when the user presses the mouse.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   if (mouseIsPressed === true) {
   *     fill(0);
   *   } else {
   *     fill(255);
   *   }
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   * </code>
   * </div>
   */ fn.mouseIsPressed = false;
    fn._updatePointerCoords = function(e) {
        if (this._curElement !== null) {
            const canvas = this._curElement.elt;
            const sx = canvas.scrollWidth / this.width || 1;
            const sy = canvas.scrollHeight / this.height || 1;
            if (e.pointerType === 'touch') {
                const touches = [];
                for (const touch of this._activePointers.values()){
                    touches.push(getTouchInfo(canvas, sx, sy, touch));
                }
                this.touches = touches;
            }
            const mousePos = getMouseInfo(canvas, sx, sy, e);
            this.movedX = e.movementX || 0;
            this.movedY = e.movementY || 0;
            this.mouseX = mousePos.x;
            this.mouseY = mousePos.y;
            this.winMouseX = mousePos.winX;
            this.winMouseY = mousePos.winY;
            if (!this._hasMouseInteracted) {
                this._updateMouseCoords();
                this._hasMouseInteracted = true;
            }
        }
    };
    fn._updateMouseCoords = function() {
        this.pmouseX = this.mouseX;
        this.pmouseY = this.mouseY;
        this.pwinMouseX = this.winMouseX;
        this.pwinMouseY = this.winMouseY;
        this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
    };
    function getMouseInfo(canvas, sx, sy, evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (evt.clientX - rect.left) / sx,
            y: (evt.clientY - rect.top) / sy,
            winX: evt.clientX,
            winY: evt.clientY
        };
    }
    function getTouchInfo(canvas, sx, sy, touch) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (touch.clientX - rect.left) / sx,
            y: (touch.clientY - rect.top) / sy,
            winX: touch.clientX,
            winY: touch.clientY,
            id: touch.pointerId
        };
    }
    fn._setMouseButton = function(e) {
        // Check all active touches to determine button states
        this.mouseButton.left = Array.from(this._activePointers.values()).some((touch)=>(touch.buttons & 1) !== 0);
        this.mouseButton.center = Array.from(this._activePointers.values()).some((touch)=>(touch.buttons & 4) !== 0);
        this.mouseButton.right = Array.from(this._activePointers.values()).some((touch)=>(touch.buttons & 2) !== 0);
    };
    /**
   * A function that's called when the mouse moves.
   *
   * Declaring the function `mouseMoved()` sets a code block to run
   * automatically when the user moves the mouse without clicking any mouse
   * buttons:
   *
   * ```js
   * function mouseMoved() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mouseMoved()` is called by p5.js:
   *
   * ```js
   * function mouseMoved() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mouseMoved()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse move event:
   *
   * ```js
   * function mouseMoved(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * @method mouseMoved
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square becomes lighter as the mouse moves.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * function mouseMoved() {
   *   // Update the grayscale value.
   *   value += 5;
   *
   *   // Reset the grayscale value.
   *   if (value > 255) {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ /**
   * A function that's called when the mouse moves while a button is pressed.
   *
   * Declaring the function `mouseDragged()` sets a code block to run
   * automatically when the user clicks and drags the mouse:
   *
   * ```js
   * function mouseDragged() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mouseDragged()` is called by p5.js:
   *
   * ```js
   * function mouseDragged() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mouseDragged()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse drag event:
   *
   * ```js
   * function mouseDragged(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * On touchscreen devices, `mouseDragged()` will run when a user moves a touch
   * point.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * @method mouseDragged
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square becomes lighter as the user drags the mouse.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * function mouseDragged() {
   *   // Update the grayscale value.
   *   value += 5;
   *
   *   // Reset the grayscale value.
   *   if (value > 255) {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._onpointermove = function(e) {
        let executeDefault;
        this._updatePointerCoords(e);
        this._activePointers.set(e.pointerId, e);
        this._setMouseButton(e);
        if (!this.mouseIsPressed && typeof this._customActions.mouseMoved === 'function') {
            executeDefault = this._customActions.mouseMoved(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        } else if (this.mouseIsPressed && typeof this._customActions.mouseDragged === 'function') {
            executeDefault = this._customActions.mouseDragged(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * A function that's called once when a mouse button is pressed.
   *
   * Declaring the function `mousePressed()` sets a code block to run
   * automatically when the user presses a mouse button:
   *
   * ```js
   * function mousePressed() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mousePressed()` is called by p5.js:
   *
   * ```js
   * function mousePressed() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mousePressed()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse press event:
   *
   * ```js
   * function mousePressed(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * On touchscreen devices, `mousePressed()` will run when a user’s touch
   * begins.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * Note: `mousePressed()`, <a href="#/p5/mouseReleased">mouseReleased()</a>,
   * and <a href="#/p5/mouseClicked">mouseClicked()</a> are all related.
   * `mousePressed()` runs as soon as the user clicks the mouse.
   * <a href="#/p5/mouseReleased">mouseReleased()</a> runs as soon as the user
   * releases the mouse click. <a href="#/p5/mouseClicked">mouseClicked()</a>
   * runs immediately after <a href="#/p5/mouseReleased">mouseReleased()</a>.
   *
   * @method mousePressed
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square becomes lighter when the user presses a mouse button.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * function mousePressed() {
   *   // Update the grayscale value.
   *   value += 5;
   *
   *   // Reset the grayscale value.
   *   if (value > 255) {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Style the circle.
   *   fill('orange');
   *   stroke('royalblue');
   *   strokeWeight(10);
   *
   *   describe(
   *     'An orange circle with a thick, blue border drawn on a gray background. When the user presses and holds the mouse, the border becomes thin and pink. When the user releases the mouse, the border becomes thicker and changes color to blue.'
   *   );
   * }
   *
   * function draw() {
   *   background(220);
   *
   *   // Draw the circle.
   *   circle(50, 50, 20);
   * }
   *
   * // Set the stroke color and weight as soon as the user clicks.
   * function mousePressed() {
   *   stroke('deeppink');
   *   strokeWeight(3);
   * }
   *
   * // Set the stroke and fill colors as soon as the user releases
   * // the mouse.
   * function mouseReleased() {
   *   stroke('royalblue');
   *
   *   // This is never visible because fill() is called
   *   // in mouseClicked() which runs immediately after
   *   // mouseReleased();
   *   fill('limegreen');
   * }
   *
   * // Set the fill color and stroke weight after
   * // mousePressed() and mouseReleased() are called.
   * function mouseClicked() {
   *   fill('orange');
   *   strokeWeight(10);
   * }
   * </code>
   * </div>
   */ fn._onpointerdown = function(e) {
        let executeDefault;
        this.mouseIsPressed = true;
        this._activePointers.set(e.pointerId, e);
        this._setMouseButton(e);
        this._updatePointerCoords(e);
        if (typeof this._customActions.mousePressed === 'function') {
            executeDefault = this._customActions.mousePressed(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * A function that's called once when a mouse button is released.
   *
   * Declaring the function `mouseReleased()` sets a code block to run
   * automatically when the user releases a mouse button after having pressed
   * it:
   *
   * ```js
   * function mouseReleased() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mouseReleased()` is called by p5.js:
   *
   * ```js
   * function mouseReleased() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mouseReleased()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse release event:
   *
   * ```js
   * function mouseReleased(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * On touchscreen devices, `mouseReleased()` will run when a user’s touch
   * ends.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * Note: <a href="#/p5/mousePressed">mousePressed()</a>, `mouseReleased()`,
   * and <a href="#/p5/mouseClicked">mouseClicked()</a> are all related.
   * <a href="#/p5/mousePressed">mousePressed()</a> runs as soon as the user
   * clicks the mouse. `mouseReleased()` runs as soon as the user releases the
   * mouse click. <a href="#/p5/mouseClicked">mouseClicked()</a> runs
   * immediately after `mouseReleased()`.
   *
   * @method mouseReleased
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square becomes lighter when the user presses and releases a mouse button.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * function mouseReleased() {
   *   // Update the grayscale value.
   *   value += 5;
   *
   *   // Reset the grayscale value.
   *   if (value > 255) {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Style the circle.
   *   fill('orange');
   *   stroke('royalblue');
   *   strokeWeight(10);
   *
   *   describe(
   *     'An orange circle with a thick, blue border drawn on a gray background. When the user presses and holds the mouse, the border becomes thin and pink. When the user releases the mouse, the border becomes thicker and changes color to blue.'
   *   );
   * }
   *
   * function draw() {
   *   background(220);
   *
   *   // Draw the circle.
   *   circle(50, 50, 20);
   * }
   *
   * // Set the stroke color and weight as soon as the user clicks.
   * function mousePressed() {
   *   stroke('deeppink');
   *   strokeWeight(3);
   * }
   *
   * // Set the stroke and fill colors as soon as the user releases
   * // the mouse.
   * function mouseReleased() {
   *   stroke('royalblue');
   *
   *   // This is never visible because fill() is called
   *   // in mouseClicked() which runs immediately after
   *   // mouseReleased();
   *   fill('limegreen');
   * }
   *
   * // Set the fill color and stroke weight after
   * // mousePressed() and mouseReleased() are called.
   * function mouseClicked() {
   *   fill('orange');
   *   strokeWeight(10);
   * }
   * </code>
   * </div>
   */ fn._onpointerup = function(e) {
        let executeDefault;
        this.mouseIsPressed = false;
        this._activePointers.delete(e.pointerId);
        this._setMouseButton(e);
        this._updatePointerCoords(e);
        if (typeof this._customActions.mouseReleased === 'function') {
            executeDefault = this._customActions.mouseReleased(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    fn._ondragend = fn._onpointerup;
    fn._ondragover = fn._onpointermove;
    /**
   * A function that's called once after a mouse button is pressed and released.
   *
   * Declaring the function `mouseClicked()` sets a code block to run
   * automatically when the user releases a mouse button after having pressed
   * it:
   *
   * ```js
   * function mouseClicked() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mouseClicked()` is called by p5.js:
   *
   * ```js
   * function mouseClicked() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mouseClicked()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse click event:
   *
   * ```js
   * function mouseClicked(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * On touchscreen devices, `mouseClicked()` will run when a user’s touch
   * ends.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * Note: <a href="#/p5/mousePressed">mousePressed()</a>,
   * <a href="#/p5/mouseReleased">mouseReleased()</a>,
   * and `mouseClicked()` are all related.
   * <a href="#/p5/mousePressed">mousePressed()</a> runs as soon as the user
   * clicks the mouse. <a href="#/p5/mouseReleased">mouseReleased()</a> runs as
   * soon as the user releases the mouse click. `mouseClicked()` runs
   * immediately after <a href="#/p5/mouseReleased">mouseReleased()</a>.
   *
   * @method mouseClicked
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square changes color when the user presses and releases a mouse button.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the square's color when the user clicks.
   * function mouseClicked() {
   *   if (value === 0) {
   *     value = 255;
   *   } else {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Style the circle.
   *   fill('orange');
   *   stroke('royalblue');
   *   strokeWeight(10);
   *
   *   describe(
   *     'An orange circle with a thick, blue border drawn on a gray background. When the user presses and holds the mouse, the border becomes thin and pink. When the user releases the mouse, the border becomes thicker and changes color to blue.'
   *   );
   * }
   *
   * function draw() {
   *   background(220);
   *
   *   // Draw the circle.
   *   circle(50, 50, 20);
   * }
   *
   * // Set the stroke color and weight as soon as the user clicks.
   * function mousePressed() {
   *   stroke('deeppink');
   *   strokeWeight(3);
   * }
   *
   * // Set the stroke and fill colors as soon as the user releases
   * // the mouse.
   * function mouseReleased() {
   *   stroke('royalblue');
   *
   *   // This is never visible because fill() is called
   *   // in mouseClicked() which runs immediately after
   *   // mouseReleased();
   *   fill('limegreen');
   * }
   *
   * // Set the fill color and stroke weight after
   * // mousePressed() and mouseReleased() are called.
   * function mouseClicked() {
   *   fill('orange');
   *   strokeWeight(10);
   * }
   * </code>
   * </div>
   */ fn._onclick = function(e) {
        if (typeof this._customActions.mouseClicked === 'function') {
            const executeDefault = this._customActions.mouseClicked(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * A function that's called once when a mouse button is clicked twice quickly.
   *
   * Declaring the function `doubleClicked()` sets a code block to run
   * automatically when the user presses and releases the mouse button twice
   * quickly:
   *
   * ```js
   * function doubleClicked() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `doubleClicked()` is called by p5.js:
   *
   * ```js
   * function doubleClicked() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `doubleClicked()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the double-click event:
   *
   * ```js
   * function doubleClicked(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * On touchscreen devices, code placed in `doubleClicked()` will run after two
   * touches that occur within a short time.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * @method doubleClicked
   * @param  {MouseEvent} [event] optional `MouseEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black square at its center. The inner square changes color when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the square.
   *   fill(value);
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   * }
   *
   * // Toggle the square's color when the user double-clicks.
   * function doubleClicked() {
   *   if (value === 0) {
   *     value = 255;
   *   } else {
   *     value = 0;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let value = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a black circle at its center. When the user double-clicks on the circle, it changes color to white.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the circle.
   *   fill(value);
   *
   *   // Draw the circle.
   *   circle(50, 50, 80);
   * }
   *
   * // Reassign value to 255 when the user double-clicks on the circle.
   * function doubleClicked() {
   *   if (dist(50, 50, mouseX, mouseY) < 40) {
   *     value = 255;
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._ondblclick = function(e) {
        if (typeof this._customActions.doubleClicked === 'function') {
            const executeDefault = this._customActions.doubleClicked(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * For use with WebGL orbitControl.
   * @property {Number} _mouseWheelDeltaY
   * @readOnly
   * @private
   */ fn._mouseWheelDeltaY = 0;
    /**
   * For use with WebGL orbitControl.
   * @property {Number} _pmouseWheelDeltaY
   * @readOnly
   * @private
   */ fn._pmouseWheelDeltaY = 0;
    /**
   * A function that's called once when the mouse wheel moves.
   *
   * Declaring the function `mouseWheel()` sets a code block to run
   * automatically when the user scrolls with the mouse wheel:
   *
   * ```js
   * function mouseWheel() {
   *   // Code to run.
   * }
   * ```
   *
   * The mouse system variables, such as <a href="#/p5/mouseX">mouseX</a> and
   * <a href="#/p5/mouseY">mouseY</a>, will be updated with their most recent
   * value when `mouseWheel()` is called by p5.js:
   *
   * ```js
   * function mouseWheel() {
   *   if (mouseX < 50) {
   *     // Code to run if the mouse is on the left.
   *   }
   *
   *   if (mouseY > 50) {
   *     // Code to run if the mouse is near the bottom.
   *   }
   * }
   * ```
   *
   * The parameter, `event`, is optional. `mouseWheel()` is always passed a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank">MouseEvent</a>
   * object with properties that describe the mouse scroll event:
   *
   * ```js
   * function mouseWheel(event) {
   *   // Code to run that uses the event.
   *   console.log(event);
   * }
   * ```
   *
   * The `event` object has many properties including `delta`, a `Number`
   * containing the distance that the user scrolled. For example, `event.delta`
   * might have the value 5 when the user scrolls up. `event.delta` is positive
   * if the user scrolls up and negative if they scroll down. The signs are
   * opposite on macOS with "natural" scrolling enabled.
   *
   * Browsers may have default behaviors attached to various mouse events. For
   * example, some browsers highlight text when the user moves the mouse while
   * pressing a mouse button. To prevent any default behavior for this event,
   * add `return false;` to the end of the function.
   *
   * Note: On Safari, `mouseWheel()` may only work as expected if
   * `return false;` is added at the end of the function.
   *
   * @method mouseWheel
   * @param  {WheelEvent} [event] optional `WheelEvent` argument.
   *
   * @example
   * <div>
   * <code>
   * let circleSize = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. A white circle at its center grows up when the user scrolls the mouse wheel.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the circle
   *   circle(circleSize, 50, 50);
   * }
   *
   * // Increment circleSize when the user scrolls the mouse wheel.
   * function mouseWheel() {
   *   circleSize += 1;
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let direction = '';
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square. An arrow at its center points up when the user scrolls up. The arrow points down when the user scrolls down.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Draw an arrow that points where
   *   // the mouse last scrolled.
   *   text(direction, 50, 50);
   * }
   *
   * // Change direction when the user scrolls the mouse wheel.
   * function mouseWheel(event) {
   *   if (event.delta > 0) {
   *     direction = '▲';
   *   } else {
   *     direction = '▼';
   *   }
   *   // Uncomment to prevent any default behavior.
   *   // return false;
   * }
   * </code>
   * </div>
   */ fn._onwheel = function(e) {
        this._mouseWheelDeltaY = e.deltaY;
        if (typeof this._customActions.mouseWheel === 'function') {
            e.delta = e.deltaY;
            const executeDefault = this._customActions.mouseWheel(e);
            if (executeDefault === false) {
                e.preventDefault();
            }
        }
    };
    /**
   * Locks the mouse pointer to its current position and makes it invisible.
   *
   * `requestPointerLock()` allows the mouse to move forever without leaving the
   * screen. Calling `requestPointerLock()` locks the values of
   * <a href="#/p5/mouseX">mouseX</a>, <a href="#/p5/mouseY">mouseY</a>,
   * <a href="#/p5/pmouseX">pmouseX</a>, and <a href="#/p5/pmouseY">pmouseY</a>.
   * <a href="#/p5/movedX">movedX</a> and <a href="#/p5/movedY">movedY</a>
   * continue updating and can be used to get the distance the mouse moved since
   * the last frame was drawn. Calling
   * <a href="#/p5/exitPointerLock">exitPointerLock()</a> resumes updating the
   * mouse system variables.
   *
   * Note: Most browsers require an input, such as a click, before calling
   * `requestPointerLock()`. It’s recommended to call `requestPointerLock()` in
   * an event function such as <a href="#/p5/doubleClicked">doubleClicked()</a>.
   *
   * @method requestPointerLock
   *
   * @example
   * <div>
   * <code>
   * let score = 0;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with the text "Score: X" at its center. The score increases when the user moves the mouse upward. It decreases when the user moves the mouse downward.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update the score.
   *   score -= movedY;
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the score.
   *   text(`Score: ${score}`, 50, 50);
   * }
   *
   * // Lock the pointer when the user double-clicks.
   * function doubleClicked() {
   *   requestPointerLock();
   * }
   * </code>
   * </div>
   */ fn.requestPointerLock = function() {
        // pointer lock object forking for cross browser
        const canvas = this._curElement.elt;
        canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
        if (!canvas.requestPointerLock) {
            console.log('requestPointerLock is not implemented in this browser');
            return false;
        }
        canvas.requestPointerLock();
        return true;
    };
    /**
   * Exits a pointer lock started with
   * <a href="#/p5/requestPointerLock">requestPointerLock</a>.
   *
   * Calling `requestPointerLock()` locks the values of
   * <a href="#/p5/mouseX">mouseX</a>, <a href="#/p5/mouseY">mouseY</a>,
   * <a href="#/p5/pmouseX">pmouseX</a>, and <a href="#/p5/pmouseY">pmouseY</a>.
   * Calling `exitPointerLock()` resumes updating the mouse system variables.
   *
   * Note: Most browsers require an input, such as a click, before calling
   * `requestPointerLock()`. It’s recommended to call `requestPointerLock()` in
   * an event function such as <a href="#/p5/doubleClicked">doubleClicked()</a>.
   *
   * @method exitPointerLock
   *
   * @example
   * <div>
   * <code>
   * let isLocked = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a word at its center. The word changes between "Unlocked" and "Locked" when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Tell the user whether the pointer is locked.
   *   if (isLocked === true) {
   *     text('Locked', 50, 50);
   *   } else {
   *     text('Unlocked', 50, 50);
   *   }
   * }
   *
   * // Toggle the pointer lock when the user double-clicks.
   * function doubleClicked() {
   *   if (isLocked === true) {
   *     exitPointerLock();
   *     isLocked = false;
   *   } else {
   *     requestPointerLock();
   *     isLocked = true;
   *   }
   * }
   * </code>
   * </div>
   */ fn.exitPointerLock = function() {
        document.exitPointerLock();
    };
}
if (typeof p5 !== 'undefined') {
    pointer(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/events/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>events
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$acceleration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/acceleration.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$keyboard$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/keyboard.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$pointer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/pointer.js [app-ssr] (ecmascript)");
;
;
;
function events(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$acceleration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$keyboard$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$pointer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/utilities/conversion.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>conversion
]);
/**
 * @module Data
 * @submodule Conversion
 * @for p5
 * @requires core
 */ function conversion(p51, fn) {
    /**
   * Converts a `String` to a floating point (decimal) `Number`.
   *
   * `float()` converts strings that resemble numbers, such as `'12.34'`, into
   * numbers.
   *
   * The parameter, `str`, is the string value to convert. For example, calling
   * `float('12.34')` returns the number `12.34`.  If an array of strings is
   * passed, as in `float(['12.34', '56.78'])`, then an array of numbers will be
   * returned.
   *
   * Note: If a string can't be converted to a number, as in `float('giraffe')`,
   * then the value `NaN` (not a number) will be returned.
   *
   * @method float
   * @param {String}  str string to convert.
   * @return {Number} converted number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = '12.3';
   *
   *   // Convert the string to a number.
   *   let converted = float(original);
   *
   *   // Double the converted value.
   *   let twice = converted * 2;
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(12);
   *
   *   // Display the original and converted values.
   *   text(`${original} × 2 = ${twice}`, 50, 50);
   *
   *   describe('The text "12.3 × 2 = 24.6" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of strings.
   *   let original = ['60', '30', '15'];
   *
   *   // Convert the strings to numbers.
   *   let diameters = float(original);
   *
   *   for (let d of diameters) {
   *     // Draw a circle.
   *     circle(50, 50, d);
   *   }
   *
   *   describe('Three white, concentric circles on a gray background.');
   * }
   * </code>
   * </div>
   */ /**
   * @method float
   * @param {String[]} ns array of strings to convert.
   * @return {Number[]} converted numbers.
   */ fn.float = function(str) {
        if (str instanceof Array) {
            return str.map(parseFloat);
        }
        return parseFloat(str);
    };
    /**
   * Converts a `Boolean`, `String`, or decimal `Number` to an integer.
   *
   * `int()` converts values to integers. Integers are positive or negative
   * numbers without decimals. If the original value has decimals, as in -34.56,
   * they're removed to produce an integer such as -34.
   *
   * The parameter, `n`, is the value to convert. If `n` is a Boolean, as in
   * `int(false)` or `int(true)`, then the number 0 (`false`) or 1 (`true`) will
   * be returned. If `n` is a string or number, as in `int('45')` or
   * `int(67.89)`, then an integer will be returned. If an array is passed, as
   * in `int([12.34, 56.78])`, then an array of integers will be returned.
   *
   * Note: If a value can't be converted to a number, as in `int('giraffe')`,
   * then the value `NaN` (not a number) will be returned.
   *
   * @method int
   * @param {String|Boolean|Number} n value to convert.
   * @return {Number} converted number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a Boolean variable.
   *   let original = false;
   *
   *   // Convert the Boolean to an integer.
   *   let converted = int(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "false : 0" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = '12.34';
   *
   *   // Convert the string to an integer.
   *   let converted = int(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Display the original and converted values.
   *   text(`${original} ≈ ${converted}`, 50, 50);
   *
   *   describe('The text "12.34 ≈ 12" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a decimal number variable.
   *   let original = 12.34;
   *
   *   // Convert the decimal number to an integer.
   *   let converted = int(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Display the original and converted values.
   *   text(`${original} ≈ ${converted}`, 50, 50);
   *
   *   describe('The text "12.34 ≈ 12" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of strings.
   *   let original = ['60', '30', '15'];
   *
   *   // Convert the strings to integers.
   *   let diameters = int(original);
   *
   *   for (let d of diameters) {
   *     // Draw a circle.
   *     circle(50, 50, d);
   *   }
   *
   *   describe('Three white, concentric circles on a gray background.');
   * }
   * </code>
   * </div>
   */ /**
   * @method int
   * @param {Array} ns values to convert.
   * @return {Number[]} converted numbers.
   */ fn.int = function(n, radix = 10) {
        if (n === Infinity || n === 'Infinity') {
            return Infinity;
        } else if (n === -Infinity || n === '-Infinity') {
            return -Infinity;
        } else if (typeof n === 'string') {
            return parseInt(n, radix);
        } else if (typeof n === 'number') {
            return n | 0;
        } else if (typeof n === 'boolean') {
            return n ? 1 : 0;
        } else if (n instanceof Array) {
            return n.map((n)=>fn.int(n, radix));
        }
    };
    /**
   * Converts a `Boolean` or `Number` to `String`.
   *
   * `str()` converts values to strings. See the
   * <a href="#/p5/String">String</a> reference page for guidance on using
   * template literals instead.
   *
   * The parameter, `n`, is the value to convert. If `n` is a Boolean, as in
   * `str(false)` or `str(true)`, then the value will be returned as a string,
   * as in `'false'` or `'true'`. If `n` is a number, as in `str(123)`, then its
   * value will be returned as a string, as in `'123'`. If an array is passed,
   * as in `str([12.34, 56.78])`, then an array of strings will be returned.
   *
   * @method str
   * @param {String|Boolean|Number} n value to convert.
   * @return {String} converted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a Boolean variable.
   *   let original = false;
   *
   *   // Convert the Boolean to a string.
   *   let converted = str(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "false : false" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 123;
   *
   *   // Convert the number to a string.
   *   let converted = str(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} = ${converted}`, 50, 50);
   *
   *   describe('The text "123 = 123" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let original = [12, 34, 56];
   *
   *   // Convert the numbers to strings.
   *   let strings = str(original);
   *
   *   // Create an empty string variable.
   *   let final = '';
   *
   *   // Concatenate all the strings.
   *   for (let s of strings) {
   *     final += s;
   *   }
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the concatenated string.
   *   text(final, 50, 50);
   *
   *   describe('The text "123456" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */ fn.str = function(n) {
        if (n instanceof Array) {
            return n.map(fn.str);
        } else {
            return String(n);
        }
    };
    /**
   * Converts a `String` or `Number` to a `Boolean`.
   *
   * `boolean()` converts values to `true` or `false`.
   *
   * The parameter, `n`, is the value to convert. If `n` is a string, then
   * `boolean('true')` will return `true` and every other string value will
   * return `false`. If `n` is a number, then `boolean(0)` will return `false`
   * and every other numeric value will return `true`. If an array is passed, as
   * `in boolean([0, 1, 'true', 'blue'])`, then an array of Boolean values will
   * be returned.
   *
   * @method boolean
   * @param {String|Boolean|Number} n value to convert.
   * @return {Boolean} converted Boolean value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 0;
   *
   *   // Convert the number to a Boolean value.
   *   let converted = boolean(original);
   *
   *   // Style the circle based on the converted value.
   *   if (converted === true) {
   *     fill('blue');
   *   } else {
   *     fill('red');
   *   }
   *
   *   // Draw the circle.
   *   circle(50, 50, 40);
   *
   *   describe('A red circle on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = 'true';
   *
   *   // Convert the string to a Boolean value.
   *   let converted = boolean(original);
   *
   *   // Style the circle based on the converted value.
   *   if (converted === true) {
   *     fill('blue');
   *   } else {
   *     fill('red');
   *   }
   *
   *   // Draw the circle.
   *   circle(50, 50, 40);
   *
   *   describe('A blue circle on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of values.
   *   let original = [0, 'hi', 123, 'true'];
   *
   *   // Convert the array to a Boolean values.
   *   let converted = boolean(original);
   *
   *   // Iterate over the array of converted Boolean values.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Style the circle based on the converted value.
   *     if (converted[i] === true) {
   *       fill('blue');
   *     } else {
   *       fill('red');
   *     }
   *
   *     // Calculate the x-coordinate.
   *     let x = (i + 1) * 20;
   *
   *     // Draw the circle.
   *     circle(x, 50, 15);
   *   }
   *
   *   describe(
   *     'A row of circles on a gray background. The two circles on the left are red and the two on the right are blue.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method boolean
   * @param {Array} ns values to convert.
   * @return {Boolean[]} converted Boolean values.
   */ fn.boolean = function(n) {
        if (typeof n === 'number') {
            return n !== 0;
        } else if (typeof n === 'string') {
            return n.toLowerCase() === 'true';
        } else if (typeof n === 'boolean') {
            return n;
        } else if (n instanceof Array) {
            return n.map(fn.boolean);
        }
    };
    /**
   * Converts a `Boolean`, `String`, or `Number` to its byte value.
   *
   * `byte()` converts a value to an integer (whole number) between -128 and
   * 127. Values greater than 127 wrap around while negative values are
   * unchanged. For example, 128 becomes -128 and -129 remains the same.
   *
   * The parameter, `n`, is the value to convert. If `n` is a Boolean, as in
   * `byte(false)` or `byte(true)`, the number 0 (`false`) or 1 (`true`) will be
   * returned. If `n` is a string or number, as in `byte('256')` or `byte(256)`,
   * then the byte value will be returned. Decimal values are ignored. If an
   * array is passed, as in `byte([true, 123, '456'])`, then an array of byte
   * values will be returned.
   *
   * Note: If a value can't be converted to a number, as in `byte('giraffe')`,
   * then the value `NaN` (not a number) will be returned.
   *
   * @method byte
   * @param {String|Boolean|Number} n value to convert.
   * @return {Number} converted byte value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a Boolean variable.
   *   let original = true;
   *
   *   // Convert the Boolean to its byte value.
   *   let converted = byte(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "true : 1" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = '256';
   *
   *   // Convert the string to its byte value.
   *   let converted = byte(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "256 : 0" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 256;
   *
   *   // Convert the number to its byte value.
   *   let converted = byte(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "256 : 0" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of values.
   *   let original = [false, '64', 383];
   *
   *   // Convert the array elements to their byte values.
   *   let converted = byte(original);
   *
   *   // Iterate over the converted array elements.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Style the circle.
   *     fill(converted[i]);
   *
   *     // Calculate the x-coordinate.
   *     let x = (i + 1) * 25;
   *
   *     // Draw the circle.
   *     circle(x, 50, 20);
   *   }
   *
   *   describe(
   *     'Three gray circles on a gray background. The circles get lighter from left to right.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method byte
   * @param {Array} ns values to convert.
   * @return {Number[]} converted byte values.
   */ fn.byte = function(n) {
        const nn = fn.int(n, 10);
        if (typeof nn === 'number') {
            return (nn + 128) % 256 - 128;
        } else if (nn instanceof Array) {
            return nn.map(fn.byte);
        }
    };
    /**
   * Converts a `Number` or `String` to a single-character `String`.
   *
   * `char()` converts numbers to their single-character string representations.
   *
   * The parameter, `n`, is the value to convert. If a number is passed, as in
   * `char(65)`, the corresponding single-character string is returned. If a
   * string is passed, as in `char('65')`, the string is converted to an integer
   * (whole number) and the corresponding single-character string is returned.
   * If an array is passed, as in `char([65, 66, 67])`, an array of
   * single-character strings is returned.
   *
   * See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode" target="_blank">MDN</a>
   * for more information about conversions.
   *
   * @method char
   * @param {String|Number} n value to convert.
   * @return {String} converted single-character string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 65;
   *
   *   // Convert the number to a char.
   *   let converted = char(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "65 : A" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = '65';
   *
   *   // Convert the string to a char.
   *   let converted = char(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "65 : A" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let original = ['65', 66, '67'];
   *
   *   // Convert the string to a char.
   *   let converted = char(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Iterate over elements of the converted array.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the original and converted values.
   *     text(`${original[i]} : ${converted[i]}`, 50, y);
   *   }
   *
   *   describe(
   *     'The text "65 : A", "66 : B", and "67 : C" written on three separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method char
   * @param {Array} ns values to convert.
   * @return {String[]} converted single-character strings.
   */ fn.char = function(n) {
        if (typeof n === 'number' && !isNaN(n)) {
            return String.fromCharCode(n);
        } else if (n instanceof Array) {
            return n.map(fn.char);
        } else if (typeof n === 'string') {
            return fn.char(parseInt(n, 10));
        }
    };
    /**
   * Converts a single-character `String` to a `Number`.
   *
   * `unchar()` converts single-character strings to their corresponding
   * integer (whole number).
   *
   * The parameter, `n`, is the character to convert. For example,
   * `unchar('A')`, returns the number 65. If an array is passed, as in
   * `unchar(['A', 'B', 'C'])`, an array of integers is returned.
   *
   * @method unchar
   * @param {String} n value to convert.
   * @return {Number} converted number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let original = 'A';
   *
   *   // Convert the string to a number.
   *   let converted = unchar(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} : ${converted}`, 50, 50);
   *
   *   describe('The text "A : 65" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of characters.
   *   let original = ['A', 'B', 'C'];
   *
   *   // Convert the string to a number.
   *   let converted = unchar(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Iterate over elements of the converted array.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the original and converted values.
   *     text(`${original[i]} : ${converted[i]}`, 50, y);
   *   }
   *
   *   describe(
   *     'The text "A : 65", "B : 66", and "C :67" written on three separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method unchar
   * @param {String[]} ns values to convert.
   * @return {Number[]} converted numbers.
   */ fn.unchar = function(n) {
        if (typeof n === 'string' && n.length === 1) {
            return n.charCodeAt(0);
        } else if (n instanceof Array) {
            return n.map(fn.unchar);
        }
    };
    /**
   * Converts a `Number` to a `String` with its hexadecimal value.
   *
   * `hex()` converts a number to a string with its hexadecimal number value.
   * Hexadecimal (hex) numbers are base-16, which means there are 16 unique
   * digits. Hex extends the numbers 0–9 with the letters A–F. For example, the
   * number `11` (eleven) in base-10 is written as the letter `B` in hex.
   *
   * The first parameter, `n`, is the number to convert. For example, `hex(20)`,
   * returns the string `'00000014'`. If an array is passed, as in
   * `hex([1, 10, 100])`, an array of hexadecimal strings is returned.
   *
   * The second parameter, `digits`, is optional. If a number is passed, as in
   * `hex(20, 2)`, it sets the number of hexadecimal digits to display. For
   * example, calling `hex(20, 2)` returns the string `'14'`.
   *
   * @method hex
   * @param {Number} n value to convert.
   * @param {Number} [digits] number of digits to include.
   * @return {String} converted hexadecimal value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 20;
   *
   *   // Convert the number to a hex string.
   *   let converted = hex(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Display the original and converted values.
   *   text(`${original} = ${converted}`, 50, 50);
   *
   *   describe('The text "20 = 00000014" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let original = 20;
   *
   *   // Convert the number to a hex string.
   *   // Only display two hex digits.
   *   let converted = hex(original, 2);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} = ${converted}`, 50, 50);
   *
   *   describe('The text "20 = 14" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let original = [1, 10, 100];
   *
   *   // Convert the numbers to hex strings.
   *   // Only use two hex digits.
   *   let converted = hex(original, 2);
   *
   *   // Style the text.
   *   textAlign(RIGHT, CENTER);
   *   textSize(16);
   *
   *   // Iterate over the converted values.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the original and converted values.
   *     text(`${ original[i]} = ${converted[i]}`, 75, y);
   *   }
   *
   *   describe(
   *     'The text "1 = 01", "10 = 0A", and "100 = 64" written on three separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method hex
   * @param {Number[]} ns values to convert.
   * @param {Number} [digits]
   * @return {String[]} converted hexadecimal values.
   */ fn.hex = function(n, digits) {
        digits = digits === undefined || digits === null ? digits = 8 : digits;
        if (n instanceof Array) {
            return n.map((n)=>fn.hex(n, digits));
        } else if (n === Infinity || n === -Infinity) {
            const c = n === Infinity ? 'F' : '0';
            return c.repeat(digits);
        } else if (typeof n === 'number') {
            if (n < 0) {
                n = 0xffffffff + n + 1;
            }
            let hex = Number(n).toString(16).toUpperCase();
            while(hex.length < digits){
                hex = `0${hex}`;
            }
            if (hex.length >= digits) {
                hex = hex.substring(hex.length - digits, hex.length);
            }
            return hex;
        }
    };
    /**
   * Converts a `String` with a hexadecimal value to a  `Number`.
   *
   * `unhex()` converts a string with its hexadecimal number value to a number.
   * Hexadecimal (hex) numbers are base-16, which means there are 16 unique
   * digits. Hex extends the numbers 0–9 with the letters A–F. For example, the
   * number `11` (eleven) in base-10 is written as the letter `B` in hex.
   *
   * The first parameter, `n`, is the hex string to convert. For example,
   * `unhex('FF')`, returns the number 255. If an array is passed, as in
   * `unhex(['00', '80', 'FF'])`, an array of numbers is returned.
   *
   * @method unhex
   * @param {String} n value to convert.
   * @return {Number} converted number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a a hex string variable
   *   let original = 'FF';
   *
   *   // Convert the hex string to a number.
   *   let converted = unhex(original);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(16);
   *
   *   // Display the original and converted values.
   *   text(`${original} = ${converted}`, 50, 50);
   *
   *   describe('The text "FF = 255" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let original = ['00', '80', 'FF'];
   *
   *   // Convert the numbers to hex strings.
   *   // Only use two hex digits.
   *   let converted = unhex(original, 2);
   *
   *   // Style the text.
   *   textAlign(RIGHT, CENTER);
   *   textSize(16);
   *
   *   // Iterate over the converted values.
   *   for (let i = 0; i < converted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the original and converted values.
   *     text(`${ original[i]} = ${converted[i]}`, 80, y);
   *   }
   *
   *   describe(
   *     'The text "00 = 0", "80 = 128", and "FF = 255" written on three separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method unhex
   * @param {String[]} ns values to convert.
   * @return {Number[]} converted numbers.
   */ fn.unhex = function(n) {
        if (n instanceof Array) {
            return n.map(fn.unhex);
        } else {
            return parseInt(`0x${n}`, 16);
        }
    };
}
if (typeof p5 !== 'undefined') {
    conversion(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/utilities/utility_functions.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>utilityFunctions
]);
/**
 * @module Data
 * @submodule Utility Functions
 * @for p5
 * @requires core
 */ function utilityFunctions(p51, fn) {
    /**
   * Converts a `Number` into a `String` with a given number of digits.
   *
   * `nf()` converts numbers such as `123.45` into strings formatted with a set
   * number of digits, as in `'123.4500'`.
   *
   * The first parameter, `num`, is the number to convert to a string. For
   * example, calling `nf(123.45)` returns the string `'123.45'`. If an array of
   * numbers is passed, as in `nf([123.45, 67.89])`, an array of formatted
   * strings will be returned.
   *
   * The second parameter, `left`, is optional. If a number is passed, as in
   * `nf(123.45, 4)`, it sets the minimum number of digits to include to the
   * left of the decimal place. If `left` is larger than the number of digits in
   * `num`, then unused digits will be set to 0. For example, calling
   * `nf(123.45, 4)` returns the string `'0123.45'`.
   *
   * The third parameter, `right`, is also optional. If a number is passed, as
   * in `nf(123.45, 4, 1)`, it sets the minimum number of digits to include to
   * the right of the decimal place. If `right` is smaller than the number of
   * decimal places in `num`, then `num` will be rounded to the given number of
   * decimal places. For example, calling `nf(123.45, 4, 1)` returns the string
   * `'0123.5'`. If right is larger than the number of decimal places in `num`,
   * then unused decimal places will be set to 0. For example, calling
   * `nf(123.45, 4, 3)` returns the string `'0123.450'`.
   *
   * When the number is negative, for example, calling `nf(-123.45, 5, 2)`
   * returns the string `'-00123.45'`.
   *
   * @method nf
   * @param {Number|String} num number to format.
   * @param {Integer|String} [left] number of digits to include to the left of
   *                                the decimal point.
   * @param {Integer|String} [right] number of digits to include to the right
   *                                 of the decimal point.
   * @return {String} formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(16);
   *
   *   // Create a number variable.
   *   let number = 123.45;
   *
   *   // Display the number as a string.
   *   let formatted = nf(number);
   *   text(formatted, 20, 20);
   *
   *   let negative = nf(-number, 4, 2);
   *   text(negative, 20, 40);
   *
   *   // Display the number with four digits
   *   // to the left of the decimal.
   *   let left = nf(number, 4);
   *   text(left, 20, 60);
   *
   *   // Display the number with four digits
   *   // to the left of the decimal and one
   *   // to the right.
   *   let right = nf(number, 4, 1);
   *   text(right, 20, 80);
   *
   *   describe(
   *     'The numbers "123.45", "-0123.45", "0123.45", and "0123.5" written on four separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method nf
   * @param {Number[]} nums numbers to format.
   * @param {Integer|String} [left]
   * @param {Integer|String} [right]
   * @return {String[]} formatted strings.
   */ fn.nf = function(nums, left, right) {
        // p5._validateParameters('nf', arguments);
        if (nums instanceof Array) {
            return nums.map((x)=>doNf(x, left, right));
        } else {
            const typeOfFirst = Object.prototype.toString.call(nums);
            if (typeOfFirst === '[object Arguments]') {
                if (nums.length === 3) {
                    return this.nf(nums[0], nums[1], nums[2]);
                } else if (nums.length === 2) {
                    return this.nf(nums[0], nums[1]);
                } else {
                    return this.nf(nums[0]);
                }
            } else {
                return doNf(nums, left, right);
            }
        }
    };
    function doNf(num, left, right) {
        let isNegative = num < 0;
        num = Math.abs(num);
        let [leftPart, rightPart] = num.toString().split('.');
        if (typeof right === 'undefined') {
            leftPart = leftPart.padStart(left, '0');
            let result = rightPart ? leftPart + '.' + rightPart : leftPart;
            return isNegative ? '-' + result : result;
        } else {
            let roundedOff = num.toFixed(right);
            [leftPart, rightPart] = roundedOff.toString().split('.');
            leftPart = leftPart.padStart(left, '0');
            let result = typeof rightPart === 'undefined' ? leftPart : leftPart + '.' + rightPart;
            return isNegative ? '-' + result : result;
        }
    }
    /**
   * Converts a `Number` into a `String` with commas to mark units of 1,000.
   *
   * `nfc()` converts numbers such as 12345 into strings formatted with commas
   * to mark the thousands place, as in `'12,345'`.
   *
   * The first parameter, `num`, is the number to convert to a string. For
   * example, calling `nfc(12345)` returns the string `'12,345'`.
   *
   * The second parameter, `right`, is optional. If a number is passed, as in
   * `nfc(12345, 1)`, it sets the minimum number of digits to include to the
   * right of the decimal place. If `right` is smaller than the number of
   * decimal places in `num`, then `num` will be rounded to the given number of
   * decimal places. For example, calling `nfc(12345.67, 1)` returns the string
   * `'12,345.7'`. If `right` is larger than the number of decimal places in
   * `num`, then unused decimal places will be set to 0. For example, calling
   * `nfc(12345.67, 3)` returns the string `'12,345.670'`.
   *
   * @method nfc
   * @param  {Number|String} num number to format.
   * @param  {Integer|String} [right] number of digits to include to the right
   *                                  of the decimal point.
   * @return {String} formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(16);
   *
   *   // Create a number variable.
   *   let number = 12345;
   *
   *   // Display the number as a string.
   *   let commas = nfc(number);
   *   text(commas, 15, 33);
   *
   *   // Display the number with four digits
   *   // to the left of the decimal.
   *   let decimals = nfc(number, 2);
   *   text(decimals, 15, 67);
   *
   *   describe(
   *     'The numbers "12,345" and "12,345.00" written on separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let numbers = [12345, 6789];
   *
   *   // Convert the numbers to formatted strings.
   *   let formatted = nfc(numbers);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < formatted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 33;
   *
   *     // Display the original and formatted numbers.
   *     text(`${numbers[i]} : ${formatted[i]}`, 50, y);
   *   }
   *
   *   describe(
   *     'The text "12345 : 12,345" and "6789 : 6,789" written on two separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method nfc
   * @param  {Number[]} nums numbers to format.
   * @param  {Integer|String} [right]
   * @return {String[]} formatted strings.
   */ fn.nfc = function(num, right) {
        // p5._validateParameters('nfc', arguments);
        if (num instanceof Array) {
            return num.map((x)=>doNfc(x, right));
        } else {
            return doNfc(num, right);
        }
    };
    function doNfc(num, right) {
        num = num.toString();
        const dec = num.indexOf('.');
        let rem = dec !== -1 ? num.substring(dec) : '';
        let n = dec !== -1 ? num.substring(0, dec) : num;
        n = n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        if (right === 0) {
            rem = '';
        } else if (typeof right !== 'undefined') {
            if (right > rem.length) {
                rem += dec === -1 ? '.' : '';
                const len = right - rem.length + 1;
                for(let i = 0; i < len; i++){
                    rem += '0';
                }
            } else {
                rem = rem.substring(0, right + 1);
            }
        }
        return n + rem;
    }
    /**
   * Converts a `Number` into a `String` with a plus or minus sign.
   *
   * `nfp()` converts numbers such as 123 into strings formatted with a `+` or
   * `-` symbol to mark whether they're positive or negative, as in `'+123'`.
   *
   * The first parameter, `num`, is the number to convert to a string. For
   * example, calling `nfp(123.45)` returns the string `'+123.45'`. If an array
   * of numbers is passed, as in `nfp([123.45, -6.78])`, an array of formatted
   * strings will be returned.
   *
   * The second parameter, `left`, is optional. If a number is passed, as in
   * `nfp(123.45, 4)`, it sets the minimum number of digits to include to the
   * left of the decimal place. If `left` is larger than the number of digits in
   * `num`, then unused digits will be set to 0. For example, calling
   * `nfp(123.45, 4)` returns the string `'+0123.45'`.
   *
   * The third parameter, `right`, is also optional. If a number is passed, as
   * in `nfp(123.45, 4, 1)`, it sets the minimum number of digits to include to
   * the right of the decimal place. If `right` is smaller than the number of
   * decimal places in `num`, then `num` will be rounded to the given number of
   * decimal places.  For example, calling `nfp(123.45, 4, 1)` returns the
   * string `'+0123.5'`. If `right` is larger than the number of decimal places
   * in `num`, then unused decimal places will be set to 0.  For example,
   * calling `nfp(123.45, 4, 3)` returns the string `'+0123.450'`.
   *
   * @method nfp
   * @param {Number} num number to format.
   * @param {Integer} [left] number of digits to include to the left of the
   *                         decimal point.
   * @param {Integer} [right] number of digits to include to the right of the
   *                          decimal point.
   * @return {String} formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create number variables.
   *   let positive = 123;
   *   let negative = -123;
   *
   *   // Convert the positive number to a formatted string.
   *   let p = nfp(positive);
   *
   *   // Convert the negative number to a formatted string
   *   // with four digits to the left of the decimal
   *   // and two digits to the right of the decimal.
   *   let n = nfp(negative, 4, 2);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Display the original and formatted numbers.
   *   text(`${positive} : ${p}`, 50, 33);
   *   text(`${negative} : ${n}`, 50, 67);
   *
   *   describe(
   *     'The text "123 : +123" and "-123 : -123.00" written on separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create number variables.
   *   let numbers = [123, -4.56];
   *
   *   // Convert the numbers to formatted strings
   *   // with four digits to the left of the decimal
   *   // and one digit to the right of the decimal.
   *   let formatted = nfp(numbers, 4, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < formatted.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 33;
   *
   *     // Display the original and formatted numbers.
   *     text(`${numbers[i]} : ${formatted[i]}`, 50, y);
   *   }
   *
   *   describe(
   *     'The text "123 : +0123.0" and "-4.56 : 00-4.6" written on separate lines. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method nfp
   * @param {Number[]} nums numbers to format.
   * @param {Integer} [left]
   * @param {Integer} [right]
   * @return {String[]} formatted strings.
   */ fn.nfp = function(...args) {
        // p5._validateParameters('nfp', args);
        const nfRes = fn.nf.apply(this, args);
        if (nfRes instanceof Array) {
            return nfRes.map(addNfp);
        } else {
            return addNfp(nfRes);
        }
    };
    function addNfp(num) {
        return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
    }
    /**
   * Converts a positive `Number` into a `String` with an extra space in front.
   *
   * `nfs()` converts positive numbers such as 123.45 into strings formatted
   * with an extra space in front, as in ' 123.45'. Doing so can be helpful for
   * aligning positive and negative numbers.
   *
   * The first parameter, `num`, is the number to convert to a string. For
   * example, calling `nfs(123.45)` returns the string `' 123.45'`.
   *
   * The second parameter, `left`, is optional. If a number is passed, as in
   * `nfs(123.45, 4)`, it sets the minimum number of digits to include to the
   * left of the decimal place. If `left` is larger than the number of digits in
   * `num`, then unused digits will be set to 0. For example, calling
   * `nfs(123.45, 4)` returns the string `' 0123.45'`.
   *
   * The third parameter, `right`, is also optional. If a number is passed, as
   * in `nfs(123.45, 4, 1)`, it sets the minimum number of digits to include to
   * the right of the decimal place. If `right` is smaller than the number of
   * decimal places in `num`, then `num` will be rounded to the given number of
   * decimal places.  For example, calling `nfs(123.45, 4, 1)` returns the
   * string `' 0123.5'`. If `right` is larger than the number of decimal places
   * in `num`, then unused decimal places will be set to 0.  For example,
   * calling `nfs(123.45, 4, 3)` returns the string `' 0123.450'`.
   *
   * @method nfs
   * @param {Number} num number to format.
   * @param {Integer} [left] number of digits to include to the left of the
   *                         decimal point.
   * @param {Integer} [right] number of digits to include to the right of the
   *                          decimal point.
   * @return {String} formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create number variables.
   *   let positive = 123;
   *   let negative = -123;
   *
   *   // Convert the positive number to a formatted string.
   *   let formatted = nfs(positive);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(16);
   *
   *   // Display the negative number and the formatted positive number.
   *   text(negative, 50, 33);
   *   text(formatted, 50, 67);
   *
   *   describe(
   *     'The numbers -123 and 123 written on separate lines. The numbers align vertically. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a number variable.
   *   let number = 123.45;
   *
   *   // Convert the positive number to a formatted string.
   *   // Use four digits to the left of the decimal and
   *   // one digit to the right.
   *   let formatted = nfs(number, 4, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(16);
   *
   *   // Display a negative version of the number and
   *   // the formatted positive version.
   *   text('-0123.5', 50, 33);
   *   text(formatted, 50, 67);
   *
   *   describe(
   *     'The numbers "-0123.5" and "0123.5" written on separate lines. The numbers align vertically. The text is in black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ /**
   * @method nfs
   * @param {Array} nums numbers to format.
   * @param {Integer} [left]
   * @param {Integer} [right]
   * @return {String[]} formatted strings.
   */ fn.nfs = function(...args) {
        // p5._validateParameters('nfs', args);
        const nfRes = fn.nf.apply(this, args);
        if (nfRes instanceof Array) {
            return nfRes.map(addNfs);
        } else {
            return addNfs(nfRes);
        }
    };
    function addNfs(num) {
        return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
    }
    /**
   * Splits a `String` into pieces and returns an array containing the pieces.
   *
   * `splitTokens()` is an enhanced version of
   * <a href="#/p5/split">split()</a>. It can split a string when any characters
   * from a list are detected.
   *
   * The first parameter, `value`, is the string to split.
   *
   * The second parameter, `delim`, is optional. It sets the character(s) that
   * should be used to split the string. `delim` can be a single string, as in
   * `splitTokens('rock...paper...scissors...shoot', '...')`, or an array of
   * strings, as in
   * `splitTokens('rock;paper,scissors...shoot, [';', ',', '...'])`. By default,
   * if no `delim` characters are specified, then any whitespace character is
   * used to split. Whitespace characters include tab (`\t`), line feed (`\n`),
   * carriage return (`\r`), form feed (`\f`), and space.
   *
   * @method splitTokens
   * @deprecated This will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String} value string to split.
   * @param  {String} [delim] character(s) to use for splitting the string.
   * @return {String[]} separated strings.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let string = 'rock paper scissors shoot';
   *
   *   // Split the string at each space.
   *   let words = splitTokens(string);
   *
   *   // Print the array to the console.
   *   print(words);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Iterate over the words array.
   *   for (let i = 0; i < words.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Display the word.
   *     text(words[i], 50, y);
   *   }
   *
   *   describe(
   *     'The words "rock", "paper", "scissors", and "shoot" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let string = 'rock...paper...scissors...shoot';
   *
   *   // Split the string at each ...
   *   let words = splitTokens(string, '...');
   *
   *   // Print the array to the console.
   *   print(words);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Iterate over the words array.
   *   for (let i = 0; i < words.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Display the word.
   *     text(words[i], 50, y);
   *   }
   *
   *   describe(
   *     'The words "rock", "paper", "scissors", and "shoot" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a string variable.
   *   let string = 'rock;paper,scissors...shoot';
   *
   *   // Split the string at each semicolon, comma, or ...
   *   let words = splitTokens(string, [';', ',', '...']);
   *
   *   // Print the array to the console.
   *   print(words);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Iterate over the words array.
   *   for (let i = 0; i < words.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Display the word.
   *     text(words[i], 50, y);
   *   }
   *
   *   describe(
   *     'The words "rock", "paper", "scissors", and "shoot" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.splitTokens = function(value, delims) {
        // p5._validateParameters('splitTokens', arguments);
        let d;
        if (typeof delims !== 'undefined') {
            let str = delims;
            const sqc = /\]/g.exec(str);
            let sqo = /\[/g.exec(str);
            if (sqo && sqc) {
                str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
                sqo = /\[/g.exec(str);
                str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
                d = new RegExp(`[\\[${str}\\]]`, 'g');
            } else if (sqc) {
                str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
                d = new RegExp(`[${str}\\]]`, 'g');
            } else if (sqo) {
                str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
                d = new RegExp(`[${str}\\[]`, 'g');
            } else {
                d = new RegExp(`[${str}]`, 'g');
            }
        } else {
            d = /\s/g;
        }
        return value.split(d).filter((n)=>n);
    };
    /**
   * Shuffles the elements of an array.
   *
   * The first parameter, `array`, is the array to be shuffled. For example,
   * calling `shuffle(myArray)` will shuffle the elements of `myArray`. By
   * default, the original array won’t be modified. Instead, a copy will be
   * created, shuffled, and returned.
   *
   * The second parameter, `modify`, is optional. If `true` is passed, as in
   * `shuffle(myArray, true)`, then the array will be shuffled in place without
   * making a copy.
   *
   * @method shuffle
   * @param  {Array} array array to shuffle.
   * @param  {Boolean} [bool] if `true`, shuffle the original array in place. Defaults to `false`.
   * @return {Array} shuffled array.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of colors.
   *   let colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
   *
   *   // Create a shuffled copy of the array.
   *   let shuffledColors = shuffle(colors);
   *
   *   // Draw  a row of circles using the original array.
   *   for (let i = 0; i < colors.length; i += 1) {
   *     // Calculate the x-coordinate.
   *     let x = (i + 1) * 12.5;
   *
   *     // Style the circle.
   *     let c = colors[i];
   *     fill(c);
   *
   *     // Draw the circle.
   *     circle(x, 33, 10);
   *   }
   *
   *   // Draw  a row of circles using the original array.
   *   for (let i = 0; i < shuffledColors.length; i += 1) {
   *     // Calculate the x-coordinate.
   *     let x = (i + 1) * 12.5;
   *
   *     // Style the circle.
   *     let c = shuffledColors[i];
   *     fill(c);
   *
   *     // Draw the circle.
   *     circle(x, 67, 10);
   *   }
   *
   *   describe(
   *     'Two rows of circles on a gray background. The top row follows the color sequence ROYGBIV. The bottom row has all the same colors but they are shuffled.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of colors.
   *   let colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];
   *
   *   // Shuffle the array.
   *   shuffle(colors, true);
   *
   *   // Draw  a row of circles using the original array.
   *   for (let i = 0; i < colors.length; i += 1) {
   *     // Calculate the x-coordinate.
   *     let x = (i + 1) * 12.5;
   *
   *     // Style the circle.
   *     let c = colors[i];
   *     fill(c);
   *
   *     // Draw the circle.
   *     circle(x, 50, 10);
   *   }
   *
   *   describe(
   *     'A row of colorful circles on a gray background. Their sequence changes each time the sketch runs.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.shuffle = function(arr, bool) {
        const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr);
        arr = bool || isView ? arr : arr.slice();
        let rnd, tmp, idx = arr.length;
        while(idx > 1){
            rnd = this.random(0, 1) * idx | 0;
            tmp = arr[--idx];
            arr[idx] = arr[rnd];
            arr[rnd] = tmp;
        }
        return arr;
    };
}
if (typeof p5 !== 'undefined') {
    utilityFunctions(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/utilities/time_date.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>timeDate
]);
/**
 * @module IO
 * @submodule Time & Date
 * @for p5
 * @requires core
 */ function timeDate(p51, fn) {
    /**
   * Returns the current day as a number from 1–31.
   *
   * @method day
   * @return {Integer} current day between 1 and 31.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current day.
   *   let d = day();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the day.
   *   text(`Current day: ${d}`, 20, 50, 60);
   *
   *   describe(`The text 'Current day: ${d}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.day = function() {
        return new Date().getDate();
    };
    /**
   * Returns the current hour as a number from 0–23.
   *
   * @method hour
   * @return {Integer} current hour between 0 and 23.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current hour.
   *   let h = hour();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the hour.
   *   text(`Current hour: ${h}`, 20, 50, 60);
   *
   *   describe(`The text 'Current hour: ${h}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.hour = function() {
        return new Date().getHours();
    };
    /**
   * Returns the current minute as a number from 0–59.
   *
   * @method minute
   * @return {Integer} current minute between 0 and 59.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current minute.
   *   let m = minute();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the minute.
   *   text(`Current minute: ${m}`, 10, 50, 80);
   *
   *   describe(`The text 'Current minute: ${m}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.minute = function() {
        return new Date().getMinutes();
    };
    /**
   * Returns the number of milliseconds since a sketch started running.
   *
   * `millis()` keeps track of how long a sketch has been running in
   * milliseconds (thousandths of a second). This information is often
   * helpful for timing events and animations.
   *
   * If a sketch has a
   * <a href="#/p5/setup">setup()</a> function, then `millis()` begins tracking
   * time before the code in <a href="#/p5/setup">setup()</a> runs.  If a
   * sketch includes asynchronous loading using `async`/`await`, then
   * `millis()` begins tracking time as soon as the asynchronous code
   * starts running.
   * @method millis
   * @return {Number} number of milliseconds since starting the sketch.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the number of milliseconds the sketch has run.
   *   let ms = millis();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(10);
   *   textFont('Courier New');
   *
   *   // Display how long it took setup() to be called.
   *   text(`Startup time: ${round(ms, 2)} ms`, 5, 50, 90);
   *
   *   describe(
   *     `The text 'Startup time: ${round(ms, 2)} ms' written in black on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('The text "Running time: S sec" written in black on a gray background. The number S increases as the sketch runs.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the number of seconds the sketch has run.
   *   let s = millis() / 1000;
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(10);
   *   textFont('Courier New');
   *
   *   // Display how long the sketch has run.
   *   text(`Running time: ${nf(s, 1, 1)} sec`, 5, 50, 90);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A white circle oscillates left and right on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the number of seconds the sketch has run.
   *   let s = millis() / 1000;
   *
   *   // Calculate an x-coordinate.
   *   let x = 30 * sin(s) + 50;
   *
   *   // Draw the circle.
   *   circle(x, 50, 30);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * async function setup() {
   *   // Load the GeoJSON.
   *   await loadJSON('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson');
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the number of milliseconds the sketch has run.
   *   let ms = millis();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(11);
   *
   *   // Display how long it took to load the data.
   *   text(`It took ${round(ms, 2)} ms to load the data`, 5, 50, 100);
   *
   *   describe(
   *     `The text "It took ${round(ms, 2)} ms to load the data" written in black on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */ fn.millis = function() {
        if (this._millisStart === -1) {
            // Sketch has not started
            return 0;
        } else {
            return window.performance.now() - this._millisStart;
        }
    };
    /**
   * Returns the current month as a number from 1–12.
   *
   * @method month
   * @return {Integer} current month between 1 and 12.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current month.
   *   let m = month();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the month.
   *   text(`Current month: ${m}`, 10, 50, 80);
   *
   *   describe(`The text 'Current month: ${m}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.month = function() {
        //January is 0!
        return new Date().getMonth() + 1;
    };
    /**
   * Returns the current second as a number from 0–59.
   *
   * @method second
   * @return {Integer} current second between 0 and 59.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current second.
   *   let s = second();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the second.
   *   text(`Current second: ${s}`, 10, 50, 80);
   *
   *   describe(`The text 'Current second: ${s}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.second = function() {
        return new Date().getSeconds();
    };
    /**
   * Returns the current year as a number such as 1999.
   *
   * @method year
   * @return {Integer} current year.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the current year.
   *   let y = year();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textSize(12);
   *   textFont('Courier New');
   *
   *   // Display the year.
   *   text(`Current year: ${y}`, 10, 50, 80);
   *
   *   describe(`The text 'Current year: ${y}' written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */ fn.year = function() {
        return new Date().getFullYear();
    };
}
if (typeof p5 !== 'undefined') {
    timeDate(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/utilities/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>utilities
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$utility_functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/utility_functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$time_date$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/time_date.js [app-ssr] (ecmascript)");
;
;
;
function utilities(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$utility_functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$time_date$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
"[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "S",
    ()=>StrandsNode,
    "a",
    ()=>structConstructorNode,
    "b",
    ()=>structInstanceNode,
    "c",
    ()=>createStrandsNode,
    "d",
    ()=>binaryOpNode,
    "e",
    ()=>scalarLiteralNode,
    "f",
    ()=>functionCallNode,
    "g",
    ()=>constructTypeFromIDs,
    "h",
    ()=>swizzleNode,
    "i",
    ()=>swizzleTrap,
    "m",
    ()=>memberAccessNode,
    "p",
    ()=>primitiveConstructorNode,
    "s",
    ()=>statementNode,
    "u",
    ()=>unaryOpNode,
    "v",
    ()=>variableNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
;
;
;
;
;
class StrandsNode {
    constructor(id, dimension, strandsContext){
        this.id = id;
        this.strandsContext = strandsContext;
        this.dimension = dimension;
        // Store original identifier for varying variables
        const dag = this.strandsContext.dag;
        const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, this.id);
        if (nodeData && nodeData.identifier) {
            this._originalIdentifier = nodeData.identifier;
        }
        if (nodeData) {
            this._originalBaseType = nodeData.baseType;
            this._originalDimension = nodeData.dimension;
        }
    }
    copy() {
        return createStrandsNode(this.id, this.dimension, this.strandsContext);
    }
    typeInfo() {
        return {
            baseType: this._originalBaseType || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT,
            dimension: this.dimension
        };
    }
    bridge(value) {
        const { dag, cfg } = this.strandsContext;
        const orig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, this.id);
        const baseType = orig?.baseType ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT;
        let newValueID;
        if (value instanceof StrandsNode) {
            newValueID = value.id;
        } else {
            const newVal = primitiveConstructorNode(this.strandsContext, {
                baseType,
                dimension: this.dimension
            }, value);
            newValueID = newVal.id;
        }
        // For varying variables, we need both assignment generation AND a way to reference by identifier
        if (this._originalIdentifier) {
            // Create a variable node for the target (the varying variable)
            const { id: targetVarID } = variableNode(this.strandsContext, {
                baseType: this._originalBaseType,
                dimension: this._originalDimension
            }, this._originalIdentifier);
            // Create assignment node for GLSL generation
            const assignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                dependsOn: [
                    targetVarID,
                    newValueID
                ],
                phiBlocks: []
            });
            const assignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, assignmentNode);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, assignmentID);
            // Track for global assignments processing
            this.strandsContext.globalAssignments.push(assignmentID);
            // Simply update this node to be a variable node with the identifier
            // This ensures it always generates the variable name in expressions
            const variableNodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE,
                baseType: this._originalBaseType,
                dimension: this._originalDimension,
                identifier: this._originalIdentifier
            });
            const variableID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, variableNodeData);
            this.id = variableID; // Point to the variable node for expression generation
        } else {
            this.id = newValueID; // For non-varying variables, just update to new value
        }
        return this;
    }
    bridgeSwizzle(swizzlePattern, value) {
        const { dag, cfg } = this.strandsContext;
        const orig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, this.id);
        const baseType = orig?.baseType ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT;
        let newValueID;
        if (value instanceof StrandsNode) {
            newValueID = value.id;
        } else {
            const newVal = primitiveConstructorNode(this.strandsContext, {
                baseType,
                dimension: this.dimension
            }, value);
            newValueID = newVal.id;
        }
        // For varying variables, create swizzle assignment
        if (this._originalIdentifier) {
            // Create a variable node for the target with swizzle
            const { id: targetVarID } = variableNode(this.strandsContext, {
                baseType: this._originalBaseType,
                dimension: this._originalDimension
            }, this._originalIdentifier);
            // Create a swizzle node for the target (myVarying.xyz)
            const swizzleNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
                opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.SWIZZLE,
                baseType: this._originalBaseType,
                dimension: swizzlePattern.length,
                swizzle: swizzlePattern,
                dependsOn: [
                    targetVarID
                ]
            });
            const swizzleID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, swizzleNode);
            // Create assignment node: myVarying.xyz = value
            const assignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                dependsOn: [
                    swizzleID,
                    newValueID
                ],
                phiBlocks: []
            });
            const assignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, assignmentNode);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, assignmentID);
            // Track for global assignments processing in the current hook context
            this.strandsContext.globalAssignments.push(assignmentID);
            // Simply update this node to be a variable node with the identifier
            // This ensures it always generates the variable name in expressions
            const variableNodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE,
                baseType: this._originalBaseType,
                dimension: this._originalDimension,
                identifier: this._originalIdentifier
            });
            const variableID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, variableNodeData);
            this.id = variableID; // Point to the variable node, not the assignment node
        } else {
            this.id = newValueID; // For non-varying variables, just update to new value
        }
        return this;
    }
    getValue() {
        if (this._originalIdentifier) {
            const { id, dimension } = variableNode(this.strandsContext, {
                baseType: this._originalBaseType,
                dimension: this._originalDimension
            }, this._originalIdentifier);
            return createStrandsNode(id, dimension, this.strandsContext);
        }
        return this;
    }
}
function createStrandsNode(id, dimension, strandsContext, onRebind) {
    return new Proxy(new StrandsNode(id, dimension, strandsContext), swizzleTrap(id, dimension, strandsContext, onRebind));
}
//////////////////////////////////////////////
// Builders for node graphs
//////////////////////////////////////////////
function scalarLiteralNode(strandsContext, typeInfo, value) {
    const { cfg, dag } = strandsContext;
    let { dimension, baseType } = typeInfo;
    if (dimension !== 1) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])('Created a scalar literal node with dimension > 1.');
    }
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].LITERAL,
        dimension,
        baseType,
        value
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension
    };
}
function variableNode(strandsContext, typeInfo, identifier) {
    const { cfg, dag } = strandsContext;
    const { dimension, baseType } = typeInfo;
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE,
        dimension,
        baseType,
        identifier
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension
    };
}
function unaryOpNode(strandsContext, nodeOrValue, opCode) {
    const { dag, cfg } = strandsContext;
    let dependsOn;
    let node;
    if (nodeOrValue instanceof StrandsNode) {
        node = nodeOrValue;
    } else {
        const { id, dimension } = primitiveConstructorNode(strandsContext, {
            baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT,
            dimension: null
        }, nodeOrValue);
        node = createStrandsNode(id, dimension, strandsContext);
    }
    dependsOn = [
        node.id
    ];
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode,
        dependsOn,
        baseType: dag.baseTypes[node.id],
        dimension: node.dimension
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: node.dimension
    };
}
function binaryOpNode(strandsContext, leftStrandsNode, rightArg, opCode) {
    const { dag, cfg } = strandsContext;
    // Construct a node for right if its just an array or number etc.
    let rightStrandsNode;
    if (rightArg[0] instanceof StrandsNode && rightArg.length === 1) {
        rightStrandsNode = rightArg[0];
    } else {
        const { id, dimension } = primitiveConstructorNode(strandsContext, {
            baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT,
            dimension: null
        }, rightArg);
        rightStrandsNode = createStrandsNode(id, dimension, strandsContext);
    }
    let finalLeftNodeID = leftStrandsNode.id;
    let finalRightNodeID = rightStrandsNode.id;
    // Check if we have to cast either node
    const leftType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractNodeTypeInfo"])(dag, leftStrandsNode.id);
    const rightType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractNodeTypeInfo"])(dag, rightStrandsNode.id);
    const cast = {
        node: null,
        toType: leftType
    };
    const bothDeferred = leftType.baseType === rightType.baseType && leftType.baseType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].DEFER;
    if (bothDeferred) {
        cast.toType.baseType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT;
        if (leftType.dimension === rightType.dimension) {
            cast.toType.dimension = leftType.dimension;
        } else if (leftType.dimension === 1 && rightType.dimension > 1) {
            cast.toType.dimension = rightType.dimension;
        } else if (rightType.dimension === 1 && leftType.dimension > 1) {
            cast.toType.dimension = leftType.dimension;
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])("type error", `You have tried to perform a binary operation:\n` + `${leftType.baseType + leftType.dimension} ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCodeToSymbol"][opCode]} ${rightType.baseType + rightType.dimension}\n` + `It's only possible to operate on two nodes with the same dimension, or a scalar value and a vector.`);
        }
        const l = primitiveConstructorNode(strandsContext, cast.toType, leftStrandsNode);
        const r = primitiveConstructorNode(strandsContext, cast.toType, rightStrandsNode);
        finalLeftNodeID = l.id;
        finalRightNodeID = r.id;
    } else if (leftType.baseType !== rightType.baseType || leftType.dimension !== rightType.dimension) {
        if (leftType.dimension === 1 && rightType.dimension > 1) {
            cast.node = leftStrandsNode;
            cast.toType = rightType;
        } else if (rightType.dimension === 1 && leftType.dimension > 1) {
            cast.node = rightStrandsNode;
            cast.toType = leftType;
        } else if (leftType.priority > rightType.priority) {
            // e.g. op(float vector, int vector): cast priority is float > int > bool
            cast.node = rightStrandsNode;
            cast.toType = leftType;
        } else if (rightType.priority > leftType.priority) {
            cast.node = leftStrandsNode;
            cast.toType = rightType;
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `A vector of length ${leftType.dimension} operated with a vector of length ${rightType.dimension} is not allowed.`);
        }
        const casted = primitiveConstructorNode(strandsContext, cast.toType, cast.node);
        if (cast.node === leftStrandsNode) {
            leftStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
            finalLeftNodeID = leftStrandsNode.id;
        } else {
            rightStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
            finalRightNodeID = rightStrandsNode.id;
        }
    }
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode,
        dependsOn: [
            finalLeftNodeID,
            finalRightNodeID
        ],
        baseType: cast.toType.baseType,
        dimension: cast.toType.dimension
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: nodeData.dimension
    };
}
function memberAccessNode(strandsContext, parentNode, componentNode, memberTypeInfo) {
    const { dag, cfg } = strandsContext;
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Binary.MEMBER_ACCESS,
        dimension: memberTypeInfo.dimension,
        baseType: memberTypeInfo.baseType,
        dependsOn: [
            parentNode.id,
            componentNode.id
        ]
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: memberTypeInfo.dimension
    };
}
function structInstanceNode(strandsContext, structTypeInfo, identifier, dependsOn) {
    const { cfg, dag } = strandsContext;
    if (dependsOn.length === 0) {
        for (const prop of structTypeInfo.properties){
            const typeInfo = prop.dataType;
            const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE,
                baseType: typeInfo.baseType,
                dimension: typeInfo.dimension,
                identifier: `${identifier}.${prop.name}`
            });
            const componentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, componentID);
            dependsOn.push(componentID);
        }
    }
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE,
        dimension: structTypeInfo.properties.length,
        baseType: structTypeInfo.typeName,
        identifier,
        dependsOn
    });
    const structID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, structID);
    return {
        id: structID,
        dimension: 0,
        components: dependsOn
    };
}
function mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn) {
    const inputs = Array.isArray(dependsOn) ? dependsOn : [
        dependsOn
    ];
    const mappedDependencies = [];
    let { dimension, baseType } = typeInfo;
    const dag = strandsContext.dag;
    let calculatedDimensions = 0;
    let originalNodeID = null;
    for (const dep of inputs.flat(Infinity)){
        if (dep instanceof StrandsNode) {
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, dep.id);
            originalNodeID = dep.id;
            baseType = node.baseType;
            if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.CONSTRUCTOR) {
                for (const inner of node.dependsOn){
                    mappedDependencies.push(inner);
                }
            } else {
                mappedDependencies.push(dep.id);
            }
            calculatedDimensions += node.dimension;
            continue;
        } else if (typeof dep === 'number') {
            const { id, dimension } = scalarLiteralNode(strandsContext, {
                dimension: 1,
                baseType
            }, dep);
            mappedDependencies.push(id);
            calculatedDimensions += dimension;
            continue;
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `You've tried to construct a scalar or vector type with a non-numeric value: ${dep}`);
        }
    }
    if (dimension === null) {
        dimension = calculatedDimensions;
    } else if (dimension > calculatedDimensions && calculatedDimensions === 1) {
        calculatedDimensions = dimension;
    } else if (calculatedDimensions !== 1 && calculatedDimensions !== dimension) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `You've tried to construct a ${baseType + dimension} with ${calculatedDimensions} components`);
    }
    const inferredTypeInfo = {
        dimension,
        baseType,
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasePriority"][baseType]
    };
    return {
        originalNodeID,
        mappedDependencies,
        inferredTypeInfo
    };
}
function constructTypeFromIDs(strandsContext, typeInfo, strandsNodesArray) {
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.CONSTRUCTOR,
        dimension: typeInfo.dimension,
        baseType: typeInfo.baseType,
        dependsOn: strandsNodesArray
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(strandsContext.dag, nodeData);
    return id;
}
function primitiveConstructorNode(strandsContext, typeInfo, dependsOn) {
    const cfg = strandsContext.cfg;
    const { mappedDependencies, inferredTypeInfo } = mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn);
    const finalType = {
        baseType: typeInfo.baseType,
        dimension: inferredTypeInfo.dimension
    };
    const id = constructTypeFromIDs(strandsContext, finalType, mappedDependencies);
    if (typeInfo.baseType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].DEFER) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    }
    return {
        id,
        dimension: finalType.dimension,
        components: mappedDependencies
    };
}
function structConstructorNode(strandsContext, structTypeInfo, rawUserArgs) {
    const { cfg, dag } = strandsContext;
    const { identifer, properties } = structTypeInfo;
    if (!(rawUserArgs.length === properties.length)) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `You've tried to construct a ${structTypeInfo.typeName} struct with ${rawUserArgs.length} properties, but it expects ${properties.length} properties.\n` + `The properties it expects are:\n` + `${properties.map((prop)=>prop.name + ' ' + prop.DataType.baseType + prop.DataType.dimension)}`);
    }
    const dependsOn = [];
    for(let i = 0; i < properties.length; i++){
        const expectedProperty = properties[i];
        const { originalNodeID, mappedDependencies } = mapPrimitiveDepsToIDs(strandsContext, expectedProperty.dataType, rawUserArgs[i]);
        if (originalNodeID) {
            dependsOn.push(originalNodeID);
        } else {
            dependsOn.push(constructTypeFromIDs(strandsContext, expectedProperty.dataType, mappedDependencies));
        }
    }
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.CONSTRUCTOR,
        dimension: properties.length,
        baseType: structTypeInfo.typeName,
        dependsOn
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: properties.length,
        components: structTypeInfo.components
    };
}
function functionCallNode(strandsContext, functionName, rawUserArgs, { overloads: rawOverloads } = {}) {
    const { cfg, dag } = strandsContext;
    const overloads = rawOverloads || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["strandsBuiltinFunctions"][functionName];
    const preprocessedArgs = rawUserArgs.map((rawUserArg)=>mapPrimitiveDepsToIDs(strandsContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].defer, rawUserArg));
    const matchingArgsCounts = overloads.filter((overload)=>overload.params.length === preprocessedArgs.length);
    if (matchingArgsCounts.length === 0) {
        const argsLengthSet = new Set();
        const argsLengthArr = [];
        overloads.forEach((overload)=>argsLengthSet.add(overload.params.length));
        argsLengthSet.forEach((len)=>argsLengthArr.push(`${len}`));
        const argsLengthStr = argsLengthArr.join(', or ');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])("parameter validation error", `Function '${functionName}' has ${overloads.length} variants which expect ${argsLengthStr} arguments, but ${preprocessedArgs.length} arguments were provided.`);
    }
    const isGeneric = (T)=>T.dimension === null;
    let bestOverload = null;
    let bestScore = 0;
    let inferredReturnType = null;
    let inferredDimension = null;
    for (const overload of matchingArgsCounts){
        let isValid = true;
        let similarity = 0;
        for(let i = 0; i < preprocessedArgs.length; i++){
            const preArg = preprocessedArgs[i];
            const argType = preArg.inferredTypeInfo;
            const expectedType = overload.params[i];
            let dimension = expectedType.dimension;
            if (isGeneric(expectedType)) {
                if (inferredDimension === null || inferredDimension === 1) {
                    inferredDimension = argType.dimension;
                }
                if (inferredDimension !== argType.dimension && !(argType.dimension === 1 && inferredDimension >= 1)) {
                    isValid = false;
                }
                dimension = inferredDimension;
            } else {
                if (argType.dimension > dimension) {
                    isValid = false;
                }
            }
            if (argType.baseType === expectedType.baseType) {
                similarity += 2;
            } else if (expectedType.priority > argType.priority) {
                similarity += 1;
            }
        }
        if (isValid && (!bestOverload || similarity > bestScore)) {
            bestOverload = overload;
            bestScore = similarity;
            inferredReturnType = {
                ...overload.returnType
            };
            if (isGeneric(inferredReturnType)) {
                inferredReturnType.dimension = inferredDimension;
            }
        }
    }
    if (bestOverload === null) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('parameter validation', `No matching overload for ${functionName} was found!`);
    }
    let dependsOn = [];
    for(let i = 0; i < bestOverload.params.length; i++){
        const arg = preprocessedArgs[i];
        const paramType = {
            ...bestOverload.params[i]
        };
        if (isGeneric(paramType)) {
            paramType.dimension = inferredDimension;
        }
        if (arg.originalNodeID && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["typeEquals"])(arg.inferredTypeInfo, paramType)) {
            dependsOn.push(arg.originalNodeID);
        } else {
            const castedArgID = constructTypeFromIDs(strandsContext, paramType, arg.mappedDependencies);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, castedArgID);
            dependsOn.push(castedArgID);
        }
    }
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.FUNCTION_CALL,
        identifier: functionName,
        dependsOn,
        baseType: inferredReturnType.baseType,
        dimension: inferredReturnType.dimension
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: inferredReturnType.dimension
    };
}
function statementNode(strandsContext, statementType) {
    const { dag, cfg } = strandsContext;
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
        statementType
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return id;
}
function swizzleNode(strandsContext, parentNode, swizzle) {
    const { dag, cfg } = strandsContext;
    const baseType = dag.baseTypes[parentNode.id];
    const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
        baseType,
        dimension: swizzle.length,
        opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.SWIZZLE,
        dependsOn: [
            parentNode.id
        ],
        swizzle
    });
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, cfg.currentBlock, id);
    return {
        id,
        dimension: swizzle.length
    };
}
function swizzleTrap(id, dimension, strandsContext, onRebind) {
    const swizzleSets = [
        [
            'x',
            'y',
            'z',
            'w'
        ],
        [
            'r',
            'g',
            'b',
            'a'
        ],
        [
            's',
            't',
            'p',
            'q'
        ]
    ].map((s)=>s.slice(0, dimension));
    const trap = {
        get (target, property, receiver) {
            if (property in target) {
                return Reflect.get(...arguments);
            } else {
                for (const set of swizzleSets){
                    if ([
                        ...property.toString()
                    ].every((char)=>set.includes(char))) {
                        const swizzle = [
                            ...property
                        ].map((char)=>{
                            const index = set.indexOf(char);
                            return swizzleSets[0][index];
                        }).join('');
                        const node = swizzleNode(strandsContext, target, swizzle);
                        return createStrandsNode(node.id, node.dimension, strandsContext);
                    }
                }
            }
        },
        set (target, property, value, receiver) {
            for (const swizzleSet of swizzleSets){
                const chars = [
                    ...property
                ];
                const valid = chars.every((c)=>swizzleSet.includes(c)) && new Set(chars).size === chars.length && target.dimension >= chars.length;
                if (!valid) continue;
                const dim = target.dimension;
                // lanes are the underlying values of the target vector
                //  e.g. lane 0 holds the value aliased by 'x', 'r', and 's'
                // the lanes array is in the 'correct' order
                const lanes = new Array(dim);
                for(let i = 0; i < dim; i++){
                    const { id, dimension } = swizzleNode(strandsContext, target, 'xyzw'[i]);
                    lanes[i] = createStrandsNode(id, dimension, strandsContext);
                }
                // The scalars array contains the individual components of the users values.
                // This may not be the most efficient way, as we swizzle each component individually,
                // so that .xyz becomes .x, .y, .z
                let scalars = [];
                if (value instanceof StrandsNode) {
                    if (value.dimension === 1) {
                        scalars = Array(chars.length).fill(value);
                    } else if (value.dimension === chars.length) {
                        for(let k = 0; k < chars.length; k++){
                            const { id, dimension } = swizzleNode(strandsContext, value, 'xyzw'[k]);
                            scalars.push(createStrandsNode(id, dimension, strandsContext));
                        }
                    } else {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `Swizzle assignment: RHS vector does not match LHS vector (need ${chars.length}, got ${value.dimension}).`);
                    }
                } else if (Array.isArray(value)) {
                    const flat = value.flat(Infinity);
                    if (flat.length === 1) {
                        scalars = Array(chars.length).fill(flat[0]);
                    } else if (flat.length === chars.length) {
                        scalars = flat;
                    } else {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `Swizzle assignment: RHS length ${flat.length} does not match ${chars.length}.`);
                    }
                } else if (typeof value === 'number') {
                    scalars = Array(chars.length).fill(value);
                } else {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `Unsupported RHS for swizzle assignment: ${value}`);
                }
                // The canonical index refers to the actual value's position in the vector lanes
                // i.e. we are finding (3,2,1) from .zyx
                // We set the correct value in the lanes array
                for(let j = 0; j < chars.length; j++){
                    const canonicalIndex = swizzleSet.indexOf(chars[j]);
                    lanes[canonicalIndex] = scalars[j];
                }
                const orig = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(strandsContext.dag, target.id);
                const baseType = orig?.baseType ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT;
                const { id: newID } = primitiveConstructorNode(strandsContext, {
                    baseType,
                    dimension: dim
                }, lanes);
                target.id = newID;
                // If we swizzle assign on a struct component i.e.
                //   inputs.position.rg = [1, 2]
                // The onRebind callback will update the structs components so that it refers to the new values,
                // and make a new ID for the struct with these new values
                if (typeof onRebind === 'function') {
                    onRebind(newID);
                }
                return true;
            }
            return Reflect.set(...arguments);
        }
    };
    return trap;
}
;
}),
"[project]/node_modules/p5/dist/app.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$data$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/data/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/init.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$structure$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/structure.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$environment$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/environment.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filterRenderer2D$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filterRenderer2D.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$describe$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/describe.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$gridOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/gridOutput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$textOutput$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/textOutput.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$outputs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/outputs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$color_namer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/accessibility/color_namer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$fes_core$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/fes_core.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$internationalization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/internationalization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$i18next$2f$dist$2f$esm$2f$i18next$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/i18next/dist/esm/i18next.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$i18next$2d$browser$2d$languagedetector$2f$dist$2f$esm$2f$i18nextBrowserLanguageDetector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$browser_errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/browser_errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$stacktrace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/stacktrace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$param_validator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/param_validator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$sketch_verifier$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/sketch_verifier.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$file_errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/friendly_errors/file_errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$data$2f$local_storage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/data/local_storage.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$dom$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/dom.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$acceleration$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/acceleration.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$keyboard$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/keyboard.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$pointer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/events/pointer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$Table$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.Table.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$TableRow$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.TableRow.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$calculation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/calculation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$noise$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/noise.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$random$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/random.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$math$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/math.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$utility_functions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/utility_functions.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$time_date$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/utilities/time_date.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$interaction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/interaction.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$loading$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/loading.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$text$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/text.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$p5$2e$strands$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/p5.strands.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_glslBackend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_glslBackend.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_transpiler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_transpiler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_codegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_codegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_conditionals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_conditionals.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_for$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_for.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
// core
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$accessibility$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$friendly_errors$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$data$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$events$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$utilities$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]);
Promise.all([
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitForDocumentReady"])(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["waitingForTranslator"]
]).then(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["_globalInit"]);
;
}),
"[project]/node_modules/p5/dist/app.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$app$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/app.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$main$2d$IPkchNDB$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/main-IPkchNDB.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_p5_dist_64081bab._.js.map