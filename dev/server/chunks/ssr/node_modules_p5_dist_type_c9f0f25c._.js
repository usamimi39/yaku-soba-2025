module.exports = [
"[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>textCore,
    "textCoreConstants",
    ()=>textCoreConstants
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Typography
 * @requires core
 */ const textCoreConstants = {
    IDEOGRAPHIC: 'ideographic',
    RIGHT_TO_LEFT: 'rtl',
    LEFT_TO_RIGHT: 'ltr',
    _CTX_MIDDLE: 'middle',
    _TEXT_BOUNDS: '_textBoundsSingle',
    _FONT_BOUNDS: '_fontBoundsSingle',
    HANGING: 'hanging',
    START: 'start',
    END: 'end'
};
function textCore(p51, fn) {
    const LeadingScale = 1.275;
    const DefaultFill = '#000000';
    const LinebreakRe = /\r?\n/g;
    const CommaDelimRe = /,\s+/;
    const QuotedRe = /^".*"$/;
    const TabsRe = /\t/g;
    const FontVariationSettings = 'fontVariationSettings';
    const VariableAxes = [
        'wght',
        'wdth',
        'ital',
        'slnt',
        'opsz'
    ];
    const VariableAxesRe = new RegExp(`(?:${VariableAxes.join('|')})`);
    const textFunctions = [
        'text',
        'textAlign',
        'textAscent',
        'textDescent',
        'textLeading',
        'textMode',
        'textFont',
        'textSize',
        'textStyle',
        'textWidth',
        'textWrap',
        'textBounds',
        'textDirection',
        'textProperty',
        'textProperties',
        'fontBounds',
        'fontWidth',
        'fontAscent',
        'fontDescent',
        'textWeight'
    ];
    /**
   * Draws text to the canvas.
   *
   * The first parameter, `str`, is the text to be drawn. The second and third
   * parameters, `x` and `y`, set the coordinates of the text's bottom-left
   * corner. See <a href="#/p5/textAlign">textAlign()</a> for other ways to
   * align text.
   *
   * The fourth and fifth parameters, `maxWidth` and `maxHeight`, are optional.
   * They set the dimensions of the invisible rectangle containing the text. By
   * default, they set its  maximum width and height. See
   * <a href="#/p5/rectMode">rectMode()</a> for other ways to define the
   * rectangular text box. Text will wrap to fit within the text box. Text
   * outside of the box won't be drawn.
   *
   * Text can be styled a few ways. Call the <a href="#/p5/fill">fill()</a>
   * function to set the text's fill color. Call
   * <a href="#/p5/stroke">stroke()</a> and
   * <a href="#/p5/strokeWeight">strokeWeight()</a> to set the text's outline.
   * Call <a href="#/p5/textSize">textSize()</a> and
   * <a href="#/p5/textFont">textFont()</a> to set the text's size and font,
   * respectively.
   *
   * Note: `WEBGL` mode only supports fonts loaded with
   * <a href="#/p5/loadFont">loadFont()</a>. Calling
   * <a href="#/p5/stroke">stroke()</a> has no effect in `WEBGL` mode.
   *
   * @method text
   * @param {String|Object|Array|Number|Boolean} str text to be displayed.
   * @param {Number} x          x-coordinate of the text box.
   * @param {Number} y          y-coordinate of the text box.
   * @param {Number} [maxWidth] maximum width of the text box. See
   *                            <a href="#/p5/rectMode">rectMode()</a> for
   *                            other options.
   * @param {Number} [maxHeight] maximum height of the text box. See
   *                            <a href="#/p5/rectMode">rectMode()</a> for
   *                            other options.
   *
   * @for p5
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   text('hi', 50, 50);
   *
   *   describe('The text "hi" written in black in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('skyblue');
   *   textSize(100);
   *   text('üåà', 0, 100);
   *
   *   describe('A rainbow in a blue sky.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   textSize(32);
   *   fill(255);
   *   stroke(0);
   *   strokeWeight(4);
   *   text('hi', 50, 50);
   *
   *   describe('The text "hi" written in white with a black outline.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('black');
   *   textSize(22);
   *   fill('yellow');
   *   text('rainbows', 6, 20);
   *   fill('cornflowerblue');
   *   text('rainbows', 6, 45);
   *   fill('tomato');
   *   text('rainbows', 6, 70);
   *   fill('limegreen');
   *   text('rainbows', 6, 95);
   *
   *   describe('The text "rainbows" written on several lines, each in a different color.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   let s = 'The quick brown fox jumps over the lazy dog.';
   *   text(s, 10, 10, 70, 80);
   *
   *   describe('The sample text "The quick brown fox..." written in black across several lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   rectMode(CENTER);
   *   let s = 'The quick brown fox jumps over the lazy dog.';
   *   text(s, 50, 50, 70, 80);
   *
   *   describe('The sample text "The quick brown fox..." written in black across several lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   font = await loadFont('assets/inconsolata.otf');
   *   textFont(font);
   *   textSize(32);
   *   textAlign(CENTER, CENTER);
   * }
   *
   * function draw() {
   *   background(200);
   *   rotateY(frameCount / 30);
   *   text('p5*js', 0, 0);
   *
   *   describe('The text "p5*js" written in white and spinning in 3D.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the way text is aligned when <a href="#/p5/text">text()</a> is called.
   *
   * By default, calling `text('hi', 10, 20)` places the bottom-left corner of
   * the text's bounding box at (10, 20).
   *
   * The first parameter, `horizAlign`, changes the way
   * <a href="#/p5/text">text()</a> interprets x-coordinates. By default, the
   * x-coordinate sets the left edge of the bounding box. `textAlign()` accepts
   * the following values for `horizAlign`: `LEFT`, `CENTER`, or `RIGHT`.
   *
   * The second parameter, `vertAlign`, is optional. It changes the way
   * <a href="#/p5/text">text()</a> interprets y-coordinates. By default, the
   * y-coordinate sets the bottom edge of the bounding box. `textAlign()`
   * accepts the following values for `vertAlign`: `TOP`, `BOTTOM`, `CENTER`,
   * or `BASELINE`.
   *
   * Calling `textAlign()` without arguments returns the current alignment settings.
   *
   * @method textAlign
   * @for p5
   * @param {LEFT|CENTER|RIGHT} [horizAlign] horizontal alignment
   * @param {TOP|BOTTOM|CENTER|BASELINE} [vertAlign] vertical alignment
   * @returns {Object} If no arguments are provided, returns an object with current horizontal and vertical alignment
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw a vertical line.
   *   strokeWeight(0.5);
   *   line(50, 0, 50, 100);
   *
   *   // Top line.
   *   textSize(16);
   *   textAlign(RIGHT);
   *   text('ABCD', 50, 30);
   *
   *   // Middle line.
   *   textAlign(CENTER);
   *   text('EFGH', 50, 50);
   *
   *   // Bottom line.
   *   textAlign(LEFT);
   *   text('IJKL', 50, 70);
   *
   *   describe('The letters ABCD displayed at top-left, EFGH at center, and IJKL at bottom-right. A vertical line divides the canvas in half.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   strokeWeight(0.5);
   *
   *   // First line.
   *   line(0, 12, width, 12);
   *   textAlign(CENTER, TOP);
   *   text('TOP', 50, 12);
   *
   *   // Second line.
   *   line(0, 37, width, 37);
   *   textAlign(CENTER, CENTER);
   *   text('CENTER', 50, 37);
   *
   *   // Third line.
   *   line(0, 62, width, 62);
   *   textAlign(CENTER, BASELINE);
   *   text('BASELINE', 50, 62);
   *
   *   // Fourth line.
   *   line(0, 97, width, 97);
   *   textAlign(CENTER, BOTTOM);
   *   text('BOTTOM', 50, 97);
   *
   *   describe('The words "TOP", "CENTER", "BASELINE", and "BOTTOM" each drawn relative to a horizontal line. Their positions demonstrate different vertical alignments.');
   * }
   * </code>
   * </div>
   */ /**
   * Returns the ascent of the text.
   *
   * The `textAscent()` function calculates the distance from the baseline to the
   * highest point of the current font. This value represents the ascent, which is essential
   * for determining the overall height of the text along with `textDescent()`. If
   * a text string is provided as an argument, the ascent is calculated based on that specific
   * string; otherwise, the ascent of the current font is returned.
   *
   * @method textAscent
   * @for p5
   *
   * @param {String} [txt] - (Optional) The text string for which to calculate the ascent.
   *                         If omitted, the function returns the ascent for the current font.
   * @returns {Number} The ascent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(400, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the ascent of the current font
   *   let asc = textAscent();
   *
   *   // Draw a red line at the baseline and a blue line at the ascent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y - asc, x + 200, y - asc); // Ascent (top of text)
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("textAscent: " + asc.toFixed(2) + " pixels", x, y - asc - 10);
   * }
   * </code>
   * </div>
   *
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup()  {
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textFont(font);
   *
   *   // Different for each font.
   *   let fontScale = 0.8;
   *
   *   let baseY = 75;
   *   strokeWeight(0.5);
   *
   *   // Draw small text.
   *   textSize(24);
   *   text('dp', 0, baseY);
   *
   *   // Draw baseline and ascent.
   *   let a = textAscent() * fontScale;
   *   line(0, baseY, 23, baseY);
   *   line(23, baseY - a, 23, baseY);
   *
   *   // Draw large text.
   *   textSize(48);
   *   text('dp', 45, baseY);
   *
   *   // Draw baseline and ascent.
   *   a = textAscent() * fontScale;
   *   line(45, baseY, 91, baseY);
   *   line(91, baseY - a, 91, baseY);
   *
   *   describe('The letters "dp" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends upward from each baseline to the top of the "d".');
   * }
   * </code>
   * </div>
   */ /**
   * Returns the descent of the text.
   *
   * The `textDescent()` function calculates the distance from the baseline to the
   * lowest point of the current font. This value represents the descent, which, when combined
   * with the ascent (from `textAscent()`), determines the overall vertical span of the text.
   * If a text string is provided as an argument, the descent is calculated based on that specific string;
   * otherwise, the descent of the current font is returned.
   *
   * @method textDescent
   * @for p5
   *
   * @param {String} [txt] - (Optional) The text string for which to calculate the descent.
   *                         If omitted, the function returns the descent for the current font.
   * @returns {Number} The descent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(400, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the descent of the current font
   *   let desc = textDescent();
   *
   *   // Draw a red line at the baseline and a blue line at the bottom of the text
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y + desc, x + 200, y + desc); // Descent (bottom of text)
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("textDescent: " + desc.toFixed(2) + " pixels", x, y + desc + 20);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup()  {
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the font.
   *   textFont(font);
   *
   *   // Different for each font.
   *   let fontScale = 0.9;
   *
   *   let baseY = 75;
   *   strokeWeight(0.5);
   *
   *   // Draw small text.
   *   textSize(24);
   *   text('dp', 0, baseY);
   *
   *   // Draw baseline and descent.
   *   let d = textDescent() * fontScale;
   *   line(0, baseY, 23, baseY);
   *   line(23, baseY, 23, baseY + d);
   *
   *   // Draw large text.
   *   textSize(48);
   *   text('dp', 45, baseY);
   *
   *   // Draw baseline and descent.
   *   d = textDescent() * fontScale;
   *   line(45, baseY, 91, baseY);
   *   line(91, baseY, 91, baseY + d);
   *
   *   describe('The letters "dp" written twice in different sizes. Each version has a horizontal baseline. A vertical line extends downward from each baseline to the bottom of the "p".');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the spacing between lines of text when
   * <a href="#/p5/text">text()</a> is called.
   *
   * Note: Spacing is measured in pixels.
   *
   * Calling `textLeading()` without an argument returns the current spacing.
   *
   * @method textLeading
   * @for p5
   * @param {Number} [leading] The new text leading to apply, in pixels
   * @returns {Number} If no arguments are provided, the current text leading
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // "\n" starts a new line of text.
   *   let lines = 'one\ntwo';
   *
   *   // Left.
   *   text(lines, 10, 25);
   *
   *   // Right.
   *   textLeading(30);
   *   text(lines, 70, 25);
   *
   *   describe('The words "one" and "two" written on separate lines twice. The words on the left have less vertical spacing than the words on the right.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the font used by the <a href="#/p5/text">text()</a> function.
   *
   * The first parameter, `font`, sets the font. `textFont()` recognizes either
   * a <a href="#/p5.Font">p5.Font</a> object or a string with the name of a
   * system font. For example, `'Courier New'`.
   *
   * The second parameter, `size`, is optional. It sets the font size in pixels.
   * This has the same effect as calling <a href="#/p5/textSize">textSize()</a>.
   *
   * Calling `textFont()` without arguments returns the current font.
   *
   * Note: `WEBGL` mode only supports fonts loaded with
   * <a href="#/p5/loadFont">loadFont()</a>.
   *
   * @method textFont
   * @param {p5.Font|String|Object} [font] The font to apply
   * @param {Number} [size] An optional text size to apply.
   * @returns {String|p5.Font} If no arguments are provided, returns the current font
   * @for p5
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   textFont('Courier New');
   *   textSize(24);
   *   text('hi', 35, 55);
   *
   *   describe('The text "hi" written in a black, monospace font on a gray background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background('black');
   *   fill('palegreen');
   *   textFont('Courier New', 10);
   *   text('You turn to the left and see a door. Do you enter?', 5, 5, 90, 90);
   *   text('>', 5, 70);
   *
   *   describe('A text prompt from a game is written in a green, monospace font on a black background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *   textFont('Verdana');
   *   let currentFont = textFont();
   *   text(currentFont, 25, 50);
   *
   *   describe('The text "Verdana" written in a black, sans-serif font on a gray background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * let fontRegular;
   * let fontItalic;
   * let fontBold;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   fontRegular = await loadFont('assets/Regular.otf');
   *   fontItalic = await loadFont('assets/Italic.ttf');
   *   fontBold = await loadFont('assets/Bold.ttf');
   *
   *   background(200);
   *   textFont(fontRegular);
   *   text('I am Normal', 10, 30);
   *   textFont(fontItalic);
   *   text('I am Italic', 10, 50);
   *   textFont(fontBold);
   *   text('I am Bold', 10, 70);
   *
   *   describe('The statements "I am Normal", "I am Italic", and "I am Bold" written in black on separate lines. The statements have normal, italic, and bold fonts, respectively.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets or gets the current text size.
   *
   * The `textSize()` function is used to specify the size of the text
   * that will be rendered on the canvas. When called with an argument, it sets the
   * text size to the specified value (which can be a number representing pixels or a
   * CSS-style string, e.g., '32px', '2em'). When called without an argument, it
   * returns the current text size in pixels.
   *
   * @method textSize
   * @for p5
   *
   * @param {Number} size - The size to set for the text.
   * @returns {Number} If no arguments are provided, the current text size in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(600, 200);
   *   background(240);
   *
   *   // Set the text size to 48 pixels
   *   textSize(48);
   *   textAlign(CENTER, CENTER);
   *   textFont("Georgia");
   *
   *   // Draw text using the current text size
   *   fill(0);
   *   text("Hello, p5.js!", width / 2, height / 2);
   *
   *   // Retrieve and display the current text size
   *   let currentSize = textSize();
   *   fill(50);
   *   textSize(16);
   *   text("Current text size: " + currentSize, width / 2, height - 20);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top.
   *   textSize(12);
   *   text('Font Size 12', 10, 30);
   *
   *   // Middle.
   *   textSize(14);
   *   text('Font Size 14', 10, 60);
   *
   *   // Bottom.
   *   textSize(16);
   *   text('Font Size 16', 10, 90);
   *
   *   describe('The text "Font Size 12" drawn small, "Font Size 14" drawn medium, and "Font Size 16" drawn large.');
   * }
   * </code>
   * </div>
   */ /**
   * @method textSize
   * @for p5
   * @returns {Number} The current text size in pixels.
   */ /**
   * Sets the style for system fonts when
   * <a href="#/p5/text">text()</a> is called.
   *
   * The parameter, `style`, can be either `NORMAL`, `ITALIC`, `BOLD`, or
   * `BOLDITALIC`.
   *
   * `textStyle()` may be overridden by CSS styling. This function doesn't
   * affect fonts loaded with <a href="#/p5/loadFont">loadFont()</a>.
   *
   * @method textStyle
   * @for p5
   * @param {NORMAL|ITALIC|BOLD|BOLDITALIC} style The style to use
   * @returns {NORMAL|ITALIC|BOLD|BOLDITALIC} If no arguments are provided, the current style
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(12);
   *   textAlign(CENTER);
   *
   *   // First row.
   *   textStyle(NORMAL);
   *   text('Normal', 50, 15);
   *
   *   // Second row.
   *   textStyle(ITALIC);
   *   text('Italic', 50, 40);
   *
   *   // Third row.
   *   textStyle(BOLD);
   *   text('Bold', 50, 65);
   *
   *   // Fourth row.
   *   textStyle(BOLDITALIC);
   *   text('Bold Italic', 50, 90);
   *
   *   describe('The words "Normal" displayed normally, "Italic" in italic, "Bold" in bold, and "Bold Italic" in bold italics.');
   * }
   * </code>
   * </div>
   */ /**
   * @method textStyle
   * @for p5
   * @returns {NORMAL|BOLD|ITALIC|BOLDITALIC}
   */ /**
   * Calculates the width of the given text string in pixels.
   *
   * The `textWidth()` function processes the provided text string to determine its tight bounding box
   * based on the current text properties such as font, textSize, and textStyle. Internally, it splits
   * the text into individual lines (if line breaks are present) and computes the bounding box for each
   * line using the renderer‚Äôs measurement functions. The final width is determined as the maximum width
   * among all these lines.
   *
   * For example, if the text contains multiple lines due to wrapping or explicit line breaks, textWidth()
   * will return the width of the longest line.
   *
   * **Note:** In p5.js 2.0+, leading and trailing spaces are ignored.
   * `textWidth("  Hello  ")` returns the same width as `textWidth("Hello")`.
   *
   * @method textWidth
   * @for p5
   * @param {String} text The text to measure
   * @returns {Number} The width of the text
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200);
   *   background(220);
   *
   *   // Set text size and alignment
   *   textSize(48);
   *   textAlign(LEFT, TOP);
   *
   *   let myText = "Hello";
   *
   *   // Calculate the width of the text
   *   let tw = textWidth(myText);
   *
   *   // Draw the text on the canvas
   *   fill(0);
   *   text(myText, 50, 50);
   *
   *   // Display the text width below
   *   noStroke();
   *   fill(0);
   *   textSize(20);
   *   text("Text width: " + tw, 10, 150);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(28);
   *   strokeWeight(0.5);
   *
   *   // Calculate the text width.
   *   let s = 'yoyo';
   *   let w = textWidth(s);
   *
   *   // Display the text.
   *   text(s, 22, 55);
   *
   *   // Underline the text.
   *   line(22, 55, 22 + w, 55);
   *
   *   describe('The word "yoyo" underlined.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 160);
   *   background(235);
   *   noLoop();
   *
   *   textSize(18);
   *   textAlign(LEFT, TOP);
   *
   *   const x = 12, h = 24;
   *   const s1 = 'Hello';
   *   const s2 = 'Hello  ';      // 2 trailing spaces
   *   const s3 = 'Hello     ';   // many trailing spaces
   *
   *   // draw text
   *   fill(0);
   *   text(s1, x, 12);
   *   text(s2, x, 56);
   *   text(s3, x, 100);
   *
   *   // measure and draw tight boxes (all same width)
   *   noFill(); stroke(255, 0, 0);
   *   const w1 = textWidth(s1);
   *   const w2 = textWidth(s2);
   *   const w3 = textWidth(s3);
   *   rect(x, 10,  w1, h);
   *   rect(x, 54, w2, h);
   *   rect(x, 98, w3, h);
   *
   *   // small captions show the actual strings (spaces as ¬∑)
   *   textSize(10); noStroke(); fill(30);
   *   text('"' + s1.replace(/ /g, '¬∑') + '"  w=' + w1.toFixed(1), x, 10 + h + 2);
   *   text('"' + s2.replace(/ /g, '¬∑') + '"  w=' + w2.toFixed(1), x, 54 + h + 2);
   *   text('"' + s3.replace(/ /g, '¬∑') + '"  w=' + w3.toFixed(1), x, 98 + h + 2);
   *
   *   describe('Three lines: Hello with 0, 2, and many trailing spaces. Red boxes use textWidth and are identical. Captions show spaces as dots.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(28);
   *   strokeWeight(0.5);
   *
   *   // Calculate the text width.
   *   // "\n" starts a new line.
   *   let s = 'yo\nyo';
   *   let w = textWidth(s);
   *
   *   // Display the text.
   *   text(s, 22, 55);
   *
   *   // Underline the text.
   *   line(22, 55, 22 + w, 55);
   *
   *   describe('The word "yo" written twice, one copy beneath the other. The words are divided by a horizontal line.');
   * }
   * </code>
   * </div>
   */ /**
   * Sets the style for wrapping text when
   * <a href="#/p5/text">text()</a> is called.
   *
   * The parameter, `style`, can be one of the following values:
   *
   * `WORD` starts new lines of text at spaces. If a string of text doesn't
   * have spaces, it may overflow the text box and the canvas. This is the
   * default style.
   *
   * `CHAR` starts new lines as needed to stay within the text box.
   *
   * `textWrap()` only works when the maximum width is set for a text box. For
   * example, calling `text('Have a wonderful day', 0, 10, 100)` sets the
   * maximum width to 100 pixels.
   *
   * Calling `textWrap()` without an argument returns the current style.
   *
   * @method textWrap
   * @for p5
   *
   * @param {WORD|CHAR} style The wrapping style to use
   * @returns {CHAR|WORD} If no arguments are provided, the current wrapping style
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(WORD);
   *
   *   // Display the text.
   *   text('Have a wonderful day', 0, 10, 100);
   *
   *   describe('The text "Have a wonderful day" written across three lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(CHAR);
   *
   *   // Display the text.
   *   text('Have a wonderful day', 0, 10, 100);
   *
   *   describe('The text "Have a wonderful day" written across two lines.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textSize(20);
   *   textWrap(CHAR);
   *
   *   // Display the text.
   *   text('Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©', 0, 10, 100);
   *
   *   describe('The text "Á•ù‰Ω†ÊúâÁæéÂ•ΩÁöÑ‰∏ÄÂ§©" written across two lines.');
   * }
   * </code>
   * </div>
   */ /**
   * @method textWrap
   * @for p5
   * @returns {CHAR|WORD} The current wrapping style
   */ /**
   * Computes the tight bounding box for a block of text.
   *
   * The `textBounds()` function calculates the precise pixel boundaries that enclose
   * the rendered text based on the current text properties (such as font, textSize, textStyle, and
   * alignment). If the text spans multiple lines (due to line breaks or wrapping), the function
   * measures each line individually and then aggregates these measurements into a single bounding box.
   * The resulting object contains the x and y coordinates along with the width (w) and height (h)
   * of the text block.
   *
   * @method textBounds
   * @for p5
   *
   * @param {String} str - The text string to measure.
   * @param {Number} x - The x-coordinate where the text is drawn.
   * @param {Number} y - The y-coordinate where the text is drawn.
   * @param {Number} [width] - (Optional) The maximum width available for the text block.
   *                           When specified, the text may be wrapped to fit within this width.
   * @param {Number} [height] - (Optional) The maximum height available for the text block.
   *                            Any lines exceeding this height will be truncated.
   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` that represent the tight
   *                   bounding box of the rendered text.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(220);
   *
   *   // Set up text properties for clarity
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *
   *   let txt = "Hello, World!";
   *   // Compute the bounding box for the text starting at (50, 50)
   *   let bounds = textBounds(txt, 50, 50);
   *
   *   // Draw the text
   *   fill(0);
   *   text(txt, 50, 50);
   *
   *   // Draw the computed bounding box in red to visualize the measured area
   *   noFill();
   *   stroke('red');
   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);
   * }
   * </code>
   * </div>
   */ /**
   * Sets or gets the text drawing direction.
   *
   * The <code>textDirection()</code> function allows you to specify the direction in which text is
   * rendered on the canvas. When provided with a <code>direction</code> parameter (such as "ltr" for
   * left-to-right, "rtl" for right-to-left, or "inherit"), it updates the renderer's state with that
   * value and applies the new setting. When called without any arguments, it returns the current text
   * direction. This function is particularly useful for rendering text in languages with different
   * writing directions.
   *
   * @method textDirection
   * @for p5
   *
   * @param {String} direction - The text direction to set ("ltr", "rtl", or "inherit").
   * @returns {String} If no arguments are provided, the current text direction, either "ltr", "rtl", or "inherit"
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(240);
   *
   *   textSize(32);
   *   textFont("Georgia");
   *   textAlign(LEFT, TOP);
   *
   *   // Set text direction to right-to-left and draw Arabic text.
   *   textDirection("rtl");
   *   fill(0);
   *   text("ŸÖÿ±ÿ≠ÿ®Ÿãÿß!", 50, 50);
   *
   *   // Set text direction to left-to-right and draw English text.
   *   textDirection("ltr");
   *   text("Hello, p5.js!", 50, 150);
   *
   *   // Display the current text direction.
   *   textSize(16);
   *   fill(50);
   *   textAlign(LEFT, TOP);
   *   text("Current textDirection: " + textDirection(), 50, 250);
   * }
   * </code>
   * </div>
   */ /**
   * @method textDirection
   * @for p5
   * @returns {String} The current text direction, either "ltr", "rtl", or "inherit"
   */ /**
   * Sets or gets a single text property for the renderer.
   *
   * The `textProperty()` function allows you to set or retrieve a single text-related property,
   * such as `textAlign`, `textBaseline`, `fontStyle`, or any other property
   * that may be part of the renderer's state, its drawing context, or the canvas style.
   *
   * When called with a `prop` and a `value`, the function sets the property by checking
   * for its existence in the renderer's state, the drawing context, or the canvas style. If the property is
   * successfully modified, the function applies the updated text properties. If called with only the
   * `prop` parameter, the function returns the current value of that property.
   *
   * @method textProperty
   * @for p5
   *
   * @param {String} prop - The name of the text property to set or get.
   * @param value - The value to set for the specified text property. If omitted, the current
   *                      value of the property is returned
   * @returns If no arguments are provided, the current value of the specified text property
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(240);
   *
   *   // Set the text alignment to CENTER and the baseline to TOP using textProperty.
   *   textProperty("textAlign", CENTER);
   *   textProperty("textBaseline", TOP);
   *
   *   // Set additional text properties and draw the text.
   *   textSize(32);
   *   textFont("Georgia");
   *   fill(0);
   *   text("Hello, World!", width / 2, 50);
   *
   *   // Retrieve and display the current text properties.
   *   let currentAlign = textProperty("textAlign");
   *   let currentBaseline = textProperty("textBaseline");
   *
   *   textSize(16);
   *   textAlign(LEFT, TOP);
   *   fill(50);
   *   text("Current textAlign: " + currentAlign, 50, 150);
   *   text("Current textBaseline: " + currentBaseline, 50, 170);
   * }
   * </code>
   * </div>
   */ /**
   * @method textProperty
   * @for p5
   * @param {String} prop - The name of the text property to set or get.
   * @returns The current value of the specified text property
   */ /**
   * Gets or sets text properties in batch, similar to calling `textProperty()`
   * multiple times.
   *
   * If an object is passed in, `textProperty(key, value)` will be called for you
   * on every key/value pair in the object.
   *
   * If no arguments are passed in, an object will be returned with all the current
   * properties.
   *
   * @method textProperties
   * @for p5
   * @param {Object} properties An object whose keys are properties to set, and whose
   *                            values are what they should be set to.
   */ /**
   * @method textProperties
   * @for p5
   * @returns {Object} An object with all the possible properties and their current values.
   */ /**
   * Computes a generic (non-tight) bounding box for a block of text.
   *
   * The `fontBounds()` function calculates the bounding box for the text based on the
   * font's intrinsic metrics (such as `fontBoundingBoxAscent` and
   * `fontBoundingBoxDescent`). Unlike `textBounds()`, which measures the exact
   * pixel boundaries of the rendered text, `fontBounds()` provides a looser measurement
   * derived from the font‚Äôs default spacing. This measurement is useful for layout purposes where
   * a consistent approximation of the text's dimensions is desired.
   *
   * @method fontBounds
   * @for p5
   *
   * @param {String} str - The text string to measure.
   * @param {Number} x - The x-coordinate where the text is drawn.
   * @param {Number} y - The y-coordinate where the text is drawn.
   * @param {Number} [width] - (Optional) The maximum width available for the text block.
   *                           When specified, the text may be wrapped to fit within this width.
   * @param {Number} [height] - (Optional) The maximum height available for the text block.
   *                            Any lines exceeding this height will be truncated.
   * @returns {Object} An object with properties `x`, `y`, `w`, and `h` representing the loose
   *                   bounding box of the text based on the font's intrinsic metrics.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *   textFont('Georgia');
   *
   *   let txt = "Hello, World!";
   *   // Compute the bounding box based on the font's intrinsic metrics
   *   let bounds = fontBounds(txt, 50, 50);
   *
   *   fill(0);
   *   text(txt, 50, 50);
   *
   *   noFill();
   *   stroke('green');
   *   rect(bounds.x, bounds.y, bounds.w, bounds.h);
   *
   *   noStroke();
   *   fill(50);
   *   textSize(15);
   *   text("Font Bounds: x=" + bounds.x.toFixed(1) + ", y=" + bounds.y.toFixed(1) +
   *        ", w=" + bounds.w.toFixed(1) + ", h=" + bounds.h.toFixed(1), 8, 100);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose width of a text string based on the current font.
   *
   * The `fontWidth()` function measures the width of the provided text string using
   * the font's default measurement (i.e., the width property from the text metrics returned by
   * the browser). Unlike `textWidth()`, which calculates the tight pixel boundaries
   * of the text glyphs, `fontWidth()` uses the font's intrinsic spacing, which may include
   * additional space for character spacing and kerning. This makes it useful for scenarios where
   * an approximate width is sufficient for layout and positioning.
   *
   * @method fontWidth
   * @for p5
   *
   * @param {String} theText - The text string to measure.
   * @returns {Number} The loose width of the text in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   textSize(32);
   *   textAlign(LEFT, TOP);
   *   textFont('Georgia');
   *
   *   let s = "Hello, World!";
   *   let fw = fontWidth(s);
   *
   *   fill(0);
   *   text(s, 50, 50);
   *
   *   stroke('blue');
   *   line(50, 90, 50 + fw, 90);
   *
   *   noStroke();
   *   fill(50);
   *   textSize(16);
   *   text("Font width: " + fw.toFixed(2) + " pixels", 50, 100);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose ascent of the text based on the font's intrinsic metrics.
   *
   * The `fontAscent()` function calculates the ascent of the text using the font's
   * intrinsic metrics (e.g., `fontBoundingBoxAscent`). This value represents the space
   * above the baseline that the font inherently occupies, and is useful for layout purposes when
   * an approximate vertical measurement is required.
   *
   * @method fontAscent
   * @for p5
   *
   * @returns {Number} The loose ascent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(220);
   *
   *   textSize(35);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the font descent of the current font
   *   let fasc = fontAscent();
   *
   *   // Draw a red line at the baseline and a blue line at the ascent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y - fasc, x + 200, y - fasc); // Font ascent position
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("fontAscent: " + fasc.toFixed(2) + " pixels", x, y + fdesc + 20);
   * }
   * </code>
   * </div>
   */ /**
   * Returns the loose descent of the text based on the font's intrinsic metrics.
   *
   * The `fontDescent()` function calculates the descent of the text using the font's
   * intrinsic metrics (e.g., `fontBoundingBoxDescent`). This value represents the space
   * below the baseline that the font inherently occupies, and is useful for layout purposes when
   * an approximate vertical measurement is required.
   *
   * @method fontDescent
   * @for p5
   *
   * @returns {Number} The loose descent value in pixels.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 300);
   *   background(220);
   *
   *   textSize(48);
   *   textAlign(LEFT, BASELINE);
   *   textFont('Georgia');
   *
   *   let s = "Hello, p5.js!";
   *   let x = 50, y = 150;
   *
   *   fill(0);
   *   text(s, x, y);
   *
   *   // Get the font descent of the current font
   *   let fdesc = fontDescent();
   *
   *   // Draw a red line at the baseline and a blue line at the descent position
   *   stroke('red');
   *   line(x, y, x + 200, y); // Baseline
   *   stroke('blue');
   *   line(x, y + fdesc, x + 200, y + fdesc); // Font descent position
   *
   *   noStroke();
   *   fill(0);
   *   textSize(16);
   *   text("fontDescent: " + fdesc.toFixed(2) + " pixels", x, y + fdesc + 20);
   * }
   * </code>
   * </div>
   */ /**
   *
   * Sets or gets the current font weight.
   *
   * The <code>textWeight()</code> function is used to specify the weight (thickness) of the text.
   * When a numeric value is provided, it sets the font weight to that value and updates the
   * rendering properties accordingly (including the "font-variation-settings" on the canvas style).
   * When called without an argument, it returns the current font weight setting.
   *
   * @method textWeight
   * @for p5
   *
   * @param {Number} weight - The numeric weight value to set for the text.
   * @returns {Number} If no arguments are provided, the current font weight
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(300, 200);
   *   background(240);
   *
   *   // Set text alignment, size, and font
   *   textAlign(LEFT, TOP);
   *   textSize(20);
   *   textFont("Georgia");
   *
   *   // Draw text with a normal weight (lighter appearance)
   *   push();
   *   textWeight(400);  // Set font weight to 400
   *   fill(0);
   *   text("Normal", 50, 50);
   *   let normalWeight = textWeight();  // Should return 400
   *   pop();
   *
   *   // Draw text with a bold weight (heavier appearance)
   *   push();
   *   textWeight(900);  // Set font weight to 900
   *   fill(0);
   *   text("Bold", 50, 100);
   *   let boldWeight = textWeight();  // Should return 900
   *   pop();
   *
   *   // Display the current font weight values on the canvas
   *   textSize(16);
   *   fill(50);
   *   text("Normal Weight: " + normalWeight, 150, 52);
   *   text("Bold Weight: " + boldWeight, 150, 100);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont(
   *     'https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap'
   *   );
   * }
   *
   * function draw() {
   *   background(255);
   *   textFont(font);
   *   textAlign(LEFT, TOP);
   *   textSize(35);
   *   textWeight(sin(millis() * 0.002) * 200 + 400);
   *   text('p5*js', 0, 10);
   *   describe('The text p5*js pulsing its weight over time');
   * }
   * </code>
   * </div>
   */ /**
   * @method textWeight
   * @for p5
   * @returns {Number} The current font weight
   */ // attach each text func to p5, delegating to the renderer
    textFunctions.forEach((func)=>{
        fn[func] = function(...args) {
            if (!(func in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype)) {
                throw Error(`Renderer2D.prototype.${func} is not defined.`);
            }
            return this._renderer[func](...args);
        };
        // attach also to p5.Graphics.prototype
        p51.Graphics.prototype[func] = function(...args) {
            return this._renderer[func](...args);
        };
    });
    const RendererTextProps = {
        textAlign: {
            default: fn.LEFT,
            type: 'Context2d'
        },
        textBaseline: {
            default: fn.BASELINE,
            type: 'Context2d'
        },
        textFont: {
            default: {
                family: 'sans-serif'
            }
        },
        textLeading: {
            default: 15
        },
        textSize: {
            default: 12
        },
        textWrap: {
            default: fn.WORD
        },
        fontStretch: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontWeight: {
            default: fn.NORMAL,
            isShorthand: true
        },
        lineHeight: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontVariant: {
            default: fn.NORMAL,
            isShorthand: true
        },
        fontStyle: {
            default: fn.NORMAL,
            isShorthand: true
        },
        direction: {
            default: 'inherit'
        } // direction: { default: inherit | ltr | rtl }
    };
    // note: font must be first here otherwise it may reset other properties
    const ContextTextProps = [
        'font',
        'direction',
        'fontKerning',
        'fontStretch',
        'fontVariantCaps',
        'letterSpacing',
        'textAlign',
        'textBaseline',
        'textRendering',
        'wordSpacing'
    ];
    // shorthand font properties that can be set with context2d.font
    const ShorthandFontProps = Object.keys(RendererTextProps).filter((p)=>RendererTextProps[p].isShorthand);
    // allowable values for font-stretch property for context2d.font
    const FontStretchKeys = [
        'ultra-condensed',
        'extra-condensed',
        'condensed',
        'semi-condensed',
        'normal',
        'semi-expanded',
        'expanded',
        'extra-expanded',
        'ultra-expanded'
    ];
    let contextQueue, cachedDiv; // lazy
    ////////////////////////////// start API ///////////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.text = function(str, x, y, width, height) {
        let setBaseline = this.textDrawingContext().textBaseline; // store baseline
        // adjust {x,y,w,h} properties based on rectMode
        ({ x, y, width, height } = this._handleRectMode(x, y, width, height));
        // parse the lines according to width, height & linebreaks
        let lines = this._processLines(str, width, height);
        // add the adjusted positions [x,y] to each line
        lines = this._positionLines(x, y, width, height, lines);
        // render each line at the adjusted position
        lines.forEach((line)=>this._renderText(line.text, line.x, line.y));
        this.textDrawingContext().textBaseline = setBaseline; // restore baseline
    };
    /**
   * Computes the precise (tight) bounding box for a block of text
   * @param {String} str - the text to measure
   * @param {Number} x - the x-coordinate of the text
   * @param {Number} y - the y-coordinate of the text
   * @param {Number} width - the max width of the text block
   * @param {Number} height - the max height of the text block
   * @returns - a bounding box object for the text block: {x,y,w,h}
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textBounds = function(str, x, y, width, height) {
        // delegate to _textBoundsSingle for measuring
        return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;
    };
    /**
   * Computes a generic (non-tight) bounding box for a block of text
   * @param {String} str - the text to measure
   * @param {Number} x - the x-coordinate of the text
   * @param {Number} y - the y-coordinate of the text
   * @param {Number} width - the max width of the text block
   * @param {Number} height - the max height of the text block
   * @returns - a bounding box object for the text block: {x,y,w,h}
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontBounds = function(str, x, y, width, height) {
        // delegate to _fontBoundsSingle for measuring
        return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;
    };
    /**
   * Get the width of a text string in pixels (tight bounds)
   * @param {String} theText
   * @returns - the width of the text in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWidth = function(theText) {
        let lines = this._processLines(theText);
        // return the max width of the lines (using tight bounds)
        return Math.max(...lines.map((l)=>this._textWidthSingle(l)));
    };
    /**
   * Get the width of a text string in pixels (loose bounds)
   * @param {String} theText
   * @returns - the width of the text in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontWidth = function(theText) {
        // return the max width of the lines (using loose bounds)
        let lines = this._processLines(theText);
        return Math.max(...lines.map((l)=>this._fontWidthSingle(l)));
    };
    /**
   * @param {*} txt - optional text to measure, if provided will be
   * used to compute the ascent, otherwise the font's ascent will be used
   * @returns - the ascent of the text
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textAscent = function(txt = '') {
        if (!txt.length) return this.fontAscent();
        return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
    };
    /**
   * @returns - returns the ascent for the current font
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontAscent = function() {
        return this.textDrawingContext().measureText('_').fontBoundingBoxAscent;
    };
    /**
   * @param {*} txt - optional text to measure, if provided will
   * be used to compute the descent, otherwise the font's descent will be used
   * @returns - the descent of the text
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textDescent = function(txt = '') {
        if (!txt.length) return this.fontDescent();
        return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.fontDescent = function() {
        return this.textDrawingContext().measureText('_').fontBoundingBoxDescent;
    };
    // setters/getters for text properties //////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textAlign = function(h, v) {
        // the setter
        if (typeof h !== 'undefined') {
            this.states.setValue('textAlign', h);
            if (typeof v !== 'undefined') {
                if (v === fn.CENTER) {
                    v = textCoreConstants._CTX_MIDDLE;
                }
                this.states.setValue('textBaseline', v);
            }
            return this._applyTextProperties();
        }
        // the getter
        return {
            horizontal: this.states.textAlign,
            vertical: this.states.textBaseline
        };
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._currentTextFont = function() {
        return this.states.textFont.font || this.states.textFont.family;
    };
    /**
   * Set the font and [size] and [options] for rendering text
   * @param {p5.Font | string} font - the font to use for rendering text
   * @param {Number} size - the size of the text, can be a number or a css-style string
   * @param {Object} options - additional options for rendering text, see FontProps
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textFont = function(font, size, options1) {
        if (arguments.length === 0) {
            return this._currentTextFont();
        }
        let family = font;
        // do we have a custon loaded font ?
        if (font instanceof p51.Font) {
            family = font.face.family;
        } else if (font.data instanceof Uint8Array) {
            family = font.name.fontFamily;
            if (font.name?.fontSubfamily) {
                family += '-' + font.name.fontSubfamily;
            }
        } else if (typeof font === 'string') {
            // direct set the font-string if it contains size
            if (typeof size === 'undefined' && /[.0-9]+(%|em|p[xt])/.test(family)) {
                //console.log('direct set font-string: ', family);
                ({ family, size } = this._directSetFontString(family));
            }
        }
        if (typeof family !== 'string') throw Error('null font in textFont()');
        // handle two-arg case: textFont(font, options)
        if (arguments.length === 2 && typeof size === 'object') {
            options1 = size;
            size = undefined;
        }
        // update font properties in this.states
        this.states.setValue('textFont', {
            font,
            family,
            size
        });
        // convert/update the size in this.states
        if (typeof size !== 'undefined') {
            this._setTextSize(size);
        }
        // apply any options to this.states
        if (typeof options1 === 'object') {
            this.textProperties(options1);
        }
        return this._applyTextProperties();
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._directSetFontString = function(font, debug = 0) {
        if (debug) console.log('_directSetFontString"' + font + '"');
        let defaults = ShorthandFontProps.reduce((props, p)=>{
            props[p] = RendererTextProps[p].default;
            return props;
        }, {});
        let el = this._cachedDiv(defaults);
        el.style.font = font;
        let style = getComputedStyle(el);
        ShorthandFontProps.forEach((prop)=>{
            this.states[prop] = style[prop];
            if (debug) console.log('  this.states.' + prop + '="' + style[prop] + '"');
        });
        return {
            family: style.fontFamily,
            size: style.fontSize
        };
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textLeading = function(leading) {
        // the setter
        if (typeof leading === 'number') {
            this.states.setValue('leadingSet', true);
            this.states.setValue('textLeading', leading);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.textLeading;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWeight = function(weight) {
        // the setter
        if (typeof weight === 'number') {
            this.states.setValue('fontWeight', weight);
            this._applyTextProperties();
            // Safari works without weight set in the canvas style attribute, and actually
            // has buggy behavior if it is present, using the wrong weight when drawing
            // multiple times with different weights
            if (!p51.prototype._isSafari()) {
                this._setCanvasStyleProperty('font-variation-settings', `"wght" ${weight}`);
            }
            return;
        }
        // the getter
        return this.states.fontWeight;
    };
    /**
   * @param {*} size - the size of the text, can be a number or a css-style string
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textSize = function(size) {
        // the setter
        if (typeof size !== 'undefined') {
            this._setTextSize(size);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.textSize;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textStyle = function(style) {
        // the setter
        if (typeof style !== 'undefined') {
            this.states.setValue('fontStyle', style);
            return this._applyTextProperties();
        }
        // the getter
        return this.states.fontStyle;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textWrap = function(wrapStyle) {
        if (wrapStyle === fn.WORD || wrapStyle === fn.CHAR) {
            this.states.setValue('textWrap', wrapStyle);
            // no need to apply text properties here as not a context property
            return this._pInst;
        }
        return this.states.textWrap;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textDirection = function(direction) {
        if (typeof direction !== 'undefined') {
            this.states.setValue('direction', direction);
            return this._applyTextProperties();
        }
        return this.states.direction;
    };
    /**
   * Sets/gets a single text property for the renderer (eg. fontStyle, fontStretch, etc.)
   * The property to be set can be a mapped or unmapped property on `this.states` or a property
   * on `this.textDrawingContext()` or on `this.canvas.style`
   * The property to get can exist in `this.states` or `this.textDrawingContext()` or `this.canvas.style`
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textProperty = function(prop, value, opts) {
        let modified = false, debug = opts?.debug || false;
        // getter: return option from this.states or this.textDrawingContext()
        if (typeof value === 'undefined') {
            let props = this.textProperties();
            if (prop in props) return props[prop];
            throw Error('Unknown text option "' + prop + '"'); // FES?
        }
        // set the option in this.states if it exists
        if (prop in this.states && this.states[prop] !== value) {
            this.states[prop] = value;
            modified = true;
            if (debug) {
                console.log('this.states.' + prop + '="' + options[prop] + '"');
            }
        } else if (prop in this.textDrawingContext()) {
            this._setContextProperty(prop, value, debug);
            modified = true;
        } else if (prop in this.textCanvas().style) {
            this._setCanvasStyleProperty(prop, value, debug);
            modified = true;
        } else {
            console.warn('Ignoring unknown text option: "' + prop + '"\n'); // FES?
        }
        return modified ? this._applyTextProperties() : this._pInst;
    };
    /**
   * Batch set/get text properties for the renderer.
   * The properties can be either on `states` or `drawingContext`
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textProperties = function(properties) {
        // setter
        if (typeof properties !== 'undefined') {
            Object.keys(properties).forEach((opt)=>{
                this.textProperty(opt, properties[opt]);
            });
            return this._pInst;
        }
        // getter: get props from drawingContext
        let context = this.textDrawingContext();
        properties = ContextTextProps.reduce((props, p)=>{
            props[p] = context[p];
            return props;
        }, {});
        // add renderer props
        Object.keys(RendererTextProps).forEach((p)=>{
            if (RendererTextProps[p]?.type === 'Context2d') {
                properties[p] = context[p];
            } else {
                if (p === 'textFont') {
                    // avoid circular ref. inside textFont
                    let current = this._currentTextFont();
                    if (typeof current === 'object' && '_pInst' in current) {
                        current = Object.assign({}, current);
                        delete current._pInst;
                    }
                    properties[p] = current;
                } else {
                    properties[p] = this.states[p];
                }
            }
        });
        return properties;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.textMode = function() {};
    /////////////////////////////// end API ////////////////////////////////
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._currentTextFont = function() {
        return this.states.textFont.font || this.states.textFont.family;
    };
    /*
    Compute the bounds for a block of text based on the specified
    measure function, either _textBoundsSingle or _fontBoundsSingle
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._computeBounds = function(type, str, x, y, width, height, opts) {
        let context = this.textDrawingContext();
        let setBaseline = context.textBaseline;
        let { textLeading, textAlign } = this.states;
        // adjust width, height based on current rectMode
        ({ width, height } = this._rectModeAdjust(x, y, width, height));
        // parse the lines according to the width & linebreaks
        let lines = this._processLines(str, width, height);
        // get the adjusted positions [x,y] for each line
        let boxes = lines.map((line, i)=>this[type].bind(this)(line, x, y + i * textLeading));
        if (lines.length > 1 && typeof width !== 'undefined') {
            // adjust the bounding boxes for horizontal text alignment in 2d
            // the WebGL mode version does additional alignment adjustments
            boxes.forEach((bb)=>bb.x += p51.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));
        }
        // adjust the bounding boxes for vertical text alignment in 2d
        // the WebGL mode version does additional alignment adjustments
        p51.Renderer2D.prototype._yAlignOffset.call(this, boxes, height || 0); // fix for #7984
        // get the bounds for the text block
        let bounds = boxes[0];
        if (lines.length > 1) {
            // get the bounds for the multi-line text block
            bounds = this._aggregateBounds(boxes);
            // align the multi-line bounds
            if (!opts?.ignoreRectMode) {
                this._rectModeAlign(bounds, width || 0, height || 0);
            }
        }
        context.textBaseline = setBaseline; // restore baseline
        return {
            bounds,
            lines
        };
    };
    /*
    Adjust width, height of bounds based on current rectMode
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAdjust = function(x, y, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    break;
                case fn.CORNERS:
                    width -= x;
                    height -= y;
                    break;
                case fn.RADIUS:
                    width *= 2;
                    height *= 2;
                    break;
            }
        }
        return {
            x,
            y,
            width,
            height
        };
    };
    /*
    Attempts to set a property directly on the canvas.style object
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setCanvasStyleProperty = function(opt, val, debug) {
        let value = val.toString(); // ensure its a string
        if (debug) console.log('canvas.style.' + opt + '="' + value + '"');
        // handle variable fonts options
        if (opt === FontVariationSettings) {
            this._handleFontVariationSettings(value);
        }
        // lets try to set it on the canvas style
        this.textCanvas().style[opt] = value;
        // check if the value was set successfully
        if (this.textCanvas().style[opt] !== value) ;
    };
    /*
    Parses the fontVariationSettings string and sets the font properties, only font-weight
    working consistently across browsers at present
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._handleFontVariationSettings = function(value, debug = false) {
        // check if the value is a string or an object
        if (typeof value === 'object') {
            value = Object.keys(value).map((k)=>k + ' ' + value[k]).join(', ');
        }
        let values = value.split(CommaDelimRe);
        values.forEach((v)=>{
            v = v.replace(/["']/g, ''); // remove quotes
            let matches = VariableAxesRe.exec(v);
            //console.log('matches: ', matches);
            if (matches && matches.length) {
                let axis = matches[0];
                // get the value to 3 digits of precision with no trailing zeros
                let val = parseFloat(parseFloat(v.replace(axis, '').trim()).toFixed(3));
                switch(axis){
                    case 'wght':
                        if (debug) console.log('setting font-weight=' + val);
                        // manually set the font-weight via the font string
                        if (this.states.fontWeight !== val) this.textWeight(val);
                        return val;
                    case 'wdth':
                        break;
                    case 'ital':
                        if (debug) console.log('setting font-style=' + (val ? 'italic' : 'normal'));
                        break;
                    case 'slnt':
                        if (debug) console.log('setting font-style=' + (val ? 'oblique' : 'normal'));
                        break;
                    case 'opsz':
                        if (debug) console.log('setting font-optical-size=' + val);
                        break;
                }
            }
        });
    };
    /*
    For properties not directly managed by the renderer in this.states
      we check if it has a mapping to a property in this.states
    Otherwise, add the property to the context-queue for later application
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setContextProperty = function(prop, val, debug = false) {
        // check if the value is actually different, else short-circuit
        if (this.textDrawingContext()[prop] === val) {
            return this._pInst;
        }
        // otherwise, we will set the property directly on the `this.textDrawingContext()`
        // by adding [property, value] to context-queue for later application
        (contextQueue ??= []).push([
            prop,
            val
        ]);
        if (debug) console.log('queued context2d.' + prop + '="' + val + '"');
    };
    /*
     Adjust parameters (x,y,w,h) based on current rectMode
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._handleRectMode = function(x, y, width, height) {
        let rectMode = this.states.rectMode;
        if (typeof width !== 'undefined') {
            switch(rectMode){
                case fn.RADIUS:
                    width *= 2;
                    x -= width / 2;
                    if (typeof height !== 'undefined') {
                        height *= 2;
                        y -= height / 2;
                    }
                    break;
                case fn.CENTER:
                    x -= width / 2;
                    if (typeof height !== 'undefined') {
                        y -= height / 2;
                    }
                    break;
                case fn.CORNERS:
                    width -= x;
                    if (typeof height !== 'undefined') {
                        height -= y;
                    }
                    break;
            }
        }
        return {
            x,
            y,
            width,
            height
        };
    };
    /*
    Get the computed font-size in pixels for a given size string
    @param {String} size - the font-size string to compute
    @returns {number} - the computed font-size in pixels
   * @private
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
        const isNumString = (num)=>!isNaN(num) && num.trim() !== '';
        // check for a number in a string, eg '12'
        if (isNumString(theSize)) {
            return parseFloat(theSize);
        }
        let ele = this._cachedDiv({
            fontSize: theSize
        });
        ele.style.fontSize = theSize;
        ele.style.fontFamily = family;
        let fontSizeStr = getComputedStyle(ele).fontSize;
        let fontSize = parseFloat(fontSizeStr);
        if (typeof fontSize !== 'number') {
            throw Error('textSize: invalid font-size');
        }
        return fontSize;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._cachedDiv = function(props) {
        if (typeof cachedDiv === 'undefined') {
            let ele = document.createElement('div');
            ele.ariaHidden = 'true';
            ele.style.display = 'none';
            Object.entries(props).forEach(([prop, val])=>{
                ele.style[prop] = val;
            });
            this.textCanvas().appendChild(ele);
            cachedDiv = ele;
        }
        return cachedDiv;
    };
    /*
    Aggregate the bounding boxes of multiple lines of text
    @param {Array} bboxes - the bounding boxes to aggregate
    @returns {object} - the aggregated bounding box
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._aggregateBounds = function(bboxes) {
        // loop over the bounding boxes to get the min/max x/y values
        let minX = Math.min(...bboxes.map((b)=>b.x));
        let minY = Math.min(...bboxes.map((b)=>b.y));
        let maxY = Math.max(...bboxes.map((b)=>b.y + b.h));
        let maxX = Math.max(...bboxes.map((b)=>b.x + b.w));
        return {
            x: minX,
            y: minY,
            w: maxX - minX,
            h: maxY - minY
        };
    };
    // Renderer.prototype._aggregateBounds = function (tx, ty, bboxes) {
    //   let x = Math.min(...bboxes.map(b => b.x));
    //   let y = Math.min(...bboxes.map(b => b.y));
    //   // the width is the max of the x-offset + the box width
    //   let w = Math.max(...bboxes.map(b => (b.x - tx) + b.w));
    //   let h = bboxes[bboxes.length - 1].y - bboxes[0].y + bboxes[bboxes.length - 1].h;
    //   return { x, y, w, h };
    // };
    /*
    Process the text string to handle line-breaks and text wrapping
    @param {String} str - the text to process
    @param {Number} width - the width to wrap the text to
    @returns {array} - the processed lines of text
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._processLines = function(str, width, height) {
        if (typeof width !== 'undefined') {
            let drawingContext = this.textDrawingContext();
            if (drawingContext.textBaseline === fn.BASELINE) {
                this.drawingContext.textBaseline = fn.TOP;
            }
        }
        let lines = this._splitOnBreaks(str.toString());
        let hasLineBreaks = lines.length > 1;
        let hasWidth = typeof width !== 'undefined';
        let exceedsWidth = hasWidth && lines.some((l)=>this._textWidthSingle(l) > width);
        let { textLeading: leading, textWrap } = this.states;
        //if (!hasLineBreaks && !exceedsWidth) return lines; // a single-line
        if (hasLineBreaks || exceedsWidth) {
            if (hasWidth) lines = this._lineate(textWrap, lines, width);
        }
        // handle height truncation
        if (hasWidth && typeof height !== 'undefined') {
            if (typeof leading === 'undefined') {
                throw Error('leading is required if height is specified');
            }
            // truncate lines that exceed the height
            for(let i = 0; i < lines.length; i++){
                let lh = leading * (i + 1);
                if (lh > height) {
                    //console.log('TRUNCATING: ', i, '-', lines.length, '"' + lines.slice(i) + '"');
                    lines = lines.slice(0, i);
                    break;
                }
            }
        }
        return lines;
    };
    /*
    Get the x-offset for text given the width and textAlign property
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._xAlignOffset = function(textAlign, width) {
        switch(textAlign){
            case fn.LEFT:
                return 0;
            case fn.CENTER:
                return width / 2;
            case fn.RIGHT:
                return width;
            case textCoreConstants.START:
                return 0;
            case textCoreConstants.END:
                throw new Error('textBounds: END not yet supported for textAlign');
            default:
                return 0;
        }
    };
    /*
    Align the bounding box based on the current rectMode setting
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAlign = function(bb, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    bb.x -= (width - bb.w) / 2;
                    bb.y -= (height - bb.h) / 2;
                    break;
                case fn.CORNERS:
                    bb.w += bb.x;
                    bb.h += bb.y;
                    break;
                case fn.RADIUS:
                    bb.x -= (width - bb.w) / 2;
                    bb.y -= (height - bb.h) / 2;
                    bb.w /= 2;
                    bb.h /= 2;
                    break;
            }
            return bb;
        }
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._rectModeAlignRevert = function(bb, width, height) {
        if (typeof width !== 'undefined') {
            switch(this.states.rectMode){
                case fn.CENTER:
                    bb.x += (width - bb.w) / 2;
                    bb.y += (height - bb.h) / 2;
                    break;
                case fn.CORNERS:
                    bb.w -= bb.x;
                    bb.h -= bb.y;
                    break;
                case fn.RADIUS:
                    bb.x += (width - bb.w) / 2;
                    bb.y += (height - bb.h) / 2;
                    bb.w *= 2;
                    bb.h *= 2;
                    break;
            }
            return bb;
        }
    };
    /*
    Get the (tight) width of a single line of text
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._textWidthSingle = function(s) {
        let metrics = this.textDrawingContext().measureText(s);
        let abl = metrics.actualBoundingBoxLeft;
        let abr = metrics.actualBoundingBoxRight;
        return abr + abl;
    };
    /*
    Get the (loose) width of a single line of text as specified by the font
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontWidthSingle = function(s) {
        return this.textDrawingContext().measureText(s).width;
    };
    /*
    Get the (tight) bounds of a single line of text based on its actual bounding box
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._textBoundsSingle = function(s, x = 0, y = 0) {
        let metrics = this.textDrawingContext().measureText(s);
        let asc = metrics.actualBoundingBoxAscent;
        let desc = metrics.actualBoundingBoxDescent;
        let abl = metrics.actualBoundingBoxLeft;
        let abr = metrics.actualBoundingBoxRight;
        return {
            x: x - abl,
            y: y - asc,
            w: abr + abl,
            h: asc + desc
        };
    };
    /*
    Get the (loose) bounds of a single line of text based on its font's bounding box
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._fontBoundsSingle = function(s, x = 0, y = 0) {
        let metrics = this.textDrawingContext().measureText(s);
        let asc = metrics.fontBoundingBoxAscent;
        let desc = metrics.fontBoundingBoxDescent;
        x -= this._xAlignOffset(this.states.textAlign, metrics.width);
        return {
            x,
            y: y - asc,
            w: metrics.width,
            h: asc + desc
        };
    };
    /*
    Set the textSize property in `this.states` if it has changed
    @param {number | string} theSize - the font-size to set
    @returns {boolean} - true if the size was changed, false otherwise
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._setTextSize = function(theSize) {
        if (typeof theSize === 'string') {
            // parse the size string via computed style, eg '2em'
            theSize = this._fontSizePx(theSize);
        }
        // should be a number now
        if (typeof theSize === 'number') {
            // set it in `this.states` if its been changed
            if (this.states.textSize !== theSize) {
                this.states.setValue('textSize', theSize);
                // handle leading here, if not set otherwise
                if (!this.states.leadingSet) {
                    this.states.setValue('textLeading', this.states.textSize * LeadingScale);
                }
                return true; // size was changed
            }
        } else {
            console.warn('textSize: invalid size: ' + theSize);
        }
        return false;
    };
    /*
    Split the lines of text based on the width and the textWrap property
    @param {Array} lines - the lines of text to split
    @param {Number} maxWidth - the maximum width of the lines
    @param {Object} opts - additional options for splitting the lines
    @returns {array} - the split lines of text
   * @private
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
        let splitter = opts.splitChar ?? (textWrap === fn.WORD ? ' ' : '');
        let line, testLine, testWidth, words, newLines = [];
        for(let lidx = 0; lidx < lines.length; lidx++){
            line = '';
            words = lines[lidx].split(splitter);
            for(let widx = 0; widx < words.length; widx++){
                testLine = `${line + words[widx]}` + splitter;
                testWidth = this._textWidthSingle(testLine);
                if (line.length > 0 && testWidth > maxWidth) {
                    newLines.push(line.trim());
                    line = `${words[widx]}` + splitter;
                } else {
                    line = testLine;
                }
            }
            newLines.push(line.trim());
        }
        return newLines;
    };
    /*
    Split the text into lines based on line-breaks and tabs
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._splitOnBreaks = function(s) {
        if (!s || s.length === 0) return [
            ''
        ];
        return s.replace(TabsRe, '  ').split(LinebreakRe);
    };
    /*
    Parse the font-family string to handle complex names, fallbacks, etc.
  */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._parseFontFamily = function(familyStr) {
        let parts = familyStr.split(CommaDelimRe);
        let family = parts.map((part)=>{
            part = part.trim();
            if (part.indexOf(' ') > -1 && !QuotedRe.test(part)) {
                part = `"${part}"`; // quote font names with spaces
            }
            return part;
        }).join(', ');
        return family;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._applyFontString = function() {
        /*
      Create the font-string according to the CSS font-string specification:
      If font is specified as a shorthand for several font-related properties, then:
      - it must include values for: <font-size> and <font-family>
      - it may optionally include values for:
          [<font-style>, <font-variant>, <font-weight>, <font-stretch>, <line-height>]
      Format:
      - font-style, font-variant and font-weight must precede font-size
      - font-variant may only specify the values defined in CSS 2.1, that is 'normal' and 'small-caps'.
      - font-stretch may only be a single keyword value.
      - line-height must immediately follow font-size, preceded by "/", eg 16px/3.
      - font-family must be the last value specified.
    */ let { textFont, textSize, lineHeight, fontStyle, fontWeight, fontVariant } = this.states;
        let drawingContext = this.textDrawingContext();
        let family = this._parseFontFamily(textFont.family);
        let style = fontStyle !== fn.NORMAL ? `${fontStyle} ` : '';
        let weight = fontWeight !== fn.NORMAL ? `${fontWeight} ` : '';
        let variant = fontVariant !== fn.NORMAL ? `${fontVariant} ` : '';
        let fsize = `${textSize}px` + (lineHeight !== fn.NORMAL ? `/${lineHeight} ` : ' ');
        let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();
        //console.log('fontString="' + fontString + '"');
        // set the font string on the context
        drawingContext.font = fontString;
        // verify that it was set successfully
        if (drawingContext.font !== fontString) {
            let expected = fontString;
            let actual = drawingContext.font;
            if (expected !== actual) {
                //console.warn(`Unable to set font property on context2d. It may not be supported.`);
                //console.log('Expected "' + expected + '" but got: "' + actual + '"'); // TMP
                return false;
            }
        }
        return true;
    };
    /*
    Apply the text properties in `this.states` to the `this.textDrawingContext()`
    Then apply any properties in the context-queue
   */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._applyTextProperties = function(debug = false) {
        this._applyFontString();
        // set these after the font so they're not overridden
        let context = this.textDrawingContext();
        context.direction = this.states.direction;
        context.textAlign = this.states.textAlign;
        context.textBaseline = this.states.textBaseline;
        // set manually as (still) not fully supported as part of font-string
        let stretch = this.states.fontStretch;
        if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {
            context.fontStretch = stretch;
        }
        // apply each property in queue after the font so they're not overridden
        while(contextQueue?.length){
            let [prop, val] = contextQueue.shift();
            if (debug) console.log('apply context property "' + prop + '" = "' + val + '"');
            context[prop] = val;
            // check if the value was set successfully
            if (context[prop] !== val) {
                console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`); // FES?
                console.log('Expected "' + val + '" but got: "' + context[prop] + '"');
            }
        }
        return this._pInst;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._middleAlignOffset = function() {
        const { textFont, textSize } = this.states;
        const font = textFont?.font;
        const ctx = this.textDrawingContext();
        const metrics = ctx.measureText('X');
        let sCapHeight = (font?.data || {})['OS/2']?.sCapHeight;
        if (sCapHeight) {
            const unitsPerEm = font.data.head.unitsPerEm;
            sCapHeight *= textSize / unitsPerEm;
        } else {
            sCapHeight = metrics.fontBoundingBoxAscent;
        }
        return metrics.alphabeticBaseline + sCapHeight / 2;
    };
    if (p51.Renderer2D) {
        p51.Renderer2D.prototype.textCanvas = function() {
            return this.canvas;
        };
        p51.Renderer2D.prototype.textDrawingContext = function() {
            return this.drawingContext;
        };
        p51.Renderer2D.prototype._renderText = function(text, x, y, maxY, minY) {
            let states = this.states;
            let context = this.textDrawingContext();
            if (y < minY || y >= maxY) {
                return; // don't render lines beyond minY/maxY
            }
            this.push();
            // no stroke unless specified by user
            if (states.strokeColor && states.strokeSet) {
                context.strokeText(text, x, y);
            }
            if (!this._clipping && states.fillColor) {
                // if fill hasn't been set by user, use default text fill
                if (!states.fillSet) {
                    this._setFill(DefaultFill);
                }
                context.fillText(text, x, y);
            }
            this.pop();
        };
        /*
      Position the lines of text based on their textAlign/textBaseline properties
    */ p51.Renderer2D.prototype._positionLines = function(x, y, width, height, lines) {
            let { textLeading, textAlign } = this.states;
            let adjustedX, lineData = new Array(lines.length);
            let adjustedW = typeof width === 'undefined' ? 0 : width;
            let adjustedH = typeof height === 'undefined' ? 0 : height;
            for(let i = 0; i < lines.length; i++){
                switch(textAlign){
                    case textCoreConstants.START:
                        throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT
                    case fn.LEFT:
                        adjustedX = x;
                        break;
                    case fn.CENTER:
                        adjustedX = x + adjustedW / 2;
                        break;
                    case fn.RIGHT:
                        adjustedX = x + adjustedW;
                        break;
                    case textCoreConstants.END:
                        throw new Error('textBounds: END not yet supported for textAlign');
                }
                lineData[i] = {
                    text: lines[i],
                    x: adjustedX,
                    y: y + i * textLeading
                };
            }
            return this._yAlignOffset(lineData, adjustedH);
        };
        /*
      Get the y-offset for text given the height, leading, line-count and textBaseline property
    */ p51.Renderer2D.prototype._yAlignOffset = function(dataArr, height) {
            if (typeof height === 'undefined') {
                throw Error('_yAlignOffset: height is required');
            }
            let { textLeading, textBaseline } = this.states;
            let yOff = 0, numLines = dataArr.length;
            let ydiff = height - textLeading * (numLines - 1);
            switch(textBaseline){
                case fn.TOP:
                    break; // ??
                case fn.BASELINE:
                    break;
                case textCoreConstants._CTX_MIDDLE:
                    yOff = ydiff / 2 + this._middleAlignOffset();
                    break;
                case fn.BOTTOM:
                    yOff = ydiff;
                    break;
                case textCoreConstants.IDEOGRAPHIC:
                    console.warn('textBounds: IDEOGRAPHIC not yet supported for textBaseline'); // FES?
                    break;
                case textCoreConstants.HANGING:
                    console.warn('textBounds: HANGING not yet supported for textBaseline'); // FES?
                    break;
            }
            dataArr.forEach((ele)=>ele.y += yOff);
            return dataArr;
        };
    }
    if (p51.RendererGL) {
        p51.RendererGL.prototype.textCanvas = function() {
            if (!this._textCanvas) {
                this._textCanvas = document.createElement('canvas');
                this._textCanvas.width = 1;
                this._textCanvas.height = 1;
                this._textCanvas.style.display = 'none';
                // Has to be added to the DOM for measureText to work properly!
                this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
            }
            return this._textCanvas;
        };
        p51.RendererGL.prototype.textDrawingContext = function() {
            if (!this._textDrawingContext) {
                const textCanvas = this.textCanvas();
                this._textDrawingContext = textCanvas.getContext('2d');
            }
            return this._textDrawingContext;
        };
        const oldRemove = p51.RendererGL.prototype.remove;
        p51.RendererGL.prototype.remove = function() {
            if (this._textCanvas) {
                this._textCanvas.parentElement.removeChild(this._textCanvas);
            }
            oldRemove.call(this);
        };
        p51.RendererGL.prototype._positionLines = function(x, y, width, height, lines) {
            let { textLeading, textAlign } = this.states;
            const widths = lines.map((line)=>this._fontWidthSingle(line));
            let adjustedX, lineData = new Array(lines.length);
            let adjustedW = typeof width === 'undefined' ? Math.max(0, ...widths) : width;
            let adjustedH = typeof height === 'undefined' ? 0 : height;
            for(let i = 0; i < lines.length; i++){
                switch(textAlign){
                    case textCoreConstants.START:
                        throw new Error('textBounds: START not yet supported for textAlign'); // default to LEFT
                    case fn.LEFT:
                        adjustedX = x;
                        break;
                    case fn.CENTER:
                        adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;
                        break;
                    case fn.RIGHT:
                        adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);
                        break;
                    case textCoreConstants.END:
                        throw new Error('textBounds: END not yet supported for textAlign');
                }
                lineData[i] = {
                    text: lines[i],
                    x: adjustedX,
                    y: y + i * textLeading
                };
            }
            return this._yAlignOffset(lineData, adjustedH);
        };
        p51.RendererGL.prototype._verticalAlignFont = function() {
            const ctx = this.textDrawingContext();
            const metrics = ctx.measureText('X');
            return -metrics.alphabeticBaseline || -metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;
        };
        p51.RendererGL.prototype._yAlignOffset = function(dataArr, height) {
            if (typeof height === 'undefined') {
                throw Error('_yAlignOffset: height is required');
            }
            let { textLeading, textBaseline, textSize, textFont } = this.states;
            let yOff = 0, numLines = dataArr.length;
            let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
            switch(textBaseline){
                case fn.TOP:
                    yOff = this._verticalAlignFont();
                    break;
                case fn.BASELINE:
                    break;
                case textCoreConstants._CTX_MIDDLE:
                    yOff = (-totalHeight + textSize + (height || 0)) / 2 + this._verticalAlignFont() + this._middleAlignOffset();
                    break;
                case fn.BOTTOM:
                    yOff = -(totalHeight - textSize) + (height || 0);
                    break;
                default:
                    console.warn(`${textBaseline} is not supported in WebGL mode.`); // FES?
                    break;
            }
            dataArr.forEach((ele)=>ele.y += yOff);
            return dataArr;
        };
    }
}
if (typeof p5 !== 'undefined') {
    textCore(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "unicodeRanges",
    ()=>unicodeRanges
]);
// From https://github.com/radiovisual/unicode-range-json,
// with decimal ranges removed to save space, and with category
// names converted to lowercase ahead of time
const unicodeRanges = [
    {
        category: 'control character',
        hexrange: [
            '0000',
            '001f'
        ]
    },
    {
        category: 'basic latin',
        hexrange: [
            '0000',
            '007f'
        ]
    },
    {
        category: 'latin-1 supplement',
        hexrange: [
            '0080',
            '00ff'
        ]
    },
    {
        category: 'latin extended-a',
        hexrange: [
            '0100',
            '017f'
        ]
    },
    {
        category: 'latin extended-b',
        hexrange: [
            '0180',
            '024f'
        ]
    },
    {
        category: 'ipa extensions',
        hexrange: [
            '0250',
            '02af'
        ]
    },
    {
        category: 'spacing modifier letters',
        hexrange: [
            '02b0',
            '02ff'
        ]
    },
    {
        category: 'combining diacritical marks',
        hexrange: [
            '0300',
            '036f'
        ]
    },
    {
        category: 'greek and coptic',
        hexrange: [
            '0370',
            '03ff'
        ]
    },
    {
        category: 'cyrillic',
        hexrange: [
            '0400',
            '04ff'
        ]
    },
    {
        category: 'cyrillic supplement',
        hexrange: [
            '0500',
            '052f'
        ]
    },
    {
        category: 'armenian',
        hexrange: [
            '0530',
            '058f'
        ]
    },
    {
        category: 'hebrew',
        hexrange: [
            '0590',
            '05ff'
        ]
    },
    {
        category: 'arabic',
        hexrange: [
            '0600',
            '06ff'
        ]
    },
    {
        category: 'syriac',
        hexrange: [
            '0700',
            '074f'
        ]
    },
    {
        category: 'arabic supplement',
        hexrange: [
            '0750',
            '077f'
        ]
    },
    {
        category: 'thaana',
        hexrange: [
            '0780',
            '07bf'
        ]
    },
    {
        category: 'nko',
        hexrange: [
            '07c0',
            '07ff'
        ]
    },
    {
        category: 'samaritan',
        hexrange: [
            '0800',
            '083f'
        ]
    },
    {
        category: 'mandaic',
        hexrange: [
            '0840',
            '085f'
        ]
    },
    {
        category: 'syriac supplement',
        hexrange: [
            '0860',
            '086f'
        ]
    },
    {
        category: 'arabic extended-b',
        hexrange: [
            '0870',
            '089f'
        ]
    },
    {
        category: 'arabic extended-a',
        hexrange: [
            '08a0',
            '08ff'
        ]
    },
    {
        category: 'devanagari',
        hexrange: [
            '0900',
            '097f'
        ]
    },
    {
        category: 'bengali',
        hexrange: [
            '0980',
            '09ff'
        ]
    },
    {
        category: 'gurmukhi',
        hexrange: [
            '0a00',
            '0a7f'
        ]
    },
    {
        category: 'gujarati',
        hexrange: [
            '0a80',
            '0aff'
        ]
    },
    {
        category: 'oriya',
        hexrange: [
            '0b00',
            '0b7f'
        ]
    },
    {
        category: 'tamil',
        hexrange: [
            '0b80',
            '0bff'
        ]
    },
    {
        category: 'telugu',
        hexrange: [
            '0c00',
            '0c7f'
        ]
    },
    {
        category: 'kannada',
        hexrange: [
            '0c80',
            '0cff'
        ]
    },
    {
        category: 'malayalam',
        hexrange: [
            '0d00',
            '0d7f'
        ]
    },
    {
        category: 'sinhala',
        hexrange: [
            '0d80',
            '0dff'
        ]
    },
    {
        category: 'thai',
        hexrange: [
            '0e00',
            '0e7f'
        ]
    },
    {
        category: 'lao',
        hexrange: [
            '0e80',
            '0eff'
        ]
    },
    {
        category: 'tibetan',
        hexrange: [
            '0f00',
            '0fff'
        ]
    },
    {
        category: 'myanmar',
        hexrange: [
            '1000',
            '109f'
        ]
    },
    {
        category: 'georgian',
        hexrange: [
            '10a0',
            '10ff'
        ]
    },
    {
        category: 'hangul jamo',
        hexrange: [
            '1100',
            '11ff'
        ]
    },
    {
        category: 'ethiopic',
        hexrange: [
            '1200',
            '137f'
        ]
    },
    {
        category: 'ethiopic supplement',
        hexrange: [
            '1380',
            '139f'
        ]
    },
    {
        category: 'cherokee',
        hexrange: [
            '13a0',
            '13ff'
        ]
    },
    {
        category: 'unified canadian aboriginal syllabics',
        hexrange: [
            '1400',
            '167f'
        ]
    },
    {
        category: 'ogham',
        hexrange: [
            '1680',
            '169f'
        ]
    },
    {
        category: 'runic',
        hexrange: [
            '16a0',
            '16ff'
        ]
    },
    {
        category: 'tagalog',
        hexrange: [
            '1700',
            '171f'
        ]
    },
    {
        category: 'hanunoo',
        hexrange: [
            '1720',
            '173f'
        ]
    },
    {
        category: 'buhid',
        hexrange: [
            '1740',
            '175f'
        ]
    },
    {
        category: 'tagbanwa',
        hexrange: [
            '1760',
            '177f'
        ]
    },
    {
        category: 'khmer',
        hexrange: [
            '1780',
            '17ff'
        ]
    },
    {
        category: 'mongolian',
        hexrange: [
            '1800',
            '18af'
        ]
    },
    {
        category: 'unified canadian aboriginal syllabics extended',
        hexrange: [
            '18b0',
            '18ff'
        ]
    },
    {
        category: 'limbu',
        hexrange: [
            '1900',
            '194f'
        ]
    },
    {
        category: 'tai le',
        hexrange: [
            '1950',
            '197f'
        ]
    },
    {
        category: 'new tai lue',
        hexrange: [
            '1980',
            '19df'
        ]
    },
    {
        category: 'khmer symbols',
        hexrange: [
            '19e0',
            '19ff'
        ]
    },
    {
        category: 'buginese',
        hexrange: [
            '1a00',
            '1a1f'
        ]
    },
    {
        category: 'tai tham',
        hexrange: [
            '1a20',
            '1aaf'
        ]
    },
    {
        category: 'combining diacritical marks extended',
        hexrange: [
            '1ab0',
            '1aff'
        ]
    },
    {
        category: 'balinese',
        hexrange: [
            '1b00',
            '1b7f'
        ]
    },
    {
        category: 'sundanese',
        hexrange: [
            '1b80',
            '1bbf'
        ]
    },
    {
        category: 'batak',
        hexrange: [
            '1bc0',
            '1bff'
        ]
    },
    {
        category: 'lepcha',
        hexrange: [
            '1c00',
            '1c4f'
        ]
    },
    {
        category: 'ol chiki',
        hexrange: [
            '1c50',
            '1c7f'
        ]
    },
    {
        category: 'cyrillic extended-c',
        hexrange: [
            '1c80',
            '1c8f'
        ]
    },
    {
        category: 'georgian extended',
        hexrange: [
            '1c90',
            '1cbf'
        ]
    },
    {
        category: 'sundanese supplement',
        hexrange: [
            '1cc0',
            '1ccf'
        ]
    },
    {
        category: 'vedic extensions',
        hexrange: [
            '1cd0',
            '1cff'
        ]
    },
    {
        category: 'phonetic extensions',
        hexrange: [
            '1d00',
            '1d7f'
        ]
    },
    {
        category: 'phonetic extensions supplement',
        hexrange: [
            '1d80',
            '1dbf'
        ]
    },
    {
        category: 'combining diacritical marks supplement',
        hexrange: [
            '1dc0',
            '1dff'
        ]
    },
    {
        category: 'latin extended additional',
        hexrange: [
            '1e00',
            '1eff'
        ]
    },
    {
        category: 'greek extended',
        hexrange: [
            '1f00',
            '1fff'
        ]
    },
    {
        category: 'general punctuation',
        hexrange: [
            '2000',
            '206f'
        ]
    },
    {
        category: 'superscripts and subscripts',
        hexrange: [
            '2070',
            '209f'
        ]
    },
    {
        category: 'currency symbols',
        hexrange: [
            '20a0',
            '20cf'
        ]
    },
    {
        category: 'combining diacritical marks for symbols',
        hexrange: [
            '20d0',
            '20ff'
        ]
    },
    {
        category: 'letterlike symbols',
        hexrange: [
            '2100',
            '214f'
        ]
    },
    {
        category: 'number forms',
        hexrange: [
            '2150',
            '218f'
        ]
    },
    {
        category: 'arrows',
        hexrange: [
            '2190',
            '21ff'
        ]
    },
    {
        category: 'mathematical operators',
        hexrange: [
            '2200',
            '22ff'
        ]
    },
    {
        category: 'miscellaneous technical',
        hexrange: [
            '2300',
            '23ff'
        ]
    },
    {
        category: 'control pictures',
        hexrange: [
            '2400',
            '243f'
        ]
    },
    {
        category: 'optical character recognition',
        hexrange: [
            '2440',
            '245f'
        ]
    },
    {
        category: 'enclosed alphanumerics',
        hexrange: [
            '2460',
            '24ff'
        ]
    },
    {
        category: 'box drawing',
        hexrange: [
            '2500',
            '257f'
        ]
    },
    {
        category: 'block elements',
        hexrange: [
            '2580',
            '259f'
        ]
    },
    {
        category: 'geometric shapes',
        hexrange: [
            '25a0',
            '25ff'
        ]
    },
    {
        category: 'miscellaneous symbols',
        hexrange: [
            '2600',
            '26ff'
        ]
    },
    {
        category: 'dingbats',
        hexrange: [
            '2700',
            '27bf'
        ]
    },
    {
        category: 'miscellaneous mathematical symbols-a',
        hexrange: [
            '27c0',
            '27ef'
        ]
    },
    {
        category: 'supplemental arrows-a',
        hexrange: [
            '27f0',
            '27ff'
        ]
    },
    {
        category: 'braille patterns',
        hexrange: [
            '2800',
            '28ff'
        ]
    },
    {
        category: 'supplemental arrows-b',
        hexrange: [
            '2900',
            '297f'
        ]
    },
    {
        category: 'miscellaneous mathematical symbols-b',
        hexrange: [
            '2980',
            '29ff'
        ]
    },
    {
        category: 'supplemental mathematical operators',
        hexrange: [
            '2a00',
            '2aff'
        ]
    },
    {
        category: 'miscellaneous symbols and arrows',
        hexrange: [
            '2b00',
            '2bff'
        ]
    },
    {
        category: 'glagolitic',
        hexrange: [
            '2c00',
            '2c5f'
        ]
    },
    {
        category: 'latin extended-c',
        hexrange: [
            '2c60',
            '2c7f'
        ]
    },
    {
        category: 'coptic',
        hexrange: [
            '2c80',
            '2cff'
        ]
    },
    {
        category: 'georgian supplement',
        hexrange: [
            '2d00',
            '2d2f'
        ]
    },
    {
        category: 'tifinagh',
        hexrange: [
            '2d30',
            '2d7f'
        ]
    },
    {
        category: 'ethiopic extended',
        hexrange: [
            '2d80',
            '2ddf'
        ]
    },
    {
        category: 'cyrillic extended-a',
        hexrange: [
            '2de0',
            '2dff'
        ]
    },
    {
        category: 'supplemental punctuation',
        hexrange: [
            '2e00',
            '2e7f'
        ]
    },
    {
        category: 'cjk radicals supplement',
        hexrange: [
            '2e80',
            '2eff'
        ]
    },
    {
        category: 'kangxi radicals',
        hexrange: [
            '2f00',
            '2fdf'
        ]
    },
    {
        category: 'ideographic description characters',
        hexrange: [
            '2ff0',
            '2fff'
        ]
    },
    {
        category: 'cjk symbols and punctuation',
        hexrange: [
            '3000',
            '303f'
        ]
    },
    {
        category: 'hiragana',
        hexrange: [
            '3040',
            '309f'
        ]
    },
    {
        category: 'katakana',
        hexrange: [
            '30a0',
            '30ff'
        ]
    },
    {
        category: 'bopomofo',
        hexrange: [
            '3100',
            '312f'
        ]
    },
    {
        category: 'hangul compatibility jamo',
        hexrange: [
            '3130',
            '318f'
        ]
    },
    {
        category: 'kanbun',
        hexrange: [
            '3190',
            '319f'
        ]
    },
    {
        category: 'bopomofo extended',
        hexrange: [
            '31a0',
            '31bf'
        ]
    },
    {
        category: 'cjk strokes',
        hexrange: [
            '31c0',
            '31ef'
        ]
    },
    {
        category: 'katakana phonetic extensions',
        hexrange: [
            '31f0',
            '31ff'
        ]
    },
    {
        category: 'enclosed cjk letters and months',
        hexrange: [
            '3200',
            '32ff'
        ]
    },
    {
        category: 'cjk compatibility',
        hexrange: [
            '3300',
            '33ff'
        ]
    },
    {
        category: 'cjk unified ideographs extension a',
        hexrange: [
            '3400',
            '4dbf'
        ]
    },
    {
        category: 'yijing hexagram symbols',
        hexrange: [
            '4dc0',
            '4dff'
        ]
    },
    {
        category: 'cjk unified ideographs',
        hexrange: [
            '4e00',
            '9fff'
        ]
    },
    {
        category: 'yi syllables',
        hexrange: [
            'a000',
            'a48f'
        ]
    },
    {
        category: 'yi radicals',
        hexrange: [
            'a490',
            'a4cf'
        ]
    },
    {
        category: 'lisu',
        hexrange: [
            'a4d0',
            'a4ff'
        ]
    },
    {
        category: 'vai',
        hexrange: [
            'a500',
            'a63f'
        ]
    },
    {
        category: 'cyrillic extended-b',
        hexrange: [
            'a640',
            'a69f'
        ]
    },
    {
        category: 'bamum',
        hexrange: [
            'a6a0',
            'a6ff'
        ]
    },
    {
        category: 'modifier tone letters',
        hexrange: [
            'a700',
            'a71f'
        ]
    },
    {
        category: 'latin extended-d',
        hexrange: [
            'a720',
            'a7ff'
        ]
    },
    {
        category: 'syloti nagri',
        hexrange: [
            'a800',
            'a82f'
        ]
    },
    {
        category: 'common indic number forms',
        hexrange: [
            'a830',
            'a83f'
        ]
    },
    {
        category: 'phags-pa',
        hexrange: [
            'a840',
            'a87f'
        ]
    },
    {
        category: 'saurashtra',
        hexrange: [
            'a880',
            'a8df'
        ]
    },
    {
        category: 'devanagari extended',
        hexrange: [
            'a8e0',
            'a8ff'
        ]
    },
    {
        category: 'kayah li',
        hexrange: [
            'a900',
            'a92f'
        ]
    },
    {
        category: 'rejang',
        hexrange: [
            'a930',
            'a95f'
        ]
    },
    {
        category: 'hangul jamo extended-a',
        hexrange: [
            'a960',
            'a97f'
        ]
    },
    {
        category: 'javanese',
        hexrange: [
            'a980',
            'a9df'
        ]
    },
    {
        category: 'myanmar extended-b',
        hexrange: [
            'a9e0',
            'a9ff'
        ]
    },
    {
        category: 'cham',
        hexrange: [
            'aa00',
            'aa5f'
        ]
    },
    {
        category: 'myanmar extended-a',
        hexrange: [
            'aa60',
            'aa7f'
        ]
    },
    {
        category: 'tai viet',
        hexrange: [
            'aa80',
            'aadf'
        ]
    },
    {
        category: 'meetei mayek extensions',
        hexrange: [
            'aae0',
            'aaff'
        ]
    },
    {
        category: 'ethiopic extended-a',
        hexrange: [
            'ab00',
            'ab2f'
        ]
    },
    {
        category: 'latin extended-e',
        hexrange: [
            'ab30',
            'ab6f'
        ]
    },
    {
        category: 'cherokee supplement',
        hexrange: [
            'ab70',
            'abbf'
        ]
    },
    {
        category: 'meetei mayek',
        hexrange: [
            'abc0',
            'abff'
        ]
    },
    {
        category: 'hangul syllables',
        hexrange: [
            'ac00',
            'd7af'
        ]
    },
    {
        category: 'hangul jamo extended-b',
        hexrange: [
            'd7b0',
            'd7ff'
        ]
    },
    {
        category: 'high surrogates',
        hexrange: [
            'd800',
            'db7f'
        ]
    },
    {
        category: 'high private use surrogates',
        hexrange: [
            'db80',
            'dbff'
        ]
    },
    {
        category: 'low surrogates',
        hexrange: [
            'dc00',
            'dfff'
        ]
    },
    {
        category: 'private use area',
        hexrange: [
            'e000',
            'f8ff'
        ]
    },
    {
        category: 'cjk compatibility ideographs',
        hexrange: [
            'f900',
            'faff'
        ]
    },
    {
        category: 'alphabetic presentation forms',
        hexrange: [
            'fb00',
            'fb4f'
        ]
    },
    {
        category: 'arabic presentation forms-a',
        hexrange: [
            'fb50',
            'fdff'
        ]
    },
    {
        category: 'variation selectors',
        hexrange: [
            'fe00',
            'fe0f'
        ]
    },
    {
        category: 'vertical forms',
        hexrange: [
            'fe10',
            'fe1f'
        ]
    },
    {
        category: 'combining half marks',
        hexrange: [
            'fe20',
            'fe2f'
        ]
    },
    {
        category: 'cjk compatibility forms',
        hexrange: [
            'fe30',
            'fe4f'
        ]
    },
    {
        category: 'small form variants',
        hexrange: [
            'fe50',
            'fe6f'
        ]
    },
    {
        category: 'arabic presentation forms-b',
        hexrange: [
            'fe70',
            'feff'
        ]
    },
    {
        category: 'halfwidth and fullwidth forms',
        hexrange: [
            'ff00',
            'ffef'
        ]
    },
    {
        category: 'specials',
        hexrange: [
            'fff0',
            'ffff'
        ]
    },
    {
        category: 'linear b syllabary',
        hexrange: [
            '10000',
            '1007f'
        ]
    },
    {
        category: 'linear b ideograms',
        hexrange: [
            '10080',
            '100ff'
        ]
    },
    {
        category: 'aegean numbers',
        hexrange: [
            '10100',
            '1013f'
        ]
    },
    {
        category: 'ancient greek numbers',
        hexrange: [
            '10140',
            '1018f'
        ]
    },
    {
        category: 'ancient symbols',
        hexrange: [
            '10190',
            '101cf'
        ]
    },
    {
        category: 'phaistos disc',
        hexrange: [
            '101d0',
            '101ff'
        ]
    },
    {
        category: 'lycian',
        hexrange: [
            '10280',
            '1029f'
        ]
    },
    {
        category: 'carian',
        hexrange: [
            '102a0',
            '102df'
        ]
    },
    {
        category: 'coptic epact numbers',
        hexrange: [
            '102e0',
            '102ff'
        ]
    },
    {
        category: 'old italic',
        hexrange: [
            '10300',
            '1032f'
        ]
    },
    {
        category: 'gothic',
        hexrange: [
            '10330',
            '1034f'
        ]
    },
    {
        category: 'old permic',
        hexrange: [
            '10350',
            '1037f'
        ]
    },
    {
        category: 'ugaritic',
        hexrange: [
            '10380',
            '1039f'
        ]
    },
    {
        category: 'old persian',
        hexrange: [
            '103a0',
            '103df'
        ]
    },
    {
        category: 'deseret',
        hexrange: [
            '10400',
            '1044f'
        ]
    },
    {
        category: 'shavian',
        hexrange: [
            '10450',
            '1047f'
        ]
    },
    {
        category: 'osmanya',
        hexrange: [
            '10480',
            '104af'
        ]
    },
    {
        category: 'osage',
        hexrange: [
            '104b0',
            '104ff'
        ]
    },
    {
        category: 'elbasan',
        hexrange: [
            '10500',
            '1052f'
        ]
    },
    {
        category: 'caucasian albanian',
        hexrange: [
            '10530',
            '1056f'
        ]
    },
    {
        category: 'vithkuqi',
        hexrange: [
            '10570',
            '105bf'
        ]
    },
    {
        category: 'linear a',
        hexrange: [
            '10600',
            '1077f'
        ]
    },
    {
        category: 'latin extended-f',
        hexrange: [
            '10780',
            '107bf'
        ]
    },
    {
        category: 'cypriot syllabary',
        hexrange: [
            '10800',
            '1083f'
        ]
    },
    {
        category: 'imperial aramaic',
        hexrange: [
            '10840',
            '1085f'
        ]
    },
    {
        category: 'palmyrene',
        hexrange: [
            '10860',
            '1087f'
        ]
    },
    {
        category: 'nabataean',
        hexrange: [
            '10880',
            '108af'
        ]
    },
    {
        category: 'hatran',
        hexrange: [
            '108e0',
            '108ff'
        ]
    },
    {
        category: 'phoenician',
        hexrange: [
            '10900',
            '1091f'
        ]
    },
    {
        category: 'lydian',
        hexrange: [
            '10920',
            '1093f'
        ]
    },
    {
        category: 'meroitic hieroglyphs',
        hexrange: [
            '10980',
            '1099f'
        ]
    },
    {
        category: 'meroitic cursive',
        hexrange: [
            '109a0',
            '109ff'
        ]
    },
    {
        category: 'kharoshthi',
        hexrange: [
            '10a00',
            '10a5f'
        ]
    },
    {
        category: 'old south arabian',
        hexrange: [
            '10a60',
            '10a7f'
        ]
    },
    {
        category: 'old north arabian',
        hexrange: [
            '10a80',
            '10a9f'
        ]
    },
    {
        category: 'manichaean',
        hexrange: [
            '10ac0',
            '10aff'
        ]
    },
    {
        category: 'avestan',
        hexrange: [
            '10b00',
            '10b3f'
        ]
    },
    {
        category: 'inscriptional parthian',
        hexrange: [
            '10b40',
            '10b5f'
        ]
    },
    {
        category: 'inscriptional pahlavi',
        hexrange: [
            '10b60',
            '10b7f'
        ]
    },
    {
        category: 'psalter pahlavi',
        hexrange: [
            '10b80',
            '10baf'
        ]
    },
    {
        category: 'old turkic',
        hexrange: [
            '10c00',
            '10c4f'
        ]
    },
    {
        category: 'old hungarian',
        hexrange: [
            '10c80',
            '10cff'
        ]
    },
    {
        category: 'hanifi rohingya',
        hexrange: [
            '10d00',
            '10d3f'
        ]
    },
    {
        category: 'rumi numeral symbols',
        hexrange: [
            '10e60',
            '10e7f'
        ]
    },
    {
        category: 'yezidi',
        hexrange: [
            '10e80',
            '10ebf'
        ]
    },
    {
        category: 'arabic extended-c',
        hexrange: [
            '10ec0',
            '10eff'
        ]
    },
    {
        category: 'old sogdian',
        hexrange: [
            '10f00',
            '10f2f'
        ]
    },
    {
        category: 'sogdian',
        hexrange: [
            '10f30',
            '10f6f'
        ]
    },
    {
        category: 'old uyghur',
        hexrange: [
            '10f70',
            '10faf'
        ]
    },
    {
        category: 'chorasmian',
        hexrange: [
            '10fb0',
            '10fdf'
        ]
    },
    {
        category: 'elymaic',
        hexrange: [
            '10fe0',
            '10fff'
        ]
    },
    {
        category: 'brahmi',
        hexrange: [
            '11000',
            '1107f'
        ]
    },
    {
        category: 'kaithi',
        hexrange: [
            '11080',
            '110cf'
        ]
    },
    {
        category: 'sora sompeng',
        hexrange: [
            '110d0',
            '110ff'
        ]
    },
    {
        category: 'chakma',
        hexrange: [
            '11100',
            '1114f'
        ]
    },
    {
        category: 'mahajani',
        hexrange: [
            '11150',
            '1117f'
        ]
    },
    {
        category: 'sharada',
        hexrange: [
            '11180',
            '111df'
        ]
    },
    {
        category: 'sinhala archaic numbers',
        hexrange: [
            '111e0',
            '111ff'
        ]
    },
    {
        category: 'khojki',
        hexrange: [
            '11200',
            '1124f'
        ]
    },
    {
        category: 'multani',
        hexrange: [
            '11280',
            '112af'
        ]
    },
    {
        category: 'khudawadi',
        hexrange: [
            '112b0',
            '112ff'
        ]
    },
    {
        category: 'grantha',
        hexrange: [
            '11300',
            '1137f'
        ]
    },
    {
        category: 'newa',
        hexrange: [
            '11400',
            '1147f'
        ]
    },
    {
        category: 'tirhuta',
        hexrange: [
            '11480',
            '114df'
        ]
    },
    {
        category: 'siddham',
        hexrange: [
            '11580',
            '115ff'
        ]
    },
    {
        category: 'modi',
        hexrange: [
            '11600',
            '1165f'
        ]
    },
    {
        category: 'mongolian supplement',
        hexrange: [
            '11660',
            '1167f'
        ]
    },
    {
        category: 'takri',
        hexrange: [
            '11680',
            '116cf'
        ]
    },
    {
        category: 'ahom',
        hexrange: [
            '11700',
            '1174f'
        ]
    },
    {
        category: 'dogra',
        hexrange: [
            '11800',
            '1184f'
        ]
    },
    {
        category: 'warang citi',
        hexrange: [
            '118a0',
            '118ff'
        ]
    },
    {
        category: 'dives akuru',
        hexrange: [
            '11900',
            '1195f'
        ]
    },
    {
        category: 'nandinagari',
        hexrange: [
            '119a0',
            '119ff'
        ]
    },
    {
        category: 'zanabazar square',
        hexrange: [
            '11a00',
            '11a4f'
        ]
    },
    {
        category: 'soyombo',
        hexrange: [
            '11a50',
            '11aaf'
        ]
    },
    {
        category: 'unified canadian aboriginal syllabics extended-a',
        hexrange: [
            '11ab0',
            '11abf'
        ]
    },
    {
        category: 'pau cin hau',
        hexrange: [
            '11ac0',
            '11aff'
        ]
    },
    {
        category: 'devanagari extended-a',
        hexrange: [
            '11b00',
            '11b5f'
        ]
    },
    {
        category: 'bhaiksuki',
        hexrange: [
            '11c00',
            '11c6f'
        ]
    },
    {
        category: 'marchen',
        hexrange: [
            '11c70',
            '11cbf'
        ]
    },
    {
        category: 'masaram gondi',
        hexrange: [
            '11d00',
            '11d5f'
        ]
    },
    {
        category: 'gunjala gondi',
        hexrange: [
            '11d60',
            '11daf'
        ]
    },
    {
        category: 'makasar',
        hexrange: [
            '11ee0',
            '11eff'
        ]
    },
    {
        category: 'kawi',
        hexrange: [
            '11f00',
            '11f5f'
        ]
    },
    {
        category: 'lisu supplement',
        hexrange: [
            '11fb0',
            '11fbf'
        ]
    },
    {
        category: 'tamil supplement',
        hexrange: [
            '11fc0',
            '11fff'
        ]
    },
    {
        category: 'cuneiform',
        hexrange: [
            '12000',
            '123ff'
        ]
    },
    {
        category: 'cuneiform numbers and punctuation',
        hexrange: [
            '12400',
            '1247f'
        ]
    },
    {
        category: 'early dynastic cuneiform',
        hexrange: [
            '12480',
            '1254f'
        ]
    },
    {
        category: 'cypro-minoan',
        hexrange: [
            '12f90',
            '12fff'
        ]
    },
    {
        category: 'egyptian hieroglyphs',
        hexrange: [
            '13000',
            '1342f'
        ]
    },
    {
        category: 'egyptian hieroglyph format controls',
        hexrange: [
            '13430',
            '1345f'
        ]
    },
    {
        category: 'anatolian hieroglyphs',
        hexrange: [
            '14400',
            '1467f'
        ]
    },
    {
        category: 'bamum supplement',
        hexrange: [
            '16800',
            '16a3f'
        ]
    },
    {
        category: 'mro',
        hexrange: [
            '16a40',
            '16a6f'
        ]
    },
    {
        category: 'tangsa',
        hexrange: [
            '16a70',
            '16acf'
        ]
    },
    {
        category: 'bassa vah',
        hexrange: [
            '16ad0',
            '16aff'
        ]
    },
    {
        category: 'pahawh hmong',
        hexrange: [
            '16b00',
            '16b8f'
        ]
    },
    {
        category: 'medefaidrin',
        hexrange: [
            '16e40',
            '16e9f'
        ]
    },
    {
        category: 'miao',
        hexrange: [
            '16f00',
            '16f9f'
        ]
    },
    {
        category: 'ideographic symbols and punctuation',
        hexrange: [
            '16fe0',
            '16fff'
        ]
    },
    {
        category: 'tangut',
        hexrange: [
            '17000',
            '187ff'
        ]
    },
    {
        category: 'tangut components',
        hexrange: [
            '18800',
            '18aff'
        ]
    },
    {
        category: 'khitan small script',
        hexrange: [
            '18b00',
            '18cff'
        ]
    },
    {
        category: 'tangut supplement',
        hexrange: [
            '18d00',
            '18d7f'
        ]
    },
    {
        category: 'kana extended-b',
        hexrange: [
            '1aff0',
            '1afff'
        ]
    },
    {
        category: 'kana supplement',
        hexrange: [
            '1b000',
            '1b0ff'
        ]
    },
    {
        category: 'kana extended-a',
        hexrange: [
            '1b100',
            '1b12f'
        ]
    },
    {
        category: 'small kana extension',
        hexrange: [
            '1b130',
            '1b16f'
        ]
    },
    {
        category: 'nushu',
        hexrange: [
            '1b170',
            '1b2ff'
        ]
    },
    {
        category: 'duployan',
        hexrange: [
            '1bc00',
            '1bc9f'
        ]
    },
    {
        category: 'shorthand format controls',
        hexrange: [
            '1bca0',
            '1bcaf'
        ]
    },
    {
        category: 'znamenny musical notation',
        hexrange: [
            '1cf00',
            '1cfcf'
        ]
    },
    {
        category: 'byzantine musical symbols',
        hexrange: [
            '1d000',
            '1d0ff'
        ]
    },
    {
        category: 'musical symbols',
        hexrange: [
            '1d100',
            '1d1ff'
        ]
    },
    {
        category: 'ancient greek musical notation',
        hexrange: [
            '1d200',
            '1d24f'
        ]
    },
    {
        category: 'kaktovik numerals',
        hexrange: [
            '1d2c0',
            '1d2df'
        ]
    },
    {
        category: 'mayan numerals',
        hexrange: [
            '1d2e0',
            '1d2ff'
        ]
    },
    {
        category: 'tai xuan jing symbols',
        hexrange: [
            '1d300',
            '1d35f'
        ]
    },
    {
        category: 'counting rod numerals',
        hexrange: [
            '1d360',
            '1d37f'
        ]
    },
    {
        category: 'mathematical alphanumeric symbols',
        hexrange: [
            '1d400',
            '1d7ff'
        ]
    },
    {
        category: 'sutton signwriting',
        hexrange: [
            '1d800',
            '1daaf'
        ]
    },
    {
        category: 'latin extended-g',
        hexrange: [
            '1df00',
            '1dfff'
        ]
    },
    {
        category: 'glagolitic supplement',
        hexrange: [
            '1e000',
            '1e02f'
        ]
    },
    {
        category: 'cyrillic extended-d',
        hexrange: [
            '1e030',
            '1e08f'
        ]
    },
    {
        category: 'nyiakeng puachue hmong',
        hexrange: [
            '1e100',
            '1e14f'
        ]
    },
    {
        category: 'toto',
        hexrange: [
            '1e290',
            '1e2bf'
        ]
    },
    {
        category: 'wancho',
        hexrange: [
            '1e2c0',
            '1e2ff'
        ]
    },
    {
        category: 'nag mundari',
        hexrange: [
            '1e4d0',
            '1e4ff'
        ]
    },
    {
        category: 'ethiopic extended-b',
        hexrange: [
            '1e7e0',
            '1e7ff'
        ]
    },
    {
        category: 'mende kikakui',
        hexrange: [
            '1e800',
            '1e8df'
        ]
    },
    {
        category: 'adlam',
        hexrange: [
            '1e900',
            '1e95f'
        ]
    },
    {
        category: 'indic siyaq numbers',
        hexrange: [
            '1ec70',
            '1ecbf'
        ]
    },
    {
        category: 'ottoman siyaq numbers',
        hexrange: [
            '1ed00',
            '1ed4f'
        ]
    },
    {
        category: 'arabic mathematical alphabetic symbols',
        hexrange: [
            '1ee00',
            '1eeff'
        ]
    },
    {
        category: 'mahjong tiles',
        hexrange: [
            '1f000',
            '1f02f'
        ]
    },
    {
        category: 'domino tiles',
        hexrange: [
            '1f030',
            '1f09f'
        ]
    },
    {
        category: 'playing cards',
        hexrange: [
            '1f0a0',
            '1f0ff'
        ]
    },
    {
        category: 'enclosed alphanumeric supplement',
        hexrange: [
            '1f100',
            '1f1ff'
        ]
    },
    {
        category: 'enclosed ideographic supplement',
        hexrange: [
            '1f200',
            '1f2ff'
        ]
    },
    {
        category: 'miscellaneous symbols and pictographs',
        hexrange: [
            '1f300',
            '1f5ff'
        ]
    },
    {
        category: 'emoticons (emoji)',
        hexrange: [
            '1f600',
            '1f64f'
        ]
    },
    {
        category: 'ornamental dingbats',
        hexrange: [
            '1f650',
            '1f67f'
        ]
    },
    {
        category: 'transport and map symbols',
        hexrange: [
            '1f680',
            '1f6ff'
        ]
    },
    {
        category: 'alchemical symbols',
        hexrange: [
            '1f700',
            '1f77f'
        ]
    },
    {
        category: 'geometric shapes extended',
        hexrange: [
            '1f780',
            '1f7ff'
        ]
    },
    {
        category: 'supplemental arrows-c',
        hexrange: [
            '1f800',
            '1f8ff'
        ]
    },
    {
        category: 'supplemental symbols and pictographs',
        hexrange: [
            '1f900',
            '1f9ff'
        ]
    },
    {
        category: 'chess symbols',
        hexrange: [
            '1fa00',
            '1fa6f'
        ]
    },
    {
        category: 'symbols and pictographs extended-a',
        hexrange: [
            '1fa70',
            '1faff'
        ]
    },
    {
        category: 'symbols for legacy computing',
        hexrange: [
            '1fb00',
            '1fbff'
        ]
    },
    {
        category: 'cjk unified ideographs extension b',
        hexrange: [
            '20000',
            '2a6df'
        ]
    },
    {
        category: 'cjk unified ideographs extension c',
        hexrange: [
            '2a700',
            '2b73f'
        ]
    },
    {
        category: 'cjk unified ideographs extension d',
        hexrange: [
            '2b740',
            '2b81f'
        ]
    },
    {
        category: 'cjk unified ideographs extension e',
        hexrange: [
            '2b820',
            '2ceaf'
        ]
    },
    {
        category: 'cjk unified ideographs extension f',
        hexrange: [
            '2ceb0',
            '2ebef'
        ]
    },
    {
        category: 'cjk unified ideographs extension i',
        hexrange: [
            '2ebf0',
            '2ee5f'
        ]
    },
    {
        category: 'cjk compatibility ideographs supplement',
        hexrange: [
            '2f800',
            '2fa1f'
        ]
    },
    {
        category: 'cjk unified ideographs extension g',
        hexrange: [
            '30000',
            '3134f'
        ]
    },
    {
        category: 'cjk unified ideographs extension h',
        hexrange: [
            '31350',
            '323af'
        ]
    },
    {
        category: 'tags',
        hexrange: [
            'e0000',
            'e007f'
        ]
    },
    {
        category: 'variation selectors supplement',
        hexrange: [
            'e0100',
            'e01ef'
        ]
    },
    {
        category: 'supplementary private use area-a',
        hexrange: [
            'f0000',
            'fffff'
        ]
    },
    {
        category: 'supplementary private use area-b',
        hexrange: [
            '100000',
            '10ffff'
        ]
    }
];
;
}),
"[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>Typr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
;
// Mocking the pako module to just have inflate for a smaller package size
const pako = {
    inflate: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["inflate"]
};
var Typr = {};
Typr["parse"] = function(buff) {
    var bin = Typr["B"];
    var readFont = function(data, idx, offset, tmap) {
        var T = Typr["T"];
        var prsr = {
            "cmap": T.cmap,
            "head": T.head,
            "hhea": T.hhea,
            "maxp": T.maxp,
            "hmtx": T.hmtx,
            "name": T.name,
            "OS/2": T.OS2,
            "post": T.post,
            "loca": T.loca,
            "kern": T.kern,
            "glyf": T.glyf,
            "CFF ": T.CFF,
            /*
      "GPOS",
      "GSUB",
      "GDEF",*/ "GSUB": T.GSUB,
            "CBLC": T.CBLC,
            "CBDT": T.CBDT,
            "SVG ": T.SVG,
            "COLR": T.colr,
            "CPAL": T.cpal,
            "sbix": T.sbix,
            "fvar": T.fvar,
            "gvar": T.gvar,
            "avar": T.avar,
            "HVAR": T.HVAR
        };
        var obj = {
            "_data": data,
            "_index": idx,
            "_offset": offset
        };
        for(var t in prsr){
            var tab = Typr["findTable"](data, t, offset);
            if (tab) {
                var off = tab[0], tobj = tmap[off];
                if (tobj == null) tobj = prsr[t].parseTab(data, off, tab[1], obj);
                obj[t] = tmap[off] = tobj;
            }
        }
        return obj;
    };
    function woffToOtf(data) {
        var numTables = bin.readUshort(data, 12);
        var totalSize = bin.readUint(data, 16);
        var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
        bin.writeASCII(otf, 0, "OTTO");
        bin.writeUshort(otf, 4, numTables);
        var off = 44;
        for(var i = 0; i < numTables; i++){
            var tag = bin.readASCII(data, off, 4);
            var tof = bin.readUint(data, off + 4);
            var cLe = bin.readUint(data, off + 8);
            var oLe = bin.readUint(data, off + 12);
            off += 20;
            //console.log(i, ":::", tag,tof,oLe);
            var tab = data.slice(tof, tof + cLe);
            if (cLe != oLe) tab = pako["inflate"](tab);
            var to = 12 + i * 16;
            bin.writeASCII(otf, to, tag);
            bin.writeUint(otf, to + 8, toff);
            bin.writeUint(otf, to + 12, oLe);
            otf.set(tab, toff);
            toff += oLe;
        }
        //console.log(otf);
        return otf;
    }
    var data = new Uint8Array(buff);
    // PATCHED: keep around the compressed data if we inflate it
    let compressedData;
    if (data[0] == 0x77) {
        compressedData = data;
        data = woffToOtf(data);
    }
    var tmap = {};
    var tag = bin.readASCII(data, 0, 4);
    if (tag == "ttcf") {
        var offset = 4;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var numF = bin.readUint(data, offset);
        offset += 4;
        var fnts = [];
        for(var i = 0; i < numF; i++){
            var foff = bin.readUint(data, offset);
            offset += 4;
            fnts.push(readFont(data, i, foff, tmap));
        }
        return fnts;
    }
    var fnt = readFont(data, 0, 0, tmap); //console.log(fnt);  throw "e";
    fnt._compressedData = compressedData; // PATCH: make compressed data accessible
    var fvar = fnt["fvar"];
    if (fvar) {
        var out = [
            fnt
        ];
        for(var i = 0; i < fvar[1].length; i++){
            var fv = fvar[1][i];
            var obj = {};
            out.push(obj);
            for(var p in fnt)obj[p] = fnt[p];
            obj["_index"] = i;
            var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
            name["fontSubfamily"] = fv[0];
            if (fv[3] == null) fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
            name["postScriptName"] = fv[3];
        }
        return out;
    }
    return [
        fnt
    ];
};
Typr["findTable"] = function(data, tab, foff) {
    var bin = Typr["B"];
    var numTables = bin.readUshort(data, foff + 4);
    var offset = foff + 12;
    for(var i = 0; i < numTables; i++){
        var tag = bin.readASCII(data, offset, 4); //console.log(tag);
        bin.readUint(data, offset + 4);
        var toffset = bin.readUint(data, offset + 8);
        var length = bin.readUint(data, offset + 12);
        if (tag == tab) return [
            toffset,
            length
        ];
        offset += 16;
    }
    return null;
};
/*
Typr["splitBy"] = function(data,tag) {
  data = new Uint8Array(data);  console.log(data.slice(0,64));
  var bin = Typr["B"];
  var ttcf = bin.readASCII(data, 0, 4);  if(ttcf!="ttcf") return {};

  var offset = 8;
  var numF = bin.readUint  (data, offset);  offset+=4;
  var colls = [], used={};
  for(var i=0; i<numF; i++) {
    var foff = bin.readUint  (data, offset);  offset+=4;
    var toff = Typr["findTable"](data,tag,foff)[0];
    if(used[toff]==null) used[toff] = [];
    used[toff].push([foff,bin.readUshort(data,foff+4)]);  // font offset, numTables
  }
  for(var toff in used) {
    var offs = used[toff];
    var hlen = 12+4*offs.length;
    var out = new Uint8Array(hlen);
    for(var i=0; i<8; i++) out[i]=data[i];
    bin.writeUint(out,8,offs.length);

    for(var i=0; i<offs.length; i++) hlen += 12+offs[i][1]*16;

    var hdrs = [out], tabs = [], hoff=out.length, toff=hlen, noffs={};
    for(var i=0; i<offs.length; i++) {
      bin.writeUint(out, 12+i*4, hoff);  hoff+=12+offs[i][1]*16;
      toff = Typr["_cutFont"](data, offs[i][0], hdrs, tabs, toff, noffs);
    }
    colls.push(Typr["_joinArrs"](hdrs.concat(tabs)));
  }
  return colls;
}

Typr["splitFonts"] = function(data) {
  data = new Uint8Array(data);
  var bin = Typr["B"];
  var ttcf = bin.readASCII(data, 0, 4);  if(ttcf!="ttcf") return {};

  var offset = 8;
  var numF = bin.readUint  (data, offset);  offset+=4;
  var fnts = [];
  for(var i=0; i<numF; i++) {
    var foff = bin.readUint  (data, offset);  offset+=4;
    fnts.push(Typr._cutFont(data, foff));
    break;
  }
  return fnts;
}

Typr["_cutFont"] = function(data,foff,hdrs,tabs,toff, noffs) {
  var bin = Typr["B"];
  var numTables = bin.readUshort(data, foff+4);

  var out = new Uint8Array(12+numTables*16);  hdrs.push(out);
  for(var i=0; i<12; i++) out[i]=data[foff+i];  //console.log(out);

  var off = 12;
  for(var i=0; i<numTables; i++)
  {
    var tag      = bin.readASCII(data, foff+off, 4);
    var checkSum = bin.readUint (data, foff+off+ 4);
    var toffset  = bin.readUint (data, foff+off+ 8);
    var length   = bin.readUint (data, foff+off+12);

    while((length&3)!=0) length++;

    for(var j=0; j<16; j++) out[off+j]=data[foff+off+j];

    if(noffs[toffset]!=null) bin.writeUint(out,off+8,noffs[toffset]);
    else {
      noffs[toffset] = toff;
      bin.writeUint(out, off+8, toff);
      tabs.push(new Uint8Array(data.buffer, toffset, length));  toff+=length;
    }
    off+=16;
  }
  return toff;
}
Typr["_joinArrs"] = function(tabs) {
  var len = 0;
  for(var i=0; i<tabs.length; i++) len+=tabs[i].length;
  var out = new Uint8Array(len), ooff=0;
  for(var i=0; i<tabs.length; i++) {
    var tab = tabs[i];
    for(var j=0; j<tab.length; j++) out[ooff+j]=tab[j];
    ooff+=tab.length;
  }
  return out;
}
*/ Typr["T"] = {};
Typr["B"] = {
    readFixed: function(data, o) {
        return (data[o] << 8 | data[o + 1]) + (data[o + 2] << 8 | data[o + 3]) / (256 * 256 + 4);
    },
    readF2dot14: function(data, o) {
        var num = Typr["B"].readShort(data, o);
        return num / 16384;
    },
    readInt: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[0] = buff[p + 3];
        a[1] = buff[p + 2];
        a[2] = buff[p + 1];
        a[3] = buff[p];
        return Typr["B"].t.int32[0];
    },
    readInt8: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[0] = buff[p];
        return Typr["B"].t.int8[0];
    },
    readShort: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint16;
        a[0] = buff[p] << 8 | buff[p + 1];
        return Typr["B"].t.int16[0];
    },
    readUshort: function(buff, p) {
        //if(p>=buff.length) throw "error";
        return buff[p] << 8 | buff[p + 1];
    },
    writeUshort: function(buff, p, n) {
        buff[p] = n >> 8 & 255;
        buff[p + 1] = n & 255;
    },
    readUshorts: function(buff, p, len) {
        var arr = [];
        for(var i = 0; i < len; i++){
            var v = Typr["B"].readUshort(buff, p + i * 2); //if(v==932) console.log(p+i*2);
            arr.push(v);
        }
        return arr;
    },
    readUint: function(buff, p) {
        //if(p>=buff.length) throw "error";
        var a = Typr["B"].t.uint8;
        a[3] = buff[p];
        a[2] = buff[p + 1];
        a[1] = buff[p + 2];
        a[0] = buff[p + 3];
        return Typr["B"].t.uint32[0];
    },
    writeUint: function(buff, p, n) {
        buff[p] = n >> 24 & 255;
        buff[p + 1] = n >> 16 & 255;
        buff[p + 2] = n >> 8 & 255;
        buff[p + 3] = n >> 0 & 255;
    },
    readUint64: function(buff, p) {
        //if(p>=buff.length) throw "error";
        return Typr["B"].readUint(buff, p) * (0xffffffff + 1) + Typr["B"].readUint(buff, p + 4);
    },
    readASCII: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = "";
        for(var i = 0; i < l; i++)s += String.fromCharCode(buff[p + i]);
        return s;
    },
    writeASCII: function(buff, p, s) {
        for(var i = 0; i < s.length; i++)buff[p + i] = s.charCodeAt(i);
    },
    readUnicode: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = "";
        for(var i = 0; i < l; i++){
            var c = buff[p++] << 8 | buff[p++];
            s += String.fromCharCode(c);
        }
        return s;
    },
    _tdec: window["TextDecoder"] ? new window["TextDecoder"]() : null,
    readUTF8: function(buff, p, l) {
        var tdec = Typr["B"]._tdec;
        if (tdec && p == 0 && l == buff.length) return tdec["decode"](buff);
        return Typr["B"].readASCII(buff, p, l);
    },
    readBytes: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var arr = [];
        for(var i = 0; i < l; i++)arr.push(buff[p + i]);
        return arr;
    },
    readASCIIArray: function(buff, p, l) {
        //if(p>=buff.length) throw "error";
        var s = [];
        for(var i = 0; i < l; i++)s.push(String.fromCharCode(buff[p + i]));
        return s;
    },
    t: function() {
        var ab = new ArrayBuffer(8);
        return {
            buff: ab,
            int8: new Int8Array(ab),
            uint8: new Uint8Array(ab),
            int16: new Int16Array(ab),
            uint16: new Uint16Array(ab),
            int32: new Int32Array(ab),
            uint32: new Uint32Array(ab)
        };
    }()
};
Typr["T"].CFF = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var CFF = Typr["T"].CFF;
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        // Header
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        data[offset];
        offset++;
        //console.log(major, minor, hdrSize, offsize);
        // Name INDEX
        var ninds = [];
        offset = CFF.readIndex(data, offset, ninds);
        var names = [];
        for(var i = 0; i < ninds.length - 1; i++)names.push(bin.readASCII(data, offset + ninds[i], ninds[i + 1] - ninds[i]));
        offset += ninds[ninds.length - 1];
        // Top DICT INDEX
        var tdinds = [];
        offset = CFF.readIndex(data, offset, tdinds); //console.log(tdinds);
        // Top DICT Data
        var topDicts = [];
        for(var i = 0; i < tdinds.length - 1; i++)topDicts.push(CFF.readDict(data, offset + tdinds[i], offset + tdinds[i + 1]));
        offset += tdinds[tdinds.length - 1];
        var topdict = topDicts[0];
        //console.log(topdict);
        // String INDEX
        var sinds = [];
        offset = CFF.readIndex(data, offset, sinds);
        // String Data
        var strings = [];
        for(var i = 0; i < sinds.length - 1; i++)strings.push(bin.readASCII(data, offset + sinds[i], sinds[i + 1] - sinds[i]));
        offset += sinds[sinds.length - 1];
        // Global Subr INDEX  (subroutines)
        CFF.readSubrs(data, offset, topdict);
        // charstrings
        if (topdict["CharStrings"]) topdict["CharStrings"] = CFF.readBytes(data, topdict["CharStrings"]);
        // CID font
        if (topdict["ROS"]) {
            offset = topdict["FDArray"];
            var fdind = [];
            offset = CFF.readIndex(data, offset, fdind);
            topdict["FDArray"] = [];
            for(var i = 0; i < fdind.length - 1; i++){
                var dict = CFF.readDict(data, offset + fdind[i], offset + fdind[i + 1]);
                CFF._readFDict(data, dict, strings);
                topdict["FDArray"].push(dict);
            }
            offset += fdind[fdind.length - 1];
            offset = topdict["FDSelect"];
            topdict["FDSelect"] = [];
            var fmt = data[offset];
            offset++;
            if (fmt == 3) {
                var rns = bin.readUshort(data, offset);
                offset += 2;
                for(var i = 0; i < rns + 1; i++){
                    topdict["FDSelect"].push(bin.readUshort(data, offset), data[offset + 2]);
                    offset += 3;
                }
            } else throw fmt;
        }
        // Encoding
        //if(topdict["Encoding"]) topdict["Encoding"] = CFF.readEncoding(data, topdict["Encoding"], topdict["CharStrings"].length);
        // charset
        if (topdict["charset"]) topdict["charset"] = CFF.readCharset(data, topdict["charset"], topdict["CharStrings"].length);
        CFF._readFDict(data, topdict, strings);
        return topdict;
    },
    _readFDict: function(data, dict, ss) {
        var CFF = Typr["T"].CFF;
        var offset;
        if (dict["Private"]) {
            offset = dict["Private"][1];
            dict["Private"] = CFF.readDict(data, offset, offset + dict["Private"][0]);
            if (dict["Private"]["Subrs"]) CFF.readSubrs(data, offset + dict["Private"]["Subrs"], dict["Private"]);
        }
        for(var p in dict)if ([
            "FamilyName",
            "FontName",
            "FullName",
            "Notice",
            "version",
            "Copyright"
        ].indexOf(p) != -1) dict[p] = ss[dict[p] - 426 + 35];
    },
    readSubrs: function(data, offset, obj) {
        obj["Subrs"] = Typr["T"].CFF.readBytes(data, offset);
        var bias, nSubrs = obj["Subrs"].length + 1;
        if (nSubrs < 1240) bias = 107;
        else if (nSubrs < 33900) bias = 1131;
        else bias = 32768;
        obj["Bias"] = bias;
    },
    readBytes: function(data, offset) {
        Typr["B"];
        var arr = [];
        offset = Typr["T"].CFF.readIndex(data, offset, arr);
        var subrs = [], arl = arr.length - 1, no = data.byteOffset + offset;
        for(var i = 0; i < arl; i++){
            var ari = arr[i];
            subrs.push(new Uint8Array(data.buffer, no + ari, arr[i + 1] - ari));
        }
        return subrs;
    },
    tableSE: [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        62,
        63,
        64,
        65,
        66,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        82,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        91,
        92,
        93,
        94,
        95,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        96,
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        0,
        111,
        112,
        113,
        114,
        0,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        0,
        123,
        0,
        124,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        0,
        132,
        133,
        0,
        134,
        135,
        136,
        137,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        138,
        0,
        139,
        0,
        0,
        0,
        0,
        140,
        141,
        142,
        143,
        0,
        0,
        0,
        0,
        0,
        144,
        0,
        0,
        0,
        145,
        0,
        0,
        146,
        147,
        148,
        149,
        0,
        0,
        0,
        0
    ],
    glyphByUnicode: function(cff, code) {
        for(var i = 0; i < cff["charset"].length; i++)if (cff["charset"][i] == code) return i;
        return -1;
    },
    glyphBySE: function(cff, charcode) {
        if (charcode < 0 || charcode > 255) return -1;
        return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
    },
    /*readEncoding : function(data, offset, num)
  {
    var bin = Typr["B"];

    var array = ['.notdef'];
    var format = data[offset];  offset++;
    //console.log("Encoding");
    //console.log(format);

    if(format==0)
    {
      var nCodes = data[offset];  offset++;
      for(var i=0; i<nCodes; i++)  array.push(data[offset+i]);
    }
    /*
    else if(format==1 || format==2)
    {
      while(charset.length<num)
      {
        var first = bin.readUshort(data, offset);  offset+=2;
        var nLeft=0;
        if(format==1) {  nLeft = data[offset];  offset++;  }
        else          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }
        for(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }
      }
    }

    else throw "error: unknown encoding format: " + format;

    return array;
  },*/ readCharset: function(data, offset, num) {
        var bin = Typr["B"];
        var charset = [
            '.notdef'
        ];
        var format = data[offset];
        offset++;
        if (format == 0) {
            for(var i = 0; i < num; i++){
                var first = bin.readUshort(data, offset);
                offset += 2;
                charset.push(first);
            }
        } else if (format == 1 || format == 2) {
            while(charset.length < num){
                var first = bin.readUshort(data, offset);
                offset += 2;
                var nLeft = 0;
                if (format == 1) {
                    nLeft = data[offset];
                    offset++;
                } else {
                    nLeft = bin.readUshort(data, offset);
                    offset += 2;
                }
                for(var i = 0; i <= nLeft; i++){
                    charset.push(first);
                    first++;
                }
            }
        } else throw "error: format: " + format;
        return charset;
    },
    readIndex: function(data, offset, inds) {
        var bin = Typr["B"];
        var count = bin.readUshort(data, offset) + 1;
        offset += 2;
        var offsize = data[offset];
        offset++;
        if (offsize == 1) for(var i = 0; i < count; i++)inds.push(data[offset + i]);
        else if (offsize == 2) for(var i = 0; i < count; i++)inds.push(bin.readUshort(data, offset + i * 2));
        else if (offsize == 3) for(var i = 0; i < count; i++)inds.push(bin.readUint(data, offset + i * 3 - 1) & 0x00ffffff);
        else if (offsize == 4) for(var i = 0; i < count; i++)inds.push(bin.readUint(data, offset + i * 4));
        else if (count != 1) throw "unsupported offset size: " + offsize + ", count: " + count;
        offset += count * offsize;
        return offset - 1;
    },
    getCharString: function(data, offset, o) {
        var bin = Typr["B"];
        var b0 = data[offset], b1 = data[offset + 1];
        data[offset + 2];
        data[offset + 3];
        data[offset + 4];
        var vs = 1;
        var op = null, val = null;
        // operand
        if (b0 <= 20) {
            op = b0;
            vs = 1;
        }
        if (b0 == 12) {
            op = b0 * 100 + b1;
            vs = 2;
        }
        //if(b0==19 || b0==20) { op = b0/*+" "+b1*/;  vs=2; }
        if (21 <= b0 && b0 <= 27) {
            op = b0;
            vs = 1;
        }
        if (b0 == 28) {
            val = bin.readShort(data, offset + 1);
            vs = 3;
        }
        if (29 <= b0 && b0 <= 31) {
            op = b0;
            vs = 1;
        }
        if (32 <= b0 && b0 <= 246) {
            val = b0 - 139;
            vs = 1;
        }
        if (247 <= b0 && b0 <= 250) {
            val = (b0 - 247) * 256 + b1 + 108;
            vs = 2;
        }
        if (251 <= b0 && b0 <= 254) {
            val = -(b0 - 251) * 256 - b1 - 108;
            vs = 2;
        }
        if (b0 == 255) {
            val = bin.readInt(data, offset + 1) / 0xffff;
            vs = 5;
        }
        o.val = val != null ? val : "o" + op;
        o.size = vs;
    },
    readCharString: function(data, offset, length) {
        var end = offset + length;
        var bin = Typr["B"];
        var arr = [];
        while(offset < end){
            var b0 = data[offset], b1 = data[offset + 1];
            data[offset + 2];
            data[offset + 3];
            data[offset + 4];
            var vs = 1;
            var op = null, val = null;
            // operand
            if (b0 <= 20) {
                op = b0;
                vs = 1;
            }
            if (b0 == 12) {
                op = b0 * 100 + b1;
                vs = 2;
            }
            if (b0 == 19 || b0 == 20) {
                op = b0 /*+" "+b1*/ ;
                vs = 2;
            }
            if (21 <= b0 && b0 <= 27) {
                op = b0;
                vs = 1;
            }
            if (b0 == 28) {
                val = bin.readShort(data, offset + 1);
                vs = 3;
            }
            if (29 <= b0 && b0 <= 31) {
                op = b0;
                vs = 1;
            }
            if (32 <= b0 && b0 <= 246) {
                val = b0 - 139;
                vs = 1;
            }
            if (247 <= b0 && b0 <= 250) {
                val = (b0 - 247) * 256 + b1 + 108;
                vs = 2;
            }
            if (251 <= b0 && b0 <= 254) {
                val = -(b0 - 251) * 256 - b1 - 108;
                vs = 2;
            }
            if (b0 == 255) {
                val = bin.readInt(data, offset + 1) / 0xffff;
                vs = 5;
            }
            arr.push(val != null ? val : "o" + op);
            offset += vs;
        //var cv = arr[arr.length-1];
        //if(cv==undefined) throw "error";
        //console.log()
        }
        return arr;
    },
    readDict: function(data, offset, end) {
        var bin = Typr["B"];
        //var dict = [];
        var dict = {};
        var carr = [];
        while(offset < end){
            var b0 = data[offset], b1 = data[offset + 1];
            data[offset + 2];
            data[offset + 3];
            data[offset + 4];
            var vs = 1;
            var key = null, val = null;
            // operand
            if (b0 == 28) {
                val = bin.readShort(data, offset + 1);
                vs = 3;
            }
            if (b0 == 29) {
                val = bin.readInt(data, offset + 1);
                vs = 5;
            }
            if (32 <= b0 && b0 <= 246) {
                val = b0 - 139;
                vs = 1;
            }
            if (247 <= b0 && b0 <= 250) {
                val = (b0 - 247) * 256 + b1 + 108;
                vs = 2;
            }
            if (251 <= b0 && b0 <= 254) {
                val = -(b0 - 251) * 256 - b1 - 108;
                vs = 2;
            }
            if (b0 == 255) {
                val = bin.readInt(data, offset + 1) / 0xffff;
                vs = 5;
                throw "unknown number";
            }
            if (b0 == 30) {
                var nibs = [];
                vs = 1;
                while(true){
                    var b = data[offset + vs];
                    vs++;
                    var nib0 = b >> 4, nib1 = b & 0xf;
                    if (nib0 != 0xf) nibs.push(nib0);
                    if (nib1 != 0xf) nibs.push(nib1);
                    if (nib1 == 0xf) break;
                }
                var s = "";
                var chars = [
                    0,
                    1,
                    2,
                    3,
                    4,
                    5,
                    6,
                    7,
                    8,
                    9,
                    ".",
                    "e",
                    "e-",
                    "reserved",
                    "-",
                    "endOfNumber"
                ];
                for(var i = 0; i < nibs.length; i++)s += chars[nibs[i]];
                //console.log(nibs);
                val = parseFloat(s);
            }
            if (b0 <= 21) {
                var keys = [
                    "version",
                    "Notice",
                    "FullName",
                    "FamilyName",
                    "Weight",
                    "FontBBox",
                    "BlueValues",
                    "OtherBlues",
                    "FamilyBlues",
                    "FamilyOtherBlues",
                    "StdHW",
                    "StdVW",
                    "escape",
                    "UniqueID",
                    "XUID",
                    "charset",
                    "Encoding",
                    "CharStrings",
                    "Private",
                    "Subrs",
                    "defaultWidthX",
                    "nominalWidthX"
                ];
                key = keys[b0];
                vs = 1;
                if (b0 == 12) {
                    var keys = [
                        "Copyright",
                        "isFixedPitch",
                        "ItalicAngle",
                        "UnderlinePosition",
                        "UnderlineThickness",
                        "PaintType",
                        "CharstringType",
                        "FontMatrix",
                        "StrokeWidth",
                        "BlueScale",
                        "BlueShift",
                        "BlueFuzz",
                        "StemSnapH",
                        "StemSnapV",
                        "ForceBold",
                        "",
                        "",
                        "LanguageGroup",
                        "ExpansionFactor",
                        "initialRandomSeed",
                        "SyntheticBase",
                        "PostScript",
                        "BaseFontName",
                        "BaseFontBlend",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "ROS",
                        "CIDFontVersion",
                        "CIDFontRevision",
                        "CIDFontType",
                        "CIDCount",
                        "UIDBase",
                        "FDArray",
                        "FDSelect",
                        "FontName"
                    ];
                    key = keys[b1];
                    vs = 2;
                }
            }
            if (key != null) {
                dict[key] = carr.length == 1 ? carr[0] : carr;
                carr = [];
            } else carr.push(val);
            offset += vs;
        }
        return dict;
    }
};
Typr["T"].cmap = {
    parseTab: function(data, offset, length) {
        var obj = {
            tables: [],
            ids: {},
            off: offset
        };
        data = new Uint8Array(data.buffer, offset, length);
        offset = 0;
        var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
        rU(data, offset);
        offset += 2;
        var numTables = rU(data, offset);
        offset += 2;
        //console.log(version, numTables);
        var offs = [];
        for(var i = 0; i < numTables; i++){
            var platformID = rU(data, offset);
            offset += 2;
            var encodingID = rU(data, offset);
            offset += 2;
            var noffset = bin.readUint(data, offset);
            offset += 4;
            var id = "p" + platformID + "e" + encodingID;
            //console.log("cmap subtable", platformID, encodingID, noffset);
            var tind = offs.indexOf(noffset);
            if (tind == -1) {
                tind = obj.tables.length;
                var subt = {};
                offs.push(noffset);
                //var time = Date.now();
                var format = subt.format = rU(data, noffset);
                if (format == 0) subt = cmap.parse0(data, noffset, subt);
                else if (format == 4) subt = cmap.parse4(data, noffset, subt);
                else if (format == 6) subt = cmap.parse6(data, noffset, subt);
                else if (format == 12) subt = cmap.parse12(data, noffset, subt);
                //console.log(format, Date.now()-time);
                //else console.log("unknown format: "+format, platformID, encodingID, noffset);
                obj.tables.push(subt);
            }
            if (obj.ids[id] != null) console.log("multiple tables for one platform+encoding: " + id);
            obj.ids[id] = tind;
        }
        return obj;
    },
    parse0: function(data, offset, obj) {
        var bin = Typr["B"];
        offset += 2;
        var len = bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.map = [];
        for(var i = 0; i < len - 6; i++)obj.map.push(data[offset + i]);
        return obj;
    },
    parse4: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
        var offset0 = offset;
        offset += 2;
        var length = rU(data, offset);
        offset += 2;
        rU(data, offset);
        offset += 2;
        var segCountX2 = rU(data, offset);
        offset += 2;
        var segCount = segCountX2 >>> 1;
        obj.searchRange = rU(data, offset);
        offset += 2;
        obj.entrySelector = rU(data, offset);
        offset += 2;
        obj.rangeShift = rU(data, offset);
        offset += 2;
        obj.endCount = rUs(data, offset, segCount);
        offset += segCount * 2;
        offset += 2;
        obj.startCount = rUs(data, offset, segCount);
        offset += segCount * 2;
        obj.idDelta = [];
        for(var i = 0; i < segCount; i++){
            obj.idDelta.push(bin.readShort(data, offset));
            offset += 2;
        }
        obj.idRangeOffset = rUs(data, offset, segCount);
        offset += segCount * 2;
        obj.glyphIdArray = rUs(data, offset, offset0 + length - offset >> 1); //offset += segCount*2;
        return obj;
    },
    parse6: function(data, offset, obj) {
        var bin = Typr["B"];
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        obj.firstCode = bin.readUshort(data, offset);
        offset += 2;
        var entryCount = bin.readUshort(data, offset);
        offset += 2;
        obj.glyphIdArray = [];
        for(var i = 0; i < entryCount; i++){
            obj.glyphIdArray.push(bin.readUshort(data, offset));
            offset += 2;
        }
        return obj;
    },
    parse12: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUint;
        offset += 4;
        rU(data, offset);
        offset += 4;
        rU(data, offset);
        offset += 4;
        var nGroups = rU(data, offset) * 3;
        offset += 4;
        var gps = obj.groups = new Uint32Array(nGroups); //new Uint32Array(data.slice(offset, offset+nGroups*12).buffer);
        for(var i = 0; i < nGroups; i += 3){
            gps[i] = rU(data, offset + (i << 2));
            gps[i + 1] = rU(data, offset + (i << 2) + 4);
            gps[i + 2] = rU(data, offset + (i << 2) + 8);
        }
        return obj;
    }
};
Typr["T"].CBLC = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"], ooff = offset;
        bin.readUshort(data, offset);
        offset += 2;
        bin.readUshort(data, offset);
        offset += 2;
        var numSizes = bin.readUint(data, offset);
        offset += 4;
        var out = [];
        for(var i = 0; i < numSizes; i++){
            var off = bin.readUint(data, offset);
            offset += 4; // indexSubTableArrayOffset
            bin.readUint(data, offset);
            offset += 4; // indexTablesSize
            bin.readUint(data, offset);
            offset += 4; // numberOfIndexSubTables
            offset += 4;
            offset += 2 * 12;
            bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            //console.log(off,siz,num, sGlyph, eGlyph);
            offset += 4;
            var coff = ooff + off;
            for(var j = 0; j < 3; j++){
                var fgI = bin.readUshort(data, coff);
                coff += 2;
                var lgI = bin.readUshort(data, coff);
                coff += 2;
                var nxt = bin.readUint(data, coff);
                coff += 4;
                var gcnt = lgI - fgI + 1;
                //console.log(fgI, lgI, nxt);   //if(nxt==0) break;
                var ioff = ooff + off + nxt;
                var inF = bin.readUshort(data, ioff);
                ioff += 2;
                if (inF != 1) throw inF;
                var imF = bin.readUshort(data, ioff);
                ioff += 2;
                var imgo = bin.readUint(data, ioff);
                ioff += 4;
                var oarr = [];
                for(var gi = 0; gi < gcnt; gi++){
                    var sbitO = bin.readUint(data, ioff + gi * 4);
                    oarr.push(imgo + sbitO);
                //console.log("--",sbitO);
                }
                out.push([
                    fgI,
                    lgI,
                    imF,
                    oarr
                ]);
            }
        }
        return out;
    }
};
Typr["T"].CBDT = {
    parseTab: function(data, offset, length) {
        Typr["B"];
        //var maj = bin.readUshort(data,offset);  offset+=2;
        //var min = bin.readUshort(data,offset);  offset+=2;
        return new Uint8Array(data.buffer, data.byteOffset + offset, length);
    }
};
Typr["T"].glyf = {
    parseTab: function(data, offset, length, font) {
        var obj = [], ng = font["maxp"]["numGlyphs"];
        for(var g = 0; g < ng; g++)obj.push(null);
        return obj;
    },
    _parseGlyf: function(font, g) {
        var bin = Typr["B"];
        var data = font["_data"], loca = font["loca"];
        if (loca[g] == loca[g + 1]) return null;
        var offset = Typr["findTable"](data, "glyf", font["_offset"])[0] + loca[g];
        var gl = {};
        gl.noc = bin.readShort(data, offset);
        offset += 2; // number of contours
        gl.xMin = bin.readShort(data, offset);
        offset += 2;
        gl.yMin = bin.readShort(data, offset);
        offset += 2;
        gl.xMax = bin.readShort(data, offset);
        offset += 2;
        gl.yMax = bin.readShort(data, offset);
        offset += 2;
        if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) return null;
        if (gl.noc > 0) {
            gl.endPts = [];
            for(var i = 0; i < gl.noc; i++){
                gl.endPts.push(bin.readUshort(data, offset));
                offset += 2;
            }
            var instructionLength = bin.readUshort(data, offset);
            offset += 2;
            if (data.length - offset < instructionLength) return null;
            gl.instructions = bin.readBytes(data, offset, instructionLength);
            offset += instructionLength;
            var crdnum = gl.endPts[gl.noc - 1] + 1;
            gl.flags = [];
            for(var i = 0; i < crdnum; i++){
                var flag = data[offset];
                offset++;
                gl.flags.push(flag);
                if ((flag & 8) != 0) {
                    var rep = data[offset];
                    offset++;
                    for(var j = 0; j < rep; j++){
                        gl.flags.push(flag);
                        i++;
                    }
                }
            }
            gl.xs = [];
            for(var i = 0; i < crdnum; i++){
                var i8 = (gl.flags[i] & 2) != 0, same = (gl.flags[i] & 16) != 0;
                if (i8) {
                    gl.xs.push(same ? data[offset] : -data[offset]);
                    offset++;
                } else {
                    if (same) gl.xs.push(0);
                    else {
                        gl.xs.push(bin.readShort(data, offset));
                        offset += 2;
                    }
                }
            }
            gl.ys = [];
            for(var i = 0; i < crdnum; i++){
                var i8 = (gl.flags[i] & 4) != 0, same = (gl.flags[i] & 32) != 0;
                if (i8) {
                    gl.ys.push(same ? data[offset] : -data[offset]);
                    offset++;
                } else {
                    if (same) gl.ys.push(0);
                    else {
                        gl.ys.push(bin.readShort(data, offset));
                        offset += 2;
                    }
                }
            }
            var x = 0, y = 0;
            for(var i = 0; i < crdnum; i++){
                x += gl.xs[i];
                y += gl.ys[i];
                gl.xs[i] = x;
                gl.ys[i] = y;
            }
        //console.log(endPtsOfContours, instructionLength, instructions, flags, xCoordinates, yCoordinates);
        } else {
            var ARG_1_AND_2_ARE_WORDS = 1 << 0;
            var ARGS_ARE_XY_VALUES = 1 << 1;
            var WE_HAVE_A_SCALE = 1 << 3;
            var MORE_COMPONENTS = 1 << 5;
            var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
            var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
            var WE_HAVE_INSTRUCTIONS = 1 << 8;
            gl.parts = [];
            var flags;
            do {
                flags = bin.readUshort(data, offset);
                offset += 2;
                var part = {
                    m: {
                        a: 1,
                        b: 0,
                        c: 0,
                        d: 1,
                        tx: 0,
                        ty: 0
                    },
                    p1: -1,
                    p2: -1
                };
                gl.parts.push(part);
                part.glyphIndex = bin.readUshort(data, offset);
                offset += 2;
                if (flags & ARG_1_AND_2_ARE_WORDS) {
                    var arg1 = bin.readShort(data, offset);
                    offset += 2;
                    var arg2 = bin.readShort(data, offset);
                    offset += 2;
                } else {
                    var arg1 = bin.readInt8(data, offset);
                    offset++;
                    var arg2 = bin.readInt8(data, offset);
                    offset++;
                }
                if (flags & ARGS_ARE_XY_VALUES) {
                    part.m.tx = arg1;
                    part.m.ty = arg2;
                } else {
                    part.p1 = arg1;
                    part.p2 = arg2;
                }
                //part.m.tx = arg1;  part.m.ty = arg2;
                //else { throw "params are not XY values"; }
                if (flags & WE_HAVE_A_SCALE) {
                    part.m.a = part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                    part.m.a = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                    part.m.a = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.b = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.c = bin.readF2dot14(data, offset);
                    offset += 2;
                    part.m.d = bin.readF2dot14(data, offset);
                    offset += 2;
                }
            }while (flags & MORE_COMPONENTS)
            if (flags & WE_HAVE_INSTRUCTIONS) {
                var numInstr = bin.readUshort(data, offset);
                offset += 2;
                gl.instr = [];
                for(var i = 0; i < numInstr; i++){
                    gl.instr.push(data[offset]);
                    offset++;
                }
            }
        }
        return gl;
    }
};
Typr["T"].head = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        obj["fontRevision"] = bin.readFixed(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        obj["flags"] = bin.readUshort(data, offset);
        offset += 2;
        obj["unitsPerEm"] = bin.readUshort(data, offset);
        offset += 2;
        obj["created"] = bin.readUint64(data, offset);
        offset += 8;
        obj["modified"] = bin.readUint64(data, offset);
        offset += 8;
        obj["xMin"] = bin.readShort(data, offset);
        offset += 2;
        obj["yMin"] = bin.readShort(data, offset);
        offset += 2;
        obj["xMax"] = bin.readShort(data, offset);
        offset += 2;
        obj["yMax"] = bin.readShort(data, offset);
        offset += 2;
        obj["macStyle"] = bin.readUshort(data, offset);
        offset += 2;
        obj["lowestRecPPEM"] = bin.readUshort(data, offset);
        offset += 2;
        obj["fontDirectionHint"] = bin.readShort(data, offset);
        offset += 2;
        obj["indexToLocFormat"] = bin.readShort(data, offset);
        offset += 2;
        obj["glyphDataFormat"] = bin.readShort(data, offset);
        offset += 2;
        return obj;
    }
};
Typr["T"].hhea = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readFixed(data, offset);
        offset += 4;
        var keys = [
            "ascender",
            "descender",
            "lineGap",
            "advanceWidthMax",
            "minLeftSideBearing",
            "minRightSideBearing",
            "xMaxExtent",
            "caretSlopeRise",
            "caretSlopeRun",
            "caretOffset",
            "res0",
            "res1",
            "res2",
            "res3",
            "metricDataFormat",
            "numberOfHMetrics"
        ];
        for(var i = 0; i < keys.length; i++){
            var key = keys[i];
            var func = key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort;
            obj[key] = func(data, offset + i * 2);
        }
        return obj;
    }
};
Typr["T"].hmtx = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"];
        var aWidth = [];
        var lsBearing = [];
        var nG = font["maxp"]["numGlyphs"], nH = font["hhea"]["numberOfHMetrics"];
        var aw = 0, lsb = 0, i = 0;
        while(i < nH){
            aw = bin.readUshort(data, offset + (i << 2));
            lsb = bin.readShort(data, offset + (i << 2) + 2);
            aWidth.push(aw);
            lsBearing.push(lsb);
            i++;
        }
        while(i < nG){
            aWidth.push(aw);
            lsBearing.push(lsb);
            i++;
        }
        return {
            aWidth: aWidth,
            lsBearing: lsBearing
        };
    }
};
Typr["T"].kern = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"], kern = Typr["T"].kern;
        var version = bin.readUshort(data, offset);
        if (version == 1) return kern.parseV1(data, offset, length, font);
        var nTables = bin.readUshort(data, offset + 2);
        offset += 4;
        var map = {
            glyph1: [],
            rval: []
        };
        for(var i = 0; i < nTables; i++){
            offset += 2; // skip version
            var length = bin.readUshort(data, offset);
            offset += 2;
            var coverage = bin.readUshort(data, offset);
            offset += 2;
            var format = coverage >>> 8;
            /* I have seen format 128 once, that's why I do */ format &= 0xf;
            if (format == 0) offset = kern.readFormat0(data, offset, map);
        //else throw "unknown kern table format: "+format;
        }
        return map;
    },
    parseV1: function(data, offset, length, font) {
        var bin = Typr["B"], kern = Typr["T"].kern;
        bin.readFixed(data, offset); // 0x00010000
        var nTables = bin.readUint(data, offset + 4);
        offset += 8;
        var map = {
            glyph1: [],
            rval: []
        };
        for(var i = 0; i < nTables; i++){
            bin.readUint(data, offset);
            offset += 4;
            var coverage = bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            var format = coverage & 0xff;
            if (format == 0) offset = kern.readFormat0(data, offset, map);
        //else throw "unknown kern table format: "+format;
        }
        return map;
    },
    readFormat0: function(data, offset, map) {
        var bin = Typr["B"], rUs = bin.readUshort;
        var pleft = -1;
        var nPairs = rUs(data, offset);
        rUs(data, offset + 2);
        rUs(data, offset + 4);
        rUs(data, offset + 6);
        offset += 8;
        for(var j = 0; j < nPairs; j++){
            var left = rUs(data, offset);
            offset += 2;
            var right = rUs(data, offset);
            offset += 2;
            var value = bin.readShort(data, offset);
            offset += 2;
            if (left != pleft) {
                map.glyph1.push(left);
                map.rval.push({
                    glyph2: [],
                    vals: []
                });
            }
            var rval = map.rval[map.rval.length - 1];
            rval.glyph2.push(right);
            rval.vals.push(value);
            pleft = left;
        }
        return offset;
    }
};
Typr["T"].loca = {
    parseTab: function(data, offset, length, font) {
        var bin = Typr["B"];
        var obj = [];
        var ver = font["head"]["indexToLocFormat"];
        var len = font["maxp"]["numGlyphs"] + 1;
        if (ver == 0) for(var i = 0; i < len; i++)obj.push(bin.readUshort(data, offset + (i << 1)) << 1);
        if (ver == 1) for(var i = 0; i < len; i++)obj.push(bin.readUint(data, offset + (i << 2)));
        return obj;
    }
};
Typr["T"].maxp = {
    parseTab: function(data, offset, length) {
        //console.log(data.length, offset, length);
        var bin = Typr["B"], rU = bin.readUshort;
        var obj = {};
        // both versions 0.5 and 1.0
        bin.readUint(data, offset);
        offset += 4;
        obj["numGlyphs"] = rU(data, offset);
        offset += 2;
        // only 1.0
        /*
    if(ver == 0x00010000) {
      obj.maxPoints             = rU(data, offset);  offset += 2;
      obj.maxContours           = rU(data, offset);  offset += 2;
      obj.maxCompositePoints    = rU(data, offset);  offset += 2;
      obj.maxCompositeContours  = rU(data, offset);  offset += 2;
      obj.maxZones              = rU(data, offset);  offset += 2;
      obj.maxTwilightPoints     = rU(data, offset);  offset += 2;
      obj.maxStorage            = rU(data, offset);  offset += 2;
      obj.maxFunctionDefs       = rU(data, offset);  offset += 2;
      obj.maxInstructionDefs    = rU(data, offset);  offset += 2;
      obj.maxStackElements      = rU(data, offset);  offset += 2;
      obj.maxSizeOfInstructions = rU(data, offset);  offset += 2;
      obj.maxComponentElements  = rU(data, offset);  offset += 2;
      obj.maxComponentDepth     = rU(data, offset);  offset += 2;
    }
    */ return obj;
    }
};
Typr["T"].name = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        bin.readUshort(data, offset);
        offset += 2;
        var count = bin.readUshort(data, offset);
        offset += 2;
        var stringOffset = bin.readUshort(data, offset);
        offset += 2;
        var ooo = offset - 6 + stringOffset;
        //console.log(format,count);
        var names = [
            "copyright",
            "fontFamily",
            "fontSubfamily",
            "ID",
            "fullName",
            "version",
            "postScriptName",
            "trademark",
            "manufacturer",
            "designer",
            "description",
            "urlVendor",
            "urlDesigner",
            "licence",
            "licenceURL",
            "---",
            "typoFamilyName",
            "typoSubfamilyName",
            "compatibleFull",
            "sampleText",
            "postScriptCID",
            "wwsFamilyName",
            "wwsSubfamilyName",
            "lightPalette",
            "darkPalette"
        ];
        var rU = bin.readUshort;
        for(var i = 0; i < count; i++){
            var platformID = rU(data, offset);
            offset += 2;
            var encodingID = rU(data, offset);
            offset += 2;
            var languageID = rU(data, offset);
            offset += 2;
            var nameID = rU(data, offset);
            offset += 2;
            var slen = rU(data, offset);
            offset += 2;
            var noffset = rU(data, offset);
            offset += 2;
            //console.log(platformID, encodingID, languageID.toString(16), nameID, length, noffset);
            var soff = ooo + noffset;
            var str;
            if (platformID == 0) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 3 && encodingID == 0) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 1 && encodingID == 25) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 0) str = bin.readASCII(data, soff, slen);
            else if (encodingID == 1) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 3) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 4) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 5) str = bin.readUnicode(data, soff, slen / 2);
            else if (encodingID == 10) str = bin.readUnicode(data, soff, slen / 2);
            else if (platformID == 1) {
                str = bin.readASCII(data, soff, slen);
                console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
            } else {
                console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
                str = bin.readASCII(data, soff, slen);
            }
            var tid = "p" + platformID + "," + languageID.toString(16); //Typr._platforms[platformID];
            if (obj[tid] == null) obj[tid] = {};
            var name = names[nameID];
            if (name == null) name = "_" + nameID;
            obj[tid][name] = str;
            obj[tid]["_lang"] = languageID;
        //console.log(tid, obj[tid]);
        }
        /*
    if(format == 1)
    {
      var langTagCount = bin.readUshort(data, offset);  offset += 2;
      for(var i=0; i<langTagCount; i++)
      {
        var length  = bin.readUshort(data, offset);  offset += 2;
        var noffset = bin.readUshort(data, offset);  offset += 2;
      }
    }
    */ var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
        if (out[ff] == null) {
            for(var p in obj)if (obj[p][ff] != null) out[ff] = obj[p][ff];
        }
        return out;
    },
    selectOne: function(obj) {
        //console.log(obj);
        var psn = "postScriptName";
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0409) return obj[p]; // United States
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0000) return obj[p]; // Universal
        for(var p in obj)if (obj[p][psn] != null && obj[p]["_lang"] == 0x0c0c) return obj[p]; // Canada
        for(var p in obj)if (obj[p][psn] != null) return obj[p];
        var out;
        for(var p in obj){
            out = obj[p];
            break;
        }
        console.log("returning name table with languageID " + out._lang);
        if (out[psn] == null && out["ID"] != null) out[psn] = out["ID"];
        return out;
    }
};
Typr["T"].OS2 = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ver = bin.readUshort(data, offset);
        offset += 2;
        var OS2 = Typr["T"].OS2;
        var obj = {};
        if (ver == 0) OS2.version0(data, offset, obj);
        else if (ver == 1) OS2.version1(data, offset, obj);
        else if (ver == 2 || ver == 3 || ver == 4) OS2.version2(data, offset, obj);
        else if (ver == 5) OS2.version5(data, offset, obj);
        else throw "unknown OS/2 table version: " + ver;
        return obj;
    },
    version0: function(data, offset, obj) {
        var bin = Typr["B"];
        obj["xAvgCharWidth"] = bin.readShort(data, offset);
        offset += 2;
        obj["usWeightClass"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usWidthClass"] = bin.readUshort(data, offset);
        offset += 2;
        obj["fsType"] = bin.readUshort(data, offset);
        offset += 2;
        obj["ySubscriptXSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptYSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptXOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySubscriptYOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptXSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptYSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptXOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["ySuperscriptYOffset"] = bin.readShort(data, offset);
        offset += 2;
        obj["yStrikeoutSize"] = bin.readShort(data, offset);
        offset += 2;
        obj["yStrikeoutPosition"] = bin.readShort(data, offset);
        offset += 2;
        obj["sFamilyClass"] = bin.readShort(data, offset);
        offset += 2;
        obj["panose"] = bin.readBytes(data, offset, 10);
        offset += 10;
        obj["ulUnicodeRange1"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange2"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange3"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulUnicodeRange4"] = bin.readUint(data, offset);
        offset += 4;
        obj["achVendID"] = bin.readASCII(data, offset, 4);
        offset += 4;
        obj["fsSelection"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usFirstCharIndex"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usLastCharIndex"] = bin.readUshort(data, offset);
        offset += 2;
        obj["sTypoAscender"] = bin.readShort(data, offset);
        offset += 2;
        obj["sTypoDescender"] = bin.readShort(data, offset);
        offset += 2;
        obj["sTypoLineGap"] = bin.readShort(data, offset);
        offset += 2;
        obj["usWinAscent"] = bin.readUshort(data, offset);
        offset += 2;
        obj["usWinDescent"] = bin.readUshort(data, offset);
        offset += 2;
        return offset;
    },
    version1: function(data, offset, obj) {
        var bin = Typr["B"];
        offset = Typr["T"].OS2.version0(data, offset, obj);
        obj["ulCodePageRange1"] = bin.readUint(data, offset);
        offset += 4;
        obj["ulCodePageRange2"] = bin.readUint(data, offset);
        offset += 4;
        return offset;
    },
    version2: function(data, offset, obj) {
        var bin = Typr["B"], rU = bin.readUshort;
        offset = Typr["T"].OS2.version1(data, offset, obj);
        obj["sxHeight"] = bin.readShort(data, offset);
        offset += 2;
        obj["sCapHeight"] = bin.readShort(data, offset);
        offset += 2;
        obj["usDefault"] = rU(data, offset);
        offset += 2;
        obj["usBreak"] = rU(data, offset);
        offset += 2;
        obj["usMaxContext"] = rU(data, offset);
        offset += 2;
        return offset;
    },
    version5: function(data, offset, obj) {
        var rU = Typr["B"].readUshort;
        offset = Typr["T"].OS2.version2(data, offset, obj);
        obj["usLowerOpticalPointSize"] = rU(data, offset);
        offset += 2;
        obj["usUpperOpticalPointSize"] = rU(data, offset);
        offset += 2;
        return offset;
    }
};
Typr["T"].post = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {};
        obj["version"] = bin.readFixed(data, offset);
        offset += 4;
        obj["italicAngle"] = bin.readFixed(data, offset);
        offset += 4;
        obj["underlinePosition"] = bin.readShort(data, offset);
        offset += 2;
        obj["underlineThickness"] = bin.readShort(data, offset);
        offset += 2;
        return obj;
    }
};
Typr["T"].SVG = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var obj = {
            entries: [],
            svgs: []
        };
        var offset0 = offset;
        bin.readUshort(data, offset);
        offset += 2;
        var svgDocIndexOffset = bin.readUint(data, offset);
        offset += 4;
        bin.readUint(data, offset);
        offset += 4;
        offset = svgDocIndexOffset + offset0;
        var numEntries = bin.readUshort(data, offset);
        offset += 2;
        for(var i = 0; i < numEntries; i++){
            var startGlyphID = bin.readUshort(data, offset);
            offset += 2;
            var endGlyphID = bin.readUshort(data, offset);
            offset += 2;
            var svgDocOffset = bin.readUint(data, offset);
            offset += 4;
            var svgDocLength = bin.readUint(data, offset);
            offset += 4;
            var sbuf = new Uint8Array(data.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
            if (sbuf[0] == 0x1f && sbuf[1] == 0x8b && sbuf[2] == 0x08) sbuf = pako["inflate"](sbuf);
            var svg = bin.readUTF8(sbuf, 0, sbuf.length);
            for(var f = startGlyphID; f <= endGlyphID; f++){
                obj.entries[f] = obj.svgs.length;
            }
            obj.svgs.push(svg);
        }
        return obj;
    }
};
Typr["T"].sbix = {
    parseTab: function(data, offset, length, obj) {
        var numGlyphs = obj["maxp"]["numGlyphs"];
        var ooff = offset;
        var bin = Typr["B"];
        //var ver = bin.readUshort(data,offset);  offset+=2;
        //var flg = bin.readUshort(data,offset);  offset+=2;
        var numStrikes = bin.readUint(data, offset + 4);
        var out = [];
        for(var si = numStrikes - 1; si < numStrikes; si++){
            var off = ooff + bin.readUint(data, offset + 8 + si * 4);
            //var ppem = bin.readUshort(data,off);  off+=2;
            //var ppi  = bin.readUshort(data,off);  off+=2;
            for(var gi = 0; gi < numGlyphs; gi++){
                var aoff = bin.readUint(data, off + 4 + gi * 4);
                var noff = bin.readUint(data, off + 4 + gi * 4 + 4);
                if (aoff == noff) {
                    out[gi] = null;
                    continue;
                }
                var go = off + aoff;
                //var ooX = bin.readUshort(data,go);
                //var ooY = bin.readUshort(data,go+2);
                var tag = bin.readASCII(data, go + 4, 4);
                if (tag != "png ") throw tag;
                out[gi] = new Uint8Array(data.buffer, data.byteOffset + go + 8, noff - aoff - 8);
            }
        }
        return out;
    }
};
Typr["T"].colr = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ooff = offset;
        offset += 2;
        var num = bin.readUshort(data, offset);
        offset += 2;
        var boff = bin.readUint(data, offset);
        offset += 4;
        var loff = bin.readUint(data, offset);
        offset += 4;
        var lnum = bin.readUshort(data, offset);
        offset += 2;
        //console.log(num,boff,loff,lnum);
        var base = {};
        var coff = ooff + boff;
        for(var i = 0; i < num; i++){
            base["g" + bin.readUshort(data, coff)] = [
                bin.readUshort(data, coff + 2),
                bin.readUshort(data, coff + 4)
            ];
            coff += 6;
        }
        var lays = [];
        coff = ooff + loff;
        for(var i = 0; i < lnum; i++){
            lays.push(bin.readUshort(data, coff), bin.readUshort(data, coff + 2));
            coff += 4;
        }
        return [
            base,
            lays
        ];
    }
};
Typr["T"].cpal = {
    parseTab: function(data, offset, length) {
        var bin = Typr["B"];
        var ooff = offset;
        var vsn = bin.readUshort(data, offset);
        offset += 2;
        if (vsn == 0) {
            bin.readUshort(data, offset);
            offset += 2;
            bin.readUshort(data, offset);
            offset += 2;
            var tot = bin.readUshort(data, offset);
            offset += 2;
            var fst = bin.readUint(data, offset);
            offset += 4;
            return new Uint8Array(data.buffer, ooff + fst, tot * 4);
        /*
      var coff=ooff+fst;

      for(var i=0; i<tot; i++) {
        console.log(data[coff],data[coff+1],data[coff+2],data[coff+3]);
        coff+=4;
      }

      console.log(ets,pts,tot); */ } else throw vsn; //console.log("unknown color palette",vsn);
    }
};
Typr["T"].GSUB = {
    parseTab: function(data, offset, length, obj) {
        //console.log(obj.name.ID);
        var bin = Typr["B"], rU = bin.readUshort;
        bin.readUint;
        var off = offset;
        rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        var flO = rU(data, off);
        off += 2;
        rU(data, off);
        off += 2;
        //console.log(maj,min,slO,flO,llO);
        off = offset + flO;
        var fmap = {};
        var cnt = rU(data, off);
        off += 2;
        for(var i = 0; i < cnt; i++){
            var tag = bin.readASCII(data, off, 4);
            off += 4;
            rU(data, off);
            off += 2;
            fmap[tag] = true;
        }
        //console.log(fmap);
        return fmap;
    }
};
Typr["T"].fvar = {
    parseTab: function(data, offset, length, obj) {
        var name = obj["name"];
        var off = offset;
        var bin = Typr["B"];
        var axes = [], inst = [];
        off += 8;
        var acnt = bin.readUshort(data, off);
        off += 2;
        off += 2;
        var icnt = bin.readUshort(data, off);
        off += 2;
        var isiz = bin.readUshort(data, off);
        off += 2;
        for(var i = 0; i < acnt; i++){
            var tag = bin.readASCII(data, off, 4);
            var min = bin.readFixed(data, off + 4);
            var def = bin.readFixed(data, off + 8);
            var max = bin.readFixed(data, off + 12);
            var flg = bin.readUshort(data, off + 16);
            var nid = bin.readUshort(data, off + 18);
            axes.push([
                tag,
                min,
                def,
                max,
                flg,
                name["_" + nid]
            ]);
            //console.log(tag,min,def,max,flg,nid);
            off += 20;
        }
        for(var i = 0; i < icnt; i++){
            var snid = bin.readUshort(data, off), pnid = null;
            var flg = bin.readUshort(data, off + 2);
            var crd = [];
            for(var j = 0; j < acnt; j++)crd.push(bin.readFixed(data, off + 4 + j * 4));
            off += 4 + acnt * 4;
            if ((isiz & 3) == 2) {
                pnid = bin.readUshort(data, off);
                off += 2;
            }
            inst.push([
                name["_" + snid],
                flg,
                crd,
                pnid
            ]);
        //console.log(snid,flg, crd);
        }
        return [
            axes,
            inst
        ];
    }
};
Typr["T"].gvar = function() {
    var EMBEDDED_PEAK_TUPLE = 0x8000;
    var INTERMEDIATE_REGION = 0x4000;
    var PRIVATE_POINT_NUMBERS = 0x2000;
    var DELTAS_ARE_ZERO = 0x80;
    var DELTAS_ARE_WORDS = 0x40;
    var POINTS_ARE_WORDS = 0x80;
    var SHARED_POINT_NUMBERS = 0x8000;
    var bin = Typr["B"];
    function readTuple(data, o, acnt) {
        var tup = [];
        for(var j = 0; j < acnt; j++)tup.push(bin.readF2dot14(data, o + j * 2));
        return tup;
    }
    function readTupleVarHeader(data, off, vcnt, acnt, eoff) {
        var out = [];
        for(var j = 0; j < vcnt; j++){
            var dsiz = bin.readUshort(data, off);
            off += 2;
            var tind = bin.readUshort(data, off), flag = tind & 0xf000;
            tind = tind & 0xfff;
            off += 2;
            //console.log(j, dsiz,tind, flag.toString(16));
            var peak = null, start = null, end = null;
            if (flag & EMBEDDED_PEAK_TUPLE) {
                peak = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            if (flag & INTERMEDIATE_REGION) {
                start = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            if (flag & INTERMEDIATE_REGION) {
                end = readTuple(data, off, acnt);
                off += acnt * 2;
            }
            out.push([
                dsiz,
                tind,
                flag,
                start,
                peak,
                end
            ]);
        }
        return out;
    }
    // Packed "point" numbers
    function readPointNumbers(data, off, gid) {
        var cnt = data[off];
        off++;
        if (cnt == 0) return [
            [],
            off
        ];
        if (127 < cnt) {
            cnt = (cnt & 127) << 8 | data[off++];
        }
        //if(gid==116) console.log("---",cnt);
        var pts = [], last = 0; // point number data runs
        while(pts.length < cnt){
            var v = data[off];
            off++;
            var wds = (v & POINTS_ARE_WORDS) != 0;
            v = (v & 127) + 1;
            //if(gid==116) console.log("-",v);
            for(var i = 0; i < v; i++){
                var dif = 0;
                if (wds) {
                    dif = bin.readUshort(data, off);
                    off += 2;
                } else {
                    dif = data[off];
                    off++;
                }
                //if(gid==116) console.log(dif);
                last += dif;
                pts.push(last);
            }
        }
        //console.log(pts);
        return [
            pts,
            off
        ];
    //throw "e";
    }
    function parseTab(data, offset, length, obj) {
        var off = offset + 4;
        var acnt = bin.readUshort(data, off);
        off += 2;
        var tcnt = bin.readUshort(data, off);
        off += 2;
        var toff = bin.readUint(data, off);
        off += 4;
        var gcnt = bin.readUshort(data, off);
        off += 2;
        bin.readUshort(data, off);
        off += 2;
        var goff = bin.readUint(data, off);
        off += 4;
        // glyphVariationDataOffsets
        var offs = [];
        for(var i = 0; i < gcnt + 1; i++)offs.push(bin.readUint(data, off + i * 4));
        // sharedTuples
        var tups = [], mins = [], maxs = [];
        off = offset + toff;
        for(var i = 0; i < tcnt; i++){
            var peak = readTuple(data, off + i * acnt * 2, acnt), imin = [], imax = [];
            tups.push(peak);
            mins.push(imin);
            maxs.push(imax);
            for(var k = 0; k < acnt; k++){
                imin[k] = Math.min(peak[k], 0);
                imax[k] = Math.max(peak[k], 0);
            }
        }
        //console.log(tups);
        //console.log(acnt,stcnt,stoff,gcnt,flgs,goff);
        var i8 = new Int8Array(data.buffer);
        // GlyphVariationData table array
        var tabs = [];
        for(var i = 0; i < gcnt; i++){
            //console.log("-------",i);
            off = offset + goff + offs[i];
            // tupleVariationCount
            var vcnt = bin.readUshort(data, off);
            off += 2; //if((vcnt>>>12)!=0) throw "e";
            var snum = vcnt & SHARED_POINT_NUMBERS;
            vcnt &= 0xfff;
            //  offset to the serialized data
            var soff = bin.readUshort(data, off);
            off += 2;
            var hdr = readTupleVarHeader(data, off, vcnt, acnt);
            var tab = [];
            tabs.push(tab);
            // Serialized Data
            off = offset + goff + offs[i] + soff;
            var sind = null;
            if (snum) {
                var oo = readPointNumbers(data, off);
                sind = oo[0];
                off = oo[1];
            }
            for(var j = 0; j < vcnt; j++){
                var vr = hdr[j], end = off + vr[0]; //console.log(vr);  console.log(data.slice(off,off+vr[0]));
                var ind = sind;
                if (vr[2] & PRIVATE_POINT_NUMBERS) {
                    var oo = readPointNumbers(data, off);
                    ind = oo[0];
                    off = oo[1];
                }
                // read packed deltas (delta runs)
                var ds = [];
                while(off < end){
                    var cb = data[off++]; // control byte;
                    var cnt = (cb & 0x3f) + 1;
                    if (cb & DELTAS_ARE_ZERO) {
                        for(var k = 0; k < cnt; k++)ds.push(0);
                    } else if (cb & DELTAS_ARE_WORDS) {
                        for(var k = 0; k < cnt; k++)ds.push(bin.readShort(data, off + k * 2));
                        off += cnt * 2;
                    } else {
                        for(var k = 0; k < cnt; k++)ds.push(i8[off + k]);
                        off += cnt;
                    }
                }
                //if(ind) console.log(ind, ds);
                var ti = vr[1];
                tab.push([
                    [
                        vr[3] ? vr[3] : mins[ti],
                        vr[4] ? vr[4] : tups[ti],
                        vr[5] ? vr[5] : maxs[ti]
                    ],
                    ds,
                    ind.length == 0 ? null : ind
                ]);
                if (ind.length != 0 && ind.length * 2 != ds.length) throw "e";
            //if(i==116) console.log(ind, ds);
            }
        }
        return tabs;
    }
    return {
        parseTab: parseTab
    };
}();
Typr["T"].avar = {
    parseTab: function(data, offset, length, obj) {
        var off = offset;
        var bin = Typr["B"], out = [];
        off += 6;
        var acnt = bin.readUshort(data, off);
        off += 2;
        for(var ai = 0; ai < acnt; ai++){
            var cnt = bin.readUshort(data, off);
            off += 2;
            var poly = [];
            out.push(poly);
            for(var i = 0; i < cnt; i++){
                var x = bin.readF2dot14(data, off);
                var y = bin.readF2dot14(data, off + 2);
                off += 4;
                poly.push(x, y);
            }
        }
        return out;
    }
};
Typr["T"].HVAR = {
    parseTab: function(data, offset, length, obj) {
        var off = offset, oo = offset;
        var bin = Typr["B"];
        //console.log(data.slice(off));
        off += 4;
        var varO = bin.readUint(data, off);
        off += 4;
        var advO = bin.readUint(data, off);
        off += 4;
        var lsbO = bin.readUint(data, off);
        off += 4;
        var rsbO = bin.readUint(data, off);
        off += 4;
        if (lsbO != 0 || rsbO != 0) throw lsbO;
        //console.log(varO,advO,lsbO,rsbO);
        off = oo + varO; // item variation store
        // ItemVariationStore
        var ioff = off;
        var fmt = bin.readUshort(data, off);
        off += 2;
        if (fmt != 1) throw "e";
        var vregO = bin.readUint(data, off);
        off += 4;
        // itemVariationDataCount
        var vcnt = bin.readUshort(data, off);
        off += 2;
        var offs = [];
        for(var i = 0; i < vcnt; i++)offs.push(bin.readUint(data, off + i * 4));
        off += vcnt * 4; //if(offs.length!=1) throw "e";
        //console.log(vregO,vcnt,offs);
        off = ioff + vregO;
        var acnt = bin.readUshort(data, off);
        off += 2;
        var rcnt = bin.readUshort(data, off);
        off += 2;
        var regs = [];
        for(var i = 0; i < rcnt; i++){
            var crd = [
                [],
                [],
                []
            ];
            regs.push(crd);
            for(var j = 0; j < acnt; j++){
                crd[0].push(bin.readF2dot14(data, off + 0));
                crd[1].push(bin.readF2dot14(data, off + 2));
                crd[2].push(bin.readF2dot14(data, off + 4));
                off += 6;
            }
        }
        //console.log(acnt, rcnt, regs);
        var i8 = new Int8Array(data.buffer);
        var varStore = [];
        for(var i = 0; i < offs.length; i++){
            // ItemVariationData
            off = oo + varO + offs[i];
            var vdata = [];
            varStore.push(vdata);
            var icnt = bin.readUshort(data, off);
            off += 2; // itemCount
            var dcnt = bin.readUshort(data, off);
            off += 2;
            if (dcnt & 0x8000) throw "e";
            var rcnt = bin.readUshort(data, off);
            off += 2;
            var ixs = [];
            for(var j = 0; j < rcnt; j++)ixs.push(bin.readUshort(data, off + j * 2));
            off += rcnt * 2;
            //console.log(icnt,dcnt,rcnt,ixs);
            //console.log(data.slice(off));
            for(var k = 0; k < icnt; k++){
                var deltaData = []; //vdata.push(deltaData);
                for(var ri = 0; ri < rcnt; ri++){
                    deltaData.push(ri < dcnt ? bin.readShort(data, off) : i8[off]);
                    off += ri < dcnt ? 2 : 1;
                }
                var dd = new Array(regs.length);
                dd.fill(0);
                vdata.push(dd);
                for(var j = 0; j < ixs.length; j++)dd[ixs[j]] = deltaData[j];
            }
        }
        //console.log(varStore);
        // VariationRegionList
        off = oo + advO; // advance widths
        // DeltaSetIndexMap
        var fmt = data[off++];
        if (fmt != 0) throw "e";
        var entryFormat = data[off++];
        var mapCount = bin.readUshort(data, off);
        off += 2;
        var INNER_INDEX_BIT_COUNT_MASK = 0x0f;
        var MAP_ENTRY_SIZE_MASK = 0x30;
        var entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1; //if(entrySize!=1) throw entrySize;
        //console.log(fmt, entryFormat, mapCount, entrySize);
        var dfs = [];
        for(var i = 0; i < mapCount; i++){
            var entry = 0;
            if (entrySize == 1) entry = data[off++];
            else {
                entry = bin.readUshort(data, off);
                off += 2;
            }
            var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
            var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
            //map.push(outerIndex,innerIndex);
            dfs.push(varStore[outerIndex][innerIndex]);
        //console.log(outerIndex,innerIndex);
        //console.log(i,varStore[outerIndex][innerIndex]);
        }
        return [
            regs,
            dfs
        ];
    }
};
Typr["U"] = function() {
    var P = {
        MoveTo: function(p, x, y) {
            p.cmds.push("M");
            p.crds.push(x, y);
        },
        LineTo: function(p, x, y) {
            p.cmds.push("L");
            p.crds.push(x, y);
        },
        CurveTo: function(p, a, b, c, d, e, f) {
            p.cmds.push("C");
            p.crds.push(a, b, c, d, e, f);
        },
        qCurveTo: function(p, a, b, c, d) {
            p.cmds.push("Q");
            p.crds.push(a, b, c, d);
        },
        ClosePath: function(p) {
            p.cmds.push("Z");
        }
    };
    function getGlyphPosition(font, gls, i1, ltr) {
        var g1 = gls[i1], g2 = gls[i1 + 1], kern = font["kern"];
        if (kern) {
            var ind1 = kern.glyph1.indexOf(g1);
            if (ind1 != -1) {
                var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
                if (ind2 != -1) return [
                    0,
                    0,
                    kern.rval[ind1].vals[ind2],
                    0
                ];
            }
        }
        //console.log("no kern");
        return [
            0,
            0,
            0,
            0
        ];
    }
    function shape(font, str, prm) {
        if (prm == null) prm = {};
        prm["ltr"];
        prm["fts"];
        var axs = prm["axs"];
        if (font["fvar"] && axs == null) axs = font["fvar"][1][font["_index"]][2];
        var HVAR = font["HVAR"]; //console.log(HVAR);
        if (axs && HVAR) {
            axs = _normalizeAxis(font, axs);
        } //console.log(S,axs);
        var gls = [];
        for(var i = 0; i < str.length; i++){
            var cc = str.codePointAt(i);
            if (cc > 0xffff) i++;
            gls.push(codeToGlyph(font, cc));
        }
        var shape = [];
        for(var i = 0; i < gls.length; i++){
            var padj = getGlyphPosition(font, gls, i);
            var gid = gls[i]; //console.log(gid);
            var ax = font["hmtx"].aWidth[gid] + padj[2];
            if (HVAR && HVAR[1][gid]) {
                var difs = HVAR[1][gid]; //console.log(difs);
                for(var j = 0; j < HVAR[0].length; j++){
                    ax += _interpolate(HVAR[0][j], axs) * difs[j];
                }
            }
            shape.push({
                "g": gid,
                "cl": i,
                "dx": 0,
                "dy": 0,
                "ax": ax,
                "ay": 0
            });
        }
        return shape;
    }
    function shapeToPath(font, shape, prm) {
        var tpath = {
            cmds: [],
            crds: []
        };
        var x = 0, y = 0, clr, axs;
        if (prm) {
            clr = prm["clr"];
            axs = prm["axs"];
        }
        for(var i = 0; i < shape.length; i++){
            var it = shape[i];
            var path = glyphToPath(font, it["g"], false, axs), crds = path["crds"];
            for(var j = 0; j < crds.length; j += 2){
                tpath.crds.push(crds[j] + x + it["dx"]);
                tpath.crds.push(crds[j + 1] + y + it["dy"]);
            }
            if (clr) tpath.cmds.push(clr);
            for(var j = 0; j < path["cmds"].length; j++)tpath.cmds.push(path["cmds"][j]);
            var clen = tpath.cmds.length;
            if (clr) {
                if (clen != 0 && tpath.cmds[clen - 1] != "X") tpath.cmds.push("X"); // SVG fonts might contain "X". Then, nothing would stroke non-SVG glyphs.
            }
            x += it["ax"];
            y += it["ay"];
        }
        return {
            "cmds": tpath.cmds,
            "crds": tpath.crds
        };
    }
    // find the greatest index with a value <=v
    function arrSearch(arr, k, v) {
        var l = 0, r = ~~(arr.length / k);
        while(l + 1 != r){
            var mid = l + (r - l >>> 1);
            if (arr[mid * k] <= v) l = mid;
            else r = mid;
        }
        //var mi = 0;  for(var i=0; i<arr.length; i+=k) if(arr[i]<=v) mi=i;  if(mi!=l*k) throw "e";
        return l * k;
    }
    var wha = [
        0x9,
        0xa,
        0xb,
        0xc,
        0xd,
        0x20,
        0x85,
        0xa0,
        0x1680,
        0x180e,
        0x2028,
        0x2029,
        0x202f,
        0x2060,
        0x3000,
        0xfeff
    ], whm = {};
    for(var i = 0; i < wha.length; i++)whm[wha[i]] = 1;
    for(var i = 0x2000; i <= 0x200d; i++)whm[i] = 1;
    function codeToGlyph(font, code) {
        //console.log(cmap);
        // "p3e10" for NotoEmoji-Regular.ttf
        //console.log(cmap);
        if (font["_ctab"] == null) {
            var cmap = font["cmap"];
            var tind = -1, pps = [
                "p3e10",
                "p0e4",
                "p3e1",
                "p1e0",
                "p0e3",
                "p0e1" /*,"p3e3"*/ ,
                "p3e0" /*Hebrew*/ ,
                "p3e5" /*Korean*/ 
            ];
            for(var i = 0; i < pps.length; i++)if (cmap.ids[pps[i]] != null) {
                tind = cmap.ids[pps[i]];
                break;
            }
            if (tind == -1) throw "no familiar platform and encoding!";
            font["_ctab"] = cmap.tables[tind];
        }
        var tab = font["_ctab"], fmt = tab.format, gid = -1; //console.log(fmt); throw "e";
        if (fmt == 0) {
            if (code >= tab.map.length) gid = 0;
            else gid = tab.map[code];
        } else if (fmt == 4) {
            var ec = tab.endCount;
            gid = 0;
            if (code <= ec[ec.length - 1]) {
                // smallest index with code <= value
                var sind = arrSearch(ec, 1, code);
                if (ec[sind] < code) sind++;
                if (code >= tab.startCount[sind]) {
                    var gli = 0;
                    if (tab.idRangeOffset[sind] != 0) gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
                    else gli = code + tab.idDelta[sind];
                    gid = gli & 0xFFFF;
                }
            }
        } else if (fmt == 6) {
            var off = code - tab.firstCode, arr = tab.glyphIdArray;
            if (off < 0 || off >= arr.length) gid = 0;
            else gid = arr[off];
        } else if (fmt == 12) {
            var grp = tab.groups;
            gid = 0; //console.log(grp);  throw "e";
            if (code <= grp[grp.length - 2]) {
                var i = arrSearch(grp, 3, code);
                if (grp[i] <= code && code <= grp[i + 1]) {
                    gid = grp[i + 2] + (code - grp[i]);
                }
            }
        } else throw "unknown cmap table format " + tab.format;
        //*
        var SVG = font["SVG "], loca = font["loca"];
        // if the font claims to have a Glyph for a character, but the glyph is empty, and the character is not "white", it is a lie!
        if (gid != 0 && font["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] // loca not present in CFF or SVG fonts
         && whm[code] == null) gid = 0;
        //*/
        return gid;
    }
    function glyphToPath(font, gid, noColor, axs) {
        var path = {
            cmds: [],
            crds: []
        };
        if (font["fvar"]) {
            if (axs == null) axs = font["fvar"][1][font["_index"]][2];
            axs = _normalizeAxis(font, axs);
        }
        var SVG = font["SVG "], CFF = font["CFF "], COLR = font["COLR"], CBLC = font["CBLC"], CBDT = font["CBDT"], sbix = font["sbix"], upng = window["UPNG"];
        var strike = null;
        if (CBLC && upng) {
            for(var i = 0; i < CBLC.length; i++)if (CBLC[i][0] <= gid && gid <= CBLC[i][1]) strike = CBLC[i];
        }
        if (strike || sbix && sbix[gid]) {
            if (strike && strike[2] != 17) throw "not a PNG";
            if (font["__tmp"] == null) font["__tmp"] = {};
            var cmd = font["__tmp"]["g" + gid];
            if (cmd == null) {
                var bmp, len;
                if (sbix) {
                    bmp = sbix[gid];
                    len = bmp.length;
                } else {
                    var boff = strike[3][gid - strike[0]] + 5; // smallGlyphMetrics
                    len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
                    boff += 4;
                    bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
                }
                var str = "";
                for(var i = 0; i < len; i++)str += String.fromCharCode(bmp[i]);
                cmd = font["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
            }
            path.cmds.push(cmd);
            var upe = font["head"]["unitsPerEm"] * 1.15;
            var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * 0.15);
            path.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy); //*/
        } else if (SVG && SVG.entries[gid]) {
            var p = SVG.entries[gid];
            if (p != null) {
                if (typeof p == "number") {
                    var svg = SVG.svgs[p];
                    if (typeof svg == "string") {
                        var prsr = new DOMParser();
                        var doc = prsr["parseFromString"](svg, "image/svg+xml");
                        svg = SVG.svgs[p] = doc.getElementsByTagName("svg")[0];
                    }
                    p = Typr["U"]["SVG"].toPath(svg, gid);
                    SVG.entries[gid] = p;
                }
                path = p;
            }
        } else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
            function toHex(n) {
                var o = n.toString(16);
                return (o.length == 1 ? "0" : "") + o;
            }
            var CPAL = font["CPAL"], gl = COLR[0]["g" + gid];
            for(var i = 0; i < gl[1]; i++){
                var lid = gl[0] + i;
                var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
                var pth = glyphToPath(font, cgl, cgl == gid);
                var col = "#" + toHex(CPAL[pid + 2]) + toHex(CPAL[pid + 1]) + toHex(CPAL[pid + 0]);
                path.cmds.push(col);
                path.cmds = path.cmds.concat(pth["cmds"]);
                path.crds = path.crds.concat(pth["crds"]);
                //console.log(gid, cgl,pid,col);
                path.cmds.push("X");
            }
        } else if (CFF) {
            var pdct = CFF["Private"];
            var state = {
                x: 0,
                y: 0,
                stack: [],
                nStems: 0,
                haveWidth: false,
                width: pdct ? pdct["defaultWidthX"] : 0,
                open: false
            };
            if (CFF["ROS"]) {
                var gi = 0;
                while(CFF["FDSelect"][gi + 2] <= gid)gi += 2;
                pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
            }
            _drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path);
        } else if (font["glyf"]) {
            _drawGlyf(gid, font, path, axs);
        }
        return {
            "cmds": path.cmds,
            "crds": path.crds
        };
    }
    function _drawGlyf(gid, font, path, axs) {
        var gl = font["glyf"][gid];
        if (gl == null) gl = font["glyf"][gid] = Typr["T"].glyf._parseGlyf(font, gid);
        if (gl != null) {
            if (gl.noc > -1) _simpleGlyph(gl, font, gid, path, axs);
            else _compoGlyph(gl, font, gid, path, axs);
        }
    }
    function _interpolate(axs, v) {
        v.length;
        var S = 1;
        var s = axs[0]; // start
        var p = axs[1]; // peak
        var e = axs[2]; // end
        for(var i = 0; i < v.length; i++){
            var AS = 1;
            if (s[i] > p[i] || p[i] > e[i]) AS = 1;
            else if (s[i] < 0 && e[i] > 0 && p[i] != 0) AS = 1;
            else if (p[i] == 0) AS = 1;
            else if (v[i] < s[i] || v[i] > e[i]) AS = 0;
            else {
                if (v[i] == p[i]) AS = 1;
                else if (v[i] < p[i]) AS = (v[i] - s[i]) / (p[i] - s[i]);
                else AS = (e[i] - v[i]) / (e[i] - p[i]);
            }
            S = S * AS;
        }
        return S;
    }
    function _normalizeAxis(font, vv) {
        var fvar = font["fvar"], avar = font["avar"];
        var fv = fvar ? fvar[0] : null;
        var nv = [];
        for(var i = 0; i < fv.length; i++){
            var min = fv[i][1], def = fv[i][2], max = fv[i][3], v = Math.max(min, Math.min(max, vv[i]));
            if (v < def) nv[i] = (def - v) / (min - def);
            else if (v > def) nv[i] = (v - def) / (max - def);
            else nv[i] = 0;
            if (avar && nv[i] != -1) {
                var av = avar[i], j = 0;
                for(; j < av.length; j += 2)if (av[j] >= nv[i]) break;
                var f = (nv[i] - av[j - 2]) / (av[j] - av[j - 2]);
                nv[i] = f * av[j + 1] + (1 - f) * av[j - 1];
            }
        }
        return nv;
    }
    function interpolateDeltas(dfs, ind, xs, ys, endPts) {
        var N = xs.length, ndfs = new Array(N * 2 + 8);
        ndfs.fill(0);
        for(var i = 0; i < N; i++){
            var dx = 0, dy = 0, ii = ind.indexOf(i);
            if (ii != -1) {
                dx = dfs[ii];
                dy = dfs[ind.length + ii];
            } else {
                var cmp = 0;
                while(endPts[cmp] < i)cmp++;
                var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
                var cmp1 = endPts[cmp];
                var i0 = -1, i1 = -1;
                for(var j = 0; j < ind.length; j++){
                    var v = ind[j];
                    if (v < cmp0 || v > cmp1 || v >= N) continue;
                    i0 = j;
                    if (i1 == -1) i1 = j;
                }
                for(var j = 0; j < ind.length; j++){
                    var v = ind[j];
                    if (v < cmp0 || v > cmp1 || v >= N) continue;
                    if (v < i) i0 = j;
                    if (i < v) {
                        i1 = j;
                        break;
                    }
                }
                //var i0 = ind.length-1, i1=0;  if(ind[i0]>=N) i0--;
                //for(var j=0; j<ind.length; j++) {  var v=ind[j];  if(v<N) { if(v<i) i0=j;  if(i<v) {  i1=j;  break;  }  }  }
                for(var ax = 0; ax < 2; ax++){
                    var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
                    var c0 = crd[ind[i0]], c1 = crd[ind[i1]], cC = crd[i];
                    var d0 = dfs[ofs + i0], d1 = dfs[ofs + i1];
                    if (c0 == c1) {
                        if (d0 == d1) dlt = d0;
                        else dlt = 0;
                    } else {
                        if (cC <= Math.min(c0, c1)) {
                            if (c0 < c1) dlt = d0;
                            else dlt = d1;
                        } else if (Math.max(c0, c1) <= cC) {
                            if (c0 < c1) dlt = d1;
                            else dlt = d0;
                        } else {
                            var prop = (cC - c0) / (c1 - c0); //if(prop<0) throw "e";
                            dlt = prop * d1 + (1 - prop) * d0;
                        }
                    }
                    if (ax == 0) dx = dlt;
                    else dy = dlt;
                }
            }
            ndfs[i] = dx;
            ndfs[N + 4 + i] = dy;
        }
        return ndfs;
    }
    function _simpleGlyph(gl, font, gid, p, axs) {
        var xs = gl.xs, ys = gl.ys;
        //*
        if (font["fvar"] && axs) {
            xs = xs.slice(0);
            ys = ys.slice(0);
            var gvar = font["gvar"];
            var gv = gvar ? gvar[gid] : null;
            for(var vi = 0; vi < gv.length; vi++){
                var axv = gv[vi][0]; //console.log(axs);
                var S = _interpolate(axv, axs);
                if (S < 1e-9) continue;
                var dfs = gv[vi][1], ind = gv[vi][2]; //if(dfs.length!=2*xs.length+8) throw "e";
                //console.log(vi,S,axv,ind,dfs);
                if (ind) {
                    dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
                    gv[vi][2] = null;
                }
                //if(ind==null)
                if (dfs.length == xs.length * 2 + 8) for(var i = 0; i < xs.length; i++){
                    xs[i] += S * dfs[i];
                    ys[i] += S * dfs[i + xs.length + 4];
                }
            }
        } //*/
        for(var c = 0; c < gl.noc; c++){
            var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;
            var il = gl.endPts[c];
            for(var i = i0; i <= il; i++){
                var pr = i == i0 ? il : i - 1;
                var nx = i == il ? i0 : i + 1;
                var onCurve = gl.flags[i] & 1;
                var prOnCurve = gl.flags[pr] & 1;
                var nxOnCurve = gl.flags[nx] & 1;
                var x = xs[i], y = ys[i];
                if (i == i0) {
                    if (onCurve) {
                        if (prOnCurve) P.MoveTo(p, xs[pr], ys[pr]);
                        else {
                            P.MoveTo(p, x, y);
                            continue; /*  will do CurveTo at il  */ 
                        }
                    } else {
                        if (prOnCurve) P.MoveTo(p, xs[pr], ys[pr]);
                        else P.MoveTo(p, Math.floor((xs[pr] + x) * 0.5), Math.floor((ys[pr] + y) * 0.5));
                    }
                }
                if (onCurve) {
                    if (prOnCurve) P.LineTo(p, x, y);
                } else {
                    if (nxOnCurve) P.qCurveTo(p, x, y, xs[nx], ys[nx]);
                    else P.qCurveTo(p, x, y, Math.floor((x + xs[nx]) * 0.5), Math.floor((y + ys[nx]) * 0.5));
                }
            }
            P.ClosePath(p);
        }
    }
    function _compoGlyph(gl, font, gid, p, axs) {
        var dx = [
            0,
            0,
            0,
            0,
            0,
            0
        ], dy = [
            0,
            0,
            0,
            0,
            0,
            0
        ], ccnt = gl.parts.length;
        if (font["fvar"] && axs) {
            var gvar = font["gvar"];
            var gv = gvar ? gvar[gid] : null;
            for(var vi = 0; vi < gv.length; vi++){
                var axv = gv[vi][0]; //console.log(axs);
                var S = _interpolate(axv, axs);
                if (S < 1e-6) continue;
                var dfs = gv[vi][1], ind = gv[vi][2]; //if(dfs.length!=2*ccnt+8) throw "e";
                if (ind == null) for(var i = 0; i < ccnt; i++){
                    dx[i] += S * dfs[i];
                    dy[i] += S * dfs[i + ccnt + 4];
                }
                else for(var j = 0; j < ind.length; j++){
                    var i = ind[j];
                    dx[i] += S * dfs[0];
                    dy[i] += S * dfs[0 + ccnt];
                }
            }
        }
        for(var j = 0; j < ccnt; j++){
            var path = {
                cmds: [],
                crds: []
            };
            var prt = gl.parts[j];
            _drawGlyf(prt.glyphIndex, font, path, axs);
            var m = prt.m, tx = m.tx + dx[j], ty = m.ty + dy[j];
            for(var i = 0; i < path.crds.length; i += 2){
                var x = path.crds[i], y = path.crds[i + 1];
                p.crds.push(x * m.a + y * m.c + tx); // not sure, probably right
                p.crds.push(x * m.b + y * m.d + ty);
            }
            for(var i = 0; i < path.cmds.length; i++)p.cmds.push(path.cmds[i]);
        }
    }
    function pathToSVG(path, prec) {
        var cmds = path["cmds"], crds = path["crds"];
        if (prec == null) prec = 5;
        function num(v) {
            return parseFloat(v.toFixed(prec));
        }
        function merge(o) {
            var no = [], lstF = false, lstC = "";
            for(var i = 0; i < o.length; i++){
                var it = o[i], isF = typeof it == "number";
                if (!isF) {
                    if (it == lstC && it.length == 1 && it != "m") continue;
                    lstC = it;
                } // move should not be merged (it actually means lineTo)
                if (lstF && isF && it >= 0) no.push(" ");
                no.push(it);
                lstF = isF;
            }
            return no.join("");
        }
        var out = [], co = 0, lmap = {
            "M": 2,
            "L": 2,
            "Q": 4,
            "C": 6
        };
        var x = 0, y = 0, //dx=0, dy=0, // relative perfect coords
        //rx=0, ry=0, // relative rounded coords
        ex = 0, ey = 0, mx = 0, my = 0; // perfect coords of the last "Move"
        for(var i = 0; i < cmds.length; i++){
            var cmd = cmds[i], cc = lmap[cmd] ? lmap[cmd] : 0;
            var o0 = [], dx, dy, rx, ry; // o1=[], cx, cy, ax,ay;
            if (cmd == "L") {
                dx = crds[co] - x;
                dy = crds[co + 1] - y;
                rx = num(dx + ex);
                ry = num(dy + ey);
                // if this "lineTo" leads to the starting point, and "Z" follows, do not output anything.
                if (cmds[i + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
                    rx = dx;
                    ry = dy;
                } else if (rx == 0 && ry == 0) ;
                else if (rx == 0) o0.push("v", ry);
                else if (ry == 0) o0.push("h", rx);
                else {
                    o0.push("l", rx, ry);
                }
            } else {
                o0.push(cmd.toLowerCase());
                for(var j = 0; j < cc; j += 2){
                    dx = crds[co + j] - x;
                    dy = crds[co + j + 1] - y;
                    rx = num(dx + ex);
                    ry = num(dy + ey);
                    o0.push(rx, ry);
                }
            }
            if (cc != 0) {
                ex += dx - rx;
                ey += dy - ry;
            }
            var ou = o0;
            for(var j = 0; j < ou.length; j++)out.push(ou[j]);
            if (cc != 0) {
                co += cc;
                x = crds[co - 2];
                y = crds[co - 1];
            }
            if (cmd == "M") {
                mx = x;
                my = y;
            }
            if (cmd == "Z") {
                x = mx;
                y = my;
            }
        }
        return merge(out);
    }
    function SVGToPath(d) {
        var pth = {
            cmds: [],
            crds: []
        };
        Typr["U"]["SVG"].svgToPath(d, pth);
        return {
            "cmds": pth.cmds,
            "crds": pth.crds
        };
    }
    function mipmapB(buff, w, h, hlp) {
        var nw = w >> 1, nh = h >> 1;
        var nbuf = new Uint8Array(nw * nh * 4);
        var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
        for(var y = 0; y < nh; y++)for(var x = 0; x < nw; x++){
            var ti = y * nw + x, si = (y << 1) * w + (x << 1);
            //nbuf[ti  ] = buff[si  ];  nbuf[ti+1] = buff[si+1];  nbuf[ti+2] = buff[si+2];  nbuf[ti+3] = buff[si+3];
            //*
            var c0 = sb32[si], c1 = sb32[si + 1], c2 = sb32[si + w], c3 = sb32[si + w + 1];
            var a0 = c0 >>> 24, a1 = c1 >>> 24, a2 = c2 >>> 24, a3 = c3 >>> 24, a = a0 + a1 + a2 + a3;
            if (a == 1020) {
                var r = (c0 >>> 0 & 255) + (c1 >>> 0 & 255) + (c2 >>> 0 & 255) + (c3 >>> 0 & 255) + 2 >>> 2;
                var g = (c0 >>> 8 & 255) + (c1 >>> 8 & 255) + (c2 >>> 8 & 255) + (c3 >>> 8 & 255) + 2 >>> 2;
                var b = (c0 >>> 16 & 255) + (c1 >>> 16 & 255) + (c2 >>> 16 & 255) + (c3 >>> 16 & 255) + 2 >>> 2;
                nb32[ti] = 255 << 24 | b << 16 | g << 8 | r;
            } else if (a == 0) nb32[ti] = 0;
            else {
                var r = (c0 >>> 0 & 255) * a0 + (c1 >>> 0 & 255) * a1 + (c2 >>> 0 & 255) * a2 + (c3 >>> 0 & 255) * a3;
                var g = (c0 >>> 8 & 255) * a0 + (c1 >>> 8 & 255) * a1 + (c2 >>> 8 & 255) * a2 + (c3 >>> 8 & 255) * a3;
                var b = (c0 >>> 16 & 255) * a0 + (c1 >>> 16 & 255) * a1 + (c2 >>> 16 & 255) * a2 + (c3 >>> 16 & 255) * a3;
                var ia = 1 / a;
                r = ~~(r * ia + 0.5);
                g = ~~(g * ia + 0.5);
                b = ~~(b * ia + 0.5);
                nb32[ti] = a + 2 >>> 2 << 24 | b << 16 | g << 8 | r;
            }
        }
        return {
            buff: nbuf,
            w: nw,
            h: nh
        };
    }
    var __cnv, __ct;
    function pathToContext(path, ctx) {
        var c = 0, cmds = path["cmds"], crds = path["crds"];
        //ctx.translate(3500,500);  ctx.rotate(0.25);  ctx.scale(1,-1);
        for(var j = 0; j < cmds.length; j++){
            var cmd = cmds[j];
            if (cmd == "M") {
                ctx.moveTo(crds[c], crds[c + 1]);
                c += 2;
            } else if (cmd == "L") {
                ctx.lineTo(crds[c], crds[c + 1]);
                c += 2;
            } else if (cmd == "C") {
                ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
                c += 6;
            } else if (cmd == "Q") {
                ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
                c += 4;
            } else if (cmd[0] == "d") {
                var upng = window["UPNG"];
                var x0 = crds[c], y0 = crds[c + 1], x1 = crds[c + 2], y1 = crds[c + 3], x2 = crds[c + 4], y2 = crds[c + 5], x3 = crds[c + 6], y3 = crds[c + 7];
                c += 8;
                //y0+=400;  y1+=400;  y1+=600;
                if (upng == null) {
                    ctx.moveTo(x0, y0);
                    ctx.lineTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.lineTo(x3, y3);
                    ctx.closePath();
                    continue;
                }
                var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
                var sbmp = atob(cmd.slice(22));
                var bmp = new Uint8Array(sbmp.length);
                for(var i = 0; i < sbmp.length; i++)bmp[i] = sbmp.charCodeAt(i);
                var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"]; //console.log(img);
                var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
                var tr = ctx["getTransform"]();
                var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
                while(scl < 0.5){
                    var nd = mipmapB(nbmp, w, h);
                    nbmp = nd.buff;
                    w = nd.w;
                    h = nd.h;
                    scl *= 2;
                }
                if (__cnv == null) {
                    __cnv = document.createElement("canvas");
                    __ct = __cnv.getContext("2d");
                }
                if (__cnv.width != w || __cnv.height != h) {
                    __cnv.width = w;
                    __cnv.height = h;
                }
                __ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
                ctx.save();
                ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
                ctx.scale(1 / w, 1 / h);
                ctx.drawImage(__cnv, 0, 0); //*/
                ctx.restore();
            } else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
                ctx.beginPath();
                ctx.fillStyle = cmd;
            } else if (cmd.charAt(0) == "O" && cmd != "OX") {
                ctx.beginPath();
                var pts = cmd.split("-");
                ctx.lineWidth = parseFloat(pts[2]);
                ctx.lineCap = [
                    "butt",
                    "round",
                    "square"
                ][parseFloat(pts[3])];
                ctx.lineJoin = [
                    "miter",
                    "round",
                    "bevel"
                ][parseFloat(pts[4])];
                ctx.miterLimit = parseFloat(pts[5]);
                ctx.lineDashOffset = parseFloat(pts[6]);
                ctx.setLineDash(pts[7].split(",").map(parseFloat));
                ctx.strokeStyle = pts[1];
            } else if (cmd == "Z") {
                ctx.closePath();
            } else if (cmd == "X") {
                ctx.fill();
            } else if (cmd == "OX") {
                ctx.stroke();
            }
        }
    }
    function _drawCFF(cmds, state, font, pdct, p) {
        var stack = state.stack;
        var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
        var i = 0;
        var x = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
        var CFF = Typr["T"].CFF;
        var nominalWidthX = pdct["nominalWidthX"];
        var o = {
            val: 0,
            size: 0
        };
        //console.log(cmds);
        while(i < cmds.length){
            CFF.getCharString(cmds, i, o);
            var v = o.val;
            i += o.size;
            if (v == "o1" || v == "o18") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
            } else if (v == "o3" || v == "o23") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
            } else if (v == "o4") {
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                if (open) P.ClosePath(p);
                y += stack.pop();
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o5") {
                while(stack.length > 0){
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
            } else if (v == "o6" || v == "o7") {
                var count = stack.length;
                var isX = v == "o6";
                for(var j = 0; j < count; j++){
                    var sval = stack.shift();
                    if (isX) x += sval;
                    else y += sval;
                    isX = !isX;
                    P.LineTo(p, x, y);
                }
            } else if (v == "o8" || v == "o24") {
                var count = stack.length;
                var index = 0;
                while(index + 6 <= count){
                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                    index += 6;
                }
                if (v == "o24") {
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
            } else if (v == "o11") break;
            else if (v == "o1234" || v == "o1235" || v == "o1236" || v == "o1237") {
                if (v == "o1234") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y; // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y; // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = c2y; // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = y; // dy5
                    x = c4x + stack.shift(); // dx6
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1235") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y + stack.shift(); // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = jpy + stack.shift(); // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    x = c4x + stack.shift(); // dx6
                    y = c4y + stack.shift(); // dy6
                    stack.shift(); // flex depth
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1236") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y; // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = c2y; // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    x = c4x + stack.shift(); // dx6
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
                if (v == "o1237") {
                    c1x = x + stack.shift(); // dx1
                    c1y = y + stack.shift(); // dy1
                    c2x = c1x + stack.shift(); // dx2
                    c2y = c1y + stack.shift(); // dy2
                    jpx = c2x + stack.shift(); // dx3
                    jpy = c2y + stack.shift(); // dy3
                    c3x = jpx + stack.shift(); // dx4
                    c3y = jpy + stack.shift(); // dy4
                    c4x = c3x + stack.shift(); // dx5
                    c4y = c3y + stack.shift(); // dy5
                    if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                        x = c4x + stack.shift();
                    } else {
                        y = c4y + stack.shift();
                    }
                    P.CurveTo(p, c1x, c1y, c2x, c2y, jpx, jpy);
                    P.CurveTo(p, c3x, c3y, c4x, c4y, x, y);
                }
            } else if (v == "o14") {
                if (stack.length > 0 && stack.length != 4 && !haveWidth) {
                    width = stack.shift() + font["nominalWidthX"];
                    haveWidth = true;
                }
                if (stack.length == 4) {
                    var adx = stack.shift();
                    var ady = stack.shift();
                    var bchar = stack.shift();
                    var achar = stack.shift();
                    var bind = CFF.glyphBySE(font, bchar);
                    var aind = CFF.glyphBySE(font, achar);
                    //console.log(bchar, bind);
                    //console.log(achar, aind);
                    //state.x=x; state.y=y; state.nStems=nStems; state.haveWidth=haveWidth; state.width=width;  state.open=open;
                    _drawCFF(font["CharStrings"][bind], state, font, pdct, p);
                    state.x = adx;
                    state.y = ady;
                    _drawCFF(font["CharStrings"][aind], state, font, pdct, p);
                //x=state.x; y=state.y; nStems=state.nStems; haveWidth=state.haveWidth; width=state.width;  open=state.open;
                }
                if (open) {
                    P.ClosePath(p);
                    open = false;
                }
            } else if (v == "o19" || v == "o20") {
                var hasWidthArg;
                // The number of stem operators on the stack is always even.
                // If the value is uneven, that means a width is specified.
                hasWidthArg = stack.length % 2 !== 0;
                if (hasWidthArg && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                }
                nStems += stack.length >> 1;
                stack.length = 0;
                haveWidth = true;
                i += nStems + 7 >> 3;
            } else if (v == "o21") {
                if (stack.length > 2 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                y += stack.pop();
                x += stack.pop();
                if (open) P.ClosePath(p);
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o22") {
                if (stack.length > 1 && !haveWidth) {
                    width = stack.shift() + nominalWidthX;
                    haveWidth = true;
                }
                x += stack.pop();
                if (open) P.ClosePath(p);
                P.MoveTo(p, x, y);
                open = true;
            } else if (v == "o25") {
                while(stack.length > 6){
                    x += stack.shift();
                    y += stack.shift();
                    P.LineTo(p, x, y);
                }
                c1x = x + stack.shift();
                c1y = y + stack.shift();
                c2x = c1x + stack.shift();
                c2y = c1y + stack.shift();
                x = c2x + stack.shift();
                y = c2y + stack.shift();
                P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
            } else if (v == "o26") {
                if (stack.length % 2) {
                    x += stack.shift();
                }
                while(stack.length > 0){
                    c1x = x;
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x;
                    y = c2y + stack.shift();
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                }
            } else if (v == "o27") {
                if (stack.length % 2) {
                    y += stack.shift();
                }
                while(stack.length > 0){
                    c1x = x + stack.shift();
                    c1y = y;
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y;
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                }
            } else if (v == "o10" || v == "o29") {
                var obj = v == "o10" ? pdct : font;
                if (stack.length == 0) {
                    console.log("error: empty stack");
                } else {
                    var ind = stack.pop();
                    var subr = obj["Subrs"][ind + obj["Bias"]];
                    state.x = x;
                    state.y = y;
                    state.nStems = nStems;
                    state.haveWidth = haveWidth;
                    state.width = width;
                    state.open = open;
                    _drawCFF(subr, state, font, pdct, p);
                    x = state.x;
                    y = state.y;
                    nStems = state.nStems;
                    haveWidth = state.haveWidth;
                    width = state.width;
                    open = state.open;
                }
            } else if (v == "o30" || v == "o31") {
                var count, count1 = stack.length;
                var index = 0;
                var alternate = v == "o31";
                count = count1 & -3;
                index += count1 - count;
                while(index < count){
                    if (alternate) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        if (count - index == 5) {
                            x = c2x + stack.shift();
                            index++;
                        } else x = c2x;
                        alternate = false;
                    } else {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        if (count - index == 5) {
                            y = c2y + stack.shift();
                            index++;
                        } else y = c2y;
                        alternate = true;
                    }
                    P.CurveTo(p, c1x, c1y, c2x, c2y, x, y);
                    index += 4;
                }
            } else if ((v + "").charAt(0) == "o") {
                console.log("Unknown operation: " + v, cmds);
                throw v;
            } else stack.push(v);
        }
        //console.log(cmds);
        state.x = x;
        state.y = y;
        state.nStems = nStems;
        state.haveWidth = haveWidth;
        state.width = width;
        state.open = open;
    }
    function initHB(hurl, resp) {
        var codeLength = function(code) {
            var len = 0;
            if ((code & 0xffffffff - (1 << 7) + 1) == 0) {
                len = 1;
            } else if ((code & 0xffffffff - (1 << 11) + 1) == 0) {
                len = 2;
            } else if ((code & 0xffffffff - (1 << 16) + 1) == 0) {
                len = 3;
            } else if ((code & 0xffffffff - (1 << 21) + 1) == 0) {
                len = 4;
            }
            return len;
        };
        fetch(hurl).then(function(x) {
            return x["arrayBuffer"]();
        }).then(function(ab) {
            return WebAssembly["instantiate"](ab);
        }).then(function(res) {
            console.log("HB ready");
            var exp = res["instance"]["exports"], mem = exp["memory"];
            //mem["grow"](30); // each page is 64kb in size
            var heapu8, u32, i32, f32;
            var __lastFnt, blob, blobPtr, face, font;
            Typr["U"]["shapeHB"] = function() {
                var toJson = function(ptr) {
                    var length = exp["hb_buffer_get_length"](ptr);
                    var result = [];
                    var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
                    var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
                    for(var i = 0; i < length; ++i){
                        var a = iPtr32 + i * 5, b = pPtr32 + i * 5;
                        result.push({
                            "g": u32[a + 0],
                            "cl": u32[a + 2],
                            "ax": i32[b + 0],
                            "ay": i32[b + 1],
                            "dx": i32[b + 2],
                            "dy": i32[b + 3]
                        });
                    }
                    //console.log(result);
                    return result;
                };
                var te;
                return function(fnt, str, prm) {
                    var fdata = fnt["_data"], fn = fnt["name"]["postScriptName"];
                    var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
                    if (fnt["fvar"] && axs == null) axs = fnt["fvar"][1][fnt["_index"]][2];
                    //var olen = mem.buffer.byteLength, nlen = 2*fdata.length+str.length*16 + 4e6;
                    //if(olen<nlen) mem["grow"](((nlen-olen)>>>16)+4);  //console.log("growing",nlen);
                    heapu8 = new Uint8Array(mem.buffer);
                    u32 = new Uint32Array(mem.buffer);
                    i32 = new Int32Array(mem.buffer);
                    f32 = new Float32Array(mem.buffer);
                    if (__lastFnt != fn) {
                        if (blob != null) {
                            exp["hb_blob_destroy"](blob);
                            exp["free"](blobPtr);
                            exp["hb_face_destroy"](face);
                            exp["hb_font_destroy"](font);
                        }
                        blobPtr = exp["malloc"](fdata.byteLength);
                        heapu8.set(fdata, blobPtr);
                        blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
                        face = exp["hb_face_create"](blob, fnt["_index"]);
                        font = exp["hb_font_create"](face);
                        __lastFnt = fn;
                    }
                    if (window["TextEncoder"] == null) {
                        alert("Your browser is too old. Please, update it.");
                        return;
                    }
                    if (te == null) te = new window["TextEncoder"]("utf8");
                    var buffer = exp["hb_buffer_create"]();
                    var bytes = te["encode"](str);
                    var len = bytes.length, strp = exp["malloc"](len);
                    heapu8.set(bytes, strp);
                    exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
                    exp["free"](strp);
                    var bin = Typr["B"];
                    var feat = 0;
                    if (fts) {
                        feat = exp["malloc"](16 * fts.length);
                        for(var i = 0; i < fts.length; i++){
                            var fe = fts[i];
                            var off = feat + i * 16, qo = off >>> 2;
                            bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
                            u32[qo + 1] = fe[1];
                            u32[qo + 2] = fe[2];
                            u32[qo + 3] = fe[3];
                        }
                    //console.log(fts);
                    }
                    var vdat = 0;
                    if (axs && fnt["fvar"]) {
                        var axes = fnt["fvar"][0]; //console.log(axes, axs);
                        vdat = exp["malloc"](8 * axs.length);
                        for(var i = 0; i < axs.length; i++){
                            var off = vdat + i * 8, qo = off >>> 2;
                            bin.writeASCII(heapu8, off, axes[i][0].split("").reverse().join(""));
                            f32[qo + 1] = axs[i];
                        }
                    }
                    //*/
                    if (axs) exp["hb_font_set_variations"](font, vdat, axs.length);
                    exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
                    exp["hb_buffer_guess_segment_properties"](buffer);
                    exp["hb_shape"](font, buffer, feat, fts ? fts.length : 0);
                    var json = toJson(buffer); //buffer["json"]();
                    exp["hb_buffer_destroy"](buffer);
                    if (fts) exp["free"](feat);
                    if (axs) exp["free"](vdat);
                    var arr = json.slice(0);
                    if (!ltr) arr.reverse();
                    var ci = 0, bi = 0; // character index, binary index
                    for(var i = 1; i < arr.length; i++){
                        var gl = arr[i], cl = gl["cl"];
                        while(true){
                            var cpt = str.codePointAt(ci), cln = codeLength(cpt);
                            if (bi + cln <= cl) {
                                bi += cln;
                                ci += cpt <= 0xffff ? 1 : 2;
                            } else break;
                        }
                        //while(bi+codeLength(str.charCodeAt(ci)) <=cl) {  bi+=codeLength(str.charCodeAt(ci));  ci++;  }
                        gl["cl"] = ci;
                    }
                    return json;
                };
            }();
            resp();
        });
    }
    return {
        "shape": shape,
        "shapeToPath": shapeToPath,
        "codeToGlyph": codeToGlyph,
        "glyphToPath": glyphToPath,
        "pathToSVG": pathToSVG,
        "SVGToPath": SVGToPath,
        "pathToContext": pathToContext,
        "initHB": initHB
    };
}();
;
}),
"[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Font",
    ()=>Font,
    "_sanitizeFontName",
    ()=>sanitizeFontName,
    "arrayCommandsToObjects",
    ()=>arrayCommandsToObjects,
    "default",
    ()=>font
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Typography
 */ const pathArgCounts = {
    M: 2,
    L: 2,
    C: 6,
    Q: 4
};
const validFontTypes = [
    'ttf',
    'otf',
    'woff'
]; //, 'woff2'];
const validFontTypesRe = new RegExp(`\\.(${validFontTypes.join('|')})`, 'i');
const extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join('|')}))`, 'i');
const invalidFontError = 'Sorry, only TTF, OTF and WOFF files are supported.'; // and WOFF2
const fontFaceVariations = [
    'weight',
    'stretch',
    'style'
];
class Font {
    constructor(p, fontFace, name, path, data){
        if (!(fontFace instanceof FontFace)) {
            throw Error('FontFace is required');
        }
        this._pInst = p;
        this.name = name;
        this.path = path;
        this.data = data;
        this.face = fontFace;
    }
    /**
   * Checks whether a font has glyph point data and
   * can thus be used for textToPoints(), WEBGL mode, etc.
   * @private
   */ static hasGlyphData(textFont) {
        let { font } = textFont;
        return typeof font === 'object' && typeof font.data !== 'undefined';
    }
    fontBounds(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        if (!renderer) throw Error('p5 or graphics required for fontBounds()');
        return renderer.fontBounds(str, x, y, width, height);
    }
    textBounds(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        if (!renderer) throw Error('p5 or graphics required for fontBounds()');
        return renderer.textBounds(str, x, y, width, height);
    }
    /**
   * Returns a flat array of path commands that describe the outlines of a string of text.
   *
   * Each command is represented as an array of the form `[type, ...coords]`, where:
   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,
   * - `coords` are the numeric values needed for that command.
   *
   * `'M'` indicates a "move to" (starting a new contour),
   * `'L'` a line segment,
   * `'Q'` a quadratic bezier,
   * `'C'` a cubic bezier, and
   * `'Z'` closes the current path.
   *
   * The first two parameters, `x` and `y`, specify the baseline origin for the text.
   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need
   * wrapping, you can omit them and directly pass `options` as the fourth parameter.
   *
   * @param  {String} str            The text to convert into path commands.
   * @param  {Number} x              x‚Äêcoordinate of the text baseline.
   * @param  {Number} y              y‚Äêcoordinate of the text baseline.
   * @param  {Number} [width]        Optional width for text wrapping.
   * @param  {Number} [height]       Optional height for text wrapping.
   * @return {Array<Array>}          A flat array of path commands.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(200, 200);
   *   background(220);
   *   noLoop();
   * }
   *
   * function draw() {
   *   background(220);
   *   stroke(0);
   *   noFill();
   *   textSize(60);
   *
   *   // Get path commands for "Hello" (drawn at baseline x=50, y=100):
   *   const pathCommands = font.textToPaths('Hello', 30, 110);
   *
   *   beginShape();
   *   for (let i = 0; i < pathCommands.length; i++) {
   *     const cmd = pathCommands[i];
   *     const type = cmd[0];
   *
   *     switch (type) {
   *       case 'M': {
   *         // Move to (start a new contour)
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         endContour(); // In case we were already drawing
   *         beginContour();
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'L': {
   *         // Line to
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'Q': {
   *         // Quadratic bezier
   *         const cx = cmd[1];
   *         const cy = cmd[2];
   *         const x = cmd[3];
   *         const y = cmd[4];
   *         bezierOrder(2);
   *         bezierVertex(cx, cy);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'C': {
   *         // Cubic bezier
   *         const cx1 = cmd[1];
   *         const cy1 = cmd[2];
   *         const cx2 = cmd[3];
   *         const cy2 = cmd[4];
   *         const x = cmd[5];
   *         const y = cmd[6];
   *         bezierOrder(3);
   *         bezierVertex(cx1, cy1);
   *         bezierVertex(cx2, cy2);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'Z': {
   *         // Close path
   *         endContour(CLOSE);
   *         beginContour();
   *         break;
   *       }
   *     }
   *   }
   *   endContour();
   *   endShape();
   * }
   * </code>
   * </div>
   */ textToPaths(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        if (!this.data) {
            throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
        }
        // lineate and get glyphs/paths for each line
        let lines = this._lineateAndPathify(str, x, y, width, height, options);
        // flatten into a single array containing all the glyphs
        let glyphs = lines.map((o)=>o.glyphs).flat();
        // flatten into a single array with all the path commands
        return glyphs.map((g)=>g.path.commands).flat();
    }
    /**
   * Returns an array of points outlining a string of text written using the
   * font.
   *
   * Each point object in the array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle in radians to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  Configuration:
   * @param  {Number} [options.sampleFactor=0.1] The ratio of the text's path length to the number of samples.
   * @param  {Number} [options.simplifyThreshold=0] A minmum angle in radian sbetween two segments. Segments with a shallower angle will be merged.
   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   background(200);
   *   textSize(35);
   *
   *   // Get the point array.
   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });
   *
   *   // Draw a dot at each point.
   *   for (let p of points) {
   *     point(p.x, p.y);
   *   }
   *
   *   describe('A set of black dots outlining the text "p5*js" on a gray background.');
   * }
   * </code>
   * </div>
   */ textToPoints(str, x, y, width, height, options) {
        // By segmenting per contour, pointAtLength becomes much faster
        const contourPoints = this.textToContours(str, x, y, width, height, options);
        return contourPoints.reduce((acc, next)=>{
            acc.push(...next);
            return acc;
        }, []);
    }
    /**
   * Returns an array of arrays of points outlining a string of text written using the
   * font. Each array represents a contour, so the letter O will have two outer arrays:
   * one for the outer edge of the shape, and one for the inner edge of the hole.
   *
   * Each point object in a contour array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle in radians to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  Configuration options:
   * @param  {Number} [options.sampleFactor=0.1] The ratio of the text's path length to the number of samples.
   * @param  {Number} [options.simplifyThreshold=0] A minmum angle in radians between two segments. Segments with a shallower angle will be merged.
   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('/assets/inconsolata.otf');
   * }
   *
   * function draw() {
   *   background(200);
   *   textAlign(CENTER, CENTER);
   *   textSize(30);
   *
   *   // Get the point array.
   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });
   *
   *   beginShape();
   *   for (const pts of contours) {
   *     beginContour();
   *     for (const pt of pts) {
   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);
   *     }
   *     endContour(CLOSE);
   *   }
   *   endShape();
   *
   *   describe('The text p5*js wobbling over time');
   * }
   * </code>
   * </div>
   */ textToContours(str, x = 0, y = 0, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        const cmds = this.textToPaths(str, x, y, width, height, options);
        const cmdContours = [];
        for (const cmd of cmds){
            if (cmd[0] === 'M') {
                cmdContours.push([]);
            }
            cmdContours[cmdContours.length - 1].push(cmd);
        }
        return cmdContours.map((commands)=>pathToPoints(commands, options, this));
    }
    /**
   *
   * Converts text into a 3D model that can be rendered in WebGL mode.
   *
   * This method transforms flat text into extruded 3D geometry, allowing
   * for dynamic effects like depth, warping, and custom shading.
   *
   * It works by taking the outlines (contours) of each character in the
   * provided text string and constructing a 3D shape from them.
   *
   * Once your 3D text is ready, you can rotate it in 3D space using <a href="#/p5/orbitControl">orbitControl()</a>
   * ‚Äî just click and drag with your mouse to see it from all angles!
   *
   * Use the extrude slider to give your letters depth: slide it up, and your
   * flat text turns into a solid, multi-dimensional object.
   *
   * You can also choose from various fonts such as "Anton", "Montserrat", or "Source Serif",
   * much like selecting fancy fonts in a word processor,
   *
   * The generated model (a Geometry object) can be manipulated further‚Äîrotated, scaled,
   * or styled with shaders‚Äîto create engaging, interactive visual art.
   *
   * @param {String} str The text string to convert into a 3D model.
   * @param {Number} x The x-coordinate for the starting position of the text.
   * @param {Number} y The y-coordinate for the starting position of the text.
   * @param {Number} width Maximum width of the text block (wraps text if exceeded).
   * @param {Number} height Maximum height of the text block.
   * @param {Object} [options] Configuration options for the 3D text:
   * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces
   * flat text; higher values create thicker, 3D models.
   * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.
   *  Higher values result in smoother curves.
   * @return {p5.Geometry} A geometry object representing the 3D model of the text.
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   * let geom;
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
   *
   *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2 });
   *   geom.clearColors();
   *   geom.normalize();
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   fill("red");
   *   strokeWeight(4);
   *   scale(min(width, height) / 300);
   *   model(geom);
   *   describe('A red non-extruded "Hello" in Anton on white canvas, rotatable via mouse.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let font;
   * let geom;
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *
   *   // Alternative fonts:
   *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
   *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
   *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
   *
   *   // Using Source Serif for this example:
   *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');
   *
   *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2, extrude: 5 });
   *   geom.clearColors();
   *   geom.normalize();
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   fill("red");
   *   strokeWeight(4);
   *   scale(min(width, height) / 300);
   *   model(geom);
   *   describe('3D red extruded "Hello" in Source Serif on white, rotatable via mouse.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div modernizr='webgl'>
   * <code>
   * let geom;
   * let activeFont;
   * let artShader;
   * let lineShader;
   *
   * // Define parameters as simple variables
   * let words = 'HELLO';
   * let warp = 1;
   * let extrude = 5;
   * let palette = ["#ffe03d", "#fe4830", "#d33033", "#6d358a", "#1c509e", "#00953c"];
   *
   * async function setup() {
   *   createCanvas(200, 200, WEBGL);
   *
   *   // Using Anton as the default font for this example:
   *
   *  // Alternative fonts:
   *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
   *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
   *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
   *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
   *
   *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });
   *   geom.clearColors();
   *   geom.normalize();
   *
   *   artShader = baseMaterialShader().modify({
   *     uniforms: {
   *       'float time': () => millis(),
   *       'float warp': () => warp,
   *       'float numColors': () => palette.length,
   *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),
   *     },
   *     vertexDeclarations: 'out vec3 vPos;',
   *     fragmentDeclarations: 'in vec3 vPos;',
   *     'Vertex getObjectInputs': `(Vertex inputs) {
   *       vPos = inputs.position;
   *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
   *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
   *       return inputs;
   *     }`,
   *     'vec4 getFinalColor': `(vec4 _c) {
   *       float x = vPos.x * 0.005;
   *       float a = floor(fract(x) * numColors);
   *       float b = a == numColors - 1. ? 0. : a + 1.;
   *       float t = fract(x * numColors);
   *       vec3 c = mix(colors[int(a)], colors[int(b)], t);
   *       return vec4(c, 1.);
   *     }`
   *   });
   *
   *   lineShader = baseStrokeShader().modify({
   *     uniforms: {
   *       'float time': () => millis(),
   *       'float warp': () => warp,
   *     },
   *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {
   *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
   *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
   *       return inputs;
   *     }`,
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   orbitControl();
   *   shader(artShader);
   *   strokeShader(lineShader);
   *   strokeWeight(4);
   *   scale(min(width, height) / 210);
   *   model(geom);
   *   describe('3D wavy with different color sets "Hello" in Anton on white canvas, rotatable via mouse.');
   * }
   * </code>
   * </div>
   */ textToModel(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        const extrude = options?.extrude || 0;
        let contours = this.textToContours(str, x, y, width, height, options);
        // Step 2: build base flat geometry - single shape
        const geom = this._pInst.buildGeometry(()=>{
            const prevValidateFaces = this._pInst._renderer._validateFaces;
            this._pInst._renderer._validateFaces = true;
            this._pInst.beginShape();
            for (const contour of contours){
                this._pInst.beginContour();
                for (const pt of contour){
                    this._pInst.vertex(pt.x, pt.y, 0);
                }
                this._pInst.endContour(this._pInst.CLOSE);
            }
            this._pInst.endShape(this._pInst.CLOSE);
            this._pInst._renderer._validateFaces = prevValidateFaces;
        });
        if (extrude === 0) {
            return geom;
        }
        // The tessellation process creates separate vertices for each triangle,
        // even when they share the same position. We need to deduplicate them
        // to find which faces are actually connected, so we can identify the
        // outer edges for extrusion.
        const vertexIndices = {};
        const vertexId = (v)=>`${v.x.toFixed(6)}-${v.y.toFixed(6)}-${v.z.toFixed(6)}`;
        const newVertices = [];
        const newVertexIndex = [];
        for (const v of geom.vertices){
            const id = vertexId(v);
            if (!(id in vertexIndices)) {
                const index = newVertices.length;
                vertexIndices[id] = index;
                newVertices.push(v.copy());
            }
            newVertexIndex.push(vertexIndices[id]);
        }
        // Remap faces to use deduplicated vertices
        const newFaces = geom.faces.map((f)=>f.map((i)=>newVertexIndex[i]));
        //Find outer edges (edges that appear in only one face)
        const seen = {};
        for (const face of newFaces){
            for(let off = 0; off < face.length; off++){
                const a = face[off];
                const b = face[(off + 1) % face.length];
                const id = `${Math.min(a, b)}-${Math.max(a, b)}`;
                if (!seen[id]) seen[id] = [];
                seen[id].push([
                    a,
                    b
                ]);
            }
        }
        const validEdges = [];
        for(const key in seen){
            if (seen[key].length === 1) {
                validEdges.push(seen[key][0]);
            }
        }
        // Step 5: Create extruded geometry
        const extruded = this._pInst.buildGeometry(()=>{});
        const half = extrude * 0.5;
        extruded.vertices = [];
        extruded.faces = [];
        extruded.edges = []; // INITIALIZE EDGES ARRAY
        // Add side face vertices (separate for each edge for flat shading)
        for (const [a, b] of validEdges){
            const vA = newVertices[a];
            const vB = newVertices[b];
            // Skip if vertices are too close (degenerate edge)
            // We only need to check the perimeter edge length since the other edge
            // is the extrude direction, which is always > 0 for extruded geometry
            const edgeVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](vB.x - vA.x, vB.y - vA.y, vB.z - vA.z);
            const extrudeVector = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](0, 0, extrude);
            const crossProduct = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].cross(edgeVector, extrudeVector);
            const dist = edgeVector.mag();
            if (crossProduct.mag() < 0.0001 || dist < 0.0001) continue;
            // Front face vertices
            const frontA = extruded.vertices.length;
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](vA.x, vA.y, vA.z + half));
            const frontB = extruded.vertices.length;
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](vB.x, vB.y, vB.z + half));
            const backA = extruded.vertices.length;
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](vA.x, vA.y, vA.z - half));
            const backB = extruded.vertices.length;
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](vB.x, vB.y, vB.z - half));
            extruded.faces.push([
                frontA,
                backA,
                backB
            ]);
            extruded.faces.push([
                frontA,
                backB,
                frontB
            ]);
            extruded.edges.push([
                frontA,
                frontB
            ]);
            extruded.edges.push([
                backA,
                backB
            ]);
            extruded.edges.push([
                frontA,
                backA
            ]);
            extruded.edges.push([
                frontB,
                backB
            ]);
        }
        // Add front face (with unshared vertices for flat shading)
        const frontVertexOffset = extruded.vertices.length;
        for (const v of newVertices){
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](v.x, v.y, v.z + half));
        }
        for (const face of newFaces){
            if (face.length < 3) continue;
            const mappedFace = face.map((i)=>i + frontVertexOffset);
            extruded.faces.push(mappedFace);
            // ADD EDGES FOR FRONT FACE
            for(let i = 0; i < mappedFace.length; i++){
                const nextIndex = (i + 1) % mappedFace.length;
                extruded.edges.push([
                    mappedFace[i],
                    mappedFace[nextIndex]
                ]);
            }
        }
        // Add back face (reversed winding order)
        const backVertexOffset = extruded.vertices.length;
        for (const v of newVertices){
            extruded.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](v.x, v.y, v.z - half));
        }
        for (const face of newFaces){
            if (face.length < 3) continue;
            const mappedFace = [
                ...face
            ].reverse().map((i)=>i + backVertexOffset);
            extruded.faces.push(mappedFace);
            // ADD EDGES FOR BACK FACE
            for(let i = 0; i < mappedFace.length; i++){
                const nextIndex = (i + 1) % mappedFace.length;
                extruded.edges.push([
                    mappedFace[i],
                    mappedFace[nextIndex]
                ]);
            }
        }
        extruded.computeNormals();
        return extruded;
    }
    variations() {
        let vars = {};
        if (this.data) {
            let axes = this.face?.axes;
            if (axes) {
                axes.forEach((ax)=>{
                    vars[ax.tag] = ax.value;
                });
            }
        }
        fontFaceVariations.forEach((v)=>{
            let val = this.face[v];
            if (val !== 'normal') {
                vars[v] = vars[v] || val;
            }
        });
        return vars;
    }
    metadata() {
        let meta = this.data?.name || {};
        for(let p in this.face){
            if (!/^load/.test(p)) {
                meta[p] = meta[p] || this.face[p];
            }
        }
        return meta;
    }
    static async list(log = false) {
        if (log) {
            console.log('There are', document.fonts.size, 'font-faces\n');
            let loaded = 0;
            for (let fontFace of document.fonts.values()){
                console.log('FontFace: {');
                for(let property in fontFace){
                    console.log('  ' + property + ': ' + fontFace[property]);
                }
                console.log('}\n');
                if (fontFace.status === 'loaded') {
                    loaded++;
                }
            }
            console.log(loaded + ' loaded');
        }
        return await Array.from(document.fonts);
    }
    /////////////////////////////// HELPERS ////////////////////////////////
    /*
    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }
  */ _lineateAndPathify(str, x, y, width, height, options = {}) {
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        renderer.push();
        renderer.textFont(this);
        // lineate and compute bounds for the text
        let { lines, bounds } = renderer._computeBounds(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["textCoreConstants"]._FONT_BOUNDS, str, x, y, width, height, {
            ignoreRectMode: true,
            ...options
        });
        // compute positions for each of the lines
        lines = this._position(renderer, lines, bounds, width, height);
        // convert lines to paths
        let uPE = this.data?.head?.unitsPerEm || 1000;
        let scale = renderer.states.textSize / uPE;
        const axs = this._currentAxes(renderer);
        let pathsForLine = lines.map((l)=>this._lineToGlyphs(l, {
                scale,
                axs
            }));
        renderer.pop();
        return pathsForLine;
    }
    _currentAxes(renderer) {
        let axs;
        if ((this.data?.fvar?.length ?? 0) > 0) {
            const fontAxes = this.data.fvar[0];
            axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name])=>{
                if (!renderer) return defaultVal;
                if (tag === 'wght') {
                    return renderer.states.fontWeight;
                } else if (tag === 'wdth') {
                    // TODO: map from keywords (normal, ultra-condensed, etc) to values
                    // return renderer.states.fontStretch
                    return 100;
                } else if (renderer.textCanvas().style.fontVariationSettings) {
                    const match = new RegExp(`\\b${tag}\s+(\d+)`).exec(renderer.textCanvas().style.fontVariationSettings);
                    if (match) {
                        return parseInt(match[1]);
                    } else {
                        return defaultVal;
                    }
                } else {
                    return defaultVal;
                }
            });
        }
        return axs;
    }
    _textToPathPoints(str, x, y, width, height, options) {
        ({ width, height, options } = this._parseArgs(width, height, options));
        // lineate and get the points for each line
        let cmds = this.textToPaths(str, x, y, width, height, options);
        // divide line-segments with intermediate points
        const subdivide = (pts, pt1, pt2, md)=>{
            if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
                let middle = {
                    x: (pt1.x + pt2.x) / 2,
                    y: (pt1.y + pt2.y) / 2
                };
                pts.push(middle);
                subdivide(pts, pt1, middle, md);
                subdivide(pts, middle, pt2, md);
            }
        };
        // a point for each path-command plus line subdivisions
        let pts = [];
        let { textSize } = this._pInst._renderer.states;
        let maxDist = textSize / this.data.head.unitsPerEm * 500;
        for(let i = 0; i < cmds.length; i++){
            let { type, data: d } = cmds[i];
            if (type !== 'Z') {
                let pt = {
                    x: d[d.length - 2],
                    y: d[d.length - 1]
                };
                if (type === 'L' && pts.length && !options?.nodivide > 0) {
                    subdivide(pts, pts[pts.length - 1], pt, maxDist);
                }
                pts.push(pt);
            }
        }
        return pts;
    }
    _parseArgs(width, height, options = {}) {
        if (typeof width === 'object') {
            options = width;
            width = height = undefined;
        } else if (typeof height === 'object') {
            options = height;
            height = undefined;
        }
        return {
            width,
            height,
            options
        };
    }
    _position(renderer, lines, bounds, width, height) {
        let { textAlign, textLeading, textSize } = renderer.states;
        let metrics = this._measureTextDefault(renderer, 'X');
        let ascent = metrics.fontBoundingBoxAscent;
        let coordify = (text, i)=>{
            let x = bounds.x;
            let y = bounds.y + i * textLeading + ascent;
            let lineWidth = renderer._fontWidthSingle(text);
            if (textAlign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]) {
                x += (bounds.w - lineWidth) / 2;
            } else if (textAlign === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"]) {
                x += bounds.w - lineWidth;
            }
            if (typeof width !== 'undefined') {
                switch(renderer.states.rectMode){
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]:
                        x -= width / 2;
                        y -= height / 2;
                        break;
                    case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"]:
                        x -= width;
                        y -= height;
                        break;
                }
            }
            return {
                text,
                x,
                y
            };
        };
        return lines.map(coordify);
    }
    _lineToGlyphs(line, { scale = 1, axs } = {}) {
        if (!this.data) {
            throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
        }
        let glyphShapes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.shape(this.data, line.text, {
            axs
        });
        line.glyphShapes = glyphShapes;
        line.glyphs = this._shapeToPaths(glyphShapes, line, {
            scale,
            axs
        });
        return line;
    }
    _positionGlyphs(text, options) {
        let renderer = options?.graphics?._renderer || this._pInst._renderer;
        const axs = this._currentAxes(renderer);
        const glyphShapes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.shape(this.data, text, {
            axs
        });
        const positionedGlyphs = [];
        let x = 0;
        for (const glyph of glyphShapes){
            positionedGlyphs.push({
                x,
                index: glyph.g,
                shape: glyph
            });
            x += glyph.ax;
        }
        return positionedGlyphs;
    }
    _singleShapeToPath(shape, { scale = 1, x = 0, y = 0, lineX = 0, lineY = 0, axs } = {}) {
        let font = this.data;
        let crdIdx = 0;
        let { g, ax, ay, dx, dy } = shape;
        let { crds, cmds } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].U.glyphToPath(font, g, true, axs);
        // can get simple points for each glyph here, but we don't need them ?
        let glyph = {
            path: {
                commands: []
            }
        };
        for(let j = 0; j < cmds.length; j++){
            let type = cmds[j], command = [
                type
            ];
            if (type in pathArgCounts) {
                let argCount = pathArgCounts[type];
                for(let k = 0; k < argCount; k += 2){
                    let gx = crds[k + crdIdx] + x + dx;
                    let gy = crds[k + crdIdx + 1] + y + dy;
                    let fx = lineX + gx * scale;
                    let fy = lineY + gy * -scale;
                    command.push(fx);
                    command.push(fy);
                /*if (k === argCount - 2) {
            glyph.points.push({ x: fx, y: fy });
          }*/ }
                crdIdx += argCount;
            }
            glyph.path.commands.push(command);
        }
        return {
            glyph,
            ax,
            ay
        };
    }
    _shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {
        let x = 0, y = 0, paths = [];
        if (glyphs.length !== line.text.length) {
            throw Error('Invalid shape data');
        }
        // iterate over the glyphs, converting each to a glyph object
        // with a path property containing an array of commands
        for(let i = 0; i < glyphs.length; i++){
            const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i], {
                scale,
                x,
                y,
                lineX: line.x,
                lineY: line.y,
                axs
            });
            paths.push(glyph);
            x += ax;
            y += ay;
        }
        return paths;
    }
    _measureTextDefault(renderer, str) {
        let { textAlign, textBaseline } = renderer.states;
        let ctx = renderer.textDrawingContext();
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        let metrics = ctx.measureText(str);
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        return metrics;
    }
    drawPaths(ctx, commands, opts) {
        ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;
        ctx.fillStyle = opts?.fill || ctx.fillStyle;
        ctx.beginPath();
        commands.forEach(([type, ...data])=>{
            if (type === 'M') {
                ctx.moveTo(...data);
            } else if (type === 'L') {
                ctx.lineTo(...data);
            } else if (type === 'C') {
                ctx.bezierCurveTo(...data);
            } else if (type === 'Q') {
                ctx.quadraticCurveTo(...data);
            } else if (type === 'Z') {
                ctx.closePath();
            }
        });
        if (opts?.fill) ctx.fill();
        if (opts?.stroke) ctx.stroke();
    }
    _pathsToCommands(paths, scale) {
        let commands = [];
        for(let i = 0; i < paths.length; i++){
            let pathData = paths[i];
            let { x, y, path } = pathData;
            let { crds, cmds } = path;
            // iterate over the path, storing each non-control point
            for(let c = 0, j = 0; j < cmds.length; j++){
                let cmd = cmds[j], obj = {
                    type: cmd,
                    data: []
                };
                if (cmd === 'M' || cmd === 'L') {
                    obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);
                    c += 2;
                } else if (cmd === 'C') {
                    for(let i = 0; i < 6; i += 2){
                        obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);
                    }
                    c += 6;
                } else if (cmd === 'Q') {
                    for(let i = 0; i < 4; i += 2){
                        obj.data.push(x + crds[c + i] * scale, y + crds[c + i + 1] * -scale);
                    }
                    c += 4;
                }
                commands.push(obj);
            }
        }
        return commands;
    }
}
async function create(pInst, name, path, descriptors, rawFont) {
    let face = createFontFace(name, path, descriptors, rawFont);
    // load if we need to
    if (face.status !== 'loaded') await face.load();
    // add it to the document
    document.fonts.add(face);
    // ensure the font is ready to be rendered
    await document.fonts.ready;
    // return a new p5.Font
    return new Font(pInst, face, name, path, rawFont);
}
function sanitizeFontName(name) {
    if (!/^[A-Za-z][A-Za-z0-9_-]*$/.test(name)) {
        name = "'" + String(name).replace(/'/g, "\\'") + "'";
    }
    return name;
}
function createFontFace(name, path, descriptors, rawFont) {
    name = sanitizeFontName(name);
    let fontArg = rawFont?._compressedData ?? rawFont?._data;
    if (!fontArg) {
        if (!validFontTypesRe.test(path)) {
            throw Error(invalidFontError);
        }
        if (!path.startsWith('url(')) {
            path = 'url(' + path + ')';
        }
        fontArg = path;
    }
    if ((rawFont?.fvar?.length ?? 0) > 0) {
        descriptors = descriptors || {};
        for (const [tag, minVal, defaultVal, maxVal, flags, name] of rawFont.fvar[0]){
            if (tag === 'wght') {
                descriptors.weight = `${minVal} ${maxVal}`;
            } else if (tag === 'wdth') {
                descriptors.stretch = `${minVal}% ${maxVal}%`;
            }
        // TODO add other descriptors
        }
    }
    // create/return the FontFace object
    let face = new FontFace(name, fontArg, descriptors);
    if (face.status === 'error') {
        throw Error('Failed to create FontFace for "' + name + '"');
    }
    return face;
}
function extractFontName(font, path) {
    let result, meta = font?.name;
    // use the metadata if we have it
    if (meta) {
        if (meta.fullName) {
            return meta.fullName;
        }
        if (meta.familyName) {
            result = meta.familyName;
        }
    }
    if (!result) {
        // if not, try to extract the name from the path
        let matches = extractFontNameRe.exec(path);
        if (matches && matches.length >= 3) {
            result = matches[1];
        } else {
            // give up and return the full path
            result = path;
        }
    }
    // replace spaces with underscores
    if (result.includes(' ')) {
        result = result.replace(/ /g, '_');
    }
    return result;
}
function pathToPoints(cmds, options, font) {
    const parseOpts = (options, defaults)=>{
        if (typeof options !== 'object') {
            options = defaults;
        } else {
            for(const key in defaults){
                if (typeof options[key] === 'undefined') {
                    options[key] = defaults[key];
                }
            }
        }
        return options;
    };
    const at = (v, i)=>{
        const s = v.length;
        return v[i < 0 ? i % s + s : i % s];
    };
    const simplify = (pts, angle)=>{
        angle = angle || 0;
        let num = 0;
        for(let i = pts.length - 1; pts.length > 3 && i >= 0; --i){
            if (collinear(at(pts, i - 1), at(pts, i), at(pts, i + 1), angle)) {
                pts.splice(i % pts.length, 1); // Remove middle point
                num++;
            }
        }
        return num;
    };
    const collinear = (a, b, c, thresholdAngle)=>{
        if (!thresholdAngle) {
            return areaTriangle(a, b, c) === 0;
        }
        if (typeof collinear.tmpPoint1 === 'undefined') {
            collinear.tmpPoint1 = [];
            collinear.tmpPoint2 = [];
        }
        const ab = collinear.tmpPoint1, bc = collinear.tmpPoint2;
        ab.x = b.x - a.x;
        ab.y = b.y - a.y;
        bc.x = c.x - b.x;
        bc.y = c.y - b.y;
        const dot = ab.x * bc.x + ab.y * bc.y, magA = Math.sqrt(ab.x * ab.x + ab.y * ab.y), magB = Math.sqrt(bc.x * bc.x + bc.y * bc.y), angle = Math.acos(dot / (magA * magB));
        return angle < thresholdAngle;
    };
    const areaTriangle = (a, b, c)=>{
        return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
    };
    const path = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createFromCommands"])(arrayCommandsToObjects(cmds));
    let opts = parseOpts(options, {
        sampleFactor: 0.1,
        simplifyThreshold: 0
    });
    const totalPoints = Math.max(1, Math.ceil(path.getTotalLength() * opts.sampleFactor));
    let points = [];
    const mode = font._pInst.angleMode();
    const DEGREES = font._pInst.DEGREES;
    for(let i = 0; i < totalPoints; i++){
        const length = path.getTotalLength() * (totalPoints === 1 ? 0 : i / (totalPoints - 1));
        points.push({
            ...path.getPointAtLength(length),
            get angle () {
                const angle = path.getAngleAtLength(length);
                if (mode === DEGREES) {
                    return angle * 180 / Math.PI;
                } else {
                    return angle;
                }
            },
            // For backwards compatibility
            get alpha () {
                return this.angle;
            }
        });
    }
    if (opts.simplifyThreshold) {
        simplify(points, opts.simplifyThreshold);
    }
    return points;
}
function unquote(name) {
    // Unquote name from CSS
    if ((name.startsWith('"') || name.startsWith("'")) && name.at(0) === name.at(-1)) {
        return name.slice(1, -1).replace(/\/(['"])/g, '$1');
    }
    return name;
}
function parseCreateArgs(...args /*path, name, onSuccess, onError*/ ) {
    // parse the path
    let path = args.shift();
    if (typeof path !== 'string' || path.length === 0) {
        p5._friendlyError(invalidFontError, 'p5.loadFont'); // ?
    }
    // parse the name
    let name;
    if (typeof args[0] === 'string') {
        name = args.shift();
    }
    // get the callbacks/descriptors if any
    let success, error, options;
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (typeof arg === 'function') {
            if (!success) {
                success = arg;
            } else {
                error = arg;
            }
        } else if (typeof arg === 'object') {
            options = arg;
        }
    }
    return {
        path,
        name,
        success,
        error,
        options
    };
}
function font(p51, fn1) {
    /**
   * A class to describe fonts. Create through <a href="#/p5/loadFont">`loadFont()`</a>.
   *
   * @class p5.Font
   */ p51.Font = Font;
    /**
   * @private
   */ fn1.parseFontData = async function(pathOrData) {
        // load the raw font bytes
        let result = pathOrData instanceof Uint8Array ? pathOrData : await fn1.loadBytes(pathOrData);
        //console.log('result:', result);
        if (!result) {
            throw Error('Failed to load font data');
        }
        // parse the font data
        let fonts = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].parse(result);
        // TODO: generate descriptors from font in the future
        if (fonts.length === 0 || fonts[0].cmap === undefined) {
            throw Error('parsing font data');
        }
        return fonts[0];
    };
    /**
   * Loads a font and creates a <a href="#/p5.Font">p5.Font</a> object.
   * `loadFont()` can load fonts in either .otf or .ttf format. Loaded fonts can
   * be used to style text on the canvas and in HTML elements.
   *
   * The first parameter, `path`, is the path to a font file.
   * Paths to local files should be relative. For example,
   * `'assets/inconsolata.otf'`. The Inconsolata font used in the following
   * examples can be downloaded for free
   * <a href="https://www.fontsquirrel.com/fonts/inconsolata" target="_blank">here</a>.
   * Paths to remote files should be URLs. For example,
   * `'https://example.com/inconsolata.otf'`. URLs may be blocked due to browser
   * security.
   *
   * In 2D mode, `path` can take on a few other forms. It could be a path to a CSS file,
   * such as one from <a href="https://fonts.google.com/">Google Fonts.</a> It could also
   * be a string with a <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face">CSS `@font-face` declaration.</a>
   *
   * The second parameter, `successCallback`, is optional. If a function is
   * passed, it will be called once the font has loaded. The callback function
   * may use the new <a href="#/p5.Font">p5.Font</a> object if needed.
   *
   * The third parameter, `failureCallback`, is also optional. If a function is
   * passed, it will be called if the font fails to load. The callback function
   * may use the error
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
   * object if needed.
   *
   * Fonts can take time to load. `await` the result of `loadFont()` in
   * <a href="#/p5/setup">setup()</a> before using the result.
   *
   * @method loadFont
   * @for p5
   * @param  {String}        path       path of the font or CSS file to be loaded, or a CSS `@font-face` string.
   * @param  {String}        [name]            An alias that can be used for this font in `textFont()`. Defaults to the name in the font's metadata.
   * @param  {Object}        [options]         An optional object with extra CSS font face descriptors, or p5.js font settings.
   * @param  {String|Array<String>} [options.sets] (Experimental) An optional string of list of strings with Unicode character set names that should be included. When a CSS file is used as the font, it may contain multiple font files. The font best matching the requested character sets will be picked.
   * @param  {Function}      [successCallback] function called with the
   *                                           <a href="#/p5.Font">p5.Font</a> object after it
   *                                           loads.
   * @param  {Function}      [failureCallback] function called with the error
   *                                           <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
   *                                           object if the font fails to load.
   * @return {Promise<p5.Font>}                         <a href="#/p5.Font">p5.Font</a> object.
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *   fill('deeppink');
   *   textFont(font);
   *   textSize(36);
   *   text('p5*js', 10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   loadFont('assets/inconsolata.otf', font => {
   *     fill('deeppink');
   *     textFont(font);
   *     textSize(36);
   *     text('p5*js', 10, 50);
   *
   *     describe('The text "p5*js" written in pink on a white background.');
   *   });
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   loadFont('assets/inconsolata.otf', success, failure);
   * }
   *
   * function success(font) {
   *   fill('deeppink');
   *   textFont(font);
   *   textSize(36);
   *   text('p5*js', 10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   *
   * function failure(event) {
   *   console.error('Oops!', event);
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * async function setup() {
   *   createCanvas(100, 100);
   *   await loadFont('assets/inconsolata.otf');
   *   let p = createP('p5*js');
   *   p.style('color', 'deeppink');
   *   p.style('font-family', 'Inconsolata');
   *   p.style('font-size', '36px');
   *   p.position(10, 50);
   *
   *   describe('The text "p5*js" written in pink on a white background.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div class="norender">
   * <code>
   * // Some other forms of loading fonts:
   * loadFont("https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap");
   *
   * loadFont('@font-face { font-family: "Bricolage Grotesque", serif; font-optical-sizing: auto; font-weight: 400; font-style: normal; font-variation-settings: "wdth" 100; }');
   * </code>
   * </div>
   */ /**
   * @method loadFont
   * @for p5
   * @param  {String}        path              path of the font to be loaded.
   * @param  {Function}      [successCallback] function called with the
   *                                           <a href="#/p5.Font">p5.Font</a> object after it
   *                                           loads.
   * @param  {Function}      [failureCallback] function called with the error
   *                                           <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank">Event</a>
   *                                           object if the font fails to load.
   * @returns {Promise<p5.Font>} The font.
   */ fn1.loadFont = async function(...args) {
        /*path, name, onSuccess, onError, descriptors*/ let { path, name, success, error, options: { sets, ...descriptors } = {} } = parseCreateArgs(...args);
        let isCSS = path.includes('@font-face');
        if (!isCSS) {
            let info;
            try {
                info = await fetch(path, {
                    method: 'HEAD'
                });
            } catch (e) {
                // Sometimes files fail when requested with HEAD. Fallback to a
                // regular GET. It loads more data, but at least then it's cached
                // for the likely case when we have to fetch the whole thing.
                info = await fetch(path);
            }
            const isCSSFile = info.headers.get('content-type')?.startsWith('text/css');
            if (isCSSFile) {
                isCSS = true;
                path = await fetch(path).then((res)=>res.text());
            }
        }
        if (isCSS) {
            const stylesheet = new CSSStyleSheet();
            await stylesheet.replace(path);
            const possibleFonts = [];
            for (const rule of stylesheet.cssRules){
                if (rule instanceof CSSFontFaceRule) {
                    const style = rule.style;
                    let name = unquote(style.getPropertyValue('font-family'));
                    const src = style.getPropertyValue('src');
                    const fontDescriptors = {
                        ...descriptors || {}
                    };
                    for (const key of style){
                        if (key === 'font-family' || key === 'src') continue;
                        const camelCaseKey = key.replace(/^font-/, '').split('-').map((v, i)=>i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join('');
                        fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
                    }
                    possibleFonts.push({
                        name,
                        src,
                        fontDescriptors,
                        loadWithData: async ()=>{
                            let fontData;
                            try {
                                const urlMatch = /url\(([^\)]+)\)/.exec(src);
                                if (urlMatch) {
                                    let url = urlMatch[1];
                                    if (/^['"]/.exec(url) && url.at(0) === url.at(-1)) {
                                        url = url.slice(1, -1);
                                    }
                                    fontData = await fn1.parseFontData(url);
                                }
                            } catch (_e) {}
                            return create(this, name, src, fontDescriptors, fontData);
                        },
                        loadWithoutData: ()=>create(this, name, src, fontDescriptors)
                    });
                }
            }
            // TODO: handle multiple font faces?
            sets = sets || [
                'latin'
            ]; // Default to latin for now if omitted
            const requestedGroups = (sets instanceof Array ? sets : [
                sets
            ]).map((s)=>s.toLowerCase());
            // Grab thr named groups with names that include the requested keywords
            const requestedCategories = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unicodeRanges"].filter((r)=>requestedGroups.some((g)=>r.category.includes(g) && // Only include extended character sets if specifically requested
                    r.category.includes('ext') === g.includes('ext')));
            const requestedRanges = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnicodeRange"].parse(requestedCategories.map((c)=>`U+${c.hexrange[0]}-${c.hexrange[1]}`)));
            let closestRangeOverlap = 0;
            let closestDescriptorOverlap = 0;
            let closestMatch = undefined;
            for (const font of possibleFonts){
                if (!font.fontDescriptors.unicodeRange) continue;
                const fontRange = new Set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnicodeRange"].parse(font.fontDescriptors.unicodeRange.split(/,\s*/g)));
                const rangeOverlap = [
                    ...fontRange.values()
                ].filter((v)=>requestedRanges.has(v)).length;
                const targetDescriptors = {
                    // Default to normal style at regular weight
                    style: 'normal',
                    weight: 400,
                    // Override from anything else passed in
                    ...descriptors
                };
                const descriptorOverlap = Object.keys(font.fontDescriptors).filter((k)=>font.fontDescriptors[k] === targetDescriptors[k]).length;
                if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
                    closestDescriptorOverlap = descriptorOverlap;
                    closestRangeOverlap = rangeOverlap;
                    closestMatch = font;
                }
            }
            const picked = closestMatch || possibleFonts.at(-1);
            for (const font of possibleFonts){
                if (font !== picked) {
                    // Load without parsing data with Typr so that it still can be accessed
                    // via regular CSS by name
                    font.loadWithoutData();
                }
            }
            return picked?.loadWithData();
        }
        let pfont;
        try {
            const fontData = await fn1.parseFontData(path);
            // make sure we have a valid name
            name = name || extractFontName(fontData, path);
            // create a FontFace object and pass it to the p5.Font constructor
            pfont = await create(this, name, path, descriptors, fontData);
        } catch (err) {
            // failed to parse the font, load it as a simple FontFace
            let ident = name || path.substring(path.lastIndexOf('/') + 1).replace(/\.[^/.]+$/, '');
            console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
            try {
                // create a FontFace object and pass it to p5.Font
                pfont = await create(this, ident, path, descriptors);
            } catch (err) {
                if (error) return error(err);
                throw err;
            }
        }
        if (success) return success(pfont);
        return pfont;
    };
}
// Convert arrays to named objects
const arrayCommandsToObjects = (commands)=>commands.map((command)=>{
        const type = command[0];
        switch(type){
            case 'Z':
                {
                    return {
                        type
                    };
                }
            case 'M':
            case 'L':
                {
                    const [, x, y] = command;
                    return {
                        type,
                        x,
                        y
                    };
                }
            case 'Q':
                {
                    const [, x1, y1, x, y] = command;
                    return {
                        type,
                        x1,
                        y1,
                        x,
                        y
                    };
                }
            case 'C':
                {
                    const [, x1, y1, x2, y2, x, y] = command;
                    return {
                        type,
                        x1,
                        y1,
                        x2,
                        y2,
                        x,
                        y
                    };
                }
            default:
                {
                    throw new Error(`Unexpected path command: ${type}`);
                }
        }
    });
if (typeof p5 !== 'undefined') {
    font(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/type/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>type
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function type(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
];

//# sourceMappingURL=node_modules_p5_dist_type_c9f0f25c._.js.map