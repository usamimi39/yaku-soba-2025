module.exports = [
"[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Anchor",
    ()=>Anchor,
    "BezierSegment",
    ()=>BezierSegment,
    "Contour",
    ()=>Contour,
    "Line",
    ()=>Line,
    "LineSegment",
    ()=>LineSegment,
    "Point",
    ()=>Point,
    "PointAtLengthGetter",
    ()=>PointAtLengthGetter,
    "PrimitiveToPath2DConverter",
    ()=>PrimitiveToPath2DConverter,
    "PrimitiveToVerticesConverter",
    ()=>PrimitiveToVerticesConverter,
    "PrimitiveVisitor",
    ()=>PrimitiveVisitor,
    "Quad",
    ()=>Quad,
    "QuadStrip",
    ()=>QuadStrip,
    "Segment",
    ()=>Segment,
    "Shape",
    ()=>Shape,
    "ShapePrimitive",
    ()=>ShapePrimitive,
    "SplineSegment",
    ()=>SplineSegment,
    "Triangle",
    ()=>Triangle,
    "TriangleFan",
    ()=>TriangleFan,
    "TriangleStrip",
    ()=>TriangleStrip,
    "Vertex",
    ()=>Vertex,
    "default",
    ()=>customShapes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
;
;
;
;
;
/**
 * @module Shape
 * @submodule Custom Shapes
 * @for p5
 * @requires core
 * @requires constants
 */ // ---- UTILITY FUNCTIONS ----
function polylineLength(vertices) {
    let length = 0;
    for(let i = 1; i < vertices.length; i++){
        length += vertices[i - 1].position.dist(vertices[i].position);
    }
    return length;
}
// ---- GENERAL BUILDING BLOCKS ----
class Vertex {
    constructor(properties){
        for (const [key, value] of Object.entries(properties)){
            this[key] = value;
        }
    }
}
class ShapePrimitive {
    vertices;
    _shape = null;
    _primitivesIndex = null;
    _contoursIndex = null;
    isClosing = false;
    constructor(...vertices){
        if (this.constructor === ShapePrimitive) {
            throw new Error('ShapePrimitive is an abstract class: it cannot be instantiated.');
        }
        if (vertices.length > 0) {
            this.vertices = vertices;
        } else {
            throw new Error('At least one vertex must be passed to the constructor.');
        }
    }
    get vertexCount() {
        return this.vertices.length;
    }
    get vertexCapacity() {
        throw new Error('Getter vertexCapacity must be implemented.');
    }
    get _firstInterpolatedVertex() {
        return this.startVertex();
    }
    get canOverrideAnchor() {
        return false;
    }
    accept(visitor) {
        throw new Error('Method accept() must be implemented.');
    }
    addToShape(shape) {
        /*
    TODO:
    Refactor?
    Test this method once more primitives are implemented.
    Test segments separately (Segment adds an extra step to this method).
    */ let lastContour = shape.at(-1);
        if (lastContour.primitives.length === 0) {
            lastContour.primitives.push(this);
        } else {
            // last primitive in shape
            let lastPrimitive = shape.at(-1, -1);
            let hasSameType = lastPrimitive instanceof this.constructor;
            let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;
            // this primitive
            let pushableVertices;
            let remainingVertices;
            if (hasSameType && spareCapacity > 0) {
                pushableVertices = this.vertices.splice(0, spareCapacity);
                remainingVertices = this.vertices;
                lastPrimitive.vertices.push(...pushableVertices);
                if (remainingVertices.length > 0) {
                    lastContour.primitives.push(this);
                }
            } else {
                lastContour.primitives.push(this);
            }
        }
        // if primitive itself was added
        // (i.e. its individual vertices weren't all added to an existing primitive)
        // give it a reference to the shape and store its location within the shape
        let addedToShape = this.vertices.length > 0;
        if (addedToShape) {
            let lastContour = shape.at(-1);
            this._primitivesIndex = lastContour.primitives.length - 1;
            this._contoursIndex = shape.contours.length - 1;
            this._shape = shape;
        }
        return shape.at(-1, -1);
    }
    get _nextPrimitive() {
        return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;
    }
    get _belongsToShape() {
        return this._shape !== null;
    }
    handlesClose() {
        return false;
    }
    close(vertex) {
        throw new Error('Unimplemented!');
    }
}
class Contour {
    #kind;
    primitives;
    constructor(kind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]){
        this.#kind = kind;
        this.primitives = [];
    }
    get kind() {
        const isEmpty = this.primitives.length === 0;
        const isPath = this.#kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"];
        return isEmpty && isPath ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["E"] : this.#kind;
    }
    accept(visitor) {
        for (const primitive of this.primitives){
            primitive.accept(visitor);
        }
    }
}
// ---- PATH PRIMITIVES ----
class Anchor extends ShapePrimitive {
    #vertexCapacity = 1;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitAnchor(this);
    }
    getEndVertex() {
        return this.vertices[0];
    }
}
// abstract class
class Segment extends ShapePrimitive {
    constructor(...vertices){
        super(...vertices);
        if (this.constructor === Segment) {
            throw new Error('Segment is an abstract class: it cannot be instantiated.');
        }
    }
    // segments in a shape always have a predecessor
    // (either an anchor or another segment)
    get _previousPrimitive() {
        return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;
    }
    getStartVertex() {
        return this._previousPrimitive.getEndVertex();
    }
    getEndVertex() {
        return this.vertices.at(-1);
    }
}
class LineSegment extends Segment {
    #vertexCapacity = 1;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitLineSegment(this);
    }
}
class BezierSegment extends Segment {
    #order;
    #vertexCapacity;
    constructor(order, ...vertices){
        super(...vertices);
        // Order m may sometimes be passed as an array [m], since arrays
        // may be used elsewhere to store order of
        // Bezier curves and surfaces in a common format
        let numericalOrder = Array.isArray(order) ? order[0] : order;
        this.#order = numericalOrder;
        this.#vertexCapacity = numericalOrder;
    }
    get order() {
        return this.#order;
    }
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    #_hullLength;
    hullLength() {
        if (this.#_hullLength === undefined) {
            this.#_hullLength = polylineLength([
                this.getStartVertex(),
                ...this.vertices
            ]);
        }
        return this.#_hullLength;
    }
    accept(visitor) {
        visitor.visitBezierSegment(this);
    }
}
/*
To-do: Consider type and end modes -- see #6766
may want to use separate classes, but maybe not

For now, the implementation overrides
super.getEndVertex() in order to preserve current p5
endpoint behavior, but we're considering defaulting
to interpolated endpoints (a breaking change)
*/ class SplineSegment extends Segment {
    #vertexCapacity = Infinity;
    _splineProperties = {
        ends: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"],
        tightness: 0
    };
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitSplineSegment(this);
    }
    get _comesAfterSegment() {
        return this._previousPrimitive instanceof Segment;
    }
    get canOverrideAnchor() {
        return this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"];
    }
    // assuming for now that the first interpolated vertex is always
    // the second vertex passed to splineVertex()
    // if this spline segment doesn't follow another segment,
    // the first vertex is in an anchor
    get _firstInterpolatedVertex() {
        if (this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"]) {
            return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];
        } else {
            return this.getStartVertex();
        }
    }
    get _chainedToSegment() {
        if (this._belongsToShape && this._comesAfterSegment) {
            let interpolatedStartPosition = this._firstInterpolatedVertex.position;
            let predecessorEndPosition = this.getStartVertex().position;
            return predecessorEndPosition.equals(interpolatedStartPosition);
        } else {
            return false;
        }
    }
    // extend addToShape() with a warning in case second vertex
    // doesn't line up with end of last segment
    addToShape(shape) {
        const added = super.addToShape(shape);
        this._splineProperties.ends = shape._splineProperties.ends;
        this._splineProperties.tightness = shape._splineProperties.tightness;
        if (this._splineProperties.ends !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"]) return added;
        let verticesPushed = !this._belongsToShape;
        let lastPrimitive = shape.at(-1, -1);
        let message = (array1, array2)=>`Spline does not start where previous path segment ends:
      second spline vertex at (${array1})
      expected to be at (${array2}).`;
        if (verticesPushed && // Only check once the first interpolated vertex has been added
        lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {
            let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;
            let predecessorEnd = lastPrimitive.getStartVertex().position;
            console.warn(message(interpolatedStart.array(), predecessorEnd.array()));
        }
        // Note: Could add a warning in an else-if case for when this spline segment
        // is added directly to the shape instead of pushing its vertices to
        // an existing spline segment. However, if we assume addToShape() is called by
        // splineVertex(), it'd add a new spline segment with only one vertex in that case,
        // and the check wouldn't be needed yet.
        // TODO: Consider case where positions match but other vertex properties don't.
        return added;
    }
    // override method on base class
    getEndVertex() {
        if (this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"]) {
            return super.getEndVertex();
        } else if (this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"]) {
            return this.vertices.at(-2);
        } else {
            return this.getStartVertex();
        }
    }
    getControlPoints() {
        let points = [];
        if (this._comesAfterSegment) {
            points.push(this.getStartVertex());
        }
        points.push(this.getStartVertex());
        for (const vertex of this.vertices){
            points.push(vertex);
        }
        const prevVertex = this.getStartVertex();
        if (this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"]) {
            points.unshift(prevVertex);
            points.push(this.vertices.at(-1));
        } else if (this._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["J"]) {
            points.unshift(this.vertices.at(-1));
            points.push(prevVertex, this.vertices.at(0));
        }
        return points;
    }
    handlesClose() {
        if (!this._belongsToShape) return false;
        // Only handle closing if the spline is the only thing in its contour after
        // the anchor
        const contour = this._shape.at(this._contoursIndex);
        return contour.primitives.length === 2 && this._primitivesIndex === 1;
    }
    close() {
        this._splineProperties.ends = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["J"];
    }
}
// ---- ISOLATED PRIMITIVES ----
class Point extends ShapePrimitive {
    #vertexCapacity = 1;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitPoint(this);
    }
}
class Line extends ShapePrimitive {
    #vertexCapacity = 2;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitLine(this);
    }
}
class Triangle extends ShapePrimitive {
    #vertexCapacity = 3;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitTriangle(this);
    }
}
class Quad extends ShapePrimitive {
    #vertexCapacity = 4;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitQuad(this);
    }
}
// ---- TESSELLATION PRIMITIVES ----
class TriangleFan extends ShapePrimitive {
    #vertexCapacity = Infinity;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitTriangleFan(this);
    }
}
class TriangleStrip extends ShapePrimitive {
    #vertexCapacity = Infinity;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitTriangleStrip(this);
    }
}
class QuadStrip extends ShapePrimitive {
    #vertexCapacity = Infinity;
    get vertexCapacity() {
        return this.#vertexCapacity;
    }
    accept(visitor) {
        visitor.visitQuadStrip(this);
    }
}
// ---- PRIMITIVE SHAPE CREATORS ----
class PrimitiveShapeCreators {
    // TODO: make creators private?
    // That'd probably be better, but for now, it may be convenient to use
    // native Map properties like size, e.g. for testing, and it's simpler to
    // not have to wrap all the properties that might be useful
    creators;
    constructor(){
        let creators = new Map();
        /* TODO: REFACTOR BASED ON THE CODE BELOW,
       ONCE CONSTANTS ARE IMPLEMENTED AS SYMBOLS

    // Store Symbols as strings for use in Map keys
    const EMPTY_PATH = constants.EMPTY_PATH.description;
    const PATH = constants.PATH.description;
    //etc.

    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    // etc.

    get(vertexKind, shapeKind) {
      const key = `${vertexKind}-${shapeKind.description}`;
      return this.creators.get(key);
    }
    // etc.
    */ // vertex
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["E"]}`, (...vertices)=>new Anchor(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]}`, (...vertices)=>new LineSegment(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["o"]}`, (...vertices)=>new Point(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["L"]}`, (...vertices)=>new Line(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]}`, (...vertices)=>new Triangle(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Q"]}`, (...vertices)=>new Quad(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"]}`, (...vertices)=>new TriangleFan(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]}`, (...vertices)=>new TriangleStrip(...vertices));
        creators.set(`vertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]}`, (...vertices)=>new QuadStrip(...vertices));
        // bezierVertex (constructors all take order and vertices so they can be called in a uniform way)
        creators.set(`bezierVertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["E"]}`, (order, ...vertices)=>new Anchor(...vertices));
        creators.set(`bezierVertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]}`, (order, ...vertices)=>new BezierSegment(order, ...vertices));
        // splineVertex
        creators.set(`splineVertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["E"]}`, (...vertices)=>new Anchor(...vertices));
        creators.set(`splineVertex-${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]}`, (...vertices)=>new SplineSegment(...vertices));
        this.creators = creators;
    }
    get(vertexKind, shapeKind) {
        const key = `${vertexKind}-${shapeKind}`;
        return this.creators.get(key);
    }
    set(vertexKind, shapeKind, creator) {
        const key = `${vertexKind}-${shapeKind}`;
        this.creators.set(key, creator);
    }
    clear() {
        this.creators.clear();
    }
}
// ---- SHAPE ----
/* Note: It's assumed that Shape instances are always built through
 * their beginShape()/endShape() methods. For example, this ensures
 * that a segment is never the first primitive in a contour (paths
 * always start with an anchor), which simplifies code elsewhere.
 */ class Shape {
    #vertexProperties;
    #initialVertexProperties;
    #primitiveShapeCreators;
    #bezierOrder = 3;
    kind = null;
    contours = [];
    _splineProperties = {
        tightness: 0,
        ends: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["I"]
    };
    userVertexProperties = null;
    constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators()){
        this.#initialVertexProperties = vertexProperties;
        this.#vertexProperties = vertexProperties;
        this.#primitiveShapeCreators = primitiveShapeCreators;
        for(const key in this.#vertexProperties){
            if (key !== 'position' && key !== 'textureCoordinates') {
                this[key] = function(value) {
                    this.#vertexProperties[key] = value;
                };
            }
        }
    }
    serializeToArray(val) {
        if (val === null || val === undefined) {
            return [];
        }
        if (val instanceof Number) {
            return [
                val
            ];
        } else if (val instanceof Array) {
            return val;
        } else if (val.array instanceof Function) {
            return val.array();
        } else {
            throw new Error(`Can't convert ${val} to array!`);
        }
    }
    vertexToArray(vertex) {
        const array = [];
        for(const key in this.#vertexProperties){
            if (this.userVertexProperties && key in this.userVertexProperties) continue;
            const val = vertex[key];
            array.push(...this.serializeToArray(val));
        }
        for(const key in this.userVertexProperties){
            if (key in vertex) {
                array.push(...this.serializeToArray(vertex[key]));
            } else {
                array.push(...new Array(this.userVertexProperties[key]).fill(0));
            }
        }
        return array;
    }
    hydrateValue(queue, original) {
        if (original === null) {
            return null;
        } else if (original instanceof Number) {
            return queue.shift();
        } else if (original instanceof Array) {
            const array = [];
            for(let i = 0; i < original.length; i++){
                array.push(queue.shift());
            }
            return array;
        } else if (original instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"]) {
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](queue.shift(), queue.shift(), queue.shift());
        } else if (original instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]) {
            // NOTE: Not sure what intention here is, `Color` constructor signature
            // has changed so needed to be reviewed
            const array = [
                queue.shift(),
                queue.shift(),
                queue.shift(),
                queue.shift()
            ];
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"](array);
        }
    }
    arrayToVertex(array) {
        const vertex = {};
        const queue = [
            ...array
        ];
        for(const key in this.#vertexProperties){
            if (this.userVertexProperties && key in this.userVertexProperties) continue;
            const original = this.#vertexProperties[key];
            vertex[key] = this.hydrateValue(queue, original);
        }
        for(const key in this.userVertexProperties){
            const original = this.#vertexProperties[key];
            vertex[key] = this.hydrateValue(queue, original);
        }
        return vertex;
    }
    arrayScale(array, scale) {
        return array.map((v)=>v * scale);
    }
    arraySum(first, ...rest) {
        return first.map((v, i)=>{
            let result = v;
            for(let j = 0; j < rest.length; j++){
                result += rest[j][i];
            }
            return result;
        });
    }
    arrayMinus(a, b) {
        return a.map((v, i)=>v - b[i]);
    }
    evaluateCubicBezier([a, b, c, d], t) {
        return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 3)), this.arrayScale(b, 3 * Math.pow(1 - t, 2) * t), this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)), this.arrayScale(d, Math.pow(t, 3)));
    }
    evaluateQuadraticBezier([a, b, c], t) {
        return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 2)), this.arrayScale(b, 2 * (1 - t) * t), this.arrayScale(c, t * t));
    }
    /*
  catmullRomToBezier(vertices, tightness)

  Abbreviated description:
  Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.

  Parameters:
  vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices
  tightness -> Number affecting shape of curve

  Returns:
  array of Bezier curveTo control points, each represented as [c1, c2, c3][]

  TODO:
  1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:

  catmullRomToBezier() is based on code in the legacy endShape() function:
  https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1

  A different conversion can be found elsewhere in p5:
  https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179

  A more careful review and comparison of both implementations would be helpful. They're different. I put
  catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept
  for the refactor.

  2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.
  */ catmullRomToBezier(vertices, tightness) {
        let s = 1 - tightness;
        let bezArrays = [];
        for(let i = 0; i + 3 < vertices.length; i++){
            const [a, b, c, d] = vertices.slice(i, i + 4);
            const bezB = this.arraySum(b, this.arrayScale(this.arrayMinus(c, a), s / 6));
            const bezC = this.arraySum(c, this.arrayScale(this.arrayMinus(b, d), s / 6));
            const bezD = c;
            bezArrays.push([
                bezB,
                bezC,
                bezD
            ]);
        }
        return bezArrays;
    }
    // TODO for at() method:
    // RENAME?
    // -at() indicates it works like Array.prototype.at(), e.g. with negative indices
    // -get() may work better if we want to add a corresponding set() method
    // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)
    // -renaming or removing would necessitate changes at call sites (it's already in use)
    // REFACTOR?
    // TEST
    at(contoursIndex, primitivesIndex, verticesIndex) {
        let contour;
        let primitive;
        contour = this.contours.at(contoursIndex);
        switch(arguments.length){
            case 1:
                return contour;
            case 2:
                return contour.primitives.at(primitivesIndex);
            case 3:
                primitive = contour.primitives.at(primitivesIndex);
                return primitive.vertices.at(verticesIndex);
        }
    }
    // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?
    // note: p5.Geometry has a reset() method, but also clearColors()
    // looks like reset() isn't in the public reference, so maybe we can switch
    // everything to clear()? Not sure if reset/clear is used in other classes,
    // but it'd be good if geometries and shapes are consistent
    reset() {
        this.#vertexProperties = {
            ...this.#initialVertexProperties
        };
        this.kind = null;
        this.contours = [];
        this.userVertexProperties = null;
    }
    vertexProperty(name, data) {
        this.userVertexProperties = this.userVertexProperties || {};
        const key = this.vertexPropertyKey(name);
        const dataArray = Array.isArray(data) ? data : [
            data
        ];
        if (!this.userVertexProperties[key]) {
            this.userVertexProperties[key] = dataArray.length;
        }
        this.#vertexProperties[key] = dataArray;
    }
    vertexPropertyName(key) {
        return key.replace(/Src$/, '');
    }
    vertexPropertyKey(name) {
        return name + 'Src';
    }
    bezierOrder(...order) {
        this.#bezierOrder = order;
    }
    splineProperty(key, value) {
        this._splineProperties[key] = value;
    }
    splineProperties(values) {
        if (values) {
            for(const key in values){
                this.splineProperty(key, values[key]);
            }
        } else {
            return this._splineProperties;
        }
    }
    /*
  To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised
  in the method name?
  */ #createVertex(position, textureCoordinates) {
        this.#vertexProperties.position = position;
        if (textureCoordinates !== undefined) {
            this.#vertexProperties.textureCoordinates = textureCoordinates;
        }
        return new Vertex(this.#vertexProperties);
    }
    #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {
        let primitiveShapeCreator = this.#primitiveShapeCreators.get(vertexKind, shapeKind);
        return vertexKind === 'bezierVertex' ? primitiveShapeCreator(this.#bezierOrder, ...vertices) : primitiveShapeCreator(...vertices);
    }
    /*
    #generalVertex() is reused by the special vertex functions,
    including vertex(), bezierVertex(), splineVertex(), and arcVertex():

    It creates a vertex, builds a primitive including that
    vertex, and has the primitive add itself to the shape.
  */ #generalVertex(kind, position, textureCoordinates) {
        let vertexKind = kind;
        let lastContourKind = this.at(-1).kind;
        let vertex = this.#createVertex(position, textureCoordinates);
        let primitiveShape = this.#createPrimitiveShape(vertexKind, lastContourKind, vertex);
        return primitiveShape.addToShape(this);
    }
    vertex(position, textureCoordinates, { isClosing = false } = {}) {
        const added = this.#generalVertex('vertex', position, textureCoordinates);
        added.isClosing = isClosing;
    }
    bezierVertex(position, textureCoordinates) {
        this.#generalVertex('bezierVertex', position, textureCoordinates);
    }
    splineVertex(position, textureCoordinates) {
        this.#generalVertex('splineVertex', position, textureCoordinates);
    }
    arcVertex(position, textureCoordinates) {
        this.#generalVertex('arcVertex', position, textureCoordinates);
    }
    beginContour(shapeKind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]) {
        if (this.at(-1)?.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["E"]) {
            this.contours.pop();
        }
        this.contours.push(new Contour(shapeKind));
    }
    endContour(closeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["O"], _index = this.contours.length - 1) {
        const contour = this.at(_index);
        if (closeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"]) {
            // shape characteristics
            const isPath = contour.kind === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"];
            // anchor characteristics
            const anchorVertex = this.at(_index, 0, 0);
            const anchorHasPosition = Object.hasOwn(anchorVertex, 'position');
            const lastSegment = this.at(_index, -1);
            // close path
            if (isPath && anchorHasPosition) {
                if (lastSegment.handlesClose()) {
                    lastSegment.close(anchorVertex);
                } else {
                    // Temporarily remove contours after the current one so that we add to the original
                    // contour again
                    const rest = this.contours.splice(_index + 1, this.contours.length - _index - 1);
                    const prevVertexProperties = this.#vertexProperties;
                    this.#vertexProperties = {
                        ...prevVertexProperties
                    };
                    for(const key in anchorVertex){
                        if ([
                            'position',
                            'textureCoordinates'
                        ].includes(key)) continue;
                        this.#vertexProperties[key] = anchorVertex[key];
                    }
                    this.vertex(anchorVertex.position, anchorVertex.textureCoordinates, {
                        isClosing: true
                    });
                    this.#vertexProperties = prevVertexProperties;
                    this.contours.push(...rest);
                }
            }
        }
    }
    beginShape(shapeKind = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]) {
        this.kind = shapeKind;
        // Implicitly start a contour
        this.beginContour(shapeKind);
    }
    /* TO-DO:
     Refactor?
     - Might not need anchorHasPosition.
     - Might combine conditions at top, and rely on shortcircuiting.
     Does nothing if shape is not a path or has multiple contours. Might discuss this.
  */ endShape(closeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["O"]) {
        if (closeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["n"]) {
            // Close the first contour, the one implicitly used for shape data
            // added without an explicit contour
            this.endContour(closeMode, 0);
        }
    }
    accept(visitor) {
        for (const contour of this.contours){
            contour.accept(visitor);
        }
    }
}
// ---- PRIMITIVE VISITORS ----
// abstract class
class PrimitiveVisitor {
    constructor(){
        if (this.constructor === PrimitiveVisitor) {
            throw new Error('PrimitiveVisitor is an abstract class: it cannot be instantiated.');
        }
    }
    // path primitives
    visitAnchor(anchor) {
        throw new Error('Method visitAnchor() has not been implemented.');
    }
    visitLineSegment(lineSegment) {
        throw new Error('Method visitLineSegment() has not been implemented.');
    }
    visitBezierSegment(bezierSegment) {
        throw new Error('Method visitBezierSegment() has not been implemented.');
    }
    visitSplineSegment(curveSegment) {
        throw new Error('Method visitSplineSegment() has not been implemented.');
    }
    visitArcSegment(arcSegment) {
        throw new Error('Method visitArcSegment() has not been implemented.');
    }
    // isolated primitives
    visitPoint(point) {
        throw new Error('Method visitPoint() has not been implemented.');
    }
    visitLine(line) {
        throw new Error('Method visitLine() has not been implemented.');
    }
    visitTriangle(triangle) {
        throw new Error('Method visitTriangle() has not been implemented.');
    }
    visitQuad(quad) {
        throw new Error('Method visitQuad() has not been implemented.');
    }
    // tessellation primitives
    visitTriangleFan(triangleFan) {
        throw new Error('Method visitTriangleFan() has not been implemented.');
    }
    visitTriangleStrip(triangleStrip) {
        throw new Error('Method visitTriangleStrip() has not been implemented.');
    }
    visitQuadStrip(quadStrip) {
        throw new Error('Method visitQuadStrip() has not been implemented.');
    }
}
// requires testing
class PrimitiveToPath2DConverter extends PrimitiveVisitor {
    path = new Path2D();
    strokeWeight;
    constructor({ strokeWeight }){
        super();
        this.strokeWeight = strokeWeight;
    }
    // path primitives
    visitAnchor(anchor) {
        let vertex = anchor.getEndVertex();
        this.path.moveTo(vertex.position.x, vertex.position.y);
    }
    visitLineSegment(lineSegment) {
        if (lineSegment.isClosing) {
            // The same as lineTo, but it adds a stroke join between this
            // and the starting vertex rather than having two caps
            this.path.closePath();
        } else {
            let vertex = lineSegment.getEndVertex();
            this.path.lineTo(vertex.position.x, vertex.position.y);
        }
    }
    visitBezierSegment(bezierSegment) {
        let [v1, v2, v3] = bezierSegment.vertices;
        switch(bezierSegment.order){
            case 2:
                this.path.quadraticCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y);
                break;
            case 3:
                this.path.bezierCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y, v3.position.x, v3.position.y);
                break;
        }
    }
    visitSplineSegment(splineSegment) {
        const shape = splineSegment._shape;
        if (splineSegment._splineProperties.ends === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"] && !splineSegment._comesAfterSegment) {
            let startVertex = splineSegment._firstInterpolatedVertex;
            this.path.moveTo(startVertex.position.x, startVertex.position.y);
        }
        const arrayVertices = splineSegment.getControlPoints().map((v)=>shape.vertexToArray(v));
        let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness).map((arr)=>arr.map((vertArr)=>shape.arrayToVertex(vertArr)));
        for (const array of bezierArrays){
            const points = array.flatMap((vert)=>[
                    vert.position.x,
                    vert.position.y
                ]);
            this.path.bezierCurveTo(...points);
        }
    }
    visitPoint(point) {
        const { x, y } = point.vertices[0].position;
        this.path.moveTo(x, y);
        // Hack: to draw just strokes and not fills, draw a very very tiny line
        this.path.lineTo(x + 0.00001, y);
    }
    visitLine(line) {
        const { x: x0, y: y0 } = line.vertices[0].position;
        const { x: x1, y: y1 } = line.vertices[1].position;
        this.path.moveTo(x0, y0);
        this.path.lineTo(x1, y1);
    }
    visitTriangle(triangle) {
        const [v0, v1, v2] = triangle.vertices;
        this.path.moveTo(v0.position.x, v0.position.y);
        this.path.lineTo(v1.position.x, v1.position.y);
        this.path.lineTo(v2.position.x, v2.position.y);
        this.path.closePath();
    }
    visitQuad(quad) {
        const [v0, v1, v2, v3] = quad.vertices;
        this.path.moveTo(v0.position.x, v0.position.y);
        this.path.lineTo(v1.position.x, v1.position.y);
        this.path.lineTo(v2.position.x, v2.position.y);
        this.path.lineTo(v3.position.x, v3.position.y);
        this.path.closePath();
    }
    visitTriangleFan(triangleFan) {
        const [v0, ...rest] = triangleFan.vertices;
        for(let i = 0; i < rest.length - 1; i++){
            const v1 = rest[i];
            const v2 = rest[i + 1];
            this.path.moveTo(v0.position.x, v0.position.y);
            this.path.lineTo(v1.position.x, v1.position.y);
            this.path.lineTo(v2.position.x, v2.position.y);
            this.path.closePath();
        }
    }
    visitTriangleStrip(triangleStrip) {
        for(let i = 0; i < triangleStrip.vertices.length - 2; i++){
            const v0 = triangleStrip.vertices[i];
            const v1 = triangleStrip.vertices[i + 1];
            const v2 = triangleStrip.vertices[i + 2];
            this.path.moveTo(v0.position.x, v0.position.y);
            this.path.lineTo(v1.position.x, v1.position.y);
            this.path.lineTo(v2.position.x, v2.position.y);
            this.path.closePath();
        }
    }
    visitQuadStrip(quadStrip) {
        for(let i = 0; i < quadStrip.vertices.length - 3; i += 2){
            const v0 = quadStrip.vertices[i];
            const v1 = quadStrip.vertices[i + 1];
            const v2 = quadStrip.vertices[i + 2];
            const v3 = quadStrip.vertices[i + 3];
            this.path.moveTo(v0.position.x, v0.position.y);
            this.path.lineTo(v1.position.x, v1.position.y);
            // These are intentionally out of order to go around the quad
            this.path.lineTo(v3.position.x, v3.position.y);
            this.path.lineTo(v2.position.x, v2.position.y);
            this.path.closePath();
        }
    }
}
class PrimitiveToVerticesConverter extends PrimitiveVisitor {
    contours = [];
    curveDetail;
    constructor({ curveDetail = 1 } = {}){
        super();
        this.curveDetail = curveDetail;
    }
    lastContour() {
        return this.contours[this.contours.length - 1];
    }
    visitAnchor(anchor) {
        this.contours.push([]);
        // Weird edge case: if the next segment is a spline, we might
        // need to jump to a different vertex.
        const next = anchor._nextPrimitive;
        if (next?.canOverrideAnchor) {
            this.lastContour().push(next._firstInterpolatedVertex);
        } else {
            this.lastContour().push(anchor.getEndVertex());
        }
    }
    visitLineSegment(lineSegment) {
        this.lastContour().push(lineSegment.getEndVertex());
    }
    visitBezierSegment(bezierSegment) {
        const contour = this.lastContour();
        const numPoints = Math.max(1, Math.ceil(bezierSegment.hullLength() * this.curveDetail));
        const vertexArrays = [
            bezierSegment.getStartVertex(),
            ...bezierSegment.vertices
        ].map((v)=>bezierSegment._shape.vertexToArray(v));
        for(let i = 0; i < numPoints; i++){
            const t = (i + 1) / numPoints;
            contour.push(bezierSegment._shape.arrayToVertex(bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)));
        }
    }
    visitSplineSegment(splineSegment) {
        const shape = splineSegment._shape;
        const contour = this.lastContour();
        const arrayVertices = splineSegment.getControlPoints().map((v)=>shape.vertexToArray(v));
        let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness);
        let startVertex = shape.vertexToArray(splineSegment._firstInterpolatedVertex);
        for (const array of bezierArrays){
            const bezierControls = [
                startVertex,
                ...array
            ];
            const numPoints = Math.max(1, Math.ceil(polylineLength(bezierControls.map((v)=>shape.arrayToVertex(v))) * this.curveDetail));
            for(let i = 0; i < numPoints; i++){
                const t = (i + 1) / numPoints;
                contour.push(shape.arrayToVertex(shape.evaluateCubicBezier(bezierControls, t)));
            }
            startVertex = array[2];
        }
    }
    visitPoint(point) {
        this.contours.push(point.vertices.slice());
    }
    visitLine(line) {
        this.contours.push(line.vertices.slice());
    }
    visitTriangle(triangle) {
        this.contours.push(triangle.vertices.slice());
    }
    visitQuad(quad) {
        this.contours.push(quad.vertices.slice());
    }
    visitTriangleFan(triangleFan) {
        // WebGL itself interprets the vertices as a fan, no reformatting needed
        this.contours.push(triangleFan.vertices.slice());
    }
    visitTriangleStrip(triangleStrip) {
        // WebGL itself interprets the vertices as a strip, no reformatting needed
        this.contours.push(triangleStrip.vertices.slice());
    }
    visitQuadStrip(quadStrip) {
        // WebGL itself interprets the vertices as a strip, no reformatting needed
        this.contours.push(quadStrip.vertices.slice());
    }
}
class PointAtLengthGetter extends PrimitiveVisitor {
    constructor(){
        super();
    }
}
function customShapes(p51, fn) {
    // ---- GENERAL CLASSES ----
    /**
   * @private
   * A class to describe a custom shape made with `beginShape()`/`endShape()`.
   *
   * Every `Shape` has a `kind`. The kind takes any value that
   * can be passed to <a href="#/p5/beginShape">beginShape()</a>:
   *
   * - `PATH`
   * - `POINTS`
   * - `LINES`
   * - `TRIANGLES`
   * - `QUADS`
   * - `TRIANGLE_FAN`
   * - `TRIANGLE_STRIP`
   * - `QUAD_STRIP`
   *
   * A `Shape` of any kind consists of `contours`, which can be thought of as
   * subshapes (shapes inside another shape). Each `contour` is built from
   * basic shapes called primitives, and each primitive consists of one or more vertices.
   *
   * For example, a square can be made from a single path contour with four line-segment
   * primitives. Each line segment contains a vertex that indicates its endpoint. A square
   * with a circular hole in it contains the circle in a separate contour.
   *
   * By default, each vertex only has a position, but a shape's vertices may have other
   * properties such as texture coordinates, a normal vector, a fill color, and a stroke color.
   * The properties every vertex should have may be customized by passing `vertexProperties` to
   * `createShape()`.
   *
   * Once a shape is created and given a name like `myShape`, it can be built up with
   * methods such as `myShape.beginShape()`, `myShape.vertex()`, and `myShape.endShape()`.
   *
   * Vertex functions such as `vertex()` or `bezierVertex()` are used to set the `position`
   * property of vertices, as well as the `textureCoordinates` property if applicable. Those
   * properties only apply to a single vertex.
   *
   * If `vertexProperties` includes other properties, they are each set by a method of the
   * same name. For example, if vertices in `myShape` have a `fill`, then that is set with
   * `myShape.fill()`. In the same way that a <a href="#/p5/fill">fill()</a> may be applied
   * to one or more shapes, `myShape.fill()` may be applied to one or more vertices.
   *
   * @class p5.Shape
   * @param {Object} [vertexProperties={position: createVector(0, 0)}] vertex properties and their initial values.
   */ p51.Shape = Shape;
    /**
   * @private
   * A class to describe a contour made with `beginContour()`/`endContour()`.
   *
   * Contours may be thought of as shapes inside of other shapes.
   * For example, a contour may be used to create a hole in a shape that is created
   * with <a href="#/p5/beginShape">beginShape()</a>/<a href="#/p5/endShape">endShape()</a>.
   * Multiple contours may be included inside a single shape.
   *
   * Contours can have any `kind` that a shape can have:
   *
   * - `PATH`
   * - `POINTS`
   * - `LINES`
   * - `TRIANGLES`
   * - `QUADS`
   * - `TRIANGLE_FAN`
   * - `TRIANGLE_STRIP`
   * - `QUAD_STRIP`
   *
   * By default, a contour has the same kind as the shape that contains it, but this
   * may be changed by passing a different `kind` to <a href="#/p5/beginContour">beginContour()</a>.
   *
   * A `Contour` of any kind consists of `primitives`, which are the most basic
   * shapes that can be drawn. For example, if a contour is a hexagon, then
   * it's made from six line-segment primitives.
   *
   * @class p5.Contour
   */ p51.Contour = Contour;
    /**
   * @private
   * A base class to describe a shape primitive (a basic shape drawn with
   * `beginShape()`/`endShape()`).
   *
   * Shape primitives are the most basic shapes that can be drawn with
   * <a href="#/p5/beginShape">beginShape()</a>/<a href="#/p5/endShape">endShape()</a>:
   *
   * - segment primitives: line segments, bezier segments, spline segments, and arc segments
   * - isolated primitives: points, lines, triangles, and quads
   * - tessellation primitives: triangle fans, triangle strips, and quad strips
   *
   * More complex shapes may be created by combining many primitives, possibly of different kinds,
   * into a single shape.
   *
   * In a similar way, every shape primitive is built from one or more vertices.
   * For example, a point consists of a single vertex, while a triangle consists of three vertices.
   * Each type of shape primitive has a `vertexCapacity`, which may be `Infinity` (for example, a
   * spline may consist of any number of vertices). A primitive's `vertexCount` is the number of
   * vertices it currently contains.
   *
   * Each primitive can add itself to a shape with an `addToShape()` method.
   *
   * It can also accept visitor objects with an `accept()` method. When a primitive accepts a visitor,
   * it gives the visitor access to its vertex data. For example, one visitor to a segment might turn
   * the data into 2D drawing instructions. Another might find a point at a given distance
   * along the segment.
   *
   * @class p5.ShapePrimitive
   * @abstract
   */ p51.ShapePrimitive = ShapePrimitive;
    /**
   * @private
   * A class to describe a vertex (a point on a shape), in 2D or 3D.
   *
   * Vertices are the basic building blocks of all `p5.Shape` objects, including
   * shapes made with <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/arcVertex">arcVertex()</a>,
   * <a href="#/p5/bezierVertex">bezierVertex()</a>, and <a href="#/p5/splineVertex">splineVertex()</a>.
   *
   * Like a point on an object in the real world, a vertex may have different properties.
   * These may include coordinate properties such as `position`, `textureCoordinates`, and `normal`,
   * color properties such as `fill` and `stroke`, and more.
   *
   * A vertex called `myVertex` with position coordinates `(2, 3, 5)` and a green stroke may be created
   * like this:
   *
   * ```js
   * let myVertex = new p5.Vertex({
   *   position: createVector(2, 3, 5),
   *   stroke: color('green')
   * });
   * ```
   *
   * Any property names may be used. The `p5.Shape` class assumes that if a vertex has a
   * position or texture coordinates, they are stored in `position` and `textureCoordinates`
   * properties.
   *
   * Property values may be any
   * <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">JavaScript primitive</a>, any
   * <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">object literal</a>,
   * or any object with an `array` property.
   *
   * For example, if a position is stored as a `p5.Vector` object and a stroke is stored as a `p5.Color` object,
   * then the `array` properties of those objects will be used by the vertex's own `array` property, which provides
   * all the vertex data in a single array.
   *
   * @class p5.Vertex
   * @param {Object} [properties={position: createVector(0, 0)}] vertex properties.
   */ p51.Vertex = Vertex;
    // ---- PATH PRIMITIVES ----
    /**
   * @private
   * A class responsible for...
   *
   * @class p5.Anchor
   * @extends p5.ShapePrimitive
   * @param {p5.Vertex} vertex the vertex to include in the anchor.
   */ p51.Anchor = Anchor;
    /**
   * @private
   * A class responsible for...
   *
   * Note: When a segment is added to a shape, it's attached to an anchor or another segment.
   * Adding it to another shape may result in unexpected behavior.
   *
   * @class p5.Segment
   * @extends p5.ShapePrimitive
   * @param {...p5.Vertex} vertices the vertices to include in the segment.
   */ p51.Segment = Segment;
    /**
   * @private
   * A class responsible for...
   *
   * @class p5.LineSegment
   * @param {p5.Vertex} vertex the vertex to include in the anchor.
   */ p51.LineSegment = LineSegment;
    /**
   * @private
   * A class responsible for...
   */ p51.BezierSegment = BezierSegment;
    /**
   * @private
   * A class responsible for...
   */ p51.SplineSegment = SplineSegment;
    // ---- ISOLATED PRIMITIVES ----
    /**
   * @private
   * A class responsible for...
   */ p51.Point = Point;
    /**
   * @private
   * A class responsible for...
   *
   * @class p5.Line
   * @param {...p5.Vertex} vertices the vertices to include in the line.
   */ p51.Line = Line;
    /**
   * @private
   * A class responsible for...
   */ p51.Triangle = Triangle;
    /**
   * @private
   * A class responsible for...
   */ p51.Quad = Quad;
    // ---- TESSELLATION PRIMITIVES ----
    /**
   * @private
   * A class responsible for...
   */ p51.TriangleFan = TriangleFan;
    /**
   * @private
   * A class responsible for...
   */ p51.TriangleStrip = TriangleStrip;
    /**
   * @private
   * A class responsible for...
   */ p51.QuadStrip = QuadStrip;
    // ---- PRIMITIVE VISITORS ----
    /**
   * @private
   * A class responsible for...
   */ p51.PrimitiveVisitor = PrimitiveVisitor;
    /**
   * @private
   * A class responsible for...
   *
   * Notes:
   * 1. Assumes vertex positions are stored as p5.Vector instances.
   * 2. Currently only supports position properties of vectors.
   */ p51.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;
    /**
   * @private
   * A class responsible for...
   */ p51.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;
    /**
   * @private
   * A class responsible for...
   */ p51.PointAtLengthGetter = PointAtLengthGetter;
    // ---- FUNCTIONS ----
    /**
   * Influences the shape of the Bzier curve segment in a custom shape.
   * By default, this is 3; the other possible parameter is 2. This
   * results in quadratic Bzier curves.
   *
   * `bezierVertex()` adds a curved segment to custom shapes. The Bzier curves
   * it creates are defined like those made by the
   * <a href="#/p5/bezier">bezier()</a> function. `bezierVertex()` must be
   * called between the
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> functions. There must be at least
   * one call to <a href="#/p5/vertex">bezierVertex()</a>, before
   * a number of `bezierVertex()` calls that is a multiple of the parameter
   * set by <a href="#/p5/bezierOrder">bezierOrder(...)</a> (default 3).
   *
   * Each curve of order 3 requires three calls to `bezierVertex`, so
   * 2 curves would need 7 calls to `bezierVertex()`:
   * (1 one initial anchor point, two sets of 3 curves describing the curves)
   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2.
   *
   * Bzier curves can also be drawn in 3D using WebGL mode.
   *
   * Note: `bezierVertex()` wont work when an argument is passed to
   * <a href="#/p5/beginShape">beginShape()</a>.
   *
   * @method bezierOrder
   * @param {Number} order The new order to set. Can be either 2 or 3, by default 3
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shape.
   *   noFill();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // set the order to 2 for a quadratic Bzier curve
   *   bezierOrder(2);
   *
   *   // Add the first anchor point.
   *   bezierVertex(30, 20);
   *
   *   // Add the Bzier vertex.
   *   bezierVertex(80, 20);
   *   bezierVertex(50, 50);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('A black curve drawn on a gray square. The curve starts at the top-left corner and ends at the center.');
   * }
   * </code>
   * </div>
   */ /**
   * @method bezierOrder
   * @returns {Number} The current Bzier order.
   */ fn.bezierOrder = function(order) {
        return this._renderer.bezierOrder(order);
    };
    /**
   * Connects points with a smooth curve (a spline).
   *
   * `splineVertex()` adds a curved segment to custom shapes.
   * The curve it creates follows the same rules as the ones
   * made with the <a href="#/p5/spline">spline()</a> function.
   * `splineVertex()` must be called between the
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> functions.
   *
   * Spline curves can form shapes and curves that slope gently. Theyre like
   * cables that are attached to a set of points. `splineVertex()` draws a smooth
   * curve through the points you give it.
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> in order to draw a curve:
   *
   *
   * If you provide three points, the spline will pass through them.
   * It works the same way with any number of points.
   *
   *
   *
   * ```js
   * beginShape();
   *
   * // Add the first point.
   * splineVertex(25, 80);
   *
   * // Add the second point.
   * splineVertex(20, 30);
   *
   * // Add the last point.
   * splineVertex(85, 60);
   *
   * endShape();
   * ```
   *
   * <img src="assets/openCurveSpline.png"></img>
   *
   *
   * Passing in `CLOSE` to `endShape()` closes the spline smoothly.
   * ```js
   * beginShape();
   *
   * // Add the first point.
   * splineVertex(25, 80);
   *
   * // Add the second point.
   * splineVertex(20, 30);
   *
   * // Add the second point.
   * splineVertex(85, 60);
   *
   * endShape(CLOSE);
   * ```
   *
   * <img src="assets/closeCurveSpline.png"></img>
   *
   *
   * By default (`ends: INCLUDE`), the curve passes through
   * all the points you add with `splineVertex()`, similar to
   * the <a href="#/p5/spline">spline()</a> function. To draw only
   * the middle span p1->p2 (skipping p0->p1 and p2->p3), set
   * `splineProperty('ends', EXCLUDE)`. You dont need to duplicate
   * vertices to draw those spans.
   *
   * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of
   * `splineVertex()` has three arguments because each point has x-, y-, and
   * z-coordinates. By default, the vertexs z-coordinate is set to 0.
   *
   * Note: `splineVertex()` wont work when an argument is passed to
   * <a href="#/p5/beginShape">beginShape()</a>.
   *
   * @method splineVertex
   * @param {Number} x x-coordinate of the vertex
   * @param {Number} y y-coordinate of the vertex
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(220);
   *   noFill();
   *   strokeWeight(1);
   *
   *   beginShape();
   *   splineVertex(25, 80);
   *   splineVertex(20, 30);
   *   splineVertex(85, 60);
   *   endShape();
   *
   *   strokeWeight(5);
   *   stroke(0);
   *
   *   point(25, 80);
   *   point(20, 30);
   *   point(85, 60);
   *
   *   describe(
   *     'On a gray background, a black spline passes through three marked points.'
   *   );
   * }
   *
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(220);
   *
   *   beginShape();
   *   splineVertex(25, 80);
   *   splineVertex(20, 30);
   *   splineVertex(85, 60);
   *   endShape(CLOSE);
   *
   *   describe(
   *     'On a gray background, a closed black spline with a white interior forms a triangular shape with smooth corners.'
   *   );
   * }
   *
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let ringInnerRadius, ringWidth;
   * let radius, dRadius;
   * let theta, dTheta;
   * let time, dTime;
   * let vertexCount, unit, offset;
   *
   * function setup() {
   *   createCanvas(400, 400);
   *
   *   vertexCount = 15;
   *   unit = createVector(1, 0);
   *   dTheta = TAU / vertexCount;
   *   dTime = 0.004;
   *
   *   ringInnerRadius = 25;
   *   ringWidth = 5 * ringInnerRadius;
   *
   *   offset = width;
   *
   *   describe(
   *     'A white blob with a black outline changes its shape over time.'
   *   );
   * }
   *
   * function draw() {
   *   background(220);
   *   strokeWeight(2);
   *   translate(width / 2, height / 2);
   *
   *   time = dTime * frameCount;
   *
   *   beginShape();
   *   for (let i = 0; i < vertexCount; i++) {
   *     unit.rotate(dTheta);
   *     dRadius = noise(offset + unit.x, offset + unit.y, time) * ringWidth;
   *     radius = ringInnerRadius + dRadius;
   *     splineVertex(radius * unit.x, radius * unit.y);
   *   }
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   * 
   * @example
   * <div>
   * <code>
   * let vertexA;
   * let vertexB;
   * let vertexC;
   * let vertexD;
   * let vertexE;
   * let vertexF;
   * 
   * let markerRadius;
   * 
   * let vectorAB;
   * let vectorFE;
   * 
   * let endOfTangentB;
   * let endOfTangentE;
   * 
   * function setup() {
   *   createCanvas(100, 100);
   *   
   *   // Initialize variables
   *   // Adjusting vertices A and F affects the slopes at B and E
   *   
   *   vertexA = createVector(35, 85);
   *   vertexB = createVector(25, 70);
   *   vertexC = createVector(30, 30);
   *   vertexD = createVector(70, 30);
   *   vertexE = createVector(75, 70);
   *   vertexF = createVector(65, 85);
   *   
   *   markerRadius = 4;
   *   
   *   vectorAB = p5.Vector.sub(vertexB, vertexA);
   *   vectorFE = p5.Vector.sub(vertexE, vertexF);
   *   
   *   endOfTangentB = p5.Vector.add(vertexC, vectorAB);
   *   endOfTangentE = p5.Vector.add(vertexD, vectorFE);
   *   
   *   splineProperty(`ends`, EXCLUDE);
   *   
   *   // Draw figure
   *   
   *   background(220);
   *   
   *   noFill();
   *   
   *   beginShape();
   *   splineVertex(vertexA.x, vertexA.y);
   *   splineVertex(vertexB.x, vertexB.y);
   *   splineVertex(vertexC.x, vertexC.y);
   *   splineVertex(vertexD.x, vertexD.y);
   *   splineVertex(vertexE.x, vertexE.y);
   *   splineVertex(vertexF.x, vertexF.y);
   *   endShape();
   *   
   *   stroke('red');
   *   line(vertexA.x, vertexA.y, vertexC.x, vertexC.y);
   *   line(vertexB.x, vertexB.y, endOfTangentB.x, endOfTangentB.y);
   *   
   *   stroke('blue');
   *   line(vertexD.x, vertexD.y, vertexF.x, vertexF.y);
   *   line(vertexE.x, vertexE.y, endOfTangentE.x, endOfTangentE.y);
   *     
   *   fill('white');
   *   stroke('black');
   *   circle(vertexA.x, vertexA.y, markerRadius);
   *   circle(vertexB.x, vertexB.y, markerRadius);
   *   circle(vertexC.x, vertexC.y, markerRadius);
   *   circle(vertexD.x, vertexD.y, markerRadius);
   *   circle(vertexE.x, vertexE.y, markerRadius);
   *   circle(vertexF.x, vertexF.y, markerRadius);
   *   
   *   fill('black');
   *   noStroke();
   *   text('A', vertexA.x - 15, vertexA.y + 5);
   *   text('B', vertexB.x - 15, vertexB.y + 5);
   *   text('C', vertexC.x - 5, vertexC.y - 5);
   *   text('D', vertexD.x - 5, vertexD.y - 5);
   *   text('E', vertexE.x + 5, vertexE.y + 5);
   *   text('F', vertexF.x + 5, vertexF.y + 5);
   *   
   *   describe('On a gray background, a black spline passes through vertices A, B, C, D, E, and F, shown as white circles. A red line segment joining vertices A and C has the same slope as the red tangent segment at B. Similarly, the blue line segment joining vertices D and F has the same slope as the blue tangent at E.');
   * }
   * </code>
   * </div>
   */ /**
   * @method splineVertex
   * @param {Number} x
   * @param {Number} y
   * @param {Number} [z] z-coordinate of the vertex.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A ghost shape drawn in white on a blue background. When the user drags the mouse, the scene rotates to reveal the outline of a second ghost.');
   * }
   *
   * function draw() {
   *   background('midnightblue');
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the first ghost.
   *   noStroke();
   *   fill('ghostwhite');
   *
   *   beginShape();
   *   splineVertex(-28, 41, 0);
   *   splineVertex(-28, 41, 0);
   *   splineVertex(-29, -33, 0);
   *   splineVertex(18, -31, 0);
   *   splineVertex(34, 41, 0);
   *   splineVertex(34, 41, 0);
   *   endShape();
   *
   *   // Draw the second ghost.
   *   noFill();
   *   stroke('ghostwhite');
   *
   *   beginShape();
   *   splineVertex(-28, 41, -20);
   *   splineVertex(-28, 41, -20);
   *   splineVertex(-29, -33, -20);
   *   splineVertex(18, -31, -20);
   *   splineVertex(34, 41, -20);
   *   splineVertex(34, 41, -20);
   *   endShape();
   * }
   * </code>
   * </div>
   */ /**
   * @method splineVertex
   * @param {Number} x
   * @param {Number} y
   * @param {Number} [u=0]
   * @param {Number} [v=0]
   */ /**
   * @method splineVertex
   * @param {Number} x
   * @param {Number} y
   * @param {Number} z
   * @param {Number} [u=0]
   * @param {Number} [v=0]
   */ fn.splineVertex = function(...args) {
        let x = 0, y = 0, z = 0, u = 0, v = 0;
        if (args.length === 2) {
            [x, y] = args;
        } else if (args.length === 4) {
            [x, y, u, v] = args;
        } else if (args.length === 3) {
            [x, y, z] = args;
        } else if (args.length === 5) {
            [x, y, z, u, v] = args;
        }
        this._renderer.splineVertex(x, y, z, u, v);
    };
    /**
   * Gets or sets a given spline property.
   *
   * Use `splineProperty()` to adjust the behavior of splines
   * created with `splineVertex()` or `spline()`. You can control
   * two key aspects of a spline: its end behavior (`ends`) and
   * its curvature (`tightness`).
   *
   * By default, the ends property is set to `INCLUDE`, which means
   * the spline passes through every point, including the endpoints.
   * You can also set it to `EXCLUDE` i.e. `splineProperty('ends', EXCLUDE)`,
   * which makes the spline pass through all points except the endpoints.
   *
   * `INCLUDE` case will have the spline passing through
   * all points, like this:
   *
   * ```js
   * splineProperty('ends', INCLUDE); // no need to set this, as it is the default
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   *
   * point(25, 46);
   * point(93, 44);
   * point(93, 81);
   * point(35, 85);
   * ```
   *
   * <img src="assets/includeSpline.png"></img>
   *
   *
   * EXCLUDE case will have the spline passing through
   * the middle points, like this:
   *
   *
   * ```js
   * splineProperty('ends', EXCLUDE);
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   *
   * point(25, 46);
   * point(93, 44);
   * point(93, 81);
   * point(35, 85);
   * ```
   *
   * <img src="assets/excludeSpline.png"></img>
   *
   * By default, the tightness property is set to `0`,
   * producing a smooth curve that passes evenly through
   * the vertices. Negative values make the curve looser,
   * while positive values make it tighter. Common values
   * range between -1 and 1, though values outside this
   * range can also be used for different effects.
   *
   * For example, To set tightness, use `splineProperty('tightness', t)`,
   * (default: t = 0).
   *
   * Here's the example showing negetive value of tightness,
   * which creates a rounder bulge:
   *
   * ```js
   * splineProperty('tightness', -5)
   * stroke(0);
   * strokeWeight(2);
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   * ```
   * <img src="assets/roundBulge.png"></img>
   * Here's the example showing positive value of tightness,
   * which makes the curve tighter and more angular:
   *
   * ```js
   * splineProperty('tightness', 5)
   * stroke(0);
   * strokeWeight(2);
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   * ```
   * <img src="assets/anglurBulge.png"></img>
   * 
   * In all cases, the splines in p5.js are <a href = "https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline">cardinal splines</a>.
   * When tightness is 0, these splines are often known as
   * <a href="https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Catmull%E2%80%93Rom_spline">Catmull-Rom splines</a>
   *
   * @method splineProperty
   * @param {String} property
   * @param value Value to set the given property to.
   *
   * @example
   * <div>
   * <code>
   * // Move the mouse left and right to see the curve change.
   *
   * let t;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   t = map(mouseX, 0, width, -5, 5, true);
   *   splineProperty('tightness', t);
   *
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *
   *   beginShape();
   *   splineVertex(10, 26);
   *   splineVertex(83, 24);
   *
   *   splineVertex(83, 61);
   *   splineVertex(25, 65);
   *   endShape();
   *
   *   push();
   *   strokeWeight(5);
   *   point(10, 26);
   *   point(83, 24);
   *   point(83, 61);
   *   point(25, 65);
   *   pop();
   *
   *   fill(0);
   *   noStroke();
   *   textSize(10);
   *   text(`tightness: ${round(t, 1)}`, 15, 90);
   *   describe('A black spline forms a sideways U shape through four points. The spline passes through the points more loosely as the mouse moves left of center (negative tightness), and more tightly as it moves right of center (positive tightness). The tightness is displayed at the bottom.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   * createCanvas(360, 140);
   * background(240);
   * noFill();
   *
   * // Right panel: ends = INCLUDE (all spans).
   * push();
   * translate(10, 10);
   * stroke(220);
   * rect(0, 0, 160, 120);
   * fill(30);
   * textSize(11);
   * text('ends: INCLUDE (all spans)', 8, 16);
   * noFill();
   *
   * splineProperty('ends', INCLUDE);
   * stroke(0);
   * strokeWeight(2);
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   *
   * // vertices
   * strokeWeight(5);
   * stroke(0);
   * point(25, 46);
   * point(93, 44);
   * point(93, 81);
   * point(35, 85);
   * pop();
   *
   * // Right panel: ends = EXCLUDE (middle only).
   * push();
   * translate(190, 10);
   * stroke(220);
   * rect(0, 0, 160, 120);
   * noStroke();
   * fill(30);
   * text('ends: EXCLUDE ', 18, 16);
   * noFill();
   *
   * splineProperty('ends', EXCLUDE);
   * stroke(0);
   * strokeWeight(2);
   * spline(25, 46, 93, 44, 93, 81, 35, 85);
   *
   * // vertices
   * strokeWeight(5);
   * stroke(0);
   * point(25, 46);
   * point(93, 44);
   * point(93, 81);
   * point(35, 85);
   *  pop();
   *
   * describe('Left panel shows spline with ends INCLUDE (three spans). Right panel shows EXCLUDE (only the middle span). Four black points mark the vertices.');
   * }
   * </code>
   * </div>
   * 
   * @example
   * 
   * <div>
   * <code>
   * let vertexA;
   * let vertexB;
   * let vertexC;
   * let vertexD;
   * let vertexE;
   * let vertexF;
   * 
   * let markerRadius;
   * 
   * let vectorAB;
   * let vectorFE;
   * 
   * let endOfTangentB;
   * let endOfTangentE;
   * 
   * function setup() {
   *   createCanvas(100, 100);
   *   
   *   // Initialize variables
   *   // Adjusting vertices A and F affects the slopes at B and E
   *   
   *   vertexA = createVector(35, 85);
   *   vertexB = createVector(25, 70);
   *   vertexC = createVector(30, 30);
   *   vertexD = createVector(70, 30);
   *   vertexE = createVector(75, 70);
   *   vertexF = createVector(65, 85);
   *   
   *   markerRadius = 4;
   *   
   *   vectorAB = p5.Vector.sub(vertexB, vertexA);
   *   vectorFE = p5.Vector.sub(vertexE, vertexF);
   *   
   *   endOfTangentB = p5.Vector.add(vertexC, vectorAB);
   *   endOfTangentE = p5.Vector.add(vertexD, vectorFE);
   *   
   *   splineProperty(`ends`, EXCLUDE);
   *   
   *   // Draw figure
   *   
   *   background(220);
   *   
   *   noFill();
   *   
   *   beginShape();
   *   splineVertex(vertexA.x, vertexA.y);
   *   splineVertex(vertexB.x, vertexB.y);
   *   splineVertex(vertexC.x, vertexC.y);
   *   splineVertex(vertexD.x, vertexD.y);
   *   splineVertex(vertexE.x, vertexE.y);
   *   splineVertex(vertexF.x, vertexF.y);
   *   endShape();
   *   
   *   stroke('red');
   *   line(vertexA.x, vertexA.y, vertexC.x, vertexC.y);
   *   line(vertexB.x, vertexB.y, endOfTangentB.x, endOfTangentB.y);
   *   
   *   stroke('blue');
   *   line(vertexD.x, vertexD.y, vertexF.x, vertexF.y);
   *   line(vertexE.x, vertexE.y, endOfTangentE.x, endOfTangentE.y);
   *     
   *   fill('white');
   *   stroke('black');
   *   circle(vertexA.x, vertexA.y, markerRadius);
   *   circle(vertexB.x, vertexB.y, markerRadius);
   *   circle(vertexC.x, vertexC.y, markerRadius);
   *   circle(vertexD.x, vertexD.y, markerRadius);
   *   circle(vertexE.x, vertexE.y, markerRadius);
   *   circle(vertexF.x, vertexF.y, markerRadius);
   *   
   *   fill('black');
   *   noStroke();
   *   text('A', vertexA.x - 15, vertexA.y + 5);
   *   text('B', vertexB.x - 15, vertexB.y + 5);
   *   text('C', vertexC.x - 5, vertexC.y - 5);
   *   text('D', vertexD.x - 5, vertexD.y - 5);
   *   text('E', vertexE.x + 5, vertexE.y + 5);
   *   text('F', vertexF.x + 5, vertexF.y + 5);
   *   
   *   describe('On a gray background, a black spline passes through vertices A, B, C, D, E, and F, shown as white circles. A red line segment joining vertices A and C has the same slope as the red tangent segment at B. Similarly, the blue line segment joining vertices D and F has the same slope as the blue tangent at E.');
   * }
   * </code>
   * </div>
   * 
   */ /**
   * @method splineProperty
   * @param {String} property
   * @returns The current value for the given property.
   */ fn.splineProperty = function(property, value) {
        return this._renderer.splineProperty(property, value);
    };
    /**
   * Sets multiple properties for spline curves at once.
   *
   * `splineProperties()` accepts an object with key-value pairs to configure
   * how spline curves are drawn. This is a convenient way to set multiple
   * spline properties with a single function call, rather than calling
   * <a href="#/p5/splineProperty">splineProperty()</a> multiple times.
   *
   * The properties object can include:
   * - `tightness`: A number that controls how tightly the curve fits to the
   *   vertex points. The default value is 0. Positive values make the curve
   *   tighter (straighter), while negative values make it looser. Values
   *   between -5 and 5 work best.
   * - `ends`: Controls whether to draw the end segments of the spline. Set to
   *   `EXCLUDE` to skip drawing the segments between the first and second
   *   points and between the second-to-last and last points. This is useful
   *   when you want to use the first and last points as control points only.
   *
   * `splineProperties()` affects curves drawn with
   * <a href="#/p5/splineVertex">splineVertex()</a> within
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>, as well as curves drawn with
   * <a href="#/p5/spline">spline()</a>. The properties remain active until
   * changed by another call to `splineProperties()` or
   * <a href="#/p5/splineProperty">splineProperty()</a>.
   *
   * @method splineProperties
   * @param  {Object} values an object containing spline property key-value pairs
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(220);
   *
   *   // Set spline tightness using splineProperties
   *   splineProperties({
   *     tightness: 0.5
   *   });
   *
   *   // Draw a spline curve
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *   
   *   beginShape();
   *   splineVertex(20, 80);
   *   splineVertex(30, 30);
   *   splineVertex(70, 30);
   *   splineVertex(80, 80);
   *   endShape();
   *
   *   // Show vertex points
   *   fill(255, 0, 0);
   *   noStroke();
   *   circle(20, 80, 6);
   *   circle(30, 30, 6);
   *   circle(70, 30, 6);
   *   circle(80, 80, 6);
   *
   *   describe('A smooth curved line with tightness 0.5 connecting four red points.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(220);
   *
   *   // Exclude end segments - first and last points become control points
   *   splineProperties({
   *     tightness: 0,
   *     ends: EXCLUDE
   *   });
   *
   *   // Draw curve only between middle points
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *   
   *   beginShape();
   *   splineVertex(10, 50);  // Control point (affects curve but not drawn to)
   *   splineVertex(30, 20);  // Start of visible curve
   *   splineVertex(70, 80);  // End of visible curve
   *   splineVertex(90, 50);  // Control point (affects curve but not drawn to)
   *   endShape();
   *
   *   // Show all points
   *   fill(200, 0, 0);
   *   noStroke();
   *   circle(10, 50, 6);  // Control point
   *   circle(90, 50, 6);  // Control point
   *   
   *   fill(0, 0, 255);
   *   circle(30, 20, 6);  // Visible curve point
   *   circle(70, 80, 6);  // Visible curve point
   *
   *   describe('A curved line between two blue points, with red control points at the ends.');
   * }
   * </code>
   * </div>
   *
   * @method splineProperties
   * @return {Object}
   */ fn.splineProperties = function(values) {
        return this._renderer.splineProperties(values);
    };
    /**
   * Adds a vertex to a custom shape.
   *
   * `vertex()` sets the coordinates of vertices drawn between the
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> functions.
   *
   * The first two parameters, `x` and `y`, set the x- and y-coordinates of the
   * vertex.
   *
   * The third parameter, `z`, is optional. It sets the z-coordinate of the
   * vertex in WebGL mode. By default, `z` is 0.
   *
   * The fourth and fifth parameters, `u` and `v`, are also optional. They set
   * the u- and v-coordinates for the vertexs texture when used with
   * <a href="#/p5/endShape">endShape()</a>. By default, `u` and `v` are both 0.
   *
   * @method vertex
   * @param  {Number} x x-coordinate of the vertex.
   * @param  {Number} y y-coordinate of the vertex.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shape.
   *   strokeWeight(3);
   *
   *   // Start drawing the shape.
   *   // Only draw the vertices.
   *   beginShape(POINTS);
   *
   *   // Add the vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Four black dots that form a square are drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   *
   *   describe('A white square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(-20, -30, 0);
   *   vertex(35, -30, 0);
   *   vertex(35, 25, 0);
   *   vertex(-20, 25, 0);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   *
   *   describe('A white square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white square spins around slowly on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(-20, -30, 0);
   *   vertex(35, -30, 0);
   *   vertex(35, 25, 0);
   *   vertex(-20, 25, 0);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load an image to apply as a texture.
   *   img = await loadImage('assets/laDefense.jpg');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A photograph of a ceiling rotates slowly against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the shape.
   *   noStroke();
   *
   *   // Apply the texture.
   *   texture(img);
   *   textureMode(NORMAL);
   *
   *   // Start drawing the shape
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(-20, -30, 0, 0, 0);
   *   vertex(35, -30, 0, 1, 0);
   *   vertex(35, 25, 0, 1, 1);
   *   vertex(-20, 25, 0, 0, 1);
   *
   *   // Stop drawing the shape.
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let vid;
   * function setup() {
   *   // Load a video and create a p5.MediaElement object.
   *   vid = createVideo('/assets/fingers.mov');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Hide the video.
   *   vid.hide();
   *
   *   // Set the video to loop.
   *   vid.loop();
   *
   *   describe('A rectangle with video as texture');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Set the texture mode.
   *   textureMode(NORMAL);
   *
   *   // Apply the video as a texture.
   *   texture(vid);
   *
   *   // Draw a custom shape using uv coordinates.
   *   beginShape();
   *   vertex(-40, -40, 0, 0);
   *   vertex(40, -40, 1, 0);
   *   vertex(40, 40, 1, 1);
   *   vertex(-40, 40, 0, 1);
   *   endShape();
   * }
   * </code>
   * </div>
   */ /**
   * @method vertex
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.
   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.
   */ /**
   * @method vertex
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} z
   * @param  {Number} [u=0]   u-coordinate of the vertex's texture.
   * @param  {Number} [v=0]   v-coordinate of the vertex's texture.
   */ fn.vertex = function(x, y) {
        let z, u, v;
        // default to (x, y) mode: all other arguments assumed to be 0.
        z = u = v = 0;
        if (arguments.length === 3) {
            // (x, y, z) mode: (u, v) assumed to be 0.
            z = arguments[2];
        } else if (arguments.length === 4) {
            // (x, y, u, v) mode: z assumed to be 0.
            u = arguments[2];
            v = arguments[3];
        } else if (arguments.length === 5) {
            // (x, y, z, u, v) mode
            z = arguments[2];
            u = arguments[3];
            v = arguments[4];
        }
        this._renderer.vertex(x, y, z, u, v);
        return;
    };
    /**
   * Begins creating a hole within a flat shape.
   *
   * The `beginContour()` and <a href="#/p5/endContour">endContour()</a>
   * functions allow for creating negative space within custom shapes that are
   * flat. `beginContour()` begins adding vertices to a negative space and
   * <a href="#/p5/endContour">endContour()</a> stops adding them.
   * `beginContour()` and <a href="#/p5/endContour">endContour()</a> must be
   * called between <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * Transformations such as <a href="#/p5/translate">translate()</a>,
   * <a href="#/p5/rotate">rotate()</a>, and <a href="#/p5/scale">scale()</a>
   * don't work between `beginContour()` and
   * <a href="#/p5/endContour">endContour()</a>. It's also not possible to use
   * other shapes, such as <a href="#/p5/ellipse">ellipse()</a> or
   * <a href="#/p5/rect">rect()</a>, between `beginContour()` and
   * <a href="#/p5/endContour">endContour()</a>.
   *
   * Note: The vertices that define a negative space must "wind" in the opposite
   * direction from the outer shape. First, draw vertices for the outer shape
   * clockwise order. Then, draw vertices for the negative space in
   * counter-clockwise order.
   *
   * @method beginContour
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Exterior vertices, clockwise winding.
   *   vertex(10, 10);
   *   vertex(90, 10);
   *   vertex(90, 90);
   *   vertex(10, 90);
   *
   *   // Interior vertices, counter-clockwise winding.
   *   beginContour();
   *   vertex(30, 30);
   *   vertex(30, 70);
   *   vertex(70, 70);
   *   vertex(70, 30);
   *   endContour(CLOSE);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   *
   *   describe('A white square with a square hole in its center drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white square with a square hole in its center drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Exterior vertices, clockwise winding.
   *   vertex(-40, -40);
   *   vertex(40, -40);
   *   vertex(40, 40);
   *   vertex(-40, 40);
   *
   *   // Interior vertices, counter-clockwise winding.
   *   beginContour();
   *   vertex(-20, -20);
   *   vertex(-20, 20);
   *   vertex(20, 20);
   *   vertex(20, -20);
   *   endContour(CLOSE);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   */ fn.beginContour = function(kind) {
        this._renderer.beginContour(kind);
    };
    /**
   * Stops creating a hole within a flat shape.
   *
   * The <a href="#/p5/beginContour">beginContour()</a> and `endContour()`
   * functions allow for creating negative space within custom shapes that are
   * flat. <a href="#/p5/beginContour">beginContour()</a> begins adding vertices
   * to a negative space and `endContour()` stops adding them.
   * <a href="#/p5/beginContour">beginContour()</a> and `endContour()` must be
   * called between <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   *  By default,
   * the controur has an `OPEN` end, and to close it,
   * call `endContour(CLOSE)`. The CLOSE contour mode closes splines smoothly.
   *
   * Transformations such as <a href="#/p5/translate">translate()</a>,
   * <a href="#/p5/rotate">rotate()</a>, and <a href="#/p5/scale">scale()</a>
   * don't work between <a href="#/p5/beginContour">beginContour()</a> and
   * `endContour()`. It's also not possible to use other shapes, such as
   * <a href="#/p5/ellipse">ellipse()</a> or <a href="#/p5/rect">rect()</a>,
   * between <a href="#/p5/beginContour">beginContour()</a> and `endContour()`.
   *
   * Note: The vertices that define a negative space must "wind" in the opposite
   * direction from the outer shape. First, draw vertices for the outer shape
   * clockwise order. Then, draw vertices for the negative space in
   * counter-clockwise order.
   *
   * @method endContour
   * @param {OPEN|CLOSE} [mode=OPEN] By default, the value is OPEN
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Exterior vertices, clockwise winding.
   *   vertex(10, 10);
   *   vertex(90, 10);
   *   vertex(90, 90);
   *   vertex(10, 90);
   *
   *   // Interior vertices, counter-clockwise winding.
   *   beginContour();
   *   vertex(30, 30);
   *   vertex(30, 70);
   *   vertex(70, 70);
   *   vertex(70, 30);
   *   endContour(CLOSE);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   *
   *   describe('A white square with a square hole in its center drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white square with a square hole in its center drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Exterior vertices, clockwise winding.
   *   vertex(-40, -40);
   *   vertex(40, -40);
   *   vertex(40, 40);
   *   vertex(-40, 40);
   *
   *   // Interior vertices, counter-clockwise winding.
   *   beginContour();
   *   vertex(-20, -20);
   *   vertex(-20, 20);
   *   vertex(20, 20);
   *   vertex(20, -20);
   *   endContour(CLOSE);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   */ fn.endContour = function(mode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["O"]) {
        this._renderer.endContour(mode);
    };
}
if (typeof p5 !== 'undefined') {
    customShapes(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>primitives
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
;
;
/**
 * @module Shape
 * @submodule 2D Primitives
 * @for p5
 * @requires core
 * @requires constants
 */ function primitives(p51, fn) {
    /**
   * This function does 3 things:
   *
   *   1. Bounds the desired start/stop angles for an arc (in radians) so that:
   *
   *          0 <= start < TWO_PI ;    start <= stop < start + TWO_PI
   *
   *      This means that the arc rendering functions don't have to be concerned
   *      with what happens if stop is smaller than start, or if the arc 'goes
   *      round more than once', etc.: they can just start at start and increase
   *      until stop and the correct arc will be drawn.
   *
   *   2. Optionally adjusts the angles within each quadrant to counter the naive
   *      scaling of the underlying ellipse up from the unit circle.  Without
   *      this, the angles become arbitrary when width != height: 45 degrees
   *      might be drawn at 5 degrees on a 'wide' ellipse, or at 85 degrees on
   *      a 'tall' ellipse.
   *
   *   3. Flags up when start and stop correspond to the same place on the
   *      underlying ellipse.  This is useful if you want to do something special
   *      there (like rendering a whole ellipse instead).
   */ fn._normalizeArcAngles = (start, stop, width, height, correctForScaling)=>{
        const epsilon = 0.00001; // Smallest visible angle on displays up to 4K.
        let separation;
        // The order of the steps is important here: each one builds upon the
        // adjustments made in the steps that precede it.
        // Constrain both start and stop to [0,TWO_PI).
        start = start - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"] * Math.floor(start / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"]);
        stop = stop - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"] * Math.floor(stop / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"]);
        // Get the angular separation between the requested start and stop points.
        //
        // Technically this separation only matches what gets drawn if
        // correctForScaling is enabled.  We could add a more complicated calculation
        // for when the scaling is uncorrected (in which case the drawn points could
        // end up pushed together or pulled apart quite dramatically relative to what
        // was requested), but it would make things more opaque for little practical
        // benefit.
        //
        // (If you do disable correctForScaling and find that correspondToSamePoint
        // is set too aggressively, the easiest thing to do is probably to just make
        // epsilon smaller...)
        separation = Math.min(Math.abs(start - stop), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"] - Math.abs(start - stop));
        // Optionally adjust the angles to counter linear scaling.
        if (correctForScaling) {
            if (start <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]) {
                start = Math.atan(width / height * Math.tan(start));
            } else if (start > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"] && start <= 3 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]) {
                start = Math.atan(width / height * Math.tan(start)) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"];
            } else {
                start = Math.atan(width / height * Math.tan(start)) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"];
            }
            if (stop <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]) {
                stop = Math.atan(width / height * Math.tan(stop));
            } else if (stop > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"] && stop <= 3 * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["g"]) {
                stop = Math.atan(width / height * Math.tan(stop)) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"];
            } else {
                stop = Math.atan(width / height * Math.tan(stop)) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"];
            }
        }
        // Ensure that start <= stop < start + TWO_PI.
        if (start > stop) {
            stop += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"];
        }
        return {
            start,
            stop,
            correspondToSamePoint: separation < epsilon
        };
    };
    /**
   * Draws an arc.
   *
   * An arc is a section of an ellipse defined by the `x`, `y`, `w`, and
   * `h` parameters. `x` and `y` set the location of the arc's center. `w` and
   * `h` set the arc's width and height. See
   * <a href="#/p5/ellipse">ellipse()</a> and
   * <a href="#/p5/ellipseMode">ellipseMode()</a> for more details.
   *
   * The fifth and sixth parameters, `start` and `stop`, set the angles
   * between which to draw the arc. Arcs are always drawn clockwise from
   * `start` to `stop`. Angles are always given in radians.
   *
   * The seventh parameter, `mode`, is optional. It determines the arc's fill
   * style. The fill modes are a semi-circle (`OPEN`), a closed semi-circle
   * (`CHORD`), or a closed pie segment (`PIE`).
   *
   * The eighth parameter, `detail`, is also optional. It determines how many
   * vertices are used to draw the arc in WebGL mode. The default value is 25.
   *
   * @method arc
   * @param  {Number} x      x-coordinate of the arc's ellipse.
   * @param  {Number} y      y-coordinate of the arc's ellipse.
   * @param  {Number} w      width of the arc's ellipse by default.
   * @param  {Number} h      height of the arc's ellipse by default.
   * @param  {Number} start  angle to start the arc, specified in radians.
   * @param  {Number} stop   angle to stop the arc, specified in radians.
   * @param  {(CHORD|PIE|OPEN)} [mode] optional parameter to determine the way of drawing
   *                         the arc. either CHORD, PIE, or OPEN.
   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to
   *                         specify the number of vertices that makes up the
   *                         perimeter of the arc. Default value is 25. Won't
   *                         draw a stroke for a detail of more than 50.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   arc(50, 50, 80, 80, 0, PI + HALF_PI);
   *
   *   describe('A white circle on a gray canvas. The top-right quarter of the circle is missing.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   arc(50, 50, 80, 40, 0, PI + HALF_PI);
   *
   *   describe('A white ellipse on a gray canvas. The top-right quarter of the ellipse is missing.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Bottom-right.
   *   arc(50, 55, 50, 50, 0, HALF_PI);
   *
   *   noFill();
   *
   *   // Bottom-left.
   *   arc(50, 55, 60, 60, HALF_PI, PI);
   *
   *   // Top-left.
   *   arc(50, 55, 70, 70, PI, PI + QUARTER_PI);
   *
   *   // Top-right.
   *   arc(50, 55, 80, 80, PI + QUARTER_PI, TWO_PI);
   *
   *   describe(
   *     'A shattered outline of an circle with a quarter of a white circle at the bottom-right.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Default fill mode.
   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI);
   *
   *   describe('A white circle with the top-right third missing. The bottom is outlined in black.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // OPEN fill mode.
   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, OPEN);
   *
   *   describe(
   *     'A white circle missing a section from the top-right. The bottom is outlined in black.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // CHORD fill mode.
   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, CHORD);
   *
   *   describe('A white circle with a black outline missing a section from the top-right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // PIE fill mode.
   *   arc(50, 50, 80, 80, 0, PI + QUARTER_PI, PIE);
   *
   *   describe('A white circle with a black outline. The top-right third is missing.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // PIE fill mode.
   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE);
   *
   *   describe('A white circle with a black outline. The top-right third is missing.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // PIE fill mode with 5 vertices.
   *   arc(0, 0, 80, 80, 0, PI + QUARTER_PI, PIE, 5);
   *
   *   describe('A white circle with a black outline. The top-right third is missing.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A yellow circle on a black background. The circle opens and closes its mouth.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Style the arc.
   *   noStroke();
   *   fill(255, 255, 0);
   *
   *   // Update start and stop angles.
   *   let biteSize = PI / 16;
   *   let startAngle = biteSize * sin(frameCount * 0.1) + biteSize;
   *   let endAngle = TWO_PI - startAngle;
   *
   *   // Draw the arc.
   *   arc(50, 50, 80, 80, startAngle, endAngle, PIE);
   * }
   * </code>
   * </div>
   */ fn.arc = function(x, y, w, h, start, stop, mode, detail) {
        // this.validate("p5.arc", arguments);
        // p5._validateParameters('arc', arguments);
        // if the current stroke and fill settings wouldn't result in something
        // visible, exit immediately
        if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
            return this;
        }
        if (start === stop) {
            return this;
        }
        start = this._toRadians(start);
        stop = this._toRadians(stop);
        const vals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
        const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);
        if (angles.correspondToSamePoint) {
            // If the arc starts and ends at (near enough) the same place, we choose to
            // draw an ellipse instead.  This is preferable to faking an ellipse (by
            // making stop ever-so-slightly less than start + TWO_PI) because the ends
            // join up to each other rather than at a vertex at the centre (leaving
            // an unwanted spike in the stroke/fill).
            this._renderer.ellipse([
                vals.x,
                vals.y,
                vals.w,
                vals.h,
                detail
            ]);
        } else {
            this._renderer.arc(vals.x, vals.y, vals.w, vals.h, angles.start, angles.stop, mode, detail);
            //accessible Outputs
            if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
                this._accsOutput('arc', [
                    vals.x,
                    vals.y,
                    vals.w,
                    vals.h,
                    angles.start,
                    angles.stop,
                    mode
                ]);
            }
        }
        return this;
    };
    /**
   * Draws an ellipse (oval).
   *
   * An ellipse is a round shape defined by the `x`, `y`, `w`, and
   * `h` parameters. `x` and `y` set the location of its center. `w` and
   * `h` set its width and height. See
   * <a href="#/p5/ellipseMode">ellipseMode()</a> for other ways to set
   * its position.
   *
   * If no height is set, the value of width is used for both the width and
   * height. If a negative height or width is specified, the absolute value is
   * taken.
   *
   * The fifth parameter, `detail`, is also optional. It determines how many
   * vertices are used to draw the ellipse in WebGL mode. The default value is
   * 25.
   *
   * @method ellipse
   * @param  {Number} x x-coordinate of the center of the ellipse.
   * @param  {Number} y y-coordinate of the center of the ellipse.
   * @param  {Number} w width of the ellipse.
   * @param  {Number} [h] height of the ellipse.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   ellipse(50, 50, 80, 80);
   *
   *   describe('A white circle on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   ellipse(50, 50, 80);
   *
   *   describe('A white circle on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   ellipse(50, 50, 80, 40);
   *
   *   describe('A white ellipse on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   ellipse(0, 0, 80, 40);
   *
   *   describe('A white ellipse on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Use 6 vertices.
   *   ellipse(0, 0, 80, 40, 6);
   *
   *   describe('A white hexagon on a gray canvas.');
   * }
   * </code>
   * </div>
   */ /**
   * @method ellipse
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} w
   * @param  {Number} h
   * @param  {Integer} [detail] optional parameter for WebGL mode only. This is to
   *                         specify the number of vertices that makes up the
   *                         perimeter of the ellipse. Default value is 25. Won't
   *                         draw a stroke for a detail of more than 50.
   */ fn.ellipse = function(x, y, w, h, detailX) {
        // p5._validateParameters('ellipse', arguments);
        return this._renderEllipse(...arguments);
    };
    /**
   * Draws a circle.
   *
   * A circle is a round shape defined by the `x`, `y`, and `d` parameters.
   * `x` and `y` set the location of its center. `d` sets its width and height (diameter).
   * Every point on the circle's edge is the same distance, `0.5 * d`, from its center.
   * `0.5 * d` (half the diameter) is the circle's radius.
   * See <a href="#/p5/ellipseMode">ellipseMode()</a> for other ways to set its position.
   *
   * @method circle
   * @param  {Number} x  x-coordinate of the center of the circle.
   * @param  {Number} y  y-coordinate of the center of the circle.
   * @param  {Number} d  diameter of the circle.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   circle(50, 50, 25);
   *
   *   describe('A white circle with black outline in the middle of a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   circle(0, 0, 25);
   *
   *   describe('A white circle with black outline in the middle of a gray canvas.');
   * }
   * </code>
   * </div>
   */ fn.circle = function(...args) {
        // p5._validateParameters('circle', args);
        const argss = args.slice(0, 2);
        argss.push(args[2], args[2]);
        return this._renderEllipse(...argss);
    };
    // internal method for drawing ellipses (without parameter validation)
    fn._renderEllipse = function(x, y, w, h, detailX) {
        // if the current stroke and fill settings wouldn't result in something
        // visible, exit immediately
        if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
            return this;
        }
        // Duplicate 3rd argument if only 3 given.
        if (typeof h === 'undefined') {
            h = w;
        }
        const vals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
        this._renderer.ellipse([
            vals.x,
            vals.y,
            vals.w,
            vals.h,
            detailX
        ]);
        //accessible Outputs
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
            this._accsOutput('ellipse', [
                vals.x,
                vals.y,
                vals.w,
                vals.h
            ]);
        }
        return this;
    };
    /**
   * Draws a straight line between two points.
   *
   * A line's default width is one pixel. The version of `line()` with four
   * parameters draws the line in 2D. To color a line, use the
   * <a href="#/p5/stroke">stroke()</a> function. To change its width, use the
   * <a href="#/p5/strokeWeight">strokeWeight()</a> function. A line
   * can't be filled, so the <a href="#/p5/fill">fill()</a> function won't
   * affect the line's color.
   *
   * The version of `line()` with six parameters allows the line to be drawn in
   * 3D space. Doing so requires adding the `WEBGL` argument to
   * <a href="#/p5/createCanvas">createCanvas()</a>.
   *
   * @method line
   * @param  {Number} x1 the x-coordinate of the first point.
   * @param  {Number} y1 the y-coordinate of the first point.
   * @param  {Number} x2 the x-coordinate of the second point.
   * @param  {Number} y2 the y-coordinate of the second point.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   line(30, 20, 85, 75);
   *
   *   describe(
   *     'A black line on a gray canvas running from top-center to bottom-right.'
   *   );
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the line.
   *   stroke('magenta');
   *   strokeWeight(5);
   *
   *   line(30, 20, 85, 75);
   *
   *   describe(
   *     'A thick, magenta line on a gray canvas running from top-center to bottom-right.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top.
   *   line(30, 20, 85, 20);
   *
   *   // Right.
   *   stroke(126);
   *   line(85, 20, 85, 75);
   *
   *   // Bottom.
   *   stroke(255);
   *   line(85, 75, 30, 75);
   *
   *   describe(
   *     'Three lines drawn in grayscale on a gray canvas. They form the top, right, and bottom sides of a square.'
   *   );
   * }
   * </code>
   * </div>
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   line(-20, -30, 35, 25);
   *
   *   describe(
   *     'A black line on a gray canvas running from top-center to bottom-right.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A black line connecting two spheres. The scene spins slowly.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw a line.
   *   line(0, 0, 0, 30, 20, -10);
   *
   *   // Draw the center sphere.
   *   sphere(10);
   *
   *   // Translate to the second point.
   *   translate(30, 20, -10);
   *
   *   // Draw the bottom-right sphere.
   *   sphere(10);
   * }
   * </code>
   * </div>
   *
   */ /**
   * @method line
   * @param  {Number} x1
   * @param  {Number} y1
   * @param  {Number} z1 the z-coordinate of the first point.
   * @param  {Number} x2
   * @param  {Number} y2
   * @param  {Number} z2 the z-coordinate of the second point.
   * @chainable
   */ fn.line = function(...args) {
        // p5._validateParameters('line', args);
        if (this._renderer.states.strokeColor) {
            this._renderer.line(...args);
        }
        //accessible Outputs
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
            this._accsOutput('line', args);
        }
        return this;
    };
    /**
   * Draws a single point in space.
   *
   * A point's default width is one pixel. To color a point, use the
   * <a href="#/p5/stroke">stroke()</a> function. To change its width, use the
   * <a href="#/p5/strokeWeight">strokeWeight()</a> function. A point
   * can't be filled, so the <a href="#/p5/fill">fill()</a> function won't
   * affect the point's color.
   *
   * The version of `point()` with two parameters allows the point's location to
   * be set with its x- and y-coordinates, as in `point(10, 20)`.
   *
   * The version of `point()` with three parameters allows the point to be drawn
   * in 3D space with x-, y-, and z-coordinates, as in `point(10, 20, 30)`.
   * Doing so requires adding the `WEBGL` argument to
   * <a href="#/p5/createCanvas">createCanvas()</a>.
   *
   * The version of `point()` with one parameter allows the point's location to
   * be set with a <a href="#/p5/p5.Vector">p5.Vector</a> object.
   *
   * @method point
   * @param  {Number} x the x-coordinate.
   * @param  {Number} y the y-coordinate.
   * @param  {Number} [z] the z-coordinate (for WebGL mode).
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *   
   *   // Making point to 5 pixels
   *   strokeWeight(5);
   * 
   *   // Top-left.
   *   point(30, 20);
   *
   *   // Top-right.
   *   point(85, 20);
   *
   *   // Bottom-right.
   *   point(85, 75);
   *
   *   // Bottom-left.
   *   point(30, 75);
   *
   *   describe(
   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   * 
   *   // Making point to 5 pixels.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   point(30, 20);
   *
   *   // Top-right.
   *   point(70, 20);
   *
   *   // Style the next points.
   *   stroke('purple');
   *   strokeWeight(10);
   *
   *   // Bottom-right.
   *   point(70, 80);
   *
   *   // Bottom-left.
   *   point(30, 80);
   *
   *   describe(
   *     'Four points drawn on a gray canvas. Two are black and two are purple. The points form the corners of a square.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   * 
   *   // Making point to 5 pixels.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let a = createVector(30, 20);
   *   point(a);
   *
   *   // Top-right.
   *   let b = createVector(70, 20);
   *   point(b);
   *
   *   // Bottom-right.
   *   let c = createVector(70, 80);
   *   point(c);
   *
   *   // Bottom-left.
   *   let d = createVector(30, 80);
   *   point(d);
   *
   *   describe(
   *     'Four small, black points drawn on a gray canvas. The points form the corners of a square.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('Two purple points drawn on a gray canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the points.
   *   stroke('purple');
   *   strokeWeight(10);
   *
   *   // Top-left.
   *   point(-20, -30);
   *
   *   // Bottom-right.
   *   point(20, 30);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('Two purple points drawn on a gray canvas. The scene spins slowly.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the points.
   *   stroke('purple');
   *   strokeWeight(10);
   *
   *   // Top-left.
   *   point(-20, -30, 0);
   *
   *   // Bottom-right.
   *   point(20, 30, -50);
   * }
   * </code>
   * </div>
   */ /**
   * @method point
   * @param {p5.Vector} coordinateVector the coordinate vector.
   * @chainable
   */ fn.point = function(...args) {
        // p5._validateParameters('point', args);
        if (this._renderer.states.strokeColor) {
            if (args.length === 1 && args[0] instanceof p51.Vector) {
                this._renderer.point.call(this._renderer, args[0].x, args[0].y, args[0].z);
            } else {
                this._renderer.point(...args);
                //accessible Outputs
                if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
                    this._accsOutput('point', args);
                }
            }
        }
        return this;
    };
    /**
   * Draws a quadrilateral (four-sided shape).
   *
   * Quadrilaterals include rectangles, squares, rhombuses, and trapezoids. The
   * first pair of parameters `(x1, y1)` sets the quad's first point. The next
   * three pairs of parameters set the coordinates for its next three points
   * `(x2, y2)`, `(x3, y3)`, and `(x4, y4)`. Points should be added in either
   * clockwise or counter-clockwise order.
   *
   * The version of `quad()` with twelve parameters allows the quad to be drawn
   * in 3D space. Doing so requires adding the `WEBGL` argument to
   * <a href="#/p5/createCanvas">createCanvas()</a>.
   *
   * The thirteenth and fourteenth parameters are optional. In WebGL mode, they
   * set the number of segments used to draw the quadrilateral in the x- and
   * y-directions. They're both 2 by default.
   *
   * @method quad
   * @param {Number} x1 the x-coordinate of the first point.
   * @param {Number} y1 the y-coordinate of the first point.
   * @param {Number} x2 the x-coordinate of the second point.
   * @param {Number} y2 the y-coordinate of the second point.
   * @param {Number} x3 the x-coordinate of the third point.
   * @param {Number} y3 the y-coordinate of the third point.
   * @param {Number} x4 the x-coordinate of the fourth point.
   * @param {Number} y4 the y-coordinate of the fourth point.
   * @param {Integer} [detailX] number of segments in the x-direction.
   * @param {Integer} [detailY] number of segments in the y-direction.
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   quad(20, 20, 80, 20, 80, 80, 20, 80);
   *
   *   describe('A white square with a black outline drawn on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   quad(20, 30, 80, 30, 80, 70, 20, 70);
   *
   *   describe('A white rectangle with a black outline drawn on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   quad(50, 62, 86, 50, 50, 38, 14, 50);
   *
   *   describe('A white rhombus with a black outline drawn on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   quad(20, 50, 80, 30, 80, 70, 20, 70);
   *
   *   describe('A white trapezoid with a black outline drawn on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   quad(-30, -30, 30, -30, 30, 30, -30, 30);
   *
   *   describe('A white square with a black outline drawn on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A wavy white surface spins around on gray canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the quad.
   *   quad(-30, -30, 0, 30, -30, 0, 30, 30, 20, -30, 30, -20);
   * }
   * </code>
   * </div>
   */ /**
   * @method quad
   * @param {Number} x1
   * @param {Number} y1
   * @param {Number} z1 the z-coordinate of the first point.
   * @param {Number} x2
   * @param {Number} y2
   * @param {Number} z2 the z-coordinate of the second point.
   * @param {Number} x3
   * @param {Number} y3
   * @param {Number} z3 the z-coordinate of the third point.
   * @param {Number} x4
   * @param {Number} y4
   * @param {Number} z4 the z-coordinate of the fourth point.
   * @param {Integer} [detailX]
   * @param {Integer} [detailY]
   * @chainable
   */ fn.quad = function(...args) {
        // p5._validateParameters('quad', args);
        if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
            if (this._renderer.isP3D && args.length < 12) {
                // if 3D and we weren't passed 12 args, assume Z is 0
                this._renderer.quad.call(this._renderer, args[0], args[1], 0, args[2], args[3], 0, args[4], args[5], 0, args[6], args[7], 0, args[8], args[9]);
            } else {
                this._renderer.quad(...args);
                //accessibile outputs
                if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
                    this._accsOutput('quadrilateral', args);
                }
            }
        }
        return this;
    };
    /**
   * Draws a rectangle.
   *
   * A rectangle is a four-sided shape defined by the `x`, `y`, `w`, and `h`
   * parameters. `x` and `y` set the location of its top-left corner. `w` sets
   * its width and `h` sets its height. Every angle in the rectangle measures
   * 90. See <a href="#/p5/rectMode">rectMode()</a> for other ways to define
   * rectangles.
   *
   * The version of `rect()` with five parameters creates a rounded rectangle. The
   * fifth parameter sets the radius for all four corners.
   *
   * The version of `rect()` with eight parameters also creates a rounded
   * rectangle. Each of the last four parameters set the radius of a corner. The
   * radii start with the top-left corner and move clockwise around the
   * rectangle. If any of these parameters are omitted, they are set to the
   * value of the last radius that was set.
   *
   * @method rect
   * @param  {Number} x  x-coordinate of the rectangle.
   * @param  {Number} y  y-coordinate of the rectangle.
   * @param  {Number} w  width of the rectangle.
   * @param  {Number} [h]  height of the rectangle.
   * @param  {Number} [tl] optional radius of top-left corner.
   * @param  {Number} [tr] optional radius of top-right corner.
   * @param  {Number} [br] optional radius of bottom-right corner.
   * @param  {Number} [bl] optional radius of bottom-left corner.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rect(30, 20, 55, 55);
   *
   *   describe('A white square with a black outline on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rect(30, 20, 55, 40);
   *
   *   describe('A white rectangle with a black outline on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Give all corners a radius of 20.
   *   rect(30, 20, 55, 50, 20);
   *
   *   describe('A white rectangle with a black outline and round edges on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Give each corner a unique radius.
   *   rect(30, 20, 55, 50, 20, 15, 10, 5);
   *
   *   describe('A white rectangle with a black outline and round edges of different radii.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   rect(-20, -30, 55, 55);
   *
   *   describe('A white square with a black outline on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white square spins around on gray canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the rectangle.
   *   rect(-20, -30, 55, 55);
   * }
   * </code>
   * </div>
   */ /**
   * @method rect
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} w
   * @param  {Number} h
   * @param  {Integer} [detailX] number of segments in the x-direction (for WebGL mode).
   * @param  {Integer} [detailY] number of segments in the y-direction (for WebGL mode).
   * @chainable
   */ fn.rect = function(...args) {
        // p5._validateParameters('rect', args);
        return this._renderRect(...args);
    };
    /**
   * Draws a square.
   *
   * A square is a four-sided shape defined by the `x`, `y`, and `s`
   * parameters. `x` and `y` set the location of its top-left corner. `s` sets
   * its width and height. Every angle in the square measures 90 and all its
   * sides are the same length. See <a href="#/p5/rectMode">rectMode()</a> for
   * other ways to define squares.
   *
   * The version of `square()` with four parameters creates a rounded square.
   * The fourth parameter sets the radius for all four corners.
   *
   * The version of `square()` with seven parameters also creates a rounded
   * square. Each of the last four parameters set the radius of a corner. The
   * radii start with the top-left corner and move clockwise around the
   * square. If any of these parameters are omitted, they are set to the
   * value of the last radius that was set.
   *
   * @method square
   * @param  {Number} x  x-coordinate of the square.
   * @param  {Number} y  y-coordinate of the square.
   * @param  {Number} s  side size of the square.
   * @param  {Number} [tl] optional radius of top-left corner.
   * @param  {Number} [tr] optional radius of top-right corner.
   * @param  {Number} [br] optional radius of bottom-right corner.
   * @param  {Number} [bl] optional radius of bottom-left corner.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   square(30, 20, 55);
   *
   *   describe('A white square with a black outline in on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Give all corners a radius of 20.
   *   square(30, 20, 55, 20);
   *
   *   describe(
   *     'A white square with a black outline and round edges on a gray canvas.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Give each corner a unique radius.
   *   square(30, 20, 55, 20, 15, 10, 5);
   *
   *   describe('A white square with a black outline and round edges of different radii.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   square(-20, -30, 55);
   *
   *   describe('A white square with a black outline in on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white square spins around on gray canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the square.
   *   square(-20, -30, 55);
   * }
   * </code>
   * </div>
   */ fn.square = function(x, y, s, tl, tr, br, bl) {
        // p5._validateParameters('square', arguments);
        // duplicate width for height in case of square
        return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);
    };
    // internal method to have renderer draw a rectangle
    fn._renderRect = function() {
        if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
            // duplicate width for height in case only 3 arguments is provided
            if (arguments.length === 3) {
                arguments[3] = arguments[2];
            }
            const vals = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer.states.rectMode);
            // For the default rectMode (CORNER), restore a possible negative width/height
            // removed by modeAdjust(). This results in flipped/mirrored rendering,
            // which is especially noticable when using WEGBL rendering and texture().
            // Note that this behavior only applies to rect(), NOT to ellipse() and arc().
            if (this._renderer.states.rectMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"]) {
                vals.w = arguments[2];
                vals.h = arguments[3];
            }
            const args = [
                vals.x,
                vals.y,
                vals.w,
                vals.h
            ];
            // append the additional arguments (either cornder radii, or
            // segment details) to the argument list
            for(let i = 4; i < arguments.length; i++){
                args[i] = arguments[i];
            }
            this._renderer.rect(args);
            //accessible outputs
            if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
                this._accsOutput('rectangle', [
                    vals.x,
                    vals.y,
                    vals.w,
                    vals.h
                ]);
            }
        }
        return this;
    };
    /**
   * Draws a triangle.
   *
   * A triangle is a three-sided shape defined by three points. The
   * first two parameters specify the triangle's first point `(x1, y1)`. The
   * middle two parameters specify its second point `(x2, y2)`. And the last two
   * parameters specify its third point `(x3, y3)`.
   *
   * @method triangle
   * @param  {Number} x1 x-coordinate of the first point.
   * @param  {Number} y1 y-coordinate of the first point.
   * @param  {Number} x2 x-coordinate of the second point.
   * @param  {Number} y2 y-coordinate of the second point.
   * @param  {Number} x3 x-coordinate of the third point.
   * @param  {Number} y3 y-coordinate of the third point.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   triangle(30, 75, 58, 20, 86, 75);
   *
   *   describe('A white triangle with a black outline on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   triangle(-20, 25, 8, -30, 36, 25);
   *
   *   describe('A white triangle with a black outline on a gray canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white triangle spins around on a gray canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the triangle.
   *   triangle(-20, 25, 8, -30, 36, 25);
   * }
   * </code>
   * </div>
   */ fn.triangle = function(...args) {
        // p5._validateParameters('triangle', args);
        if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
            this._renderer.triangle(args);
        }
        //accessible outputs
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
            this._accsOutput('triangle', args);
        }
        return this;
    };
}
if (typeof p5 !== 'undefined') {
    primitives(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>attributes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
;
/**
 * @module Shape
 * @submodule Attributes
 * @for p5
 * @requires core
 * @requires constants
 */ function attributes(p51, fn) {
    /**
   * Changes where ellipses, circles, and arcs are drawn.
   *
   * By default, the first two parameters of
   * <a href="#/p5/ellipse">ellipse()</a>, <a href="#/p5/circle">circle()</a>,
   * and <a href="#/p5/arc">arc()</a>
   * are the x- and y-coordinates of the shape's center. The next parameters set
   * the shape's width and height. This is the same as calling
   * `ellipseMode(CENTER)`.
   *
   * `ellipseMode(RADIUS)` also uses the first two parameters to set the x- and
   * y-coordinates of the shape's center. The next parameters are half of the
   * shapes's width and height. Calling `ellipse(0, 0, 10, 15)` draws a shape
   * with a width of 20 and height of 30.
   *
   * `ellipseMode(CORNER)` uses the first two parameters as the upper-left
   * corner of the shape. The next parameters are its width and height.
   *
   * `ellipseMode(CORNERS)` uses the first two parameters as the location of one
   * corner of the ellipse's bounding box. The next parameters are the location
   * of the opposite corner.
   *
   * The argument passed to `ellipseMode()` must be written in ALL CAPS because
   * the constants `CENTER`, `RADIUS`, `CORNER`, and `CORNERS` are defined this
   * way. JavaScript is a case-sensitive language.
   *
   * @method ellipseMode
   * @param  {(CENTER|RADIUS|CORNER|CORNERS)} mode either CENTER, RADIUS, CORNER, or CORNERS
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // White ellipse.
   *   ellipseMode(RADIUS);
   *   fill(255);
   *   ellipse(50, 50, 30, 30);
   *
   *   // Gray ellipse.
   *   ellipseMode(CENTER);
   *   fill(100);
   *   ellipse(50, 50, 30, 30);
   *
   *   describe('A white circle with a gray circle at its center. Both circles have black outlines.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // White ellipse.
   *   ellipseMode(CORNER);
   *   fill(255);
   *   ellipse(25, 25, 50, 50);
   *
   *   // Gray ellipse.
   *   ellipseMode(CORNERS);
   *   fill(100);
   *   ellipse(25, 25, 50, 50);
   *
   *   describe('A white circle with a gray circle at its top-left corner. Both circles have black outlines.');
   * }
   * </code>
   * </div>
   */ fn.ellipseMode = function(m) {
        // p5._validateParameters('ellipseMode', arguments);
        if (m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]) {
            this._renderer.states.setValue('ellipseMode', m);
        }
        return this;
    };
    /**
   * Draws certain features with jagged (aliased) edges.
   *
   * <a href="#/p5/smooth">smooth()</a> is active by default. In 2D mode,
   * `noSmooth()` is helpful for scaling up images without blurring. The
   * functions don't affect shapes or fonts.
   *
   * In WebGL mode, `noSmooth()` causes all shapes to be drawn with jagged
   * (aliased) edges. The functions don't affect images or fonts.
   *
   * @method noSmooth
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let heart;
   *
   * async function setup() {
   *   // Load a pixelated heart image from an image data string.
   *   heart = await loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAEZJREFUGFd9jcsNACAIQ9tB2MeR3YdBMBBq8CIXPi2vBICIiOwkOedatllqWO6Y8yOWoyuNf1GZwgmf+RRG2YXr+xVFmA8HZ9Mx/KGPMtcAAAAASUVORK5CYII=');
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Antialiased hearts.
   *   image(heart, 10, 10);
   *   image(heart, 20, 10, 16, 16);
   *   image(heart, 40, 10, 32, 32);
   *
   *   // Aliased hearts.
   *   noSmooth();
   *   image(heart, 10, 60);
   *   image(heart, 20, 60, 16, 16);
   *   image(heart, 40, 60, 32, 32);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   circle(0, 0, 80);
   *
   *   describe('A white circle on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Disable smoothing.
   *   noSmooth();
   *
   *   background(200);
   *
   *   circle(0, 0, 80);
   *
   *   describe('A pixelated white circle on a gray background.');
   * }
   * </code>
   * </div>
   */ fn.noSmooth = function() {
        if (!this._renderer.isP3D) {
            if ('imageSmoothingEnabled' in this.drawingContext) {
                this.drawingContext.imageSmoothingEnabled = false;
            }
        } else {
            this.setAttributes('antialias', false);
        }
        return this;
    };
    /**
   * Changes where rectangles and squares are drawn.
   *
   * By default, the first two parameters of
   * <a href="#/p5/rect">rect()</a> and <a href="#/p5/square">square()</a>,
   * are the x- and y-coordinates of the shape's upper left corner. The next parameters set
   * the shape's width and height. This is the same as calling
   * `rectMode(CORNER)`.
   *
   * `rectMode(CORNERS)` also uses the first two parameters as the location of
   * one of the corners. The next parameters are the location of the opposite
   * corner. This mode only works for <a href="#/p5/rect">rect()</a>.
   *
   * `rectMode(CENTER)` uses the first two parameters as the x- and
   * y-coordinates of the shape's center. The next parameters are its width and
   * height.
   *
   * `rectMode(RADIUS)` also uses the first two parameters as the x- and
   * y-coordinates of the shape's center. The next parameters are
   * half of the shape's width and height.
   *
   * The argument passed to `rectMode()` must be written in ALL CAPS because the
   * constants `CENTER`, `RADIUS`, `CORNER`, and `CORNERS` are defined this way.
   * JavaScript is a case-sensitive language.
   *
   * @method rectMode
   * @param  {(CENTER|RADIUS|CORNER|CORNERS)} mode either CORNER, CORNERS, CENTER, or RADIUS
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rectMode(CORNER);
   *   fill(255);
   *   rect(25, 25, 50, 50);
   *
   *   rectMode(CORNERS);
   *   fill(100);
   *   rect(25, 25, 50, 50);
   *
   *   describe('A small gray square drawn at the top-left corner of a white square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rectMode(RADIUS);
   *   fill(255);
   *   rect(50, 50, 30, 30);
   *
   *   rectMode(CENTER);
   *   fill(100);
   *   rect(50, 50, 30, 30);
   *
   *   describe('A small gray square drawn at the center of a white square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rectMode(CORNER);
   *   fill(255);
   *   square(25, 25, 50);
   *
   *   describe('A white square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   rectMode(RADIUS);
   *   fill(255);
   *   square(50, 50, 30);
   *
   *   rectMode(CENTER);
   *   fill(100);
   *   square(50, 50, 30);
   *
   *   describe('A small gray square drawn at the center of a white square.');
   * }
   * </code>
   * </div>
   */ fn.rectMode = function(m) {
        // p5._validateParameters('rectMode', arguments);
        if (m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"] || m === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["C"]) {
            this._renderer.states.setValue('rectMode', m);
        }
        return this; // return current rectMode ?
    };
    /**
   * Draws certain features with smooth (antialiased) edges.
   *
   * `smooth()` is active by default. In 2D mode,
   * <a href="#/p5/noSmooth">noSmooth()</a> is helpful for scaling up images
   * without blurring. The functions don't affect shapes or fonts.
   *
   * In WebGL mode, <a href="#/p5/noSmooth">noSmooth()</a> causes all shapes to
   * be drawn with jagged (aliased) edges. The functions don't affect images or
   * fonts.
   *
   * @method smooth
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let heart;
   *
   * async function setup() {
   *   // Load a pixelated heart image from an image data string.
   *   heart = await loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAYAAADEUlfTAAAAAXNSR0IArs4c6QAAAEZJREFUGFd9jcsNACAIQ9tB2MeR3YdBMBBq8CIXPi2vBICIiOwkOedatllqWO6Y8yOWoyuNf1GZwgmf+RRG2YXr+xVFmA8HZ9Mx/KGPMtcAAAAASUVORK5CYII=');
   *
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Antialiased hearts.
   *   image(heart, 10, 10);
   *   image(heart, 20, 10, 16, 16);
   *   image(heart, 40, 10, 32, 32);
   *
   *   // Aliased hearts.
   *   noSmooth();
   *   image(heart, 10, 60);
   *   image(heart, 20, 60, 16, 16);
   *   image(heart, 40, 60, 32, 32);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   circle(0, 0, 80);
   *
   *   describe('A white circle on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Disable smoothing.
   *   noSmooth();
   *
   *   background(200);
   *
   *   circle(0, 0, 80);
   *
   *   describe('A pixelated white circle on a gray background.');
   * }
   * </code>
   * </div>
   */ fn.smooth = function() {
        if (!this._renderer.isP3D) {
            if ('imageSmoothingEnabled' in this.drawingContext) {
                this.drawingContext.imageSmoothingEnabled = true;
            }
        } else {
            this.setAttributes('antialias', true);
        }
        return this;
    };
    /**
   * Sets the style for rendering the ends of lines.
   *
   * The caps for line endings are either rounded (`ROUND`), squared
   * (`SQUARE`), or extended (`PROJECT`). The default cap is `ROUND`.
   *
   * The argument passed to `strokeCap()` must be written in ALL CAPS because
   * the constants `ROUND`, `SQUARE`, and `PROJECT` are defined this way.
   * JavaScript is a case-sensitive language.
   *
   * @method strokeCap
   * @param  {(ROUND|SQUARE|PROJECT)} cap either ROUND, SQUARE, or PROJECT
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   strokeWeight(12);
   *
   *   // Top.
   *   strokeCap(ROUND);
   *   line(20, 30, 80, 30);
   *
   *   // Middle.
   *   strokeCap(SQUARE);
   *   line(20, 50, 80, 50);
   *
   *   // Bottom.
   *   strokeCap(PROJECT);
   *   line(20, 70, 80, 70);
   *
   *   describe(
   *     'Three horizontal lines. The top line has rounded ends, the middle line has squared ends, and the bottom line has longer, squared ends.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.strokeCap = function(cap) {
        // p5._validateParameters('strokeCap', arguments);
        if (cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"] || cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"] || cap === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["k"]) {
            this._renderer.strokeCap(cap);
        }
        return this;
    };
    /**
   * Sets the style of the joints that connect line segments.
   *
   * Joints are either mitered (`MITER`), beveled (`BEVEL`), or rounded
   * (`ROUND`). The default joint is `MITER` in 2D mode and `ROUND` in WebGL
   * mode.
   *
   * The argument passed to `strokeJoin()` must be written in ALL CAPS because
   * the constants `MITER`, `BEVEL`, and `ROUND` are defined this way.
   * JavaScript is a case-sensitive language.
   *
   * @method strokeJoin
   * @param  {(MITER|BEVEL|ROUND)} join either MITER, BEVEL, or ROUND
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the line.
   *   noFill();
   *   strokeWeight(10);
   *   strokeJoin(MITER);
   *
   *   // Draw the line.
   *   beginShape();
   *   vertex(35, 20);
   *   vertex(65, 50);
   *   vertex(35, 80);
   *   endShape();
   *
   *   describe('A right-facing arrowhead shape with a pointed tip in center of canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the line.
   *   noFill();
   *   strokeWeight(10);
   *   strokeJoin(BEVEL);
   *
   *   // Draw the line.
   *   beginShape();
   *   vertex(35, 20);
   *   vertex(65, 50);
   *   vertex(35, 80);
   *   endShape();
   *
   *   describe('A right-facing arrowhead shape with a flat tip in center of canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the line.
   *   noFill();
   *   strokeWeight(10);
   *   strokeJoin(ROUND);
   *
   *   // Draw the line.
   *   beginShape();
   *   vertex(35, 20);
   *   vertex(65, 50);
   *   vertex(35, 80);
   *   endShape();
   *
   *   describe('A right-facing arrowhead shape with a rounded tip in center of canvas.');
   * }
   * </code>
   * </div>
   */ fn.strokeJoin = function(join) {
        // p5._validateParameters('strokeJoin', arguments);
        if (join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["j"] || join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"] || join === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"]) {
            this._renderer.strokeJoin(join);
        }
        return this;
    };
    /**
   * Sets the width of the stroke used for points, lines, and the outlines of
   * shapes.
   *
   * Note: `strokeWeight()` is affected by transformations, especially calls to
   * <a href="#/p5/scale">scale()</a>.
   *
   * @method strokeWeight
   * @param  {Number} weight the weight of the stroke (in pixels).
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top.
   *   line(20, 20, 80, 20);
   *
   *   // Middle.
   *   strokeWeight(4);
   *   line(20, 40, 80, 40);
   *
   *   // Bottom.
   *   strokeWeight(10);
   *   line(20, 70, 80, 70);
   *
   *   describe('Three horizontal black lines. The top line is thin, the middle is medium, and the bottom is thick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top.
   *   line(20, 20, 80, 20);
   *
   *   // Scale by a factor of 5.
   *   scale(5);
   *
   *   // Bottom. Coordinates are adjusted for scaling.
   *   line(4, 8, 16, 8);
   *
   *   describe('Two horizontal black lines. The top line is thin and the bottom is five times thicker than the top.');
   * }
   * </code>
   * </div>
   */ fn.strokeWeight = function(w) {
        // p5._validateParameters('strokeWeight', arguments);
        this._renderer.strokeWeight(w);
        return this;
    };
}
if (typeof p5 !== 'undefined') {
    attributes(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>curves
]);
/**
 * @module Shape
 * @submodule Curves
 * @for p5
 * @requires core
 */ function curves(p51, fn) {
    /**
   * Draws a Bzier curve.
   *
   * Bzier curves can form shapes and curves that slope gently. They're defined
   * by two anchor points and two control points. Bzier curves provide more
   * control than the spline curves created with the
   * <a href="#/p5/spline">spline()</a> function.
   *
   * The first two parameters, `x1` and `y1`, set the first anchor point. The
   * first anchor point is where the curve starts.
   *
   * The next four parameters, `x2`, `y2`, `x3`, and `y3`, set the two control
   * points. The control points "pull" the curve towards them.
   *
   * The seventh and eighth parameters, `x4` and `y4`, set the last anchor
   * point. The last anchor point is where the curve ends.
   *
   * Bzier curves can also be drawn in 3D using WebGL mode. The 3D version of
   * `bezier()` has twelve arguments because each point has x-, y-,
   * and z-coordinates.
   *
   * @method bezier
   * @param  {Number} x1 x-coordinate of the first anchor point.
   * @param  {Number} y1 y-coordinate of the first anchor point.
   * @param  {Number} x2 x-coordinate of the first control point.
   * @param  {Number} y2 y-coordinate of the first control point.
   * @param  {Number} x3 x-coordinate of the second control point.
   * @param  {Number} y3 y-coordinate of the second control point.
   * @param  {Number} x4 x-coordinate of the second anchor point.
   * @param  {Number} y4 y-coordinate of the second anchor point.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw the anchor points in black.
   *   stroke(0);
   *   strokeWeight(5);
   *   point(85, 20);
   *   point(15, 80);
   *
   *   // Draw the control points in red.
   *   stroke(255, 0, 0);
   *   point(10, 10);
   *   point(90, 90);
   *
   *   // Draw a black bezier curve.
   *   noFill();
   *   stroke(0);
   *   strokeWeight(1);
   *   bezier(85, 20, 10, 10, 90, 90, 15, 80);
   *
   *   // Draw red lines from the anchor points to the control points.
   *   stroke(255, 0, 0);
   *   line(85, 20, 10, 10);
   *   line(15, 80, 90, 90);
   *
   *   describe(
   *     'A gray square with three curves. A black s-curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click the mouse near the red dot in the top-left corner
   * // and drag to change the curve's shape.
   *
   * let x2 = 10;
   * let y2 = 10;
   * let isChanging = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with three curves. A black s-curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the anchor points in black.
   *   stroke(0);
   *   strokeWeight(5);
   *   point(85, 20);
   *   point(15, 80);
   *
   *   // Draw the control points in red.
   *   stroke(255, 0, 0);
   *   point(x2, y2);
   *   point(90, 90);
   *
   *   // Draw a black bezier curve.
   *   noFill();
   *   stroke(0);
   *   strokeWeight(1);
   *   bezier(85, 20, x2, y2, 90, 90, 15, 80);
   *
   *   // Draw red lines from the anchor points to the control points.
   *   stroke(255, 0, 0);
   *   line(85, 20, x2, y2);
   *   line(15, 80, 90, 90);
   * }
   *
   * // Start changing the first control point if the user clicks near it.
   * function mousePressed() {
   *   if (dist(mouseX, mouseY, x2, y2) < 20) {
   *     isChanging = true;
   *   }
   * }
   *
   * // Stop changing the first control point when the user releases the mouse.
   * function mouseReleased() {
   *   isChanging = false;
   * }
   *
   * // Update the first control point while the user drags the mouse.
   * function mouseDragged() {
   *   if (isChanging === true) {
   *     x2 = mouseX;
   *     y2 = mouseY;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background('skyblue');
   *
   *   // Draw the red balloon.
   *   fill('red');
   *   bezier(50, 60, 5, 15, 95, 15, 50, 60);
   *
   *   // Draw the balloon string.
   *   line(50, 60, 50, 80);
   *
   *   describe('A red balloon in a blue sky.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A red balloon in a blue sky. The balloon rotates slowly, revealing that it is flat.');
   * }
   *
   * function draw() {
   *   background('skyblue');
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the red balloon.
   *   fill('red');
   *   bezier(0, 0, 0, -45, -45, 0, 45, -45, 0, 0, 0, 0);
   *
   *   // Draw the balloon string.
   *   line(0, 0, 0, 0, 20, 0);
   * }
   * </code>
   * </div>
   */ /**
   * @method bezier
   * @param  {Number} x1
   * @param  {Number} y1
   * @param  {Number} z1 z-coordinate of the first anchor point.
   * @param  {Number} x2
   * @param  {Number} y2
   * @param  {Number} z2 z-coordinate of the first control point.
   * @param  {Number} x3
   * @param  {Number} y3
   * @param  {Number} z3 z-coordinate of the second control point.
   * @param  {Number} x4
   * @param  {Number} y4
   * @param  {Number} z4 z-coordinate of the second anchor point.
   * @chainable
   */ fn.bezier = function(...args) {
        // p5._validateParameters('bezier', args);
        // if the current stroke and fill settings wouldn't result in something
        // visible, exit immediately
        if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
            return this;
        }
        this._renderer.bezier(...args);
        return this;
    };
    /**
   * Calculates coordinates along a Bzier curve using interpolation.
   *
   * `bezierPoint()` calculates coordinates along a Bzier curve using the
   * anchor and control points. It expects points in the same order as the
   * <a href="#/p5/bezier">bezier()</a> function. `bezierPoint()` works one axis
   * at a time. Passing the anchor and control points' x-coordinates will
   * calculate the x-coordinate of a point on the curve. Passing the anchor and
   * control points' y-coordinates will calculate the y-coordinate of a point on
   * the curve.
   *
   * The first parameter, `a`, is the coordinate of the first anchor point.
   *
   * The second and third parameters, `b` and `c`, are the coordinates of the
   * control points.
   *
   * The fourth parameter, `d`, is the coordinate of the last anchor point.
   *
   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0
   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway
   * between them.
   *
   * @method bezierPoint
   * @param {Number} a coordinate of first anchor point.
   * @param {Number} b coordinate of first control point.
   * @param {Number} c coordinate of second control point.
   * @param {Number} d coordinate of second anchor point.
   * @param {Number} t amount to interpolate between 0 and 1.
   * @return {Number} coordinate of the point on the curve.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the coordinates for the curve's anchor and control points.
   *   let x1 = 85;
   *   let x2 = 10;
   *   let x3 = 90;
   *   let x4 = 15;
   *   let y1 = 20;
   *   let y2 = 10;
   *   let y3 = 90;
   *   let y4 = 80;
   *
   *   // Style the curve.
   *   noFill();
   *
   *   // Draw the curve.
   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Draw circles along the curve's path.
   *   fill(255);
   *
   *   // Top-right.
   *   let x = bezierPoint(x1, x2, x3, x4, 0);
   *   let y = bezierPoint(y1, y2, y3, y4, 0);
   *   circle(x, y, 5);
   *
   *   // Center.
   *   x = bezierPoint(x1, x2, x3, x4, 0.5);
   *   y = bezierPoint(y1, y2, y3, y4, 0.5);
   *   circle(x, y, 5);
   *
   *   // Bottom-left.
   *   x = bezierPoint(x1, x2, x3, x4, 1);
   *   y = bezierPoint(y1, y2, y3, y4, 1);
   *   circle(x, y, 5);
   *
   *   describe('A black s-curve on a gray square. The endpoints and center of the curve are marked with white circles.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black s-curve on a gray square. A white circle moves back and forth along the curve.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Set the coordinates for the curve's anchor and control points.
   *   let x1 = 85;
   *   let x2 = 10;
   *   let x3 = 90;
   *   let x4 = 15;
   *   let y1 = 20;
   *   let y2 = 10;
   *   let y3 = 90;
   *   let y4 = 80;
   *
   *   // Draw the curve.
   *   noFill();
   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Calculate the circle's coordinates.
   *   let t = 0.5 * sin(frameCount * 0.01) + 0.5;
   *   let x = bezierPoint(x1, x2, x3, x4, t);
   *   let y = bezierPoint(y1, y2, y3, y4, t);
   *
   *   // Draw the circle.
   *   fill(255);
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   */ fn.bezierPoint = function(a, b, c, d, t) {
        // p5._validateParameters('bezierPoint', arguments);
        const adjustedT = 1 - t;
        return Math.pow(adjustedT, 3) * a + 3 * Math.pow(adjustedT, 2) * t * b + 3 * adjustedT * Math.pow(t, 2) * c + Math.pow(t, 3) * d;
    };
    /**
   * Calculates coordinates along a line that's tangent to a Bzier curve.
   *
   * Tangent lines skim the surface of a curve. A tangent line's slope equals
   * the curve's slope at the point where it intersects.
   *
   * `bezierTangent()` calculates coordinates along a tangent line using the
   * Bzier curve's anchor and control points. It expects points in the same
   * order as the <a href="#/p5/bezier">bezier()</a> function. `bezierTangent()`
   * works one axis at a time. Passing the anchor and control points'
   * x-coordinates will calculate the x-coordinate of a point on the tangent
   * line. Passing the anchor and control points' y-coordinates will calculate
   * the y-coordinate of a point on the tangent line.
   *
   * The first parameter, `a`, is the coordinate of the first anchor point.
   *
   * The second and third parameters, `b` and `c`, are the coordinates of the
   * control points.
   *
   * The fourth parameter, `d`, is the coordinate of the last anchor point.
   *
   * The fifth parameter, `t`, is the amount to interpolate along the curve. 0
   * is the first anchor point, 1 is the second anchor point, and 0.5 is halfway
   * between them.
   *
   * @method bezierTangent
   * @param {Number} a coordinate of first anchor point.
   * @param {Number} b coordinate of first control point.
   * @param {Number} c coordinate of second control point.
   * @param {Number} d coordinate of second anchor point.
   * @param {Number} t amount to interpolate between 0 and 1.
   * @return {Number} coordinate of a point on the tangent line.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the coordinates for the curve's anchor and control points.
   *   let x1 = 85;
   *   let x2 = 10;
   *   let x3 = 90;
   *   let x4 = 15;
   *   let y1 = 20;
   *   let y2 = 10;
   *   let y3 = 90;
   *   let y4 = 80;
   *
   *   // Style the curve.
   *   noFill();
   *
   *   // Draw the curve.
   *   bezier(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Draw tangents along the curve's path.
   *   fill(255);
   *
   *   // Top-right circle.
   *   stroke(0);
   *   let x = bezierPoint(x1, x2, x3, x4, 0);
   *   let y = bezierPoint(y1, y2, y3, y4, 0);
   *   circle(x, y, 5);
   *
   *   // Top-right tangent line.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   let tx = 0.1 * bezierTangent(x1, x2, x3, x4, 0);
   *   let ty = 0.1 * bezierTangent(y1, y2, y3, y4, 0);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   // Center circle.
   *   stroke(0);
   *   x = bezierPoint(x1, x2, x3, x4, 0.5);
   *   y = bezierPoint(y1, y2, y3, y4, 0.5);
   *   circle(x, y, 5);
   *
   *   // Center tangent line.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   tx = 0.1 * bezierTangent(x1, x2, x3, x4, 0.5);
   *   ty = 0.1 * bezierTangent(y1, y2, y3, y4, 0.5);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   // Bottom-left circle.
   *   stroke(0);
   *   x = bezierPoint(x1, x2, x3, x4, 1);
   *   y = bezierPoint(y1, y2, y3, y4, 1);
   *   circle(x, y, 5);
   *
   *   // Bottom-left tangent.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   tx = 0.1 * bezierTangent(x1, x2, x3, x4, 1);
   *   ty = 0.1 * bezierTangent(y1, y2, y3, y4, 1);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   describe(
   *     'A black s-curve on a gray square. The endpoints and center of the curve are marked with white circles. Red tangent lines extend from the white circles.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.bezierTangent = function(a, b, c, d, t) {
        // p5._validateParameters('bezierTangent', arguments);
        const adjustedT = 1 - t;
        return 3 * d * Math.pow(t, 2) - 3 * c * Math.pow(t, 2) + 6 * c * adjustedT * t - 6 * b * adjustedT * t + 3 * b * Math.pow(adjustedT, 2) - 3 * a * Math.pow(adjustedT, 2);
    };
    /**
   * Draws a curve using a Catmull-Rom spline.
   *
   * Spline curves can form shapes and curves that slope gently. Theyre like
   * cables that are attached to a set of points. By default (`ends: INCLUDE`),
   * the curve passes through all four points you provide, in order
   * `p0(x1,y1)` -> `p1(x2,y2)` -> `p2(x3,y3)` -> `p3(x4,y4)`. Think of them as
   * points on a curve. If you switch to `ends: EXCLUDE`, p0 and p3 act
   * like control points and only the middle span `p1->p2` is drawn.
   *
   * Spline curves can also be drawn in 3D using WebGL mode. The 3D version of
   * `spline()` has twelve arguments because each point has x-, y-, and
   * z-coordinates.
   *
   * @method spline
   * @param  {Number} x1 x-coordinate of point p0.
   * @param  {Number} y1 y-coordinate of point p0.
   * @param  {Number} x2 x-coordinate of point p1.
   * @param  {Number} y2 y-coordinate of point p1.
   * @param  {Number} x3 x-coordinate of point p2.
   * @param  {Number} y3 y-coordinate of point p2.
   * @param  {Number} x4 x-coordinate of point p3.
   * @param  {Number} y4 y-coordinate of point p3.
   * @chainable
   *
   * @example
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200);
   *   background(240);
   *   noFill();
   *
   *   stroke(0);
   *   strokeWeight(2);
   *   spline(40, 60, 100, 40, 120, 120, 60, 140);
   *
   *   strokeWeight(5);
   *   point(40, 60);
   *   point(100, 40);
   *   point(120, 120);
   *   point(60, 140);
   *
   *   describe('A black spline passes smoothly through four points');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200);
   *   background(245);
   * 
   *   // Ensure the curve includes both end spans p0->p1 and p2->p3
   *   splineProperty('ends', INCLUDE);
   * 
   *   // Control / anchor points
   *   const p0 = createVector(30, 160);
   *   const p1 = createVector(60, 40);
   *   const p2 = createVector(140, 40);
   *   const p3 = createVector(170, 160);
   * 
   *   // Draw the spline that passes through ALL four points (INCLUDE)
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *   spline(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
   * 
   *   // Draw markers + labels
   *   fill(255);
   *   stroke(0);
   *   const r = 6;
   *   circle(p0.x, p0.y, r);
   *   circle(p1.x, p1.y, r);
   *   circle(p2.x, p2.y, r);
   *   circle(p3.x, p3.y, r);
   * 
   *   noStroke();
   *   fill(0);
   *   text('p0', p0.x - 14, p0.y + 14);
   *   text('p1', p1.x - 14, p1.y - 8);
   *   text('p2', p2.x + 4, p2.y - 8);
   *   text('p3', p3.x + 4, p3.y + 14);
   * 
   *   describe('A black Catmull-Rom spline passes through p0, p1, p2, p3 with endpoints included.');
   * }
   * </code>
   * </div>
   * 
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Exclude the endsskip the outer spans (p0p1 and p2p3) so only the middle span (p1p2) is drawn.
   *   splineProperty('ends', EXCLUDE);
   *
   *   // Draw a black spline curve.
   *   noFill();
   *   strokeWeight(1);
   *   stroke(0);
   *   spline(5, 26, 73, 24, 73, 61, 15, 65);
   *
   *   // Draw red spline curves from the points.
   *   stroke(255, 0, 0);
   *   spline(5, 26, 5, 26, 73, 24, 73, 61);
   *   spline(73, 24, 73, 61, 15, 65, 15, 65);
   *
   *   // Draw the points in black.
   *   strokeWeight(5);
   *   stroke(0);
   *   point(73, 24);
   *   point(73, 61);
   *
   *   // Draw the points in red.
   *   stroke(255, 0, 0);
   *   point(5, 26);
   *   point(15, 65);
   *
   *   describe(
   *     'A gray square with a curve drawn in three segments. The curve is a sideways U shape with red segments on top and bottom, and a black segment on the right. The endpoints of all the segments are marked with dots.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let x1 = 5;
   * let y1 = 26;
   * let isChanging = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with a curve drawn in three segments. The curve is a sideways U shape with red segments on top and bottom, and a black segment on the right. The endpoints of all the segments are marked with dots.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Exclude the endsskip the outer spans (p0p1 and p2p3) so only the middle span (p1p2) is drawn.
   *   splineProperty('ends', EXCLUDE);
   *
   *   // Draw a black spline curve.
   *   noFill();
   *   strokeWeight(1);
   *   stroke(0);
   *   spline(x1, y1, 73, 24, 73, 61, 15, 65);
   *
   *   // Draw red spline curves from the points.
   *   stroke(255, 0, 0);
   *   spline(x1, y1, x1, y1, 73, 24, 73, 61);
   *   spline(73, 24, 73, 61, 15, 65, 15, 65);
   *
   *   // Draw the anchor points in black.
   *   strokeWeight(5);
   *   stroke(0);
   *   point(73, 24);
   *   point(73, 61);
   *
   *   // Draw the points in red.
   *   stroke(255, 0, 0);
   *   point(x1, y1);
   *   point(15, 65);
   * }
   *
   * // Start changing the first point if the user clicks near it.
   * function mousePressed() {
   *   if (dist(mouseX, mouseY, x1, y1) < 20) {
   *     isChanging = true;
   *   }
   * }
   *
   * // Stop changing the first point when the user releases the mouse.
   * function mouseReleased() {
   *   isChanging = false;
   * }
   *
   * // Update the first point while the user drags the mouse.
   * function mouseDragged() {
   *   if (isChanging === true) {
   *     x1 = mouseX;
   *     y1 = mouseY;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background('skyblue');
   *
   *   // Exclude the endsskip the outer spans (p0p1 and p2p3) so only the middle span (p1p2) is drawn.
   *   splineProperty('ends', EXCLUDE);
   *
   *   // Draw the red balloon.
   *   fill('red');
   *   spline(-150, 275, 50, 60, 50, 60, 250, 275);
   *
   *   // Draw the balloon string.
   *   line(50, 60, 50, 80);
   *
   *   describe('A red balloon in a blue sky.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A red balloon in a blue sky.');
   * }
   *
   * function draw() {
   *   background('skyblue');
   *
   *   // Exclude the endsskip the outer spans (p0p1 and p2p3) so only the middle span (p1p2) is drawn.
   *   splineProperty('ends', EXCLUDE);
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Draw the red balloon.
   *   fill('red');
   *   spline(-200, 225, 0, 0, 10, 0, 0, 10, 0, 200, 225, 0);
   *
   *   // Draw the balloon string.
   *   line(0, 10, 0, 0, 30, 0);
   * }
   * </code>
   * </div>
   */ /**
   * @method spline
   * @param  {Number} x1
   * @param  {Number} y1
   * @param  {Number} z1 z-coordinate of point p0.
   * @param  {Number} x2
   * @param  {Number} y2
   * @param  {Number} z2 z-coordinate of point p1.
   * @param  {Number} x3
   * @param  {Number} y3
   * @param  {Number} z3 z-coordinate of point p2.
   * @param  {Number} x4
   * @param  {Number} y4
   * @param  {Number} z4 z-coordinate of point p3.
   * @chainable
   */ fn.spline = function(...args) {
        if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
            return this;
        }
        this._renderer.spline(...args);
        return this;
    };
    /**
   * Calculates coordinates along a spline curve using interpolation.
   *
   * `splinePoint()` calculates coordinates along a spline curve using four
   * points p0, p1, p2, p3. It expects points in the same order as the
   * <a href="#/p5/spline">spline()</a> function. `splinePoint()` works one axis
   * at a time. Passing the points' x-coordinates will
   * calculate the x-coordinate of a point on the curve. Passing the
   * points' y-coordinates will calculate the y-coordinate of a point on
   * the curve.
   *
   * The first parameter, `a`, is the coordinate of point p0.
   *
   * The second and third parameters, `b` and `c`, are the coordinates of
   * points p1 and p2.
   *
   * The fourth parameter, `d`, is the coordinate of point p3.
   *
   * The fifth parameter, `t`, is the amount to interpolate along the span
   * from p1 to p2. `t = 0` is p1, `t = 1` is p2, and `t = 0.5` is halfway
   * between them.
   *
   * @method splinePoint
   * @param {Number} a coordinate of point p0.
   * @param {Number} b coordinate of point p1.
   * @param {Number} c coordinate of point p2.
   * @param {Number} d coordinate of point p3.
   * @param {Number} t amount to interpolate between 0 and 1.
   * @return {Number} coordinate of a point on the curve.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *
   *   // Set the coordinates for the curve's four points (p0, p1, p2, p3).
   *   let x1 = 5;
   *   let y1 = 26;
   *   let x2 = 73;
   *   let y2 = 24;
   *   let x3 = 73;
   *   let y3 = 61;
   *   let x4 = 15;
   *   let y4 = 65;
   *
   *   // Draw the curve.
   *   noFill();
   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Draw circles along the curve's path.
   *   fill(255);
   *
   *   // Top.
   *   let x = splinePoint(x1, x2, x3, x4, 0);
   *   let y = splinePoint(y1, y2, y3, y4, 0);
   *   circle(x, y, 5);
   *
   *   // Center.
   *   x = splinePoint(x1, x2, x3, x4, 0.5);
   *   y = splinePoint(y1, y2, y3, y4, 0.5);
   *   circle(x, y, 5);
   *
   *   // Bottom.
   *   x = splinePoint(x1, x2, x3, x4, 1);
   *   y = splinePoint(y1, y2, y3, y4, 1);
   *   circle(x, y, 5);
   *
   *   describe('A black curve on a gray square. The endpoints and center of the curve are marked with white circles.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black curve on a gray square. A white circle moves back and forth along the curve.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Set the coordinates for the curve's four points (p0, p1, p2, p3).
   *   let x1 = 5;
   *   let y1 = 26;
   *   let x2 = 73;
   *   let y2 = 24;
   *   let x3 = 73;
   *   let y3 = 61;
   *   let x4 = 15;
   *   let y4 = 65;
   *
   *   // Draw the curve.
   *   noFill();
   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Calculate the circle's coordinates.
   *   let t = 0.5 * sin(frameCount * 0.01) + 0.5;
   *   let x = splinePoint(x1, x2, x3, x4, t);
   *   let y = splinePoint(y1, y2, y3, y4, t);
   *
   *   // Draw the circle.
   *   fill(255);
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   * 
   * <div>
   * <code>
   * let p0, p1, p2, p3;
   * 
   * function setup() {
   *   createCanvas(200, 200);
   *   splineProperty('ends', INCLUDE); // make endpoints part of the curve
   * 
   *   // Four points forming a gentle arch
   *   p0 = createVector(30, 160);
   *   p1 = createVector(60, 50);
   *   p2 = createVector(140, 50);
   *   p3 = createVector(170, 160);
   * 
   *   describe('Black spline through p0p3. A red dot marks the location at parameter t on p1->p2 using splinePoint.');
   * }
   * 
   * function draw() {
   *   background(245);
   * 
   *   // Draw the spline for context
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *   spline(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
   * 
   *   // Map mouse X to t in [0, 1] (span p1->p2)
   *   let t = constrain(map(mouseX, 0, width, 0, 1), 0, 1);
   * 
   *   // Evaluate the curve point by axis (splinePoint works one axis at a time)
   *   let x = splinePoint(p0.x, p1.x, p2.x, p3.x, t);
   *   let y = splinePoint(p0.y, p1.y, p2.y, p3.y, t);
   * 
   *   // Marker at the evaluated position
   *   noStroke();
   *   fill('red');
   *   circle(x, y, 8);
   * 
   *   // Draw control/anchor points
   *   stroke(0);
   *   strokeWeight(1);
   *   fill(255);
   *   const r = 6;
   *   circle(p0.x, p0.y, r);
   *   circle(p1.x, p1.y, r);
   *   circle(p2.x, p2.y, r);
   *   circle(p3.x, p3.y, r);
   * 
   *   // Labels + UI hint
   *   noStroke();
   *   fill(20);
   *   textSize(10);
   *   text('p0', p0.x - 12, p0.y + 14);
   *   text('p1', p1.x - 12, p1.y - 8);
   *   text('p2', p2.x + 4, p2.y - 8);
   *   text('p3', p3.x + 4, p3.y + 14);
   *   text('t = ' + nf(t, 1, 2) + ' (p1p2)', 8, 16);
   * }
   * </code>
   * </div>
   * 
   */ fn.splinePoint = function(a, b, c, d, t) {
        const s = this._renderer.states.splineProperties.tightness, t3 = t * t * t, t2 = t * t, f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t, f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1.0, f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t, f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;
        return a * f1 + b * f2 + c * f3 + d * f4;
    };
    /**
   * Calculates coordinates along a line that's tangent to a spline curve.
   *
   * Tangent lines skim the surface of a curve. A tangent line's slope equals
   * the curve's slope at the point where it intersects.
   *
   * `splineTangent()` calculates coordinates along a tangent line using four
   * points p0, p1, p2, p3. It expects points in the same order as the
   * <a href="#/p5/spline">spline()</a> function. `splineTangent()` works one
   * axis at a time. Passing the points' x-coordinates returns the x-component of
   * the tangent vector; passing the points' y-coordinates returns the y-component.
   * The first parameter, `a`, is the coordinate of point p0.
   *
   * The second and third parameters, `b` and `c`, are the coordinates of
   * points p1 and p2.
   *
   * The fourth parameter, `d`, is the coordinate of point p3.
   *
   * The fifth parameter, `t`, is the amount to interpolate along the span
   * from p1 to p2. `t = 0` is p1, `t = 1` is p2, and `t = 0.5` is halfway
   * between them.
   *
   * @method splineTangent
   * @param {Number} a coordinate of point p0.
   * @param {Number} b coordinate of point p1.
   * @param {Number} c coordinate of point p2.
   * @param {Number} d coordinate of point p3.
   * @param {Number} t amount to interpolate between 0 and 1.
   * @return {Number} coordinate of a point on the tangent line.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(120, 120);
   *   describe('A black spline on a gray canvas. A red dot moves along the curve on its own. A short line shows the tangent direction at the dot.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   const x1 = 15, y1 = 40;
   *   const x2 = 90, y2 = 25;
   *   const x3 = 95, y3 = 95;
   *   const x4 = 30, y4 = 110;
   *
   *   noFill();
   *   stroke(0);
   *   strokeWeight(2);
   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   const t = 0.5 + 0.5 * sin(frameCount * 0.03);
   *
   *   const px = splinePoint(x1, x2, x3, x4, t);
   *   const py = splinePoint(y1, y2, y3, y4, t);
   *
   *   let tx = splineTangent(x1, x2, x3, x4, t);
   *   let ty = splineTangent(y1, y2, y3, y4, t);
   *
   *   const m = Math.hypot(tx, ty) || 1;
   *   tx = (tx / m) * 16;
   *   ty = (ty / m) * 16;
   *
   *   stroke(0);
   *   strokeWeight(2);
   *   line(px, py, px + tx, py + ty);
   *
   *   noStroke();
   *   fill('red');
   *   circle(px, py, 7);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the coordinates for the curve's four points (p0, p1, p2, p3).
   *   let x1 = 5;
   *   let y1 = 26;
   *   let x2 = 73;
   *   let y2 = 24;
   *   let x3 = 73;
   *   let y3 = 61;
   *   let x4 = 15;
   *   let y4 = 65;
   *
   *   // Draw the curve.
   *   noFill();
   *   spline(x1, y1, x2, y2, x3, y3, x4, y4);
   *
   *   // Draw tangents along the curve's path.
   *   fill(255);
   *
   *   // Top circle.
   *   stroke(0);
   *   let x = splinePoint(x1, x2, x3, x4, 0);
   *   let y = splinePoint(y1, y2, y3, y4, 0);
   *   circle(x, y, 5);
   *
   *   // Top tangent line.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   let tx = 0.2 * splineTangent(x1, x2, x3, x4, 0);
   *   let ty = 0.2 * splineTangent(y1, y2, y3, y4, 0);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   // Center circle.
   *   stroke(0);
   *   x = splinePoint(x1, x2, x3, x4, 0.5);
   *   y = splinePoint(y1, y2, y3, y4, 0.5);
   *   circle(x, y, 5);
   *
   *   // Center tangent line.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   tx = 0.2 * splineTangent(x1, x2, x3, x4, 0.5);
   *   ty = 0.2 * splineTangent(y1, y2, y3, y4, 0.5);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   // Bottom circle.
   *   stroke(0);
   *   x = splinePoint(x1, x2, x3, x4, 1);
   *   y = splinePoint(y1, y2, y3, y4, 1);
   *   circle(x, y, 5);
   *
   *   // Bottom tangent line.
   *   // Scale the tangent point to draw a shorter line.
   *   stroke(255, 0, 0);
   *   tx = 0.2 * splineTangent(x1, x2, x3, x4, 1);
   *   ty = 0.2 * splineTangent(y1, y2, y3, y4, 1);
   *   line(x + tx, y + ty, x - tx, y - ty);
   *
   *   describe(
   *     'A black curve on a gray square. A white circle moves back and forth along the curve.'
   *   );
   * }
   * </code>
   * </div>
   */ fn.splineTangent = function(a, b, c, d, t) {
        const s = this._renderer.states.splineProperties.tightness, tt3 = t * t * 3, t2 = t * 2, f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2, f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2, f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2, f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;
        return a * f1 + b * f2 + c * f3 + d * f4;
    };
}
if (typeof p5 !== 'undefined') {
    curves(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>vertex
]);
/**
 * @module Shape
 * @submodule Custom Shapes
 * @for p5
 * @requires core
 * @requires constants
 */ function vertex(p51, fn) {
    /**
   * Begins adding vertices to a custom shape.
   *
   * The `beginShape()` and <a href="#/p5/endShape">endShape()</a> functions
   * allow for creating custom shapes in 2D or 3D. `beginShape()` begins adding
   * vertices to a custom shape and <a href="#/p5/endShape">endShape()</a> stops
   * adding them.
   *
   * The parameter, `kind`, sets the kind of shape to make. The available kinds are:
   *
   * - `PATH` (the default) to draw shapes by tracing out the path along their edges.
   * - `POINTS` to draw a series of points.
   * - `LINES` to draw a series of unconnected line segments.
   * - `TRIANGLES` to draw a series of separate triangles.
   * - `TRIANGLE_FAN` to draw a series of connected triangles sharing the first vertex in a fan-like fashion.
   * - `TRIANGLE_STRIP` to draw a series of connected triangles in strip fashion.
   * - `QUADS` to draw a series of separate quadrilaterals (quads).
   * - `QUAD_STRIP` to draw quad strip using adjacent edges to form the next quad.
   *
   * After calling `beginShape()`, shapes can be built by calling
   * <a href="#/p5/vertex">vertex()</a>,
   * <a href="#/p5/bezierVertex">bezierVertex()</a>, and/or
   * <a href="#/p5/splineVertex">splineVertex()</a>. Calling
   * <a href="#/p5/endShape">endShape()</a> will stop adding vertices to the
   * shape. Each shape will be outlined with the current stroke color and filled
   * with the current fill color.
   *
   * Transformations such as <a href="#/p5/translate">translate()</a>,
   * <a href="#/p5/rotate">rotate()</a>, and
   * <a href="#/p5/scale">scale()</a> don't work between `beginShape()` and
   * <a href="#/p5/endShape">endShape()</a>. It's also not possible to use
   * other shapes, such as <a href="#/p5/ellipse">ellipse()</a> or
   * <a href="#/p5/rect">rect()</a>, between `beginShape()` and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * @method beginShape
   * @param  {(POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH)} [kind=PATH] either POINTS, LINES, TRIANGLES, TRIANGLE_FAN
   *                                TRIANGLE_STRIP, QUADS, QUAD_STRIP or PATH. Defaults to PATH.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape(CLOSE);
   *
   *   describe('A white square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Only draw the vertices (points).
   *   beginShape(POINTS);
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Four black dots that form a square are drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Only draw lines between alternating pairs of vertices.
   *   beginShape(LINES);
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Two horizontal black lines on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shape.
   *   noFill();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Three black lines form a sideways U shape on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shape.
   *   noFill();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *   vertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   // Connect the first and last vertices.
   *   endShape(CLOSE);
   *
   *   describe('A black outline of a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of triangles.
   *   beginShape(TRIANGLES);
   *
   *   // Left triangle.
   *   vertex(30, 75);
   *   vertex(40, 20);
   *   vertex(50, 75);
   *
   *   // Right triangle.
   *   vertex(60, 20);
   *   vertex(70, 75);
   *   vertex(80, 20);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Two white triangles drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of triangles.
   *   beginShape(TRIANGLE_STRIP);
   *
   *   // Add vertices.
   *   vertex(30, 75);
   *   vertex(40, 20);
   *   vertex(50, 75);
   *   vertex(60, 20);
   *   vertex(70, 75);
   *   vertex(80, 20);
   *   vertex(90, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Five white triangles that are interleaved drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of triangles that share their first vertex.
   *   beginShape(TRIANGLE_FAN);
   *
   *   // Add vertices.
   *   vertex(57.5, 50);
   *   vertex(57.5, 15);
   *   vertex(92, 50);
   *   vertex(57.5, 85);
   *   vertex(22, 50);
   *   vertex(57.5, 15);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Four white triangles form a square are drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of quadrilaterals.
   *   beginShape(QUADS);
   *
   *   // Left rectangle.
   *   vertex(30, 20);
   *   vertex(30, 75);
   *   vertex(50, 75);
   *   vertex(50, 20);
   *
   *   // Right rectangle.
   *   vertex(65, 20);
   *   vertex(65, 75);
   *   vertex(85, 75);
   *   vertex(85, 20);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Two white rectangles drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of quadrilaterals.
   *   beginShape(QUAD_STRIP);
   *
   *   // Add vertices.
   *   vertex(30, 20);
   *   vertex(30, 75);
   *   vertex(50, 20);
   *   vertex(50, 75);
   *   vertex(65, 20);
   *   vertex(65, 75);
   *   vertex(85, 20);
   *   vertex(85, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('Three white rectangles that share edges are drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   // Draw a series of quadrilaterals.
   *   beginShape(PATH);
   *
   *   // Add the vertices.
   *   vertex(-30, -30, 0);
   *   vertex(30, -30, 0);
   *   vertex(30, -10, 0);
   *   vertex(-10, -10, 0);
   *   vertex(-10, 10, 0);
   *   vertex(30, 10, 0);
   *   vertex(30, 30, 0);
   *   vertex(-30, 30, 0);
   *
   *   // Stop drawing the shape.
   *   // Connect the first and last vertices.
   *   endShape(CLOSE);
   *
   *   describe('A blocky C shape drawn in white on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag with the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A blocky C shape drawn in red, blue, and green on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Start drawing the shape.
   *   // Draw a series of quadrilaterals.
   *   beginShape(PATH);
   *
   *   // Add the vertices.
   *   fill('red');
   *   stroke('red');
   *   vertex(-30, -30, 0);
   *   vertex(30, -30, 0);
   *   vertex(30, -10, 0);
   *   fill('green');
   *   stroke('green');
   *   vertex(-10, -10, 0);
   *   vertex(-10, 10, 0);
   *   vertex(30, 10, 0);
   *   fill('blue');
   *   stroke('blue');
   *   vertex(30, 30, 0);
   *   vertex(-30, 30, 0);
   *
   *   // Stop drawing the shape.
   *   // Connect the first and last vertices.
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   */ fn.beginShape = function(kind) {
        // p5._validateParameters('beginShape', arguments);
        this._renderer.beginShape(...arguments);
    };
    /**
   * Adds a Bzier curve segment to a custom shape.
   *
   * `bezierVertex()` adds a curved segment to custom shapes. The Bzier curves
   * it creates are defined like those made by the
   * <a href="#/p5/bezier">bezier()</a> function. `bezierVertex()` must be
   * called between the
   * <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> functions.
   * Bzier need a starting point. Building a shape
   * only with Bzier curves needs one initial
   * call to <a href="#/p5/vertex">bezierVertex()</a>, before
   * a number of `bezierVertex()` calls that is a multiple of the parameter
   * set by <a href="#/p5/bezierOrder">bezierOrder(...)</a> (default 3).
   * But shapes can mix different types of vertices, so if there
   * are some previous vertices, then the initial anchor is not needed,
   * only the multiples of 3 (or the Bzier order) calls to
   *  `bezierVertex` for each curve.
   *
   * Each curve of order 3 requires three calls to `bezierVertex`, so
   * 2 curves would need 7 calls to `bezierVertex()`:
   * (1 one initial anchor point, two sets of 3 curves describing the curves)
   * With `bezierOrder(2)`, two curves would need 5 calls: 1 + 2 + 2.
   *
   * Bzier curves can also be drawn in 3D using WebGL mode.
   *
   * Note: `bezierVertex()` wont work when an argument is passed to
   * <a href="#/p5/beginShape">beginShape()</a>.
   *
   * @method bezierVertex
   * @param  {Number} x x-coordinate of the first control point.
   * @param  {Number} y y-coordinate of the first control point.
   * @param  {Number} [u]
   * @param  {Number} [v]
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shape.
   *   noFill();
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add the first anchor point.
   *   bezierVertex(30, 20);
   *
   *   // Add the Bzier vertex.
   *   bezierVertex(80, 0);
   *   bezierVertex(80, 75);
   *   bezierVertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('A black C curve on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw the anchor points in black.
   *   stroke(0);
   *   strokeWeight(5);
   *   point(30, 20);
   *   point(30, 75);
   *
   *   // Draw the control points in red.
   *   stroke(255, 0, 0);
   *   point(80, 0);
   *   point(80, 75);
   *
   *   // Style the shape.
   *   noFill();
   *   stroke(0);
   *   strokeWeight(1);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add the first anchor point.
   *   bezierVertex(30, 20);
   *
   *   // Add the Bzier vertex.
   *   bezierVertex(80, 0);
   *   bezierVertex(80, 75);
   *   bezierVertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   // Draw red lines from the anchor points to the control points.
   *   stroke(255, 0, 0);
   *   line(30, 20, 80, 0);
   *   line(30, 75, 80, 75);
   *
   *   describe(
   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click the mouse near the red dot in the top-right corner
   * // and drag to change the curve's shape.
   *
   * let x2 = 80;
   * let y2 = 0;
   * let isChanging = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A gray square with three curves. A black curve has two straight, red lines that extend from its ends. The endpoints of all the curves are marked with dots.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the anchor points in black.
   *   stroke(0);
   *   strokeWeight(5);
   *   point(30, 20);
   *   point(30, 75);
   *
   *   // Draw the control points in red.
   *   stroke(255, 0, 0);
   *   point(x2, y2);
   *   point(80, 75);
   *
   *   // Style the shape.
   *   noFill();
   *   stroke(0);
   *   strokeWeight(1);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add the first anchor point.
   *   bezierVertex(30, 20);
   *
   *   // Add the Bzier vertex.
   *   bezierVertex(x2, y2);
   *   bezierVertex(80, 75);
   *   bezierVertex(30, 75);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   // Draw red lines from the anchor points to the control points.
   *   stroke(255, 0, 0);
   *   line(30, 20, x2, y2);
   *   line(30, 75, 80, 75);
   * }
   *
   * // Start changing the first control point if the user clicks near it.
   * function mousePressed() {
   *   if (dist(mouseX, mouseY, x2, y2) < 20) {
   *     isChanging = true;
   *   }
   * }
   *
   * // Stop changing the first control point when the user releases the mouse.
   * function mouseReleased() {
   *   isChanging = false;
   * }
   *
   * // Update the first control point while the user drags the mouse.
   * function mouseDragged() {
   *   if (isChanging === true) {
   *     x2 = mouseX;
   *     y2 = mouseY;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Start drawing the shape.
   *   beginShape();
   *
   *   // Add the first anchor point.
   *   bezierVertex(30, 20);
   *
   *   // Add the Bzier vertices.
   *   bezierVertex(80, 0);
   *   bezierVertex(80, 75);
   *   bezierVertex(30, 75);
   *
   *   bezierVertex(50, 80);
   *   bezierVertex(60, 25);
   *   bezierVertex(30, 20);
   *
   *   // Stop drawing the shape.
   *   endShape();
   *
   *   describe('A crescent moon shape drawn in white on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A crescent moon shape drawn in white on a blue background. When the user drags the mouse, the scene rotates and a second moon is revealed.');
   * }
   *
   * function draw() {
   *   background('midnightblue');
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the moons.
   *   noStroke();
   *   fill('lemonchiffon');
   *
   *   // Draw the first moon.
   *   beginShape();
   *   bezierVertex(-20, -30, 0);
   *
   *   bezierVertex(30, -50, 0);
   *   bezierVertex(30, 25, 0);
   *   bezierVertex(-20, 25, 0);
   *
   *   bezierVertex(0, 30, 0);
   *   bezierVertex(10, -25, 0);
   *   bezierVertex(-20, -30, 0);
   *   endShape();
   *
   *   // Draw the second moon.
   *   beginShape();
   *
   *   bezierVertex(-20, -30, -20);
   *
   *   bezierVertex(30, -50, -20);
   *   bezierVertex(30, 25, -20);
   *   bezierVertex(-20, 25, -20);
   *
   *   bezierVertex(0, 30, -20);
   *   bezierVertex(10, -25, -20);
   *   bezierVertex(-20, -30, -20);
   *
   *   endShape();
   * }
   * </code>
   * </div>
   */ /**
   * @method bezierVertex
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} z
   * @param  {Number} [u]
   * @param  {Number} [v]
   */ fn.bezierVertex = function(...args) {
        this._renderer.bezierVertex(...args);
    };
    /**
   * Concludes the vertices of a custom shape.
   *
   * The <a href="#/p5/beginShape">beginShape()</a> and `endShape()` functions
   * allow for creating custom shapes in 2D or 3D.
   * <a href="#/p5/beginShape">beginShape()</a> begins adding vertices to a
   * custom shape and `endShape()` stops adding them.
   *
   * The first parameter, `mode`, is optional. By default, the first and last
   * vertices of a shape aren't connected. If the constant `CLOSE` is passed, as
   * in `endShape(CLOSE)`, then the first and last vertices will be connected.
   * When CLOSE mode is used for splines (with `splineVeertex()`), the shape is ended smoothly.
   *
   *
   * The second parameter, `count`, is also optional. In WebGL mode, its more
   * efficient to draw many copies of the same shape using a technique called
   * <a href="https://webglfundamentals.org/webgl/lessons/webgl-instanced-drawing.html" target="_blank">instancing</a>.
   * The `count` parameter tells WebGL mode how many copies to draw. For
   * example, calling `endShape(CLOSE, 400)` after drawing a custom shape will
   * make it efficient to draw 400 copies. This feature requires
   * <a href="https://p5js.org/tutorials/intro-to-shaders/" target="_blank">writing a custom shader</a>.
   *
   * After calling <a href="#/p5/beginShape">beginShape()</a>, shapes can be
   * built by calling <a href="#/p5/vertex">vertex()</a>,
   * <a href="#/p5/bezierVertex">bezierVertex()</a> and/or
   * <a href="#/p5/splineVertex">splineVertex()</a>. Calling
   * `endShape()` will stop adding vertices to the
   * shape. Each shape will be outlined with the current stroke color and filled
   * with the current fill color.
   *
   * Transformations such as <a href="#/p5/translate">translate()</a>,
   * <a href="#/p5/rotate">rotate()</a>, and
   * <a href="#/p5/scale">scale()</a> don't work between
   * <a href="#/p5/beginShape">beginShape()</a> and `endShape()`. It's also not
   * possible to use other shapes, such as <a href="#/p5/ellipse">ellipse()</a> or
   * <a href="#/p5/rect">rect()</a>, between
   * <a href="#/p5/beginShape">beginShape()</a> and `endShape()`.
   *
   * @method endShape
   * @param  {CLOSE} [mode] use CLOSE to close the shape
   * @param  {Integer} [count] number of times you want to draw/instance the shape (for WebGL mode).
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the shapes.
   *   noFill();
   *
   *   // Left triangle.
   *   beginShape();
   *   vertex(20, 20);
   *   vertex(45, 20);
   *   vertex(45, 80);
   *   endShape(CLOSE);
   *
   *   // Right triangle.
   *   beginShape();
   *   vertex(50, 20);
   *   vertex(75, 20);
   *   vertex(75, 80);
   *   endShape();
   *
   *   describe(
   *     'Two sets of black lines drawn on a gray background. The three lines on the left form a right triangle. The two lines on the right form a right angle.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 100);
   *
   *   background(240);
   *
   *   noFill();
   *   stroke(0);
   *
   *   // Open shape (left)
   *   beginShape();
   *   vertex(20, 20);
   *   vertex(80, 20);
   *   vertex(80, 80);
   *   endShape();  // Not closed
   *
   *   // Closed shape (right)
   *   beginShape();
   *   vertex(120, 20);
   *   vertex(180, 20);
   *   vertex(180, 80);
   *   endShape(CLOSE);  // Closed
   *
   *   describe(
   *     'Two right-angled shapes on a light gray background. The left shape is open with three lines. The right shape is closed, forming a triangle.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *   background(200);
   *
   *   beginShape();
   *
   *   splineVertex(32, 91);
   *   splineVertex(21, 17);
   *   splineVertex(68, 19);
   *   splineVertex(82, 91);
   *
   *   endShape(CLOSE);
   *
   *   describe(
   *     'A curvy four-sided slightly lopsided blob.'
   *   );
   * }
   * </div>
   * </code>
   *
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `#version 300 es
   *
   * precision mediump float;
   *
   * in vec3 aPosition;
   * flat out int instanceID;
   *
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * void main() {
   *
   *   // Copy the instance ID to the fragment shader.
   *   instanceID = gl_InstanceID;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *
   *   // gl_InstanceID represents a numeric value for each instance.
   *   // Using gl_InstanceID allows us to move each instance separately.
   *   // Here we move each instance horizontally by ID * 23.
   *   float xOffset = float(gl_InstanceID) * 23.0;
   *
   *   // Apply the offset to the final position.
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * (positionVec4 -
   *     vec4(xOffset, 0.0, 0.0, 0.0));
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `#version 300 es
   *
   * precision mediump float;
   *
   * out vec4 outColor;
   * flat in int instanceID;
   * uniform float numInstances;
   *
   * void main() {
   *   vec4 red = vec4(1.0, 0.0, 0.0, 1.0);
   *   vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);
   *
   *   // Normalize the instance ID.
   *   float normId = float(instanceID) / numInstances;
   *
   *   // Mix between two colors using the normalized instance ID.
   *   outColor = mix(red, blue, normId);
   * }
   * `;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   let myShader = createShader(vertSrc, fragSrc);
   *
   *   background(220);
   *
   *   // Compile and apply the p5.Shader.
   *   shader(myShader);
   *
   *   // Set the numInstances uniform.
   *   myShader.setUniform('numInstances', 4);
   *
   *   // Translate the origin to help align the drawing.
   *   translate(25, -10);
   *
   *   // Style the shapes.
   *   noStroke();
   *
   *   // Draw the shapes.
   *   beginShape();
   *   vertex(0, 0);
   *   vertex(0, 20);
   *   vertex(20, 20);
   *   vertex(20, 0);
   *   vertex(0, 0);
   *   endShape(CLOSE, 4);
   *
   *   describe('A row of four squares. Their colors transition from purple on the left to red on the right');
   * }
   * </code>
   * </div>
   */ fn.endShape = function(mode, count = 1) {
        // p5._validateParameters('endShape', arguments);
        if (count < 1) {
            console.log(' p5.js says: You can not have less than one instance');
            count = 1;
        }
        this._renderer.endShape(mode, count);
    };
    /**
   * Sets the normal vector for vertices in a custom 3D shape.
   *
   * 3D shapes created with <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> are made by connecting sets of
   * points called vertices. Each vertex added with
   * <a href="#/p5/vertex">vertex()</a> has a normal vector that points away
   * from it. The normal vector controls how light reflects off the shape.
   *
   * `normal()` can be called two ways with different parameters to define the
   * normal vector's components.
   *
   * The first way to call `normal()` has three parameters, `x`, `y`, and `z`.
   * If `Number`s are passed, as in `normal(1, 2, 3)`, they set the x-, y-, and
   * z-components of the normal vector.
   *
   * The second way to call `normal()` has one parameter, `vector`. If a
   * <a href="#/p5.Vector">p5.Vector</a> object is passed, as in
   * `normal(myVector)`, its components will be used to set the normal vector.
   *
   * `normal()` changes the normal vector of vertices added to a custom shape
   * with <a href="#/p5/vertex">vertex()</a>. `normal()` must be called between
   * the <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a> functions, just like
   * <a href="#/p5/vertex">vertex()</a>. The normal vector set by calling
   * `normal()` will affect all following vertices until `normal()` is called
   * again:
   *
   * ```js
   * beginShape();
   *
   * // Set the vertex normal.
   * normal(-0.4, -0.4, 0.8);
   *
   * // Add a vertex.
   * vertex(-30, -30, 0);
   *
   * // Set the vertex normal.
   * normal(0, 0, 1);
   *
   * // Add vertices.
   * vertex(30, -30, 0);
   * vertex(30, 30, 0);
   *
   * // Set the vertex normal.
   * normal(0.4, -0.4, 0.8);
   *
   * // Add a vertex.
   * vertex(-30, 30, 0);
   *
   * endShape();
   * ```
   *
   * @method normal
   * @param  {p5.Vector} vector vertex normal as a <a href="#/p5.Vector">p5.Vector</a> object.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click the and drag the mouse to view the scene from a different angle.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe(
   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'
   *   );
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the shape.
   *   normalMaterial();
   *   noStroke();
   *
   *   // Draw the shape.
   *   beginShape();
   *   vertex(-30, -30, 0);
   *   vertex(30, -30, 0);
   *   vertex(30, 30, 0);
   *   vertex(-30, 30, 0);
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click the and drag the mouse to view the scene from a different angle.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe(
   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'
   *   );
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the shape.
   *   normalMaterial();
   *   noStroke();
   *
   *   // Draw the shape.
   *   // Use normal() to set vertex normals.
   *   beginShape();
   *   normal(-0.4, -0.4, 0.8);
   *   vertex(-30, -30, 0);
   *
   *   normal(0, 0, 1);
   *   vertex(30, -30, 0);
   *   vertex(30, 30, 0);
   *
   *   normal(0.4, -0.4, 0.8);
   *   vertex(-30, 30, 0);
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * // Click the and drag the mouse to view the scene from a different angle.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe(
   *     'A colorful square on a black background. The square changes color and rotates when the user drags the mouse. Parts of its surface reflect light in different directions.'
   *   );
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the shape.
   *   normalMaterial();
   *   noStroke();
   *
   *   // Create p5.Vector objects.
   *   let n1 = createVector(-0.4, -0.4, 0.8);
   *   let n2 = createVector(0, 0, 1);
   *   let n3 = createVector(0.4, -0.4, 0.8);
   *
   *   // Draw the shape.
   *   // Use normal() to set vertex normals.
   *   beginShape();
   *   normal(n1);
   *   vertex(-30, -30, 0);
   *
   *   normal(n2);
   *   vertex(30, -30, 0);
   *   vertex(30, 30, 0);
   *
   *   normal(n3);
   *   vertex(-30, 30, 0);
   *   endShape();
   * }
   * </code>
   * </div>
   */ /**
   * @method normal
   * @param  {Number} x x-component of the vertex normal.
   * @param  {Number} y y-component of the vertex normal.
   * @param  {Number} z z-component of the vertex normal.
   * @chainable
   */ fn.normal = function(x, y, z) {
        this._assert3d('normal');
        // p5._validateParameters('normal', arguments);
        this._renderer.normal(...arguments);
        return this;
    };
    /**
   * Sets the shader's vertex property or attribute variables.
   *
   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some
   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are
   * set using <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/normal">normal()</a>
   * and <a href="#/p5/fill">fill()</a> respectively. Custom properties can also
   * be defined within <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * The first parameter, `propertyName`, is a string with the property's name.
   * This is the same variable name which should be declared in the shader, such as
   * `in vec3 aProperty`, similar to .`setUniform()`.
   *
   * The second parameter, `data`, is the value assigned to the shader variable. This
   * value will be applied to subsequent vertices created with
   * <a href="#/p5/vertex">vertex()</a>. It can be a Number or an array of numbers,
   * and in the shader program the type can be declared according to the WebGL
   * specification. Common types include `float`, `vec2`, `vec3`, `vec4` or matrices.
   *
   * See also the <a href="#/p5/vertexProperty">vertexProperty()</a> method on
   * <a href="#/p5/Geometry">Geometry</a> objects.
   *
   * @method vertexProperty
   * @for p5
   * @param {String} attributeName the name of the vertex attribute.
   * @param {Number|Number[]} data the data tied to the vertex attribute.
   *
   * @example
   * <div>
   * <code>
   * const vertSrc = `#version 300 es
   *  precision mediump float;
   *  uniform mat4 uModelViewMatrix;
   *  uniform mat4 uProjectionMatrix;
   *
   *  in vec3 aPosition;
   *  in vec2 aOffset;
   *
   *  void main(){
   *    vec4 positionVec4 = vec4(aPosition.xyz, 1.0);
   *    positionVec4.xy += aOffset;
   *    gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   *  }
   * `;
   *
   * const fragSrc = `#version 300 es
   *  precision mediump float;
   *  out vec4 outColor;
   *  void main(){
   *    outColor = vec4(0.0, 1.0, 1.0, 1.0);
   *  }
   * `;
   *
   * function setup(){
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create and use the custom shader.
   *   const myShader = createShader(vertSrc, fragSrc);
   *   shader(myShader);
   *
   *   describe('A wobbly, cyan circle on a gray background.');
   * }
   *
   * function draw(){
   *   // Set the styles
   *   background(125);
   *   noStroke();
   *
   *   // Draw the circle.
   *   beginShape();
   *   for (let i = 0; i < 30; i++){
   *     const x = 40 * cos(i/30 * TWO_PI);
   *     const y = 40 * sin(i/30 * TWO_PI);
   *
   *     // Apply some noise to the coordinates.
   *     const xOff = 10 * noise(x + millis()/1000) - 5;
   *     const yOff = 10 * noise(y + millis()/1000) - 5;
   *
   *     // Apply these noise values to the following vertex.
   *     vertexProperty('aOffset', [xOff, yOff]);
   *     vertex(x, y);
   *   }
   *   endShape(CLOSE);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myShader;
   * const cols = 10;
   * const rows = 10;
   * const cellSize = 6;
   *
   * const vertSrc = `#version 300 es
   *   precision mediump float;
   *   uniform mat4 uProjectionMatrix;
   *   uniform mat4 uModelViewMatrix;
   *
   *   in vec3 aPosition;
   *   in vec3 aNormal;
   *   in vec3 aVertexColor;
   *   in float aDistance;
   *
   *   out vec3 vVertexColor;
   *
   *   void main(){
   *     vec4 positionVec4 = vec4(aPosition, 1.0);
   *     positionVec4.xyz += aDistance * aNormal * 2.0;;
   *     vVertexColor = aVertexColor;
   *     gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   *   }
   * `;
   *
   * const fragSrc = `#version 300 es
   *   precision mediump float;
   *
   *   in vec3 vVertexColor;
   *   out vec4 outColor;
   *
   *   void main(){
   *     outColor = vec4(vVertexColor, 1.0);
   *   }
   * `;
   *
   * function setup(){
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create and apply the custom shader.
   *   myShader = createShader(vertSrc, fragSrc);
   *   shader(myShader);
   *   noStroke();
   *   describe('A blue grid, which moves away from the mouse position, on a gray background.');
   * }
   *
   * function draw(){
   *   background(200);
   *
   *   // Draw the grid in the middle of the screen.
   *   translate(-cols*cellSize/2, -rows*cellSize/2);
   *   beginShape(QUADS);
   *   for (let i = 0; i < cols; i++) {
   *     for (let j = 0; j < rows; j++) {
   *
   *       // Calculate the cell position.
   *       let x = i * cellSize;
   *       let y = j * cellSize;
   *
   *       fill(j/rows*255, j/cols*255, 255);
   *
   *       // Calculate the distance from the corner of each cell to the mouse.
   *       let distance = dist(x, y, mouseX, mouseY);
   *
   *       // Send the distance to the shader.
   *       vertexProperty('aDistance', min(distance, 100));
   *
   *       vertex(x, y);
   *       vertex(x + cellSize, y);
   *       vertex(x + cellSize, y + cellSize);
   *       vertex(x, y + cellSize);
   *     }
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   */ fn.vertexProperty = function(attributeName, data) {
        // this._assert3d('vertexProperty');
        // p5._validateParameters('vertexProperty', arguments);
        this._renderer.vertexProperty(attributeName, data);
    };
}
if (typeof p5 !== 'undefined') {
    vertex(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/shape/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>shape
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function shape(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
];

//# sourceMappingURL=node_modules_p5_dist_shape_344fd037._.js.map