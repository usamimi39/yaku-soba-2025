{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/p5.DataArray.js"],"sourcesContent":["class DataArray {\n  constructor(initialLength = 128) {\n    this.length = 0;\n    this.data = new Float32Array(initialLength);\n    this.initialLength = initialLength;\n  }\n\n  /**\n   * Returns a Float32Array window sized to the exact length of the data\n   */\n  dataArray() {\n    return this.subArray(0, this.length);\n  }\n\n  /**\n   * A \"soft\" clear, which keeps the underlying storage size the same, but\n   * empties the contents of its dataArray()\n   */\n  clear() {\n    this.length = 0;\n  }\n\n  /**\n   * Can be used to scale a DataArray back down to fit its contents.\n   */\n  rescale() {\n    if (this.length < this.data.length / 2) {\n      // Find the power of 2 size that fits the data\n      const targetLength = 1 << Math.ceil(Math.log2(this.length));\n      const newData = new Float32Array(targetLength);\n      newData.set(this.data.subarray(0, this.length), 0);\n      this.data = newData;\n    }\n  }\n\n  /**\n   * A full reset, which allocates a new underlying Float32Array at its initial\n   * length\n   */\n  reset() {\n    this.clear();\n    this.data = new Float32Array(this.initialLength);\n  }\n\n  /**\n   * Adds values to the DataArray, expanding its internal storage to\n   * accommodate the new items.\n   */\n  push(...values) {\n    this.ensureLength(this.length + values.length);\n    this.data.set(values, this.length);\n    this.length += values.length;\n  }\n\n  /**\n   * Returns a copy of the data from the index `from`, inclusive, to the index\n   * `to`, exclusive\n   */\n  slice(from, to) {\n    return this.data.slice(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Returns a mutable Float32Array window from the index `from`, inclusive, to\n   * the index `to`, exclusive\n   */\n  subArray(from, to) {\n    return this.data.subarray(from, Math.min(to, this.length));\n  }\n\n  /**\n   * Expand capacity of the internal storage until it can fit a target size\n   */\n  ensureLength(target) {\n    while (this.data.length < target) {\n      const newData = new Float32Array(this.data.length * 2);\n      newData.set(this.data, 0);\n      this.data = newData;\n    }\n  }\n}\nfunction dataArray(p5, fn){\n  /**\n   * An internal class to store data that will be sent to a p5.RenderBuffer.\n   * Those need to eventually go into a Float32Array, so this class provides a\n   * variable-length array container backed by a Float32Array so that it can be\n   * sent to the GPU without allocating a new array each frame.\n   *\n   * Like a C++ vector, its fixed-length Float32Array backing its contents will\n   * double in size when it goes over its capacity.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Initialize storage with a capacity of 4\n   * const storage = new DataArray(4);\n   * console.log(storage.data.length); // 4\n   * console.log(storage.length); // 0\n   * console.log(storage.dataArray()); // Empty Float32Array\n   *\n   * storage.push(1, 2, 3, 4, 5, 6);\n   * console.log(storage.data.length); // 8\n   * console.log(storage.length); // 6\n   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}\n   * </code>\n   * </div>\n   */\n  p5.DataArray = DataArray;\n}\n\nif(typeof p5 !== 'undefined'){\n  dataArray(p5, p5.prototype);\n}\n\nexport { DataArray, dataArray as default };\n"],"names":[],"mappings":";;;;;;AAAA,MAAM;IACJ,YAAY,gBAAgB,GAAG,CAAE;QAC/B,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,IAAI,GAAG,IAAI,aAAa;QAC7B,IAAI,CAAC,aAAa,GAAG;IACvB;IAEA;;GAEC,GACD,YAAY;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,MAAM;IACrC;IAEA;;;GAGC,GACD,QAAQ;QACN,IAAI,CAAC,MAAM,GAAG;IAChB;IAEA;;GAEC,GACD,UAAU;QACR,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG;YACtC,8CAA8C;YAC9C,MAAM,eAAe,KAAK,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,MAAM;YACzD,MAAM,UAAU,IAAI,aAAa;YACjC,QAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG;YAChD,IAAI,CAAC,IAAI,GAAG;QACd;IACF;IAEA;;;GAGC,GACD,QAAQ;QACN,IAAI,CAAC,KAAK;QACV,IAAI,CAAC,IAAI,GAAG,IAAI,aAAa,IAAI,CAAC,aAAa;IACjD;IAEA;;;GAGC,GACD,KAAK,GAAG,MAAM,EAAE;QACd,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,MAAM,GAAG,OAAO,MAAM;QAC7C,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,QAAQ,IAAI,CAAC,MAAM;QACjC,IAAI,CAAC,MAAM,IAAI,OAAO,MAAM;IAC9B;IAEA;;;GAGC,GACD,MAAM,IAAI,EAAE,EAAE,EAAE;QACd,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM;IACvD;IAEA;;;GAGC,GACD,SAAS,IAAI,EAAE,EAAE,EAAE;QACjB,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,MAAM;IAC1D;IAEA;;GAEC,GACD,aAAa,MAAM,EAAE;QACnB,MAAO,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,OAAQ;YAChC,MAAM,UAAU,IAAI,aAAa,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG;YACpD,QAAQ,GAAG,CAAC,IAAI,CAAC,IAAI,EAAE;YACvB,IAAI,CAAC,IAAI,GAAG;QACd;IACF;AACF;AACA,SAAS,UAAU,GAAE,EAAE,EAAE;IACvB;;;;;;;;;;;;;;;;;;;;;;;;GAwBC,GACD,IAAG,SAAS,GAAG;AACjB;AAEA,IAAG,OAAO,OAAO,aAAY;IAC3B,UAAU,IAAI,GAAG,SAAS;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/p5.Geometry.js"],"sourcesContent":["import { F as FLAT, y as SMOOTH } from '../constants-Bt1VTUeD.js';\nimport { DataArray } from './p5.DataArray.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { downloadFile } from '../io/utilities.js';\nimport 'file-saver';\n\n/**\n * @module Shape\n * @submodule 3D Primitives\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nclass Geometry {\n  constructor(detailX, detailY, callback, renderer) {\n    this.renderer = renderer;\n    this.vertices = [];\n\n    this.boundingBoxCache = null;\n\n\n    //an array containing every vertex for stroke drawing\n    this.lineVertices = new DataArray();\n\n    // The tangents going into or out of a vertex on a line. Along a straight\n    // line segment, both should be equal. At an endpoint, one or the other\n    // will not exist and will be all 0. In joins between line segments, they\n    // may be different, as they will be the tangents on either side of the join.\n    this.lineTangentsIn = new DataArray();\n    this.lineTangentsOut = new DataArray();\n\n    // When drawing lines with thickness, entries in this buffer represent which\n    // side of the centerline the vertex will be placed. The sign of the number\n    // will represent the side of the centerline, and the absolute value will be\n    // used as an enum to determine which part of the cap or join each vertex\n    // represents. See the doc comments for _addCap and _addJoin for diagrams.\n    this.lineSides = new DataArray();\n\n    this.vertexNormals = [];\n\n    this.faces = [];\n\n    this.uvs = [];\n    // a 2D array containing edge connectivity pattern for create line vertices\n    //based on faces for most objects;\n    this.edges = [];\n    this.vertexColors = [];\n\n    // One color per vertex representing the stroke color at that vertex\n    this.vertexStrokeColors = [];\n\n    this.userVertexProperties = {};\n\n    // One color per line vertex, generated automatically based on\n    // vertexStrokeColors in _edgesToVertices()\n    this.lineVertexColors = new DataArray();\n    this.detailX = detailX !== undefined ? detailX : 1;\n    this.detailY = detailY !== undefined ? detailY : 1;\n    this.dirtyFlags = {};\n\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.gid = `_p5_Geometry_${Geometry.nextId}`;\n    Geometry.nextId++;\n    if (callback instanceof Function) {\n      callback.call(this);\n    }\n  }\n\n  /**\n   * Calculates the position and size of the smallest box that contains the geometry.\n   *\n   * A bounding box is the smallest rectangular prism that contains the entire\n   * geometry. It's defined by the box's minimum and maximum coordinates along\n   * each axis, as well as the size (length) and offset (center).\n   *\n   * Calling `myGeometry.calculateBoundingBox()` returns an object with four\n   * properties that describe the bounding box:\n   *\n   * ```js\n   * // Get myGeometry's bounding box.\n   * let bbox = myGeometry.calculateBoundingBox();\n   *\n   * // Print the bounding box to the console.\n   * console.log(bbox);\n   *\n   * // {\n   * //  // The minimum coordinate along each axis.\n   * //  min: { x: -1, y: -2, z: -3 },\n   * //\n   * //  // The maximum coordinate along each axis.\n   * //  max: { x: 1, y: 2, z: 3},\n   * //\n   * //  // The size (length) along each axis.\n   * //  size: { x: 2, y: 4, z: 6},\n   * //\n   * //  // The offset (center) along each axis.\n   * //  offset: { x: 0, y: 0, z: 0}\n   * // }\n   * ```\n   *\n   * @returns {Object} bounding box of the geometry.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let particles;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a new p5.Geometry object with random spheres.\n   *   particles = buildGeometry(createParticles);\n   *\n   *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the particles.\n   *   noStroke();\n   *   fill(255);\n   *\n   *   // Draw the particles.\n   *   model(particles);\n   *\n   *   // Calculate the bounding box.\n   *   let bbox = particles.calculateBoundingBox();\n   *\n   *   // Translate to the bounding box's center.\n   *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);\n   *\n   *   // Style the bounding box.\n   *   stroke(255);\n   *   noFill();\n   *\n   *   // Draw the bounding box.\n   *   box(bbox.size.x, bbox.size.y, bbox.size.z);\n   * }\n   *\n   * function createParticles() {\n   *   for (let i = 0; i < 10; i += 1) {\n   *     // Calculate random coordinates.\n   *     let x = randomGaussian(0, 15);\n   *     let y = randomGaussian(0, 15);\n   *     let z = randomGaussian(0, 15);\n   *\n   *     push();\n   *     // Translate to the particle's coordinates.\n   *     translate(x, y, z);\n   *     // Draw the particle.\n   *     sphere(3);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n  calculateBoundingBox() {\n    if (this.boundingBoxCache) {\n      return this.boundingBoxCache; // Return cached result if available\n    }\n\n    let minVertex = new Vector(\n      Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    let maxVertex = new Vector(\n      Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);\n\n    for (let i = 0; i < this.vertices.length; i++) {\n      let vertex = this.vertices[i];\n      minVertex.x = Math.min(minVertex.x, vertex.x);\n      minVertex.y = Math.min(minVertex.y, vertex.y);\n      minVertex.z = Math.min(minVertex.z, vertex.z);\n\n      maxVertex.x = Math.max(maxVertex.x, vertex.x);\n      maxVertex.y = Math.max(maxVertex.y, vertex.y);\n      maxVertex.z = Math.max(maxVertex.z, vertex.z);\n    }\n    // Calculate size and offset properties\n    let size = new Vector(maxVertex.x - minVertex.x,\n      maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);\n    let offset = new Vector((minVertex.x + maxVertex.x) / 2,\n      (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);\n\n    // Cache the result for future access\n    this.boundingBoxCache = {\n      min: minVertex,\n      max: maxVertex,\n      size: size,\n      offset: offset\n    };\n\n    return this.boundingBoxCache;\n  }\n\n  reset() {\n    this._hasFillTransparency = undefined;\n    this._hasStrokeTransparency = undefined;\n\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    this.vertices.length = 0;\n    this.edges.length = 0;\n    this.vertexColors.length = 0;\n    this.vertexStrokeColors.length = 0;\n    this.lineVertexColors.clear();\n    this.vertexNormals.length = 0;\n    this.uvs.length = 0;\n\n    for (const propName in this.userVertexProperties){\n      this.userVertexProperties[propName].delete();\n    }\n    this.userVertexProperties = {};\n\n    this.dirtyFlags = {};\n  }\n\n  hasFillTransparency() {\n    if (this._hasFillTransparency === undefined) {\n      this._hasFillTransparency = false;\n      for (let i = 0; i < this.vertexColors.length; i += 4) {\n        if (this.vertexColors[i + 3] < 1) {\n          this._hasFillTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasFillTransparency;\n  }\n  hasStrokeTransparency() {\n    if (this._hasStrokeTransparency === undefined) {\n      this._hasStrokeTransparency = false;\n      for (let i = 0; i < this.lineVertexColors.length; i += 4) {\n        if (this.lineVertexColors[i + 3] < 1) {\n          this._hasStrokeTransparency = true;\n          break;\n        }\n      }\n    }\n    return this._hasStrokeTransparency;\n  }\n\n  /**\n   * Removes the geometry’s internal colors.\n   *\n   * `p5.Geometry` objects can be created with \"internal colors\" assigned to\n   * vertices or the entire shape. When a geometry has internal colors,\n   * <a href=\"#/p5/fill\">fill()</a> has no effect. Calling\n   * `myGeometry.clearColors()` allows the\n   * <a href=\"#/p5/fill\">fill()</a> function to apply color to the geometry.\n   *\n   * @example\n   * <div>\n   * <code>\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create a p5.Geometry object.\n   *   // Set its internal color to red.\n   *   let myGeometry = buildGeometry(function() {\n   *     fill(255, 0, 0);\n   *     plane(20);\n   *   });\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object (center).\n   *   model(myGeometry);\n   *\n   *   // Translate the origin to the bottom-right.\n   *   translate(25, 25, 0);\n   *\n   *   // Try to fill the geometry with green.\n   *   fill(0, 255, 0);\n   *\n   *   // Draw the geometry again (bottom-right).\n   *   model(myGeometry);\n   *\n   *   // Clear the geometry's colors.\n   *   myGeometry.clearColors();\n   *\n   *   // Fill the geometry with blue.\n   *   fill(0, 0, 255);\n   *\n   *   // Translate the origin up.\n   *   translate(0, -50, 0);\n   *\n   *   // Draw the geometry again (top-right).\n   *   model(myGeometry);\n   *\n   *   describe(\n   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'\n   *   );\n   * }\n   * </code>\n   * </div>\n   */\n  clearColors() {\n    this.vertexColors = [];\n    return this;\n  }\n\n  /**\n   * The `saveObj()` function exports `p5.Geometry` objects as\n   * 3D models in the Wavefront .obj file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,\n   * as well as its texture coordinates and normals, if it has them.\n   *\n   * @method saveObj\n   * @param {String} [fileName='model.obj'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.obj'.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function()) {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn = createButton('Save .obj');\n   *   saveBtn.mousePressed(() => myModel.saveObj());\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveObj(fileName = 'model.obj') {\n    let objStr= '';\n\n\n    // Vertices\n    this.vertices.forEach(v => {\n      objStr += `v ${v.x} ${v.y} ${v.z}\\n`;\n    });\n\n    // Texture Coordinates (UVs)\n    if (this.uvs && this.uvs.length > 0) {\n      for (let i = 0; i < this.uvs.length; i += 2) {\n        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\\n`;\n      }\n    }\n\n    // Vertex Normals\n    if (this.vertexNormals && this.vertexNormals.length > 0) {\n      this.vertexNormals.forEach(n => {\n        objStr += `vn ${n.x} ${n.y} ${n.z}\\n`;\n      });\n\n    }\n    // Faces, obj vertex indices begin with 1 and not 0\n    // texture coordinate (uvs) and vertexNormal indices\n    // are indicated with trailing ints vertex/normal/uv\n    // ex 1/1/1 or 2//2 for vertices without uvs\n    this.faces.forEach(face => {\n      let faceStr = 'f';\n      face.forEach(index =>{\n        faceStr += ' ';\n        faceStr += index + 1;\n        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {\n          faceStr += '/';\n          if (this.uvs.length > 0) {\n            faceStr += index + 1;\n          }\n          faceStr += '/';\n          if (this.vertexNormals.length > 0) {\n            faceStr += index + 1;\n          }\n        }\n      });\n      objStr += faceStr + '\\n';\n    });\n\n    const blob = new Blob([objStr], { type: 'text/plain' });\n    downloadFile(blob, fileName , 'obj');\n\n  }\n\n  /**\n   * The `saveStl()` function exports `p5.Geometry` objects as\n   * 3D models in the STL stereolithography file format.\n   * This way, you can use the 3D shapes you create in p5.js in other software\n   * for rendering, animation, 3D printing, or more.\n   *\n   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.\n   *\n   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact\n   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.\n   *\n   * @method saveStl\n   * @param {String} [fileName='model.stl'] The name of the file to save the model as.\n   *                                        If not specified, the default file name will be 'model.stl'.\n   * @param {Object} [options] Optional settings.\n   * @param {Boolean} [options.binary=false] Whether or not a binary .stl file is saved.\n   * @example\n   * <div>\n   * <code>\n   * let myModel;\n   * let saveBtn1;\n   * let saveBtn2;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   myModel = buildGeometry(function() {\n   *     for (let i = 0; i < 5; i++) {\n   *       push();\n   *       translate(\n   *         random(-75, 75),\n   *         random(-75, 75),\n   *         random(-75, 75)\n   *       );\n   *       sphere(random(5, 50));\n   *       pop();\n   *     }\n   *   });\n   *\n   *   saveBtn1 = createButton('Save .stl');\n   *   saveBtn1.mousePressed(function() {\n   *     myModel.saveStl();\n   *   });\n   *   saveBtn2 = createButton('Save binary .stl');\n   *   saveBtn2.mousePressed(function() {\n   *     myModel.saveStl('model.stl', { binary: true });\n   *   });\n   *\n   *   describe('A few spheres rotating in space');\n   * }\n   *\n   * function draw() {\n   *   background(0);\n   *   noStroke();\n   *   lights();\n   *   rotateX(millis() * 0.001);\n   *   rotateY(millis() * 0.002);\n   *   model(myModel);\n   * }\n   * </code>\n   * </div>\n   */\n  saveStl(fileName = 'model.stl', { binary = false } = {}){\n    let modelOutput;\n    let name = fileName.substring(0, fileName.lastIndexOf('.'));\n    let faceNormals = [];\n    for (let f of this.faces) {\n      const U = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);\n      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);\n      const nx = U.y * V.z - U.z * V.y;\n      const ny = U.z * V.x - U.x * V.z;\n      const nz = U.x * V.y - U.y * V.x;\n      faceNormals.push(new Vector(nx, ny, nz).normalize());\n    }\n    if (binary) {\n      let offset = 80;\n      const bufferLength =\n        this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      modelOutput = new DataView(arrayBuffer);\n      modelOutput.setUint32(offset, this.faces.length, true);\n      offset += 4;\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput.setFloat32(offset, norm.x, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.y, true);\n        offset += 4;\n        modelOutput.setFloat32(offset, norm.z, true);\n        offset += 4;\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput.setFloat32(offset, vert.x, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.y, true);\n          offset += 4;\n          modelOutput.setFloat32(offset, vert.z, true);\n          offset += 4;\n        }\n        modelOutput.setUint16(offset, 0, true);\n        offset += 2;\n      }\n    } else {\n      modelOutput = 'solid ' + name + '\\n';\n\n      for (const [key, f] of Object.entries(this.faces)) {\n        const norm = faceNormals[key];\n        modelOutput +=\n          ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\\n';\n        modelOutput += '  outer loop' + '\\n';\n        for (let vertexIndex of f) {\n          const vert = this.vertices[vertexIndex];\n          modelOutput +=\n            '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\\n';\n        }\n        modelOutput += '  endloop' + '\\n';\n        modelOutput += ' endfacet' + '\\n';\n      }\n      modelOutput += 'endsolid ' + name + '\\n';\n    }\n    const blob = new Blob([modelOutput], { type: 'text/plain' });\n    downloadFile(blob, fileName, 'stl');\n  }\n\n  /**\n   * Flips the geometry’s texture u-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates\n   * so that the texture appears mirrored horizontally.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipU()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the u-coordinates.\n   * myGeometry.flipU();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]\n   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]\n   * ```\n   *\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's U texture coordinates.\n   *   geom2.flipU();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipU() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return 1 - val;\n      } else {\n        return val;\n      }\n    });\n  }\n\n  /**\n   * Flips the geometry’s texture v-coordinates.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a rectangular\n   * image that's used as a texture. The geometry's vertex at coordinates\n   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.\n   *\n   * The <a href=\"#/p5.Geometry/uvs\">myGeometry.uvs</a> array stores the\n   * `(u, v)` coordinates for each vertex in the order it was added to the\n   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates\n   * so that the texture appears mirrored vertically.\n   *\n   * For example, a plane's four vertices are added clockwise starting from the\n   * top-left corner. Here's how calling `myGeometry.flipV()` would change a\n   * plane's texture coordinates:\n   *\n   * ```js\n   * // Print the original texture coordinates.\n   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]\n   * console.log(myGeometry.uvs);\n   *\n   * // Flip the v-coordinates.\n   * myGeometry.flipV();\n   *\n   * // Print the flipped texture coordinates.\n   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]\n   * console.log(myGeometry.uvs);\n   *\n   * // Notice the swaps:\n   * // Left vertices: [0, 0] <--> [1, 0]\n   * // Right vertices: [1, 0] <--> [1, 1]\n   * ```\n   *\n   * @method flipV\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Flip geom2's V texture coordinates.\n   *   geom2.flipV();\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Right (flipped).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n  flipV() {\n    this.uvs = this.uvs.flat().map((val, index) => {\n      if (index % 2 === 0) {\n        return val;\n      } else {\n        return 1 - val;\n      }\n    });\n  }\n\n  /**\n   * Computes the geometry's faces using its vertices.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles that\n   * are stitched together. Each triangular patch on the geometry's surface is\n   * called a *face*. `myGeometry.computeFaces()` performs the math needed to\n   * define each face based on the distances between vertices.\n   *\n   * The geometry's vertices are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a>\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * Calling `myGeometry.computeFaces()` fills the\n   * <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> array with three-element\n   * arrays that list the vertices that form each face. For example, a geometry\n   * made from a rectangle has two faces because a rectangle is made by joining\n   * two triangles. <a href=\"#/p5.Geometry/faces\">myGeometry.faces</a> for a\n   * rectangle would be the two-dimensional array\n   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the\n   * array `[0, 1, 2]` because it's formed by connecting\n   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the\n   * array `[2, 1, 3]` because it's formed by connecting\n   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and\n   * `myGeometry.vertices[3]`.\n   *\n   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to myGeometry's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute myGeometry's faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the shape.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   * }\n   * </code>\n   * </div>\n   */\n  computeFaces() {\n    this.faces.length = 0;\n    const sliceCount = this.detailX + 1;\n    let a, b, c, d;\n    for (let i = 0; i < this.detailY; i++) {\n      for (let j = 0; j < this.detailX; j++) {\n        a = i * sliceCount + j; // + offset;\n        b = i * sliceCount + j + 1; // + offset;\n        c = (i + 1) * sliceCount + j + 1; // + offset;\n        d = (i + 1) * sliceCount + j; // + offset;\n        this.faces.push([a, b, d]);\n        this.faces.push([d, b, c]);\n      }\n    }\n    return this;\n  }\n\n  _getFaceNormal(faceId) {\n    //This assumes that vA->vB->vC is a counter-clockwise ordering\n    const face = this.faces[faceId];\n    const vA = this.vertices[face[0]];\n    const vB = this.vertices[face[1]];\n    const vC = this.vertices[face[2]];\n    const ab = Vector.sub(vB, vA);\n    const ac = Vector.sub(vC, vA);\n    const n = Vector.cross(ab, ac);\n    const ln = Vector.mag(n);\n    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));\n    if (sinAlpha === 0 || isNaN(sinAlpha)) {\n      console.warn(\n        'p5.Geometry.prototype._getFaceNormal:',\n        'face has colinear sides or a repeated vertex'\n      );\n      return n;\n    }\n    if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error\n    return n.mult(Math.asin(sinAlpha) / ln);\n  }\n  /**\n   * Calculates the normal vector for each vertex on the geometry.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to create triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*. `myGeometry.computeNormals()` performs the\n   * math needed to orient each face. Orientation is important for lighting\n   * and other effects.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal vector.\n   * Then it calculates the normal vector for each vertex by averaging the\n   * normal vectors of the faces surrounding the vertex. The vertex normals\n   * are stored as <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertexNormals\">myGeometry.vertexNormals</a> array.\n   *\n   * The first parameter, `shadingType`, is optional. Passing the constant\n   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring\n   * faces with their own copies of the vertices they share. Surfaces appear\n   * tiled with flat shading. Passing the constant `SMOOTH`, as in\n   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their\n   * shared vertices. Surfaces appear smoother with smooth shading. By\n   * default, `shadingType` is `FLAT`.\n   *\n   * The second parameter, `options`, is also optional. If an object with a\n   * `roundToPrecision` property is passed, as in\n   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the\n   * number of decimal places to use for calculations. By default,\n   * `roundToPrecision` uses 3 decimal places.\n   *\n   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.\n   * @param {Object} [options] shading options.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus();\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     \"A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices.\"\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   stroke(0);\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 5);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using default (FLAT) shading.\n   *   myGeometry.computeNormals(FLAT);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(createShape);\n   *\n   *   // Create an options object.\n   *   let options = { roundToPrecision: 5 };\n   *\n   *   // Compute normals using smooth shading.\n   *   myGeometry.computeNormals(SMOOTH, options);\n   *\n   *   describe('A white, helical structure drawn on a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateX(1);\n   *\n   *   // Style the helix.\n   *   noStroke();\n   *\n   *   // Display the helix.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create a helical shape.\n   *   beginShape();\n   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {\n   *     let x = 30 * cos(i);\n   *     let y = 30 * sin(i);\n   *     let z = map(i, 0, TWO_PI * 3, -40, 40);\n   *     vertex(x, y, z);\n   *   }\n   *   endShape();\n   * }\n   * </code>\n   * </div>\n   */\n  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {\n    const vertexNormals = this.vertexNormals;\n    let vertices = this.vertices;\n    const faces = this.faces;\n    let iv;\n\n    if (shadingType === SMOOTH) {\n      const vertexIndices = {};\n      const uniqueVertices = [];\n\n      const power = Math.pow(10, roundToPrecision);\n      const rounded = val => Math.round(val * power) / power;\n      const getKey = vert =>\n        `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;\n\n      // loop through each vertex and add uniqueVertices\n      for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        const key = getKey(vertex);\n        if (vertexIndices[key] === undefined) {\n          vertexIndices[key] = uniqueVertices.length;\n          uniqueVertices.push(vertex);\n        }\n      }\n\n      // update face indices to use the deduplicated vertex indices\n      faces.forEach(face => {\n        for (let fv = 0; fv < 3; ++fv) {\n          const originalVertexIndex = face[fv];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          face[fv] = vertexIndices[key];\n        }\n      });\n\n      // update edge indices to use the deduplicated vertex indices\n      this.edges.forEach(edge => {\n        for (let ev = 0; ev < 2; ++ev) {\n          const originalVertexIndex = edge[ev];\n          const originalVertex = vertices[originalVertexIndex];\n          const key = getKey(originalVertex);\n          edge[ev] = vertexIndices[key];\n        }\n      });\n\n      // update the deduplicated vertices\n      this.vertices = vertices = uniqueVertices;\n    }\n\n    // initialize the vertexNormals array with empty vectors\n    vertexNormals.length = 0;\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals.push(new Vector());\n    }\n\n    // loop through all the faces adding its normal to the normal\n    // of each of its vertices\n    faces.forEach((face, f) => {\n      const faceNormal = this._getFaceNormal(f);\n\n      // all three vertices get the normal added\n      for (let fv = 0; fv < 3; ++fv) {\n        const vertexIndex = face[fv];\n        vertexNormals[vertexIndex].add(faceNormal);\n      }\n    });\n\n    // normalize the normals\n    for (iv = 0; iv < vertices.length; ++iv) {\n      vertexNormals[iv].normalize();\n    }\n\n    return this;\n  }\n\n  /**\n   * Averages the vertex normals. Used in curved\n   * surfaces\n   * @private\n   * @chainable\n   */\n  averageNormals() {\n    for (let i = 0; i <= this.detailY; i++) {\n      const offset = this.detailX + 1;\n      let temp = Vector.add(\n        this.vertexNormals[i * offset],\n        this.vertexNormals[i * offset + this.detailX]\n      );\n\n      temp = Vector.div(temp, 2);\n      this.vertexNormals[i * offset] = temp;\n      this.vertexNormals[i * offset + this.detailX] = temp;\n    }\n    return this;\n  }\n\n  /**\n   * Averages pole normals.  Used in spherical primitives\n   * @private\n   * @chainable\n   */\n  averagePoleNormals() {\n    //average the north pole\n    let sum = new Vector(0, 0, 0);\n    for (let i = 0; i < this.detailX; i++) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (let i = 0; i < this.detailX; i++) {\n      this.vertexNormals[i] = sum;\n    }\n\n    //average the south pole\n    sum = new Vector(0, 0, 0);\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      sum.add(this.vertexNormals[i]);\n    }\n    sum = Vector.div(sum, this.detailX);\n\n    for (\n      let i = this.vertices.length - 1;\n      i > this.vertices.length - 1 - this.detailX;\n      i--\n    ) {\n      this.vertexNormals[i] = sum;\n    }\n    return this;\n  }\n\n  /**\n   * Create a 2D array for establishing stroke connections\n   * @private\n   * @chainable\n   */\n  _makeTriangleEdges() {\n    this.edges.length = 0;\n\n    for (let j = 0; j < this.faces.length; j++) {\n      this.edges.push([this.faces[j][0], this.faces[j][1]]);\n      this.edges.push([this.faces[j][1], this.faces[j][2]]);\n      this.edges.push([this.faces[j][2], this.faces[j][0]]);\n    }\n\n    return this;\n  }\n\n  /**\n   * @example\n   * <div>\n   * <code>\n   * let tetrahedron;\n   * function setup() {\n   *   createCanvas(200, 200, WEBGL);\n   *   describe('A rotating tetrahedron');\n   *\n   *   tetrahedron = new p5.Geometry();\n   *\n   *   // Give each geometry a unique gid\n   *   tetrahedron.gid = 'tetrahedron';\n   *\n   *   // Add four points of the tetrahedron\n   *\n   *   let radius = 50;\n   *   // A 2D triangle:\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));\n   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));\n   *   // Add a tip in the z axis:\n   *   tetrahedron.vertices.push(createVector(0, 0, radius));\n   *\n   *   // Create the four faces by connecting the sets of three points\n   *   tetrahedron.faces.push([0, 1, 2]);\n   *   tetrahedron.faces.push([0, 1, 3]);\n   *   tetrahedron.faces.push([0, 2, 3]);\n   *   tetrahedron.faces.push([1, 2, 3]);\n   *   tetrahedron.makeEdgesFromFaces();\n   * }\n   * function draw() {\n   *   background(200);\n   *   strokeWeight(2);\n   *   orbitControl();\n   *   rotateY(millis() * 0.001);\n   *   model(tetrahedron);\n   * }\n   * </code>\n   * </div>\n   */\n  makeEdgesFromFaces() {\n    this._makeTriangleEdges();\n  }\n\n  /**\n   * Converts each line segment into the vertices and vertex attributes needed\n   * to turn the line into a polygon on screen. This will include:\n   * - Two triangles line segment to create a rectangle\n   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment\n   *   shader is responsible for displaying the appropriate cap style within\n   *   that rectangle.\n   * - Four triangles per join between adjacent line segments, creating a quad on\n   *   either side of the join, perpendicular to the lines. A vertex shader will\n   *   discard the quad in the \"elbow\" of the join, and a fragment shader will\n   *   display the appropriate join style within the remaining quad.\n   *\n   * @private\n   * @chainable\n   */\n  _edgesToVertices() {\n    this.lineVertices.clear();\n    this.lineTangentsIn.clear();\n    this.lineTangentsOut.clear();\n    this.lineSides.clear();\n\n    const potentialCaps = new Map();\n    const connected = new Set();\n    let lastValidDir;\n    for (let i = 0; i < this.edges.length; i++) {\n      const prevEdge = this.edges[i - 1];\n      const currEdge = this.edges[i];\n      const begin = this.vertices[currEdge[0]];\n      const end = this.vertices[currEdge[1]];\n      const prevColor = (this.vertexStrokeColors.length > 0 && prevEdge)\n        ? this.vertexStrokeColors.slice(\n          prevEdge[1] * 4,\n          (prevEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const fromColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[0] * 4,\n          (currEdge[0] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const toColor = this.vertexStrokeColors.length > 0\n        ? this.vertexStrokeColors.slice(\n          currEdge[1] * 4,\n          (currEdge[1] + 1) * 4\n        )\n        : [0, 0, 0, 0];\n      const dir = end\n        .copy()\n        .sub(begin)\n        .normalize();\n      const dirOK = dir.magSq() > 0;\n      if (dirOK) {\n        this._addSegment(begin, end, fromColor, toColor, dir);\n      }\n      if (!this.renderer?._simpleLines) {\n        if (i > 0 && prevEdge[1] === currEdge[0]) {\n          if (!connected.has(currEdge[0])) {\n            connected.add(currEdge[0]);\n            potentialCaps.delete(currEdge[0]);\n            // Add a join if this segment shares a vertex with the previous. Skip\n            // actually adding join vertices if either the previous segment or this\n            // one has a length of 0.\n            //\n            // Don't add a join if the tangents point in the same direction, which\n            // would mean the edges line up exactly, and there is no need for a join.\n            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {\n              this._addJoin(begin, lastValidDir, dir, fromColor);\n            }\n          }\n        } else {\n          // Start a new line\n          if (dirOK && !connected.has(currEdge[0])) {\n            const existingCap = potentialCaps.get(currEdge[0]);\n            if (existingCap) {\n              this._addJoin(\n                begin,\n                existingCap.dir,\n                dir,\n                fromColor\n              );\n              potentialCaps.delete(currEdge[0]);\n              connected.add(currEdge[0]);\n            } else {\n              potentialCaps.set(currEdge[0], {\n                point: begin,\n                dir: dir.copy().mult(-1),\n                color: fromColor\n              });\n            }\n          }\n          if (lastValidDir && !connected.has(prevEdge[1])) {\n            const existingCap = potentialCaps.get(prevEdge[1]);\n            if (existingCap) {\n              this._addJoin(\n                this.vertices[prevEdge[1]],\n                lastValidDir,\n                existingCap.dir.copy().mult(-1),\n                prevColor\n              );\n              potentialCaps.delete(prevEdge[1]);\n              connected.add(prevEdge[1]);\n            } else {\n              // Close off the last segment with a cap\n              potentialCaps.set(prevEdge[1], {\n                point: this.vertices[prevEdge[1]],\n                dir: lastValidDir,\n                color: prevColor\n              });\n            }\n            lastValidDir = undefined;\n          }\n        }\n\n        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {\n          const existingCap = potentialCaps.get(currEdge[1]);\n          if (existingCap) {\n            this._addJoin(\n              end,\n              dir,\n              existingCap.dir.copy().mult(-1),\n              toColor\n            );\n            potentialCaps.delete(currEdge[1]);\n            connected.add(currEdge[1]);\n          } else {\n            potentialCaps.set(currEdge[1], {\n              point: end,\n              dir,\n              color: toColor\n            });\n          }\n        }\n\n        if (dirOK) {\n          lastValidDir = dir;\n        }\n      }\n    }\n    for (const { point, dir, color } of potentialCaps.values()) {\n      this._addCap(point, dir, color);\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles making a rectangle\n   * for a straight line segment. A vertex shader is responsible for picking\n   * proper coordinates on the screen given the centerline positions, the tangent,\n   * and the side of the centerline each vertex belongs to. Sides follow the\n   * following scheme:\n   *\n   *  -1            -1\n   *   o-------------o\n   *   |             |\n   *   o-------------o\n   *   1             1\n   *\n   * @private\n   * @chainable\n   */\n  _addSegment(\n    begin,\n    end,\n    fromColor,\n    toColor,\n    dir\n  ) {\n    const a = begin.array();\n    const b = end.array();\n    const dirArr = dir.array();\n    this.lineSides.push(1, 1, -1, 1, -1, -1);\n    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {\n      for (let i = 0; i < 6; i++) {\n        tangents.push(...dirArr);\n      }\n    }\n    this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);\n    if (!this.renderer?._simpleLines) {\n      this.lineVertexColors.push(\n        ...fromColor,\n        ...toColor,\n        ...fromColor,\n        ...toColor,\n        ...toColor,\n        ...fromColor\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for two triangles representing the\n   * stroke cap of a line. A fragment shader is responsible for displaying the\n   * appropriate cap style within the rectangle they make.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the cap rectangle:\n   *\n   *           -1  -2\n   * -----------o---o\n   *            |   |\n   * -----------o---o\n   *            1   2\n   * @private\n   * @chainable\n   */\n  _addCap(point, tangent, color) {\n    const ptArray = point.array();\n    const tanInArray = tangent.array();\n    const tanOutArray = [0, 0, 0];\n    for (let i = 0; i < 6; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, 2, -2, 1, 2, -1);\n    return this;\n  }\n\n  /**\n   * Adds the vertices and vertex attributes for four triangles representing a\n   * join between two adjacent line segments. This creates a quad on either side\n   * of the shared vertex of the two line segments, with each quad perpendicular\n   * to the lines. A vertex shader will discard all but the quad in the \"elbow\" of\n   * the join, and a fragment shader will display the appropriate join style\n   * within the remaining quad.\n   *\n   * The lineSides buffer will include the following values for the points on\n   * the join rectangles:\n   *\n   *            -1     -2\n   * -------------o----o\n   *              |    |\n   *       1 o----o----o -3\n   *         |    | 0  |\n   * --------o----o    |\n   *        2|    3    |\n   *         |         |\n   *         |         |\n   * @private\n   * @chainable\n   */\n  _addJoin(\n    point,\n    fromTangent,\n    toTangent,\n    color\n  ) {\n    const ptArray = point.array();\n    const tanInArray = fromTangent.array();\n    const tanOutArray = toTangent.array();\n    for (let i = 0; i < 12; i++) {\n      this.lineVertices.push(...ptArray);\n      this.lineTangentsIn.push(...tanInArray);\n      this.lineTangentsOut.push(...tanOutArray);\n      this.lineVertexColors.push(...color);\n    }\n    this.lineSides.push(-1, -3, -2, -1, 0, -3);\n    this.lineSides.push(3, 1, 2, 3, 0, 1);\n    return this;\n  }\n\n  /**\n   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box\n   * centered at the origin.\n   *\n   * Calling `myGeometry.normalize()` translates the geometry's vertices so that\n   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so\n   * that they fill a 100×100×100 box. As a result, small geometries will grow\n   * and large geometries will shrink.\n   *\n   * Note: `myGeometry.normalize()` only works when called in the\n   * <a href=\"#/p5/setup\">setup()</a> function.\n   *\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a very small torus.\n   *   myGeometry = buildGeometry(function() {;\n   *     torus(1, 0.25);\n   *   });\n   *\n   *   // Normalize the torus so its vertices fill\n   *   // the range [-100, 100].\n   *   myGeometry.normalize();\n   *\n   *   describe('A white torus rotates slowly against a dark gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate around the y-axis.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the torus.\n   *   noStroke();\n   *\n   *   // Draw the torus.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n  normalize() {\n    if (this.vertices.length > 0) {\n      // Find the corners of our bounding box\n      const maxPosition = this.vertices[0].copy();\n      const minPosition = this.vertices[0].copy();\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);\n        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);\n        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);\n        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);\n        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);\n        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);\n      }\n\n      const center = Vector.lerp(maxPosition, minPosition, 0.5);\n      const dist = Vector.sub(maxPosition, minPosition);\n      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);\n      const scale = 200 / longestDist;\n\n      for (let i = 0; i < this.vertices.length; i++) {\n        this.vertices[i].sub(center);\n        this.vertices[i].mult(scale);\n      }\n    }\n    return this;\n  }\n\n  /** Sets the shader's vertex property or attribute variables.\n   *\n   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some\n   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are\n   * set using <a href=\"#/p5/vertex\">vertex()</a>, <a href=\"#/p5/normal\">normal()</a>\n   * and <a href=\"#/p5/fill\">fill()</a> respectively. Custom properties can also\n   * be defined within <a href=\"#/p5/beginShape\">beginShape()</a> and\n   * <a href=\"#/p5/endShape\">endShape()</a>.\n   *\n   * The first parameter, `propertyName`, is a string with the property's name.\n   * This is the same variable name which should be declared in the shader, as in\n   * `in vec3 aProperty`, similar to .`setUniform()`.\n   *\n   * The second parameter, `data`, is the value assigned to the shader variable. This value\n   * will be pushed directly onto the Geometry object. There should be the same number\n   * of custom property values as vertices, this method should be invoked once for each\n   * vertex.\n   *\n   * The `data` can be a Number or an array of numbers. Tn the shader program the type\n   * can be declared according to the WebGL specification. Common types include `float`,\n   * `vec2`, `vec3`, `vec4` or matrices.\n   *\n   * See also the global <a href=\"#/p5/vertexProperty\">vertexProperty()</a> function.\n   *\n   * @example\n   * <div>\n   * <code>\n   * let geo;\n   *\n   * function cartesianToSpherical(x, y, z) {\n   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));\n   *   let theta = acos(z / r);\n   *   let phi = atan2(y, x);\n   *   return { theta, phi };\n   * }\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Modify the material shader to display roughness.\n   *   const myShader = baseMaterialShader().modify({\n   *     vertexDeclarations:`in float aRoughness;\n   *                         out float vRoughness;`,\n   *     fragmentDeclarations: 'in float vRoughness;',\n   *     'void afterVertex': `() {\n   *         vRoughness = aRoughness;\n   *     }`,\n   *     'vec4 combineColors': `(ColorComponents components) {\n   *             vec4 color = vec4(0.);\n   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);\n   *             color.rgb += components.ambient * components.ambientColor;\n   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);\n   *             color.a = components.opacity;\n   *             return color;\n   *     }`\n   *   });\n   *\n   *   // Create the Geometry object.\n   *   geo = buildGeometry(function() {\n   *     fill('hotpink');\n   *     sphere(45, 50, 50);\n   *   });\n   *\n   *   // Set the roughness value for every vertex.\n   *   for (let v of geo.vertices){\n   *\n   *     // convert coordinates to spherical coordinates\n   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);\n   *\n   *     // Set the custom roughness vertex property.\n   *     let roughness = noise(spherical.theta*5, spherical.phi*5);\n   *     geo.vertexProperty('aRoughness', roughness);\n   *   }\n   *\n   *   // Use the custom shader.\n   *   shader(myShader);\n   *\n   *   describe('A rough pink sphere rotating on a blue background.');\n   * }\n   *\n   * function draw() {\n   *   // Set some styles and lighting\n   *   background('lightblue');\n   *   noStroke();\n   *\n   *   specularMaterial(255,125,100);\n   *   shininess(2);\n   *\n   *   directionalLight('white', -1, 1, -1);\n   *   ambientLight(320);\n   *\n   *   rotateY(millis()*0.001);\n   *\n   *   // Draw the geometry\n   *   model(geo);\n   * }\n   * </code>\n   * </div>\n   *\n   * @param {String} propertyName the name of the vertex property.\n   * @param {Number|Number[]} data the data tied to the vertex property.\n   * @param {Number} [size] optional size of each unit of data.\n   */\n  vertexProperty(propertyName, data, size){\n    let prop;\n    if (!this.userVertexProperties[propertyName]){\n      prop = this.userVertexProperties[propertyName] =\n        this._userVertexPropertyHelper(propertyName, data, size);\n    }\n    prop = this.userVertexProperties[propertyName];\n    if (size){\n      prop.pushDirect(data);\n    } else {\n      prop.setCurrentData(data);\n      prop.pushCurrentData();\n    }\n  }\n\n  _userVertexPropertyHelper(propertyName, data, size){\n    const geometryInstance = this;\n    const prop = this.userVertexProperties[propertyName] = {\n      name: propertyName,\n      dataSize: size ? size : data.length ? data.length : 1,\n      geometry: geometryInstance,\n      // Getters\n      getName(){\n        return this.name;\n      },\n      getCurrentData(){\n        if (this.currentData === undefined) {\n          this.currentData = new Array(this.getDataSize()).fill(0);\n        }\n        return this.currentData;\n      },\n      getDataSize() {\n        return this.dataSize;\n      },\n      getSrcName() {\n        const src = this.name.concat('Src');\n        return src;\n      },\n      getDstName() {\n        const dst = this.name.concat('Buffer');\n        return dst;\n      },\n      getSrcArray() {\n        const srcName = this.getSrcName();\n        return this.geometry[srcName];\n      },\n      //Setters\n      setCurrentData(data) {\n        data.length ? data.length : 1;\n        // if (size != this.getDataSize()){\n        //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');\n        // }\n        this.currentData = data;\n      },\n      // Utilities\n      pushCurrentData(){\n        const data = this.getCurrentData();\n        this.pushDirect(data);\n      },\n      pushDirect(data) {\n        if (data.length){\n          this.getSrcArray().push(...data);\n        } else {\n          this.getSrcArray().push(data);\n        }\n      },\n      resetSrcArray(){\n        this.geometry[this.getSrcName()] = [];\n      },\n      delete() {\n        const srcName = this.getSrcName();\n        delete this.geometry[srcName];\n        delete this;\n      }\n    };\n    this[prop.getSrcName()] = [];\n    return this.userVertexProperties[propertyName];\n  }\n}\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometry.nextId = 0;\n\nfunction geometry(p5, fn){\n  /**\n   * A class to describe a 3D shape.\n   *\n   * Each `p5.Geometry` object represents a 3D shape as a set of connected\n   * points called *vertices*. All 3D shapes are made by connecting vertices to\n   * form triangles that are stitched together. Each triangular patch on the\n   * geometry's surface is called a *face*. The geometry stores information\n   * about its vertices and faces for use with effects such as lighting and\n   * texture mapping.\n   *\n   * The first parameter, `detailX`, is optional. If a number is passed, as in\n   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use\n   * along the geometry's x-axis. By default, `detailX` is 1.\n   *\n   * The second parameter, `detailY`, is also optional. If a number is passed,\n   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle\n   * subdivisions to use along the geometry's y-axis. By default, `detailX` is\n   * 1.\n   *\n   * The third parameter, `callback`, is also optional. If a function is passed,\n   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add\n   * vertices to the new 3D shape.\n   *\n   * @class p5.Geometry\n   * @param  {Integer} [detailX] number of vertices along the x-axis.\n   * @param  {Integer} [detailY] number of vertices along the y-axis.\n   * @param {Function} [callback] function to call once the geometry is created.\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object using a callback function.\n   *   myGeometry = new p5.Geometry(1, 1, createShape);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   this.vertices.push(v0, v1, v2);\n   *\n   *   // Add an array to list which vertices belong to the face.\n   *   // Vertices are listed in clockwise \"winding\" order from\n   *   // left to top to right.\n   *   this.faces.push([0, 1, 2]);\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.\n   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/\n   * // CC-BY-SA 4.0\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   // Set detailX to 48 and detailY to 2.\n   *   // >>> try changing them.\n   *   myGeometry = new p5.Geometry(48, 2, createShape);\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   strokeWeight(0.2);\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   *\n   * function createShape() {\n   *   // \"this\" refers to the p5.Geometry object being created.\n   *\n   *   // Define the Möbius strip with a few parameters.\n   *   let spread = 0.1;\n   *   let radius = 30;\n   *   let stripWidth = 15;\n   *   let xInterval = 4 * PI / this.detailX;\n   *   let yOffset = -stripWidth / 2;\n   *   let yInterval = stripWidth / this.detailY;\n   *\n   *   for (let j = 0; j <= this.detailY; j += 1) {\n   *     // Calculate the \"vertical\" point along the strip.\n   *     let v = yOffset + yInterval * j;\n   *\n   *     for (let i = 0; i <= this.detailX; i += 1) {\n   *       // Calculate the angle of rotation around the strip.\n   *       let u = i * xInterval;\n   *\n   *       // Calculate the coordinates of the vertex.\n   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;\n   *       let y = (radius + v * cos(u / 2)) * sin(u);\n   *       if (u < TWO_PI) {\n   *         y += sin(u) * spread;\n   *       } else {\n   *         y -= sin(u) * spread;\n   *       }\n   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;\n   *\n   *       // Create a p5.Vector object to position the vertex.\n   *       let vert = createVector(x, y, z);\n   *\n   *       // Add the vertex to the p5.Geometry object's vertices array.\n   *       this.vertices.push(vert);\n   *     }\n   *   }\n   *\n   *   // Compute the faces array.\n   *   this.computeFaces();\n   *\n   *   // Compute the surface normals to help with lighting.\n   *   this.computeNormals();\n   * }\n   * </code>\n   * </div>\n   */\n  p5.Geometry = Geometry;\n\n  /**\n   * An array with the geometry's vertices.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the `myGeometry.vertices`\n   * array. The geometry's first vertex is the\n   * <a href=\"#/p5.Vector\">p5.Vector</a> object at `myGeometry.vertices[0]`,\n   * its second vertex is `myGeometry.vertices[1]`, its third vertex is\n   * `myGeometry.vertices[2]`, and so on.\n   *\n   * @property vertices\n   * @for p5.Geometry\n   * @name vertices\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2);\n   *\n   *   describe('A white triangle drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   fill(255);\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the vertices.\n   *   fill(255, 0, 0);\n   *   noStroke();\n   *\n   *   // Iterate over the vertices array.\n   *   for (let v of myGeometry.vertices) {\n   *     // Draw a sphere to mark the vertex.\n   *     push();\n   *     translate(v);\n   *     sphere(2.5);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array with the vectors that are normal to the geometry's vertices.\n   *\n   * A face's orientation is defined by its *normal vector* which points out\n   * of the face and is normal (perpendicular) to the surface. Calling\n   * `myGeometry.computeNormals()` first calculates each face's normal\n   * vector. Then it calculates the normal vector for each vertex by\n   * averaging the normal vectors of the faces surrounding the vertex. The\n   * vertex normals are stored as <a href=\"#/p5.Vector\">p5.Vector</a>\n   * objects in the `myGeometry.vertexNormals` array.\n   *\n   * @property vertexNormals\n   * @name vertexNormals\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     torus(30, 15, 10, 8);\n   *   });\n   *\n   *   // Compute the vertex normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe(\n   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'\n   *   );\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Rotate the coordinate system.\n   *   rotateY(frameCount * 0.01);\n   *\n   *   // Style the p5.Geometry object.\n   *   stroke(0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   *\n   *   // Style the normal vectors.\n   *   stroke(255, 0, 0);\n   *\n   *   // Iterate over the vertices and vertexNormals arrays.\n   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {\n   *\n   *     // Get the vertex p5.Vector object.\n   *     let v = myGeometry.vertices[i];\n   *\n   *     // Get the vertex normal p5.Vector object.\n   *     let n = myGeometry.vertexNormals[i];\n   *\n   *     // Calculate a point along the vertex normal.\n   *     let p = p5.Vector.mult(n, 8);\n   *\n   *     // Draw the vertex normal as a red line.\n   *     push();\n   *     translate(v);\n   *     line(0, 0, 0, p.x, p.y, p.z);\n   *     pop();\n   *   }\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = new p5.Geometry();\n   *\n   *   // Create p5.Vector objects to position the vertices.\n   *   let v0 = createVector(-40, 0, 0);\n   *   let v1 = createVector(0, -40, 0);\n   *   let v2 = createVector(0, 40, 0);\n   *   let v3 = createVector(40, 0, 0);\n   *\n   *   // Add the vertices to the p5.Geometry object's vertices array.\n   *   myGeometry.vertices.push(v0, v1, v2, v3);\n   *\n   *   // Compute the faces array.\n   *   myGeometry.computeFaces();\n   *\n   *   // Compute the surface normals.\n   *   myGeometry.computeNormals();\n   *\n   *   describe('A red square drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Add a white point light.\n   *   pointLight(255, 255, 255, 0, 0, 10);\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *   fill(255, 0, 0);\n   *\n   *   // Display the p5.Geometry object.\n   *   model(myGeometry);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists which of the geometry's vertices form each of its\n   * faces.\n   *\n   * All 3D shapes are made by connecting sets of points called *vertices*. A\n   * geometry's surface is formed by connecting vertices to form triangles\n   * that are stitched together. Each triangular patch on the geometry's\n   * surface is called a *face*.\n   *\n   * The geometry's vertices are stored as\n   * <a href=\"#/p5.Vector\">p5.Vector</a> objects in the\n   * <a href=\"#/p5.Geometry/vertices\">myGeometry.vertices</a> array. The\n   * geometry's first vertex is the <a href=\"#/p5.Vector\">p5.Vector</a>\n   * object at `myGeometry.vertices[0]`, its second vertex is\n   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,\n   * and so on.\n   *\n   * For example, a geometry made from a rectangle has two faces because a\n   * rectangle is made by joining two triangles. `myGeometry.faces` for a\n   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.\n   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because\n   * it's formed by connecting `myGeometry.vertices[0]`,\n   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,\n   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by\n   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and\n   * `myGeometry.vertices[3]`.\n   *\n   * @property faces\n   * @name faces\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let myGeometry;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create a p5.Geometry object.\n   *   myGeometry = buildGeometry(function() {\n   *     sphere();\n   *   });\n   *\n   *   describe(\"A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.\");\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the p5.Geometry object.\n   *   noStroke();\n   *\n   *   // Set a random seed.\n   *   randomSeed(1234);\n   *\n   *   // Iterate over the faces array.\n   *   for (let face of myGeometry.faces) {\n   *\n   *     // Style the face.\n   *     let g = random(0, 255);\n   *     fill(g);\n   *\n   *     // Draw the face.\n   *     beginShape();\n   *     // Iterate over the vertices that form the face.\n   *     for (let f of face) {\n   *       // Get the vertex's p5.Vector object.\n   *       let v = myGeometry.vertices[f];\n   *       vertex(v.x, v.y, v.z);\n   *     }\n   *     endShape();\n   *\n   *   }\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * An array that lists the texture coordinates for each of the geometry's\n   * vertices.\n   *\n   * In order for <a href=\"#/p5/texture\">texture()</a> to work, the geometry\n   * needs a way to map the points on its surface to the pixels in a\n   * rectangular image that's used as a texture. The geometry's vertex at\n   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates\n   * `(u, v)`.\n   *\n   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each\n   * vertex in the order it was added to the geometry. For example, the\n   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates\n   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.\n   *\n   * @property uvs\n   * @name uvs\n   * @for p5.Geometry\n   *\n   * @example\n   * <div>\n   * <code>\n   * let img;\n   *\n   * async function setup() {\n   *   img = await loadImage('assets/laDefense.jpg');\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   background(200);\n   *\n   *   // Create p5.Geometry objects.\n   *   let geom1 = buildGeometry(createShape);\n   *   let geom2 = buildGeometry(createShape);\n   *\n   *   // Left (original).\n   *   push();\n   *   translate(-25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom1);\n   *   pop();\n   *\n   *   // Set geom2's texture coordinates.\n   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];\n   *\n   *   // Right (zoomed in).\n   *   push();\n   *   translate(25, 0, 0);\n   *   texture(img);\n   *   noStroke();\n   *   model(geom2);\n   *   pop();\n   *\n   *   describe(\n   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'\n   *   );\n   * }\n   *\n   * function createShape() {\n   *   plane(40);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * A unique identifier for this geometry. The renderer will use this to cache resources.\n   *\n   * @property {String} gid\n   * @for p5.Geometry\n   */\n}\n\nif(typeof p5 !== 'undefined'){\n  geometry(p5, p5.prototype);\n}\n\nexport { Geometry, geometry as default };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;;CAMC,GAGD,MAAM;IACJ,YAAY,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,QAAQ,CAAE;QAChD,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,QAAQ,GAAG,EAAE;QAElB,IAAI,CAAC,gBAAgB,GAAG;QAGxB,qDAAqD;QACrD,IAAI,CAAC,YAAY,GAAG,IAAI,mKAAS;QAEjC,yEAAyE;QACzE,uEAAuE;QACvE,yEAAyE;QACzE,6EAA6E;QAC7E,IAAI,CAAC,cAAc,GAAG,IAAI,mKAAS;QACnC,IAAI,CAAC,eAAe,GAAG,IAAI,mKAAS;QAEpC,4EAA4E;QAC5E,2EAA2E;QAC3E,4EAA4E;QAC5E,yEAAyE;QACzE,0EAA0E;QAC1E,IAAI,CAAC,SAAS,GAAG,IAAI,mKAAS;QAE9B,IAAI,CAAC,aAAa,GAAG,EAAE;QAEvB,IAAI,CAAC,KAAK,GAAG,EAAE;QAEf,IAAI,CAAC,GAAG,GAAG,EAAE;QACb,2EAA2E;QAC3E,kCAAkC;QAClC,IAAI,CAAC,KAAK,GAAG,EAAE;QACf,IAAI,CAAC,YAAY,GAAG,EAAE;QAEtB,oEAAoE;QACpE,IAAI,CAAC,kBAAkB,GAAG,EAAE;QAE5B,IAAI,CAAC,oBAAoB,GAAG,CAAC;QAE7B,8DAA8D;QAC9D,2CAA2C;QAC3C,IAAI,CAAC,gBAAgB,GAAG,IAAI,mKAAS;QACrC,IAAI,CAAC,OAAO,GAAG,YAAY,YAAY,UAAU;QACjD,IAAI,CAAC,OAAO,GAAG,YAAY,YAAY,UAAU;QACjD,IAAI,CAAC,UAAU,GAAG,CAAC;QAEnB,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,CAAC,sBAAsB,GAAG;QAE9B,IAAI,CAAC,GAAG,GAAG,CAAC,aAAa,EAAE,SAAS,MAAM,EAAE;QAC5C,SAAS,MAAM;QACf,IAAI,oBAAoB,UAAU;YAChC,SAAS,IAAI,CAAC,IAAI;QACpB;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiGC,GACD,uBAAuB;QACrB,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACzB,OAAO,IAAI,CAAC,gBAAgB,EAAE,oCAAoC;QACpE;QAEA,IAAI,YAAY,IAAI,4JAAM,CACxB,OAAO,SAAS,EAAE,OAAO,SAAS,EAAE,OAAO,SAAS;QACtD,IAAI,YAAY,IAAI,4JAAM,CACxB,OAAO,SAAS,EAAE,OAAO,SAAS,EAAE,OAAO,SAAS;QAEtD,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAK;YAC7C,IAAI,SAAS,IAAI,CAAC,QAAQ,CAAC,EAAE;YAC7B,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;YAC5C,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;YAC5C,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;YAE5C,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;YAC5C,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;YAC5C,UAAU,CAAC,GAAG,KAAK,GAAG,CAAC,UAAU,CAAC,EAAE,OAAO,CAAC;QAC9C;QACA,uCAAuC;QACvC,IAAI,OAAO,IAAI,4JAAM,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,EAC7C,UAAU,CAAC,GAAG,UAAU,CAAC,EAAE,UAAU,CAAC,GAAG,UAAU,CAAC;QACtD,IAAI,SAAS,IAAI,4JAAM,CAAC,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,GACpD,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,GAAG,CAAC,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI;QAEjE,qCAAqC;QACrC,IAAI,CAAC,gBAAgB,GAAG;YACtB,KAAK;YACL,KAAK;YACL,MAAM;YACN,QAAQ;QACV;QAEA,OAAO,IAAI,CAAC,gBAAgB;IAC9B;IAEA,QAAQ;QACN,IAAI,CAAC,oBAAoB,GAAG;QAC5B,IAAI,CAAC,sBAAsB,GAAG;QAE9B,IAAI,CAAC,YAAY,CAAC,KAAK;QACvB,IAAI,CAAC,cAAc,CAAC,KAAK;QACzB,IAAI,CAAC,eAAe,CAAC,KAAK;QAC1B,IAAI,CAAC,SAAS,CAAC,KAAK;QAEpB,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG;QACvB,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;QACpB,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG;QAC3B,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG;QACjC,IAAI,CAAC,gBAAgB,CAAC,KAAK;QAC3B,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG;QAC5B,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;QAElB,IAAK,MAAM,YAAY,IAAI,CAAC,oBAAoB,CAAC;YAC/C,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,MAAM;QAC5C;QACA,IAAI,CAAC,oBAAoB,GAAG,CAAC;QAE7B,IAAI,CAAC,UAAU,GAAG,CAAC;IACrB;IAEA,sBAAsB;QACpB,IAAI,IAAI,CAAC,oBAAoB,KAAK,WAAW;YAC3C,IAAI,CAAC,oBAAoB,GAAG;YAC5B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,KAAK,EAAG;gBACpD,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,GAAG,GAAG;oBAChC,IAAI,CAAC,oBAAoB,GAAG;oBAC5B;gBACF;YACF;QACF;QACA,OAAO,IAAI,CAAC,oBAAoB;IAClC;IACA,wBAAwB;QACtB,IAAI,IAAI,CAAC,sBAAsB,KAAK,WAAW;YAC7C,IAAI,CAAC,sBAAsB,GAAG;YAC9B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,gBAAgB,CAAC,MAAM,EAAE,KAAK,EAAG;gBACxD,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,GAAG,GAAG;oBACpC,IAAI,CAAC,sBAAsB,GAAG;oBAC9B;gBACF;YACF;QACF;QACA,OAAO,IAAI,CAAC,sBAAsB;IACpC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyDC,GACD,cAAc;QACZ,IAAI,CAAC,YAAY,GAAG,EAAE;QACtB,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgDC,GACD,QAAQ,WAAW,WAAW,EAAE;QAC9B,IAAI,SAAQ;QAGZ,WAAW;QACX,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAA;YACpB,UAAU,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC;QACtC;QAEA,4BAA4B;QAC5B,IAAI,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG;YACnC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,KAAK,EAAG;gBAC3C,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC;YACpD;QACF;QAEA,iBAAiB;QACjB,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,GAAG;YACvD,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAA;gBACzB,UAAU,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC;YACvC;QAEF;QACA,mDAAmD;QACnD,oDAAoD;QACpD,oDAAoD;QACpD,4CAA4C;QAC5C,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YACjB,IAAI,UAAU;YACd,KAAK,OAAO,CAAC,CAAA;gBACX,WAAW;gBACX,WAAW,QAAQ;gBACnB,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG;oBACxD,WAAW;oBACX,IAAI,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG,GAAG;wBACvB,WAAW,QAAQ;oBACrB;oBACA,WAAW;oBACX,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,GAAG;wBACjC,WAAW,QAAQ;oBACrB;gBACF;YACF;YACA,UAAU,UAAU;QACtB;QAEA,MAAM,OAAO,IAAI,KAAK;YAAC;SAAO,EAAE;YAAE,MAAM;QAAa;QACrD,IAAA,6JAAY,EAAC,MAAM,UAAW;IAEhC;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2DC,GACD,QAAQ,WAAW,WAAW,EAAE,EAAE,SAAS,KAAK,EAAE,GAAG,CAAC,CAAC,EAAC;QACtD,IAAI;QACJ,IAAI,OAAO,SAAS,SAAS,CAAC,GAAG,SAAS,WAAW,CAAC;QACtD,IAAI,cAAc,EAAE;QACpB,KAAK,IAAI,KAAK,IAAI,CAAC,KAAK,CAAE;YACxB,MAAM,IAAI,4JAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;YAC7D,MAAM,IAAI,4JAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;YAC7D,MAAM,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAChC,MAAM,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAChC,MAAM,KAAK,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC;YAChC,YAAY,IAAI,CAAC,IAAI,4JAAM,CAAC,IAAI,IAAI,IAAI,SAAS;QACnD;QACA,IAAI,QAAQ;YACV,IAAI,SAAS;YACb,MAAM,eACJ,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,IAAI,IAAI,KAAK;YAC/D,MAAM,cAAc,IAAI,YAAY;YACpC,cAAc,IAAI,SAAS;YAC3B,YAAY,SAAS,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACjD,UAAU;YACV,KAAK,MAAM,CAAC,KAAK,EAAE,IAAI,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,EAAG;gBACjD,MAAM,OAAO,WAAW,CAAC,IAAI;gBAC7B,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;gBACvC,UAAU;gBACV,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;gBACvC,UAAU;gBACV,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;gBACvC,UAAU;gBACV,KAAK,IAAI,eAAe,EAAG;oBACzB,MAAM,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY;oBACvC,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;oBACvC,UAAU;oBACV,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;oBACvC,UAAU;oBACV,YAAY,UAAU,CAAC,QAAQ,KAAK,CAAC,EAAE;oBACvC,UAAU;gBACZ;gBACA,YAAY,SAAS,CAAC,QAAQ,GAAG;gBACjC,UAAU;YACZ;QACF,OAAO;YACL,cAAc,WAAW,OAAO;YAEhC,KAAK,MAAM,CAAC,KAAK,EAAE,IAAI,OAAO,OAAO,CAAC,IAAI,CAAC,KAAK,EAAG;gBACjD,MAAM,OAAO,WAAW,CAAC,IAAI;gBAC7B,eACE,iBAAiB,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC,GAAG;gBAC1D,eAAe,iBAAiB;gBAChC,KAAK,IAAI,eAAe,EAAG;oBACzB,MAAM,OAAO,IAAI,CAAC,QAAQ,CAAC,YAAY;oBACvC,eACE,eAAe,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC,GAAG;gBAC1D;gBACA,eAAe,cAAc;gBAC7B,eAAe,cAAc;YAC/B;YACA,eAAe,cAAc,OAAO;QACtC;QACA,MAAM,OAAO,IAAI,KAAK;YAAC;SAAY,EAAE;YAAE,MAAM;QAAa;QAC1D,IAAA,6JAAY,EAAC,MAAM,UAAU;IAC/B;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgFC,GACD,QAAQ;QACN,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,KAAK;YACnC,IAAI,QAAQ,MAAM,GAAG;gBACnB,OAAO,IAAI;YACb,OAAO;gBACL,OAAO;YACT;QACF;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiFC,GACD,QAAQ;QACN,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC,KAAK;YACnC,IAAI,QAAQ,MAAM,GAAG;gBACnB,OAAO;YACT,OAAO;gBACL,OAAO,IAAI;YACb;QACF;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgIC,GACD,eAAe;QACb,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;QACpB,MAAM,aAAa,IAAI,CAAC,OAAO,GAAG;QAClC,IAAI,GAAG,GAAG,GAAG;QACb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,IAAK;YACrC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,IAAK;gBACrC,IAAI,IAAI,aAAa,GAAG,YAAY;gBACpC,IAAI,IAAI,aAAa,IAAI,GAAG,YAAY;gBACxC,IAAI,CAAC,IAAI,CAAC,IAAI,aAAa,IAAI,GAAG,YAAY;gBAC9C,IAAI,CAAC,IAAI,CAAC,IAAI,aAAa,GAAG,YAAY;gBAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;oBAAC;oBAAG;oBAAG;iBAAE;gBACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;oBAAC;oBAAG;oBAAG;iBAAE;YAC3B;QACF;QACA,OAAO,IAAI;IACb;IAEA,eAAe,MAAM,EAAE;QACrB,8DAA8D;QAC9D,MAAM,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO;QAC/B,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QACjC,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QACjC,MAAM,KAAK,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC;QACjC,MAAM,KAAK,4JAAM,CAAC,GAAG,CAAC,IAAI;QAC1B,MAAM,KAAK,4JAAM,CAAC,GAAG,CAAC,IAAI;QAC1B,MAAM,IAAI,4JAAM,CAAC,KAAK,CAAC,IAAI;QAC3B,MAAM,KAAK,4JAAM,CAAC,GAAG,CAAC;QACtB,IAAI,WAAW,KAAK,CAAC,4JAAM,CAAC,GAAG,CAAC,MAAM,4JAAM,CAAC,GAAG,CAAC,GAAG;QACpD,IAAI,aAAa,KAAK,MAAM,WAAW;YACrC,QAAQ,IAAI,CACV,yCACA;YAEF,OAAO;QACT;QACA,IAAI,WAAW,GAAG,WAAW,GAAG,8BAA8B;QAC9D,OAAO,EAAE,IAAI,CAAC,KAAK,IAAI,CAAC,YAAY;IACtC;IACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkTC,GACD,eAAe,cAAc,wJAAI,EAAE,EAAE,mBAAmB,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;QAChE,MAAM,gBAAgB,IAAI,CAAC,aAAa;QACxC,IAAI,WAAW,IAAI,CAAC,QAAQ;QAC5B,MAAM,QAAQ,IAAI,CAAC,KAAK;QACxB,IAAI;QAEJ,IAAI,gBAAgB,wJAAM,EAAE;YAC1B,MAAM,gBAAgB,CAAC;YACvB,MAAM,iBAAiB,EAAE;YAEzB,MAAM,QAAQ,KAAK,GAAG,CAAC,IAAI;YAC3B,MAAM,UAAU,CAAA,MAAO,KAAK,KAAK,CAAC,MAAM,SAAS;YACjD,MAAM,SAAS,CAAA,OACb,GAAG,QAAQ,KAAK,CAAC,EAAE,CAAC,EAAE,QAAQ,KAAK,CAAC,EAAE,CAAC,EAAE,QAAQ,KAAK,CAAC,GAAG;YAE5D,kDAAkD;YAClD,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,MAAM,EAAE,IAAK;gBACxC,MAAM,SAAS,QAAQ,CAAC,EAAE;gBAC1B,MAAM,MAAM,OAAO;gBACnB,IAAI,aAAa,CAAC,IAAI,KAAK,WAAW;oBACpC,aAAa,CAAC,IAAI,GAAG,eAAe,MAAM;oBAC1C,eAAe,IAAI,CAAC;gBACtB;YACF;YAEA,6DAA6D;YAC7D,MAAM,OAAO,CAAC,CAAA;gBACZ,IAAK,IAAI,KAAK,GAAG,KAAK,GAAG,EAAE,GAAI;oBAC7B,MAAM,sBAAsB,IAAI,CAAC,GAAG;oBACpC,MAAM,iBAAiB,QAAQ,CAAC,oBAAoB;oBACpD,MAAM,MAAM,OAAO;oBACnB,IAAI,CAAC,GAAG,GAAG,aAAa,CAAC,IAAI;gBAC/B;YACF;YAEA,6DAA6D;YAC7D,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;gBACjB,IAAK,IAAI,KAAK,GAAG,KAAK,GAAG,EAAE,GAAI;oBAC7B,MAAM,sBAAsB,IAAI,CAAC,GAAG;oBACpC,MAAM,iBAAiB,QAAQ,CAAC,oBAAoB;oBACpD,MAAM,MAAM,OAAO;oBACnB,IAAI,CAAC,GAAG,GAAG,aAAa,CAAC,IAAI;gBAC/B;YACF;YAEA,mCAAmC;YACnC,IAAI,CAAC,QAAQ,GAAG,WAAW;QAC7B;QAEA,wDAAwD;QACxD,cAAc,MAAM,GAAG;QACvB,IAAK,KAAK,GAAG,KAAK,SAAS,MAAM,EAAE,EAAE,GAAI;YACvC,cAAc,IAAI,CAAC,IAAI,4JAAM;QAC/B;QAEA,6DAA6D;QAC7D,0BAA0B;QAC1B,MAAM,OAAO,CAAC,CAAC,MAAM;YACnB,MAAM,aAAa,IAAI,CAAC,cAAc,CAAC;YAEvC,0CAA0C;YAC1C,IAAK,IAAI,KAAK,GAAG,KAAK,GAAG,EAAE,GAAI;gBAC7B,MAAM,cAAc,IAAI,CAAC,GAAG;gBAC5B,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC;YACjC;QACF;QAEA,wBAAwB;QACxB,IAAK,KAAK,GAAG,KAAK,SAAS,MAAM,EAAE,EAAE,GAAI;YACvC,aAAa,CAAC,GAAG,CAAC,SAAS;QAC7B;QAEA,OAAO,IAAI;IACb;IAEA;;;;;GAKC,GACD,iBAAiB;QACf,IAAK,IAAI,IAAI,GAAG,KAAK,IAAI,CAAC,OAAO,EAAE,IAAK;YACtC,MAAM,SAAS,IAAI,CAAC,OAAO,GAAG;YAC9B,IAAI,OAAO,4JAAM,CAAC,GAAG,CACnB,IAAI,CAAC,aAAa,CAAC,IAAI,OAAO,EAC9B,IAAI,CAAC,aAAa,CAAC,IAAI,SAAS,IAAI,CAAC,OAAO,CAAC;YAG/C,OAAO,4JAAM,CAAC,GAAG,CAAC,MAAM;YACxB,IAAI,CAAC,aAAa,CAAC,IAAI,OAAO,GAAG;YACjC,IAAI,CAAC,aAAa,CAAC,IAAI,SAAS,IAAI,CAAC,OAAO,CAAC,GAAG;QAClD;QACA,OAAO,IAAI;IACb;IAEA;;;;GAIC,GACD,qBAAqB;QACnB,wBAAwB;QACxB,IAAI,MAAM,IAAI,4JAAM,CAAC,GAAG,GAAG;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,IAAK;YACrC,IAAI,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;QAC/B;QACA,MAAM,4JAAM,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,OAAO;QAElC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,OAAO,EAAE,IAAK;YACrC,IAAI,CAAC,aAAa,CAAC,EAAE,GAAG;QAC1B;QAEA,wBAAwB;QACxB,MAAM,IAAI,4JAAM,CAAC,GAAG,GAAG;QACvB,IACE,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,GAC/B,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,IAAI,CAAC,OAAO,EAC3C,IACA;YACA,IAAI,GAAG,CAAC,IAAI,CAAC,aAAa,CAAC,EAAE;QAC/B;QACA,MAAM,4JAAM,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,OAAO;QAElC,IACE,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,GAC/B,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,IAAI,CAAC,OAAO,EAC3C,IACA;YACA,IAAI,CAAC,aAAa,CAAC,EAAE,GAAG;QAC1B;QACA,OAAO,IAAI;IACb;IAEA;;;;GAIC,GACD,qBAAqB;QACnB,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG;QAEpB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAK;YAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;aAAC;YACpD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;aAAC;YACpD,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;gBAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE;aAAC;QACtD;QAEA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAwCC,GACD,qBAAqB;QACnB,IAAI,CAAC,kBAAkB;IACzB;IAEA;;;;;;;;;;;;;;GAcC,GACD,mBAAmB;QACjB,IAAI,CAAC,YAAY,CAAC,KAAK;QACvB,IAAI,CAAC,cAAc,CAAC,KAAK;QACzB,IAAI,CAAC,eAAe,CAAC,KAAK;QAC1B,IAAI,CAAC,SAAS,CAAC,KAAK;QAEpB,MAAM,gBAAgB,IAAI;QAC1B,MAAM,YAAY,IAAI;QACtB,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,IAAK;YAC1C,MAAM,WAAW,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE;YAClC,MAAM,WAAW,IAAI,CAAC,KAAK,CAAC,EAAE;YAC9B,MAAM,QAAQ,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;YACxC,MAAM,MAAM,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;YACtC,MAAM,YAAY,AAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,KAAK,WACrD,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAC7B,QAAQ,CAAC,EAAE,GAAG,GACd,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,IAAI,KAEpB;gBAAC;gBAAG;gBAAG;gBAAG;aAAE;YAChB,MAAM,YAAY,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,IAC/C,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAC7B,QAAQ,CAAC,EAAE,GAAG,GACd,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,IAAI,KAEpB;gBAAC;gBAAG;gBAAG;gBAAG;aAAE;YAChB,MAAM,UAAU,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,IAC7C,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAC7B,QAAQ,CAAC,EAAE,GAAG,GACd,CAAC,QAAQ,CAAC,EAAE,GAAG,CAAC,IAAI,KAEpB;gBAAC;gBAAG;gBAAG;gBAAG;aAAE;YAChB,MAAM,MAAM,IACT,IAAI,GACJ,GAAG,CAAC,OACJ,SAAS;YACZ,MAAM,QAAQ,IAAI,KAAK,KAAK;YAC5B,IAAI,OAAO;gBACT,IAAI,CAAC,WAAW,CAAC,OAAO,KAAK,WAAW,SAAS;YACnD;YACA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,cAAc;gBAChC,IAAI,IAAI,KAAK,QAAQ,CAAC,EAAE,KAAK,QAAQ,CAAC,EAAE,EAAE;oBACxC,IAAI,CAAC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE,GAAG;wBAC/B,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE;wBACzB,cAAc,MAAM,CAAC,QAAQ,CAAC,EAAE;wBAChC,qEAAqE;wBACrE,uEAAuE;wBACvE,yBAAyB;wBACzB,EAAE;wBACF,sEAAsE;wBACtE,yEAAyE;wBACzE,IAAI,gBAAgB,SAAS,IAAI,GAAG,CAAC,gBAAgB,IAAI,MAAM;4BAC7D,IAAI,CAAC,QAAQ,CAAC,OAAO,cAAc,KAAK;wBAC1C;oBACF;gBACF,OAAO;oBACL,mBAAmB;oBACnB,IAAI,SAAS,CAAC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE,GAAG;wBACxC,MAAM,cAAc,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE;wBACjD,IAAI,aAAa;4BACf,IAAI,CAAC,QAAQ,CACX,OACA,YAAY,GAAG,EACf,KACA;4BAEF,cAAc,MAAM,CAAC,QAAQ,CAAC,EAAE;4BAChC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE;wBAC3B,OAAO;4BACL,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;gCAC7B,OAAO;gCACP,KAAK,IAAI,IAAI,GAAG,IAAI,CAAC,CAAC;gCACtB,OAAO;4BACT;wBACF;oBACF;oBACA,IAAI,gBAAgB,CAAC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE,GAAG;wBAC/C,MAAM,cAAc,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE;wBACjD,IAAI,aAAa;4BACf,IAAI,CAAC,QAAQ,CACX,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC,EAC1B,cACA,YAAY,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,IAC7B;4BAEF,cAAc,MAAM,CAAC,QAAQ,CAAC,EAAE;4BAChC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE;wBAC3B,OAAO;4BACL,wCAAwC;4BACxC,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;gCAC7B,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE,CAAC;gCACjC,KAAK;gCACL,OAAO;4BACT;wBACF;wBACA,eAAe;oBACjB;gBACF;gBAEA,IAAI,MAAM,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE,GAAG;oBAC9D,MAAM,cAAc,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE;oBACjD,IAAI,aAAa;wBACf,IAAI,CAAC,QAAQ,CACX,KACA,KACA,YAAY,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,IAC7B;wBAEF,cAAc,MAAM,CAAC,QAAQ,CAAC,EAAE;wBAChC,UAAU,GAAG,CAAC,QAAQ,CAAC,EAAE;oBAC3B,OAAO;wBACL,cAAc,GAAG,CAAC,QAAQ,CAAC,EAAE,EAAE;4BAC7B,OAAO;4BACP;4BACA,OAAO;wBACT;oBACF;gBACF;gBAEA,IAAI,OAAO;oBACT,eAAe;gBACjB;YACF;QACF;QACA,KAAK,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,KAAK,EAAE,IAAI,cAAc,MAAM,GAAI;YAC1D,IAAI,CAAC,OAAO,CAAC,OAAO,KAAK;QAC3B;QACA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;GAeC,GACD,YACE,KAAK,EACL,GAAG,EACH,SAAS,EACT,OAAO,EACP,GAAG,EACH;QACA,MAAM,IAAI,MAAM,KAAK;QACrB,MAAM,IAAI,IAAI,KAAK;QACnB,MAAM,SAAS,IAAI,KAAK;QACxB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC;QACtC,KAAK,MAAM,YAAY;YAAC,IAAI,CAAC,cAAc;YAAE,IAAI,CAAC,eAAe;SAAC,CAAE;YAClE,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gBAC1B,SAAS,IAAI,IAAI;YACnB;QACF;QACA,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,MAAM,MAAM,MAAM,MAAM,MAAM;QACxD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,cAAc;YAChC,IAAI,CAAC,gBAAgB,CAAC,IAAI,IACrB,cACA,YACA,cACA,YACA,YACA;QAEP;QACA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;GAeC,GACD,QAAQ,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE;QAC7B,MAAM,UAAU,MAAM,KAAK;QAC3B,MAAM,aAAa,QAAQ,KAAK;QAChC,MAAM,cAAc;YAAC;YAAG;YAAG;SAAE;QAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YAC1B,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,IAAI,IAAI;YAC5B,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI;YAC7B,IAAI,CAAC,gBAAgB,CAAC,IAAI,IAAI;QAChC;QACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC;QACtC,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;GAsBC,GACD,SACE,KAAK,EACL,WAAW,EACX,SAAS,EACT,KAAK,EACL;QACA,MAAM,UAAU,MAAM,KAAK;QAC3B,MAAM,aAAa,YAAY,KAAK;QACpC,MAAM,cAAc,UAAU,KAAK;QACnC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAK;YAC3B,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI;YAC1B,IAAI,CAAC,cAAc,CAAC,IAAI,IAAI;YAC5B,IAAI,CAAC,eAAe,CAAC,IAAI,IAAI;YAC7B,IAAI,CAAC,gBAAgB,CAAC,IAAI,IAAI;QAChC;QACA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;QACxC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG;QACnC,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmDC,GACD,YAAY;QACV,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG;YAC5B,uCAAuC;YACvC,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI;YACzC,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI;YAEzC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAK;gBAC7C,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;gBAC1D,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;gBAC1D,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;gBAC1D,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;gBAC1D,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;gBAC1D,YAAY,CAAC,GAAG,KAAK,GAAG,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC5D;YAEA,MAAM,SAAS,4JAAM,CAAC,IAAI,CAAC,aAAa,aAAa;YACrD,MAAM,OAAO,4JAAM,CAAC,GAAG,CAAC,aAAa;YACrC,MAAM,cAAc,KAAK,GAAG,CAAC,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC;YAC7D,MAAM,QAAQ,MAAM;YAEpB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,IAAK;gBAC7C,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC;gBACrB,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,IAAI,CAAC;YACxB;QACF;QACA,OAAO,IAAI;IACb;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsGC,GACD,eAAe,YAAY,EAAE,IAAI,EAAE,IAAI,EAAC;QACtC,IAAI;QACJ,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,aAAa,EAAC;YAC3C,OAAO,IAAI,CAAC,oBAAoB,CAAC,aAAa,GAC5C,IAAI,CAAC,yBAAyB,CAAC,cAAc,MAAM;QACvD;QACA,OAAO,IAAI,CAAC,oBAAoB,CAAC,aAAa;QAC9C,IAAI,MAAK;YACP,KAAK,UAAU,CAAC;QAClB,OAAO;YACL,KAAK,cAAc,CAAC;YACpB,KAAK,eAAe;QACtB;IACF;IAEA,0BAA0B,YAAY,EAAE,IAAI,EAAE,IAAI,EAAC;QACjD,MAAM,mBAAmB,IAAI;QAC7B,MAAM,OAAO,IAAI,CAAC,oBAAoB,CAAC,aAAa,GAAG;YACrD,MAAM;YACN,UAAU,OAAO,OAAO,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG;YACpD,UAAU;YACV,UAAU;YACV;gBACE,OAAO,IAAI,CAAC,IAAI;YAClB;YACA;gBACE,IAAI,IAAI,CAAC,WAAW,KAAK,WAAW;oBAClC,IAAI,CAAC,WAAW,GAAG,IAAI,MAAM,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC;gBACxD;gBACA,OAAO,IAAI,CAAC,WAAW;YACzB;YACA;gBACE,OAAO,IAAI,CAAC,QAAQ;YACtB;YACA;gBACE,MAAM,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,OAAO;YACT;YACA;gBACE,MAAM,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;gBAC7B,OAAO;YACT;YACA;gBACE,MAAM,UAAU,IAAI,CAAC,UAAU;gBAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;YAC/B;YACA,SAAS;YACT,gBAAe,IAAI;gBACjB,KAAK,MAAM,GAAG,KAAK,MAAM,GAAG;gBAC5B,mCAAmC;gBACnC,8OAA8O;gBAC9O,IAAI;gBACJ,IAAI,CAAC,WAAW,GAAG;YACrB;YACA,YAAY;YACZ;gBACE,MAAM,OAAO,IAAI,CAAC,cAAc;gBAChC,IAAI,CAAC,UAAU,CAAC;YAClB;YACA,YAAW,IAAI;gBACb,IAAI,KAAK,MAAM,EAAC;oBACd,IAAI,CAAC,WAAW,GAAG,IAAI,IAAI;gBAC7B,OAAO;oBACL,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;gBAC1B;YACF;YACA;gBACE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,EAAE;YACvC;YACA;gBACE,MAAM,UAAU,IAAI,CAAC,UAAU;gBAC/B,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;gBAC7B,OAAO,IAAI;YACb;QACF;QACA,IAAI,CAAC,KAAK,UAAU,GAAG,GAAG,EAAE;QAC5B,OAAO,IAAI,CAAC,oBAAoB,CAAC,aAAa;IAChD;AACF;AACA;;;CAGC,GACD,SAAS,MAAM,GAAG;AAElB,SAAS,SAAS,GAAE,EAAE,EAAE;IACtB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2OC,GACD,IAAG,QAAQ,GAAG;AAEd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqGC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiIC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqFC,GAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+DC,GAED;;;;;GAKC,GACH;AAEA,IAAG,OAAO,OAAO,aAAY;IAC3B,SAAS,IAAI,GAAG,SAAS;AAC3B","ignoreList":[0]}},
    {"offset": {"line": 2552, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/GeometryBuilder.js"],"sourcesContent":["import { r as TRIANGLE_STRIP, s as QUAD_STRIP, q as TRIANGLE_FAN, p as TRIANGLES } from '../constants-Bt1VTUeD.js';\nimport '../math/p5.Matrix.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Matrix } from '../math/Matrices/Matrix.js';\nimport '../math/p5.Vector.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.DataArray.js';\nimport '../io/utilities.js';\nimport 'file-saver';\n\n/**\n * @private\n * A class responsible for converting successive WebGL draw calls into a single\n * `p5.Geometry` that can be reused and drawn with `model()`.\n */\nclass GeometryBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    renderer._pInst.push();\n    this.identityMatrix = new Matrix(4);\n    renderer.states.setValue('uModelMatrix', new Matrix(4));\n    this.geometry = new Geometry(\n      undefined,\n      undefined,\n      undefined,\n      this.renderer\n    );\n    this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;\n    GeometryBuilder.nextGeometryId++;\n    this.hasTransform = false;\n  }\n\n  /**\n   * @private\n   * Applies the current transformation matrix to each vertex.\n   */\n  transformVertices(vertices) {\n    if (!this.hasTransform) return vertices;\n\n    return vertices.map(v =>\n      this.renderer.states.uModelMatrix.multiplyPoint(v)\n    );\n  }\n\n  /**\n   * @private\n   * Applies the current normal matrix to each normal.\n   */\n  transformNormals(normals) {\n    if (!this.hasTransform) return normals;\n\n    return normals.map(\n      v => this.renderer.scratchMat3.multiplyVec(v) // this is a vec3\n    );\n  }\n\n  /**\n   * @private\n   * Adds a p5.Geometry to the builder's combined geometry, flattening\n   * transformations.\n   */\n  addGeometry(input) {\n    this.hasTransform = !this.renderer.states.uModelMatrix.mat4\n      .every((v, i) => v === this.identityMatrix.mat4[i]);\n\n    if (this.hasTransform) {\n      this.renderer.scratchMat3.inverseTranspose4x4(\n        this.renderer.states.uModelMatrix\n      );\n    }\n\n    let startIdx = this.geometry.vertices.length;\n    this.geometry.vertices.push(...this.transformVertices(input.vertices));\n    this.geometry.vertexNormals.push(\n      ...this.transformNormals(input.vertexNormals)\n    );\n    this.geometry.uvs.push(...input.uvs);\n\n    const inputUserVertexProps = input.userVertexProperties;\n    const builtUserVertexProps = this.geometry.userVertexProperties;\n    const numPreviousVertices =\n      this.geometry.vertices.length - input.vertices.length;\n\n    for (const propName in builtUserVertexProps){\n      if (propName in inputUserVertexProps){\n        continue;\n      }\n      const prop = builtUserVertexProps[propName];\n      const size = prop.getDataSize();\n      const numMissingValues = size * input.vertices.length;\n      const missingValues = Array(numMissingValues).fill(0);\n      prop.pushDirect(missingValues);\n    }\n    for (const propName in inputUserVertexProps){\n      const prop = inputUserVertexProps[propName];\n      const data = prop.getSrcArray();\n      const size = prop.getDataSize();\n      if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)){\n        const numMissingValues = size * numPreviousVertices;\n        const missingValues = Array(numMissingValues).fill(0);\n        this.geometry.vertexProperty(propName, missingValues, size);\n      }\n      this.geometry.vertexProperty(propName, data, size);\n    }\n\n    if (this.renderer.states.fillColor) {\n      this.geometry.faces.push(\n        ...input.faces.map(f => f.map(idx => idx + startIdx))\n      );\n    }\n    if (this.renderer.states.strokeColor) {\n      this.geometry.edges.push(\n        ...input.edges.map(edge => edge.map(idx => idx + startIdx))\n      );\n    }\n    const vertexColors = [...input.vertexColors];\n    while (vertexColors.length < input.vertices.length * 4) {\n      vertexColors.push(...this.renderer.states.curFillColor);\n    }\n    this.geometry.vertexColors.push(...vertexColors);\n  }\n\n  /**\n   * Adds geometry from the renderer's immediate mode into the builder's\n   * combined geometry.\n   */\n  addImmediate(geometry, shapeMode, { validateFaces = false } = {}) {\n    const faces = [];\n\n    if (this.renderer.states.fillColor) {\n      if (\n        shapeMode === TRIANGLE_STRIP ||\n        shapeMode === QUAD_STRIP\n      ) {\n        for (let i = 2; i < geometry.vertices.length; i++) {\n          if (i % 2 === 0) {\n            faces.push([i, i - 1, i - 2]);\n          } else {\n            faces.push([i, i - 2, i - 1]);\n          }\n        }\n      } else if (shapeMode === TRIANGLE_FAN) {\n        for (let i = 2; i < geometry.vertices.length; i++) {\n          faces.push([0, i - 1, i]);\n        }\n      } else if (shapeMode === TRIANGLES) {\n        for (let i = 0; i < geometry.vertices.length; i += 3) {\n          if (\n            !validateFaces ||\n            geometry.vertices[i].copy().sub(geometry.vertices[i+1])\n              .cross(geometry.vertices[i].copy().sub(geometry.vertices[i+2]))\n              .magSq() > 0\n          ) {\n            faces.push([i, i + 1, i + 2]);\n          }\n        }\n      }\n    }\n    this.addGeometry(Object.assign({}, geometry, { faces }));\n  }\n\n  /**\n   * Adds geometry from the renderer's retained mode into the builder's\n   * combined geometry.\n   */\n  addRetained(geometry) {\n    this.addGeometry(geometry);\n  }\n\n  /**\n   * Cleans up the state of the renderer and returns the combined geometry that\n   * was built.\n   * @returns p5.Geometry The flattened, combined geometry\n   */\n  finish() {\n    this.renderer._pInst.pop();\n    return this.geometry;\n  }\n}\n\n/**\n * Keeps track of how many custom geometry objects have been made so that each\n * can be assigned a unique ID.\n */\nGeometryBuilder.nextGeometryId = 0;\n\nexport { GeometryBuilder as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2725, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/p5.Quat.js"],"sourcesContent":["import { Vector } from '../math/p5.Vector.js';\nimport '../constants-Bt1VTUeD.js';\n\n/**\n * @module Math\n * @submodule Quaternion\n */\n\n\nclass Quat {\n  constructor(w, x, y, z) {\n    this.w = w;\n    this.vec = new Vector(x, y, z);\n  }\n\n  /**\n   * Returns a Quaternion for the\n   * axis angle representation of the rotation\n   *\n   * @method fromAxisAngle\n   * @param {Number} [angle] Angle with which the points needs to be rotated\n   * @param {Number} [x] x component of the axis vector\n   * @param {Number} [y] y component of the axis vector\n   * @param {Number} [z] z component of the axis vector\n   * @chainable\n   */\n  static fromAxisAngle(angle, x, y, z) {\n    const w = Math.cos(angle/2);\n    const vec = new Vector(x, y, z).normalize().mult(Math.sin(angle/2));\n    return new Quat(w, vec.x, vec.y, vec.z);\n  }\n\n  conjugate() {\n    return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);\n  }\n\n  /**\n   * Multiplies a quaternion with other quaternion.\n   * @method mult\n   * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.\n   * @chainable\n   */\n  multiply(quat) {\n\n    return new Quat(\n      this.w * quat.w - this.vec.x * quat.vec.x - this.vec.y * quat.vec.y - this.vec.z - quat.vec.z,\n      this.w * quat.vec.x + this.vec.x * quat.w + this.vec.y * quat.vec.z - this.vec.z * quat.vec.y,\n      this.w * quat.vec.y - this.vec.x * quat.vec.z + this.vec.y * quat.w + this.vec.z * quat.vec.x,\n      this.w * quat.vec.z + this.vec.x * quat.vec.y - this.vec.y * quat.vec.x + this.vec.z * quat.w\n    );\n\n  }\n\n  /**\n   * This is similar to quaternion multiplication\n   * but when multipying vector with quaternion\n   * the multiplication can be simplified to the below formula.\n   * This was taken from the below stackexchange link\n   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545\n   * @private\n   * @param {p5.Vector} [p] vector to rotate on the axis quaternion\n   */\n  rotateVector(p) {\n    return Vector.mult( p, this.w*this.w - this.vec.dot(this.vec) )\n      .add( Vector.mult( this.vec, 2 * p.dot(this.vec) ) )\n      .add( Vector.mult( this.vec, 2 * this.w ).cross( p ) )\n      .clampToZero();\n  }\n\n  /**\n   * Rotates the Quaternion by the quaternion passed\n   * which contains the axis of roation and angle of rotation\n   *\n   * @method rotateBy\n   * @param {p5.Quat} [axesQuat] axis quaternion which contains\n   *  the axis of rotation and angle of rotation\n   * @chainable\n   */\n  rotateBy(axesQuat) {\n    return axesQuat.multiply(this).multiply(axesQuat.conjugate()).\n      vec.clampToZero();\n  }\n}\n\nfunction quat(p5, fn){\n  /**\n   * A class to describe a Quaternion\n   * for vector rotations in the p5js webgl renderer.\n   * Please refer the following link for details on the implementation\n   * https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html\n   * @class p5.Quat\n   * @constructor\n   * @param {Number} [w] Scalar part of the quaternion\n   * @param {Number} [x] x component of imaginary part of quaternion\n   * @param {Number} [y] y component of imaginary part of quaternion\n   * @param {Number} [z] z component of imaginary part of quaternion\n   * @private\n   */\n  p5.Quat = Quat;\n}\n\nif(typeof p5 !== 'undefined'){\n  quat(p5, p5.prototype);\n}\n\nexport { Quat, quat as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2815, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/p5.RenderBuffer.js"],"sourcesContent":["class RenderBuffer {\n  constructor(size, src, dst, attr, renderer, map) {\n    this.size = size; // the number of FLOATs in each vertex\n    this.src = src; // the name of the model's source array\n    this.dst = dst; // the name of the geometry's buffer\n    this.attr = attr; // the name of the vertex attribute\n    this._renderer = renderer;\n    this.map = map; // optional, a transformation function to apply to src\n  }\n\n  /**\n   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.\n   * Must always be done prior to drawing geometry in WebGL.\n   * @param {p5.Geometry} geometry Geometry that is going to be drawn\n   * @param {p5.Shader} shader Active shader\n   * @private\n   */\n  _prepareBuffer(geometry, shader) {\n    const attributes = shader.attributes;\n    const gl = this._renderer.GL;\n    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);\n\n    // loop through each of the buffer definitions\n    const attr = attributes[this.attr];\n    if (!attr) {\n      return;\n    }\n    // check if the geometry has the appropriate source array\n    let buffer = glBuffers[this.dst];\n    const src = geometry[this.src];\n    if (src && src.length > 0) {\n      // check if we need to create the GL buffer\n      const createBuffer = !buffer;\n      if (createBuffer) {\n        // create and remember the buffer\n        glBuffers[this.dst] = buffer = gl.createBuffer();\n      }\n      // bind the buffer\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\n      // check if we need to fill the buffer with data\n      if (createBuffer || geometry.dirtyFlags[this.src] !== false) {\n        const map = this.map;\n        // get the values from the geometry, possibly transformed\n        const values = map ? map(src) : src;\n        // fill the buffer with the values\n        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);\n        // mark the geometry's source array as clean\n        geometry.dirtyFlags[this.src] = false;\n      }\n      // enable the attribute\n      shader.enableAttrib(attr, this.size);\n    } else {\n      const loc = attr.location;\n      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {\n        return;\n      }\n      // Disable register corresponding to unused attribute\n      gl.disableVertexAttribArray(loc);\n      // Record register availability\n      this._renderer.registerEnabled.delete(loc);\n    }\n  }\n}\n\nfunction renderBuffer(p5, fn) {\n  p5.RenderBuffer = RenderBuffer;\n}\n\nif (typeof p5 !== 'undefined') {\n  renderBuffer(p5, p5.prototype);\n}\n\nexport { RenderBuffer, renderBuffer as default };\n"],"names":[],"mappings":";;;;;;AAAA,MAAM;IACJ,YAAY,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,CAAE;QAC/C,IAAI,CAAC,IAAI,GAAG,MAAM,sCAAsC;QACxD,IAAI,CAAC,GAAG,GAAG,KAAK,uCAAuC;QACvD,IAAI,CAAC,GAAG,GAAG,KAAK,oCAAoC;QACpD,IAAI,CAAC,IAAI,GAAG,MAAM,mCAAmC;QACrD,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,GAAG,GAAG,KAAK,sDAAsD;IACxE;IAEA;;;;;;GAMC,GACD,eAAe,QAAQ,EAAE,MAAM,EAAE;QAC/B,MAAM,aAAa,OAAO,UAAU;QACpC,MAAM,KAAK,IAAI,CAAC,SAAS,CAAC,EAAE;QAC5B,MAAM,YAAY,IAAI,CAAC,SAAS,CAAC,uBAAuB,CAAC;QAEzD,8CAA8C;QAC9C,MAAM,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;QAClC,IAAI,CAAC,MAAM;YACT;QACF;QACA,yDAAyD;QACzD,IAAI,SAAS,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC;QAChC,MAAM,MAAM,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC;QAC9B,IAAI,OAAO,IAAI,MAAM,GAAG,GAAG;YACzB,2CAA2C;YAC3C,MAAM,eAAe,CAAC;YACtB,IAAI,cAAc;gBAChB,iCAAiC;gBACjC,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,SAAS,GAAG,YAAY;YAChD;YACA,kBAAkB;YAClB,GAAG,UAAU,CAAC,GAAG,YAAY,EAAE;YAE/B,gDAAgD;YAChD,IAAI,gBAAgB,SAAS,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,OAAO;gBAC3D,MAAM,MAAM,IAAI,CAAC,GAAG;gBACpB,yDAAyD;gBACzD,MAAM,SAAS,MAAM,IAAI,OAAO;gBAChC,kCAAkC;gBAClC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,GAAG,YAAY,EAAE;gBACpD,4CAA4C;gBAC5C,SAAS,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG;YAClC;YACA,uBAAuB;YACvB,OAAO,YAAY,CAAC,MAAM,IAAI,CAAC,IAAI;QACrC,OAAO;YACL,MAAM,MAAM,KAAK,QAAQ;YACzB,IAAI,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,GAAG,CAAC,MAAM;gBAC1D;YACF;YACA,qDAAqD;YACrD,GAAG,wBAAwB,CAAC;YAC5B,+BAA+B;YAC/B,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC;QACxC;IACF;AACF;AAEA,SAAS,aAAa,GAAE,EAAE,EAAE;IAC1B,IAAG,YAAY,GAAG;AACpB;AAEA,IAAI,OAAO,OAAO,aAAa;IAC7B,aAAa,IAAI,GAAG,SAAS;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 2892, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/ShapeBuilder.js"],"sourcesContent":["import { m as PATH, Q as QUADS, s as QUAD_STRIP, r as TRIANGLE_STRIP, p as TRIANGLES, a1 as IMAGE, L as LINES, q as TRIANGLE_FAN } from '../constants-Bt1VTUeD.js';\nimport { Geometry } from './p5.Geometry.js';\nimport libtess from 'libtess';\nimport { Vector } from '../math/p5.Vector.js';\nimport { RenderBuffer } from './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nimport '../io/utilities.js';\nimport 'file-saver';\n\nconst INITIAL_BUFFER_STRIDES = {\n  vertices: 1,\n  vertexNormals: 1,\n  vertexColors: 4,\n  vertexStrokeColors: 4,\n  uvs: 2\n};\n\n// The total number of properties per vertex, before additional\n// user attributes are added.\nconst INITIAL_VERTEX_SIZE =\n  Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);\n\nclass ShapeBuilder {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.shapeMode = PATH;\n    this.geometry = new Geometry(\n      undefined,\n      undefined,\n      undefined,\n      this.renderer\n    );\n    this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';\n\n    this.contourIndices = [];\n    this._useUserVertexProperties = undefined;\n\n    this._bezierVertex = [];\n    this._quadraticVertex = [];\n    this._curveVertex = [];\n\n    // Used to distinguish between user calls to vertex() and internal calls\n    this.isProcessingVertices = false;\n\n    // Used for converting shape outlines into triangles for rendering\n    this._tessy = this._initTessy();\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };\n  }\n\n  constructFromContours(shape, contours) {\n    if (this._useUserVertexProperties){\n      this._resetUserVertexProperties();\n    }\n    this.geometry.reset();\n    this.contourIndices = [];\n    // TODO: handle just some contours having non-PATH mode\n    this.shapeMode = shape.contours[0].kind;\n    const shouldProcessEdges = !!this.renderer.states.strokeColor;\n\n    const userVertexPropertyHelpers = {};\n    if (shape.userVertexProperties) {\n      this._useUserVertexProperties = true;\n      for (const key in shape.userVertexProperties) {\n        const name = shape.vertexPropertyName(key);\n        const prop = this.geometry._userVertexPropertyHelper(\n          name,\n          [],\n          shape.userVertexProperties[key]\n        );\n        userVertexPropertyHelpers[key] = prop;\n        this.tessyVertexSize += prop.getDataSize();\n        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();\n        this.renderer.buffers.user.push(\n          new RenderBuffer(\n            prop.getDataSize(),\n            prop.getSrcName(),\n            prop.getDstName(),\n            name,\n            this.renderer\n          )\n        );\n      }\n    } else {\n      this._useUserVertexProperties = false;\n    }\n\n    for (const contour of contours) {\n      this.contourIndices.push(this.geometry.vertices.length);\n      for (const vertex of contour) {\n        // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn\n        // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra\n        // work to convert QUAD_STRIP here, since the only difference is in how edges\n        // are rendered.)\n        if (this.shapeMode === QUADS) {\n          // A finished quad turned into triangles should leave 6 vertices in the\n          // buffer:\n          // 0--3     0   3--5\n          // |  | --> | \\  \\ |\n          // 1--2     1--2   4\n          // When vertex index 3 is being added, add the necessary duplicates.\n          if (this.geometry.vertices.length % 6 === 3) {\n            for (const key in this.bufferStrides) {\n              const stride = this.bufferStrides[key];\n              const buffer = this.geometry[key];\n              buffer.push(\n                ...buffer.slice(\n                  buffer.length - 3 * stride,\n                  buffer.length - 2 * stride\n                ),\n                ...buffer.slice(buffer.length - stride, buffer.length)\n              );\n            }\n          }\n        }\n\n        this.geometry.vertices.push(vertex.position);\n        this.geometry.vertexNormals.push(vertex.normal || new Vector(0, 0, 0));\n        this.geometry.uvs.push(\n          vertex.textureCoordinates.x,\n          vertex.textureCoordinates.y\n        );\n        if (this.renderer.states.fillColor) {\n          this.geometry.vertexColors.push(...vertex.fill.array());\n        } else {\n          this.geometry.vertexColors.push(0, 0, 0, 0);\n        }\n        if (this.renderer.states.strokeColor) {\n          this.geometry.vertexStrokeColors.push(...vertex.stroke.array());\n        } else {\n          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);\n        }\n        for (const key in userVertexPropertyHelpers) {\n          const prop = userVertexPropertyHelpers[key];\n          if (key in vertex) {\n            prop.setCurrentData(vertex[key]);\n          }\n          prop.pushCurrentData();\n        }\n      }\n    }\n\n    if (shouldProcessEdges) {\n      this.geometry.edges = this._calculateEdges(\n        this.shapeMode,\n        this.geometry.vertices\n      );\n    }\n    if (shouldProcessEdges && !this.renderer.geometryBuilder) {\n      this.geometry._edgesToVertices();\n    }\n\n    if (this.shapeMode === PATH) {\n      this.isProcessingVertices = true;\n      this._tesselateShape();\n      this.isProcessingVertices = false;\n    } else if (this.shapeMode === QUAD_STRIP) {\n      // The only difference between these two modes is which edges are\n      // displayed, so after we've updated the edges, we switch the mode\n      // to one that native WebGL knows how to render.\n      this.shapeMode = TRIANGLE_STRIP;\n    } else if (this.shapeMode === QUADS) {\n      // We translate QUADS to TRIANGLES when vertices are being added,\n      // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode\n      // that native WebGL knows how to render. Once we've processed edges,\n      // everything should be set up for TRIANGLES mode.\n      this.shapeMode = TRIANGLES;\n    }\n\n    if (\n      this.renderer.states.textureMode === IMAGE &&\n      this.renderer.states._tex !== null &&\n      this.renderer.states._tex.width > 0 &&\n      this.renderer.states._tex.height > 0\n    ) {\n      this.geometry.uvs = this.geometry.uvs.map((val, i) => {\n        if (i % 2 === 0) {\n          return val / this.renderer.states._tex.width;\n        } else {\n          return val / this.renderer.states._tex.height;\n        }\n      });\n    }\n  }\n\n  _resetUserVertexProperties() {\n    const properties = this.geometry.userVertexProperties;\n    for (const propName in properties){\n      const prop = properties[propName];\n      delete this.bufferStrides[propName];\n      prop.delete();\n    }\n    this._useUserVertexProperties = false;\n    this.tessyVertexSize = INITIAL_VERTEX_SIZE;\n    this.geometry.userVertexProperties = {};\n  }\n\n  /**\n   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and\n   * tesselates shapes when applicable.\n   * @private\n   * @returns  {Number[]} indices for custom shape vertices indicating edges.\n   */\n  _calculateEdges(\n    shapeMode,\n    verts\n  ) {\n    const res = [];\n    let i = 0;\n    const contourIndices = this.contourIndices.slice();\n    let contourStart = -1;\n    switch (shapeMode) {\n      case TRIANGLE_STRIP:\n        for (i = 0; i < verts.length - 2; i++) {\n          res.push([i, i + 1]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      case TRIANGLE_FAN:\n        for (i = 1; i < verts.length - 1; i++) {\n          res.push([0, i]);\n          res.push([i, i + 1]);\n        }\n        res.push([0, verts.length - 1]);\n        break;\n      case TRIANGLES:\n        for (i = 0; i < verts.length - 2; i = i + 3) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i]);\n        }\n        break;\n      case LINES:\n        for (i = 0; i < verts.length - 1; i = i + 2) {\n          res.push([i, i + 1]);\n        }\n        break;\n      case QUADS:\n        // Quads have been broken up into two triangles by `vertex()`:\n        // 0   3--5\n        // | \\  \\ |\n        // 1--2   4\n        for (i = 0; i < verts.length - 5; i += 6) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 2]);\n          res.push([i + 2, i + 5]);\n          res.push([i + 5, i]);\n        }\n        break;\n      case QUAD_STRIP:\n        // 0---2---4\n        // |   |   |\n        // 1---3---5\n        for (i = 0; i < verts.length - 2; i += 2) {\n          res.push([i, i + 1]);\n          res.push([i + 1, i + 3]);\n          res.push([i, i + 2]);\n        }\n        res.push([i, i + 1]);\n        break;\n      default:\n        // TODO: handle contours in other modes too\n        for (i = 0; i < verts.length; i++) {\n          if (i === contourIndices[0]) {\n            contourStart = contourIndices.shift();\n          } else if (\n            verts[contourStart] &&\n            verts[i].equals(verts[contourStart])\n          ) {\n            res.push([i - 1, contourStart]);\n          } else {\n            res.push([i - 1, i]);\n          }\n        }\n        break;\n    }\n    return res;\n  }\n\n  /**\n   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.\n   * @private\n   */\n  _tesselateShape() {\n    // const contours = [[]];\n    const contours = [];\n    for (let i = 0; i < this.geometry.vertices.length; i++) {\n      if (\n        this.contourIndices.length > 0 &&\n        this.contourIndices[0] === i\n      ) {\n        this.contourIndices.shift();\n        contours.push([]);\n      }\n      contours[contours.length-1].push(\n        this.geometry.vertices[i].x,\n        this.geometry.vertices[i].y,\n        this.geometry.vertices[i].z,\n        this.geometry.uvs[i * 2],\n        this.geometry.uvs[i * 2 + 1],\n        this.geometry.vertexColors[i * 4],\n        this.geometry.vertexColors[i * 4 + 1],\n        this.geometry.vertexColors[i * 4 + 2],\n        this.geometry.vertexColors[i * 4 + 3],\n        this.geometry.vertexNormals[i].x,\n        this.geometry.vertexNormals[i].y,\n        this.geometry.vertexNormals[i].z\n      );\n      for (const propName in this.geometry.userVertexProperties) {\n        const prop = this.geometry.userVertexProperties[propName];\n        const start = i * prop.getDataSize();\n        const end = start + prop.getDataSize();\n        const vals = prop.getSrcArray().slice(start, end);\n        contours[contours.length-1].push(...vals);\n      }\n    }\n\n    const polyTriangles = this._triangulate(contours);\n\n    // If there were no valid faces, we still want to use the original vertices\n    // for strokes, so we'll stop here.\n    if (polyTriangles.length === 0) {\n      return;\n    }\n\n    // TODO: handle non-PATH shape modes that have contours\n    this.shapeMode = TRIANGLES;\n    const originalVertices = this.geometry.vertices;\n    this.geometry.vertices = [];\n    this.geometry.vertexNormals = [];\n    this.geometry.uvs = [];\n    for (const propName in this.geometry.userVertexProperties){\n      const prop = this.geometry.userVertexProperties[propName];\n      prop.resetSrcArray();\n    }\n    const colors = [];\n    for (\n      let j = 0, polyTriLength = polyTriangles.length;\n      j < polyTriLength;\n      j = j + this.tessyVertexSize\n    ) {\n      colors.push(...polyTriangles.slice(j + 5, j + 9));\n      this.geometry.vertexNormals.push(\n        new Vector(...polyTriangles.slice(j + 9, j + 12))\n      );\n      {\n        let offset = 12;\n        for (const propName in this.geometry.userVertexProperties){\n          const prop = this.geometry.userVertexProperties[propName];\n          const size = prop.getDataSize();\n          const start = j + offset;\n          const end = start + size;\n          prop.setCurrentData(polyTriangles.slice(start, end));\n          prop.pushCurrentData();\n          offset += size;\n        }\n      }\n      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));\n      this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));\n    }\n    if (this.renderer.geometryBuilder) {\n      // Tesselating the face causes the indices of edge vertices to stop being\n      // correct. When rendering, this is not a problem, since _edgesToVertices\n      // will have been called before this, and edge vertex indices are no longer\n      // needed. However, the geometry builder still needs this information, so\n      // when one is active, we need to update the indices.\n      //\n      // We record index mappings in a Map so that once we have found a\n      // corresponding vertex, we don't need to loop to find it again.\n      const newIndex = new Map();\n      this.geometry.edges =\n        this.geometry.edges.map(edge => edge.map(origIdx => {\n          if (!newIndex.has(origIdx)) {\n            const orig = originalVertices[origIdx];\n            let newVertIndex = this.geometry.vertices.findIndex(\n              v =>\n                orig.x === v.x &&\n                orig.y === v.y &&\n                orig.z === v.z\n            );\n            if (newVertIndex === -1) {\n              // The tesselation process didn't output a vertex with the exact\n              // coordinate as before, potentially due to numerical issues. This\n              // doesn't happen often, but in this case, pick the closest point\n              let closestDist = Infinity;\n              let closestIndex = 0;\n              for (\n                let i = 0;\n                i < this.geometry.vertices.length;\n                i++\n              ) {\n                const vert = this.geometry.vertices[i];\n                const dX = orig.x - vert.x;\n                const dY = orig.y - vert.y;\n                const dZ = orig.z - vert.z;\n                const dist = dX*dX + dY*dY + dZ*dZ;\n                if (dist < closestDist) {\n                  closestDist = dist;\n                  closestIndex = i;\n                }\n              }\n              newVertIndex = closestIndex;\n            }\n            newIndex.set(origIdx, newVertIndex);\n          }\n          return newIndex.get(origIdx);\n        }));\n    }\n    this.geometry.vertexColors = colors;\n  }\n\n  _initTessy() {\n    // function called for each vertex of tesselator output\n    function vertexCallback(data, polyVertArray) {\n      for (const element of data) {\n        polyVertArray.push(element);\n      }\n    }\n\n    function begincallback(type) {\n      if (type !== libtess.primitiveType.GL_TRIANGLES) {\n        console.log(`expected TRIANGLES but got type: ${type}`);\n      }\n    }\n\n    function errorcallback(errno) {\n      console.log('error callback');\n      console.log(`error number: ${errno}`);\n    }\n\n    // callback for when segments intersect and must be split\n    const combinecallback = (coords, data, weight) => {\n      const result = new Array(this.tessyVertexSize).fill(0);\n      for (let i = 0; i < weight.length; i++) {\n        for (let j = 0; j < result.length; j++) {\n          if (weight[i] === 0 || !data[i]) continue;\n          result[j] += data[i][j] * weight[i];\n        }\n      }\n      return result;\n    };\n\n    function edgeCallback(flag) {\n      // don't really care about the flag, but need no-strip/no-fan behavior\n    }\n\n    const tessy = new libtess.GluTesselator();\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n    tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n    tessy.gluTessProperty(\n      libtess.gluEnum.GLU_TESS_WINDING_RULE,\n      libtess.windingRule.GLU_TESS_WINDING_NONZERO\n    );\n\n    return tessy;\n  }\n\n  /**\n   * Runs vertices through libtess to convert them into triangles\n   * @private\n   */\n  _triangulate(contours) {\n    // libtess will take 3d verts and flatten to a plane for tesselation.\n    // libtess is capable of calculating a plane to tesselate on, but\n    // if all of the vertices have the same z values, we'll just\n    // assume the face is facing the camera, letting us skip any performance\n    // issues or bugs in libtess's automatic calculation.\n    const z = contours[0] ? contours[0][2] : undefined;\n    let allSameZ = true;\n    for (const contour of contours) {\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        if (contour[j + 2] !== z) {\n          allSameZ = false;\n          break;\n        }\n      }\n    }\n    if (allSameZ) {\n      this._tessy.gluTessNormal(0, 0, 1);\n    } else {\n      // Let libtess pick a plane for us\n      this._tessy.gluTessNormal(0, 0, 0);\n    }\n\n    const triangleVerts = [];\n    this._tessy.gluTessBeginPolygon(triangleVerts);\n\n    for (const contour of contours) {\n      this._tessy.gluTessBeginContour();\n      for (\n        let j = 0;\n        j < contour.length;\n        j += this.tessyVertexSize\n      ) {\n        const coords = contour.slice(\n          j,\n          j + this.tessyVertexSize\n        );\n        this._tessy.gluTessVertex(coords, coords);\n      }\n      this._tessy.gluTessEndContour();\n    }\n\n    // finish polygon\n    this._tessy.gluTessEndPolygon();\n\n    return triangleVerts;\n  }\n}\n\nexport { ShapeBuilder };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3366, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/GeometryBufferCache.js"],"sourcesContent":["class GeometryBufferCache {\n  constructor(renderer) {\n    this.renderer = renderer;\n    this.cache = {};\n  }\n\n  numCached() {\n    return Object.keys(this.cache).length;\n  }\n\n  isCached(gid) {\n    return this.cache[gid] !== undefined;\n  }\n\n  getGeometryByID(gid) {\n    return this.cache[gid]?.geometry;\n  }\n\n  getCached(model) {\n    return this.getCachedID(model.gid);\n  }\n\n  getCachedID(gid) {\n    return this.cache[gid];\n  }\n\n  ensureCached(geometry) {\n    const gid = geometry.gid;\n    if (!gid) {\n      throw new Error('The p5.Geometry you passed in has no gid property!');\n    }\n\n    if (this.isCached(geometry.gid)) return this.getCached(geometry);\n\n    const gl = this.renderer.GL;\n\n    //initialize the gl buffers for our geom groups\n    this.freeBuffers(gid);\n\n    if (Object.keys(this.cache).length > 1000) {\n      const key = Object.keys(this.cache)[0];\n      this.freeBuffers(key);\n    }\n\n    //create a new entry in our cache\n    const buffers = {};\n    this.cache[gid] = buffers;\n\n    buffers.geometry = geometry;\n\n    let indexBuffer = buffers.indexBuffer;\n\n    if (geometry.faces.length) {\n      // allocate space for faces\n      if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();\n      const vals = geometry.faces.flat();\n\n      // If any face references a vertex with an index greater than the maximum\n      // un-singed 16 bit integer, then we need to use a Uint32Array instead of a\n      // Uint16Array\n      const hasVertexIndicesOverMaxUInt16 = vals.some(v => v > 65535);\n      let type = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;\n      this.renderer._bindBuffer(\n        indexBuffer,\n        gl.ELEMENT_ARRAY_BUFFER,\n        vals,\n        type\n      );\n\n      // If we're using a Uint32Array for our indexBuffer we will need to pass a\n      // different enum value to WebGL draw triangles. This happens in\n      // the _drawElements function.\n      buffers.indexBufferType = hasVertexIndicesOverMaxUInt16\n        ? gl.UNSIGNED_INT\n        : gl.UNSIGNED_SHORT;\n    } else {\n      // the index buffer is unused, remove it\n      if (indexBuffer) {\n        gl.deleteBuffer(indexBuffer);\n        buffers.indexBuffer = null;\n      }\n    }\n\n    return buffers;\n  }\n\n  freeBuffers(gid) {\n    const buffers = this.cache[gid];\n    if (!buffers) {\n      return;\n    }\n\n    delete this.cache[gid];\n\n    const gl = this.renderer.GL;\n    if (buffers.indexBuffer) {\n      gl.deleteBuffer(buffers.indexBuffer);\n    }\n\n    function freeBuffers(defs) {\n      for (const def of defs) {\n        if (buffers[def.dst]) {\n          gl.deleteBuffer(buffers[def.dst]);\n          buffers[def.dst] = null;\n        }\n      }\n    }\n\n    // free all the buffers\n    freeBuffers(this.renderer.buffers.stroke);\n    freeBuffers(this.renderer.buffers.fill);\n    freeBuffers(this.renderer.buffers.user);\n  }\n}\n\nexport { GeometryBufferCache };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3460, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/interaction.js"],"sourcesContent":["import { G as GRID, A as AXES } from '../constants-Bt1VTUeD.js';\nimport { Vector } from '../math/p5.Vector.js';\n\n/**\n * @module 3D\n * @submodule Interaction\n * @for p5\n * @requires core\n */\n\n\nfunction interaction(p5, fn){\n  /**\n   * Allows the user to orbit around a 3D sketch using a mouse, trackpad, or\n   * touchscreen.\n   *\n   * 3D sketches are viewed through an imaginary camera. Calling\n   * `orbitControl()` within the <a href=\"#/p5/draw\">draw()</a> function allows\n   * the user to change the camera’s position:\n   *\n   * ```js\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Rest of sketch.\n   * }\n   * ```\n   *\n   * Left-clicking and dragging or swipe motion will rotate the camera position\n   * about the center of the sketch. Right-clicking and dragging or multi-swipe\n   * will pan the camera position without rotation. Using the mouse wheel\n   * (scrolling) or pinch in/out will move the camera further or closer from the\n   * center of the sketch.\n   *\n   * The first three parameters, `sensitivityX`, `sensitivityY`, and\n   * `sensitivityZ`, are optional. They’re numbers that set the sketch’s\n   * sensitivity to movement along each axis. For example, calling\n   * `orbitControl(1, 2, -1)` keeps movement along the x-axis at its default\n   * value, makes the sketch twice as sensitive to movement along the y-axis,\n   * and reverses motion along the z-axis. By default, all sensitivity values\n   * are 1.\n   *\n   * The fourth parameter, `options`, is also optional. It’s an object that\n   * changes the behavior of orbiting. For example, calling\n   * `orbitControl(1, 1, 1, options)` keeps the default sensitivity values while\n   * changing the behaviors set with `options`. The object can have the\n   * following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Setting this to false makes mobile interactions smoother by\n   *   // preventing accidental interactions with the page while orbiting.\n   *   // By default, it's true.\n   *   disableTouchActions: true,\n   *\n   *   // Setting this to true makes the camera always rotate in the\n   *   // direction the mouse/touch is moving.\n   *   // By default, it's false.\n   *   freeRotation: false\n   * };\n   *\n   * orbitControl(1, 1, 1, options);\n   * ```\n   *\n   * @method orbitControl\n   * @for p5\n   * @param  {Number} [sensitivityX] sensitivity to movement along the x-axis. Defaults to 1.\n   * @param  {Number} [sensitivityY] sensitivity to movement along the y-axis. Defaults to 1.\n   * @param  {Number} [sensitivityZ] sensitivity to movement along the z-axis. Defaults to 1.\n   * @param  {Object} [options] Settings for orbitControl:\n   * @param {Boolean} [options.disableTouchActions=true] Prevent accidental interactions with the page while orbiting.\n   * @param {Boolean} [options.freeRotation=false] Rotate in the drag direction instead of on principal axes.\n   * @chainable\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   // Make the interactions 3X sensitive.\n   *   orbitControl(3, 3, 3);\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Create an options object.\n   *   let options = {\n   *     disableTouchActions: false,\n   *     freeRotation: true\n   *   };\n   *\n   *   // Enable orbiting with the mouse.\n   *   // Prevent accidental touch actions on touchscreen devices\n   *   // and enable free rotation.\n   *   orbitControl(1, 1, 1, options);\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(30, 50);\n   * }\n   * </code>\n   * </div>\n   */\n\n  // implementation based on three.js 'orbitControls':\n  // https://github.com/mrdoob/three.js/blob/6afb8595c0bf8b2e72818e42b64e6fe22707d896/examples/jsm/controls/OrbitControls.js#L22\n  fn.orbitControl = function(\n    sensitivityX,\n    sensitivityY,\n    sensitivityZ,\n    options\n  ) {\n    this._assert3d('orbitControl');\n    // p5._validateParameters('orbitControl', arguments);\n\n    const cam = this._renderer.states.curCamera;\n\n    if (typeof sensitivityX === 'undefined') {\n      sensitivityX = 1;\n    }\n    if (typeof sensitivityY === 'undefined') {\n      sensitivityY = sensitivityX;\n    }\n    if (typeof sensitivityZ === 'undefined') {\n      sensitivityZ = 1;\n    }\n    if (typeof options !== 'object') {\n      options = {};\n    }\n\n    // default right-mouse and mouse-wheel behaviors (context menu and scrolling,\n    // respectively) are disabled here to allow use of those events for panning and\n    // zooming. However, whether or not to disable touch actions is an option.\n\n    // disable context menu for canvas element and add 'contextMenuDisabled'\n    // flag to p5 instance\n    if (this.contextMenuDisabled !== true) {\n      this.canvas.oncontextmenu = () => false;\n      this.contextMenuDisabled = true;\n    }\n\n    // disable default scrolling behavior on the canvas element and add\n    // 'wheelDefaultDisabled' flag to p5 instance\n    if (this.wheelDefaultDisabled !== true) {\n      this.canvas.onwheel = () => false;\n      this.wheelDefaultDisabled = true;\n    }\n\n    // disable default touch behavior on the canvas element and add\n    // 'touchActionsDisabled' flag to p5 instance\n    const { disableTouchActions = true } = options;\n    if (this.touchActionsDisabled !== true && disableTouchActions) {\n      this.canvas.style['touch-action'] = 'none';\n      this.touchActionsDisabled = true;\n    }\n\n    // If option.freeRotation is true, the camera always rotates freely in the direction\n    // the pointer moves. default value is false (normal behavior)\n    const { freeRotation = false } = options;\n\n    // get moved touches.\n    const movedTouches = [];\n\n    this.touches.forEach(curTouch => {\n      this._renderer.prevTouches.forEach(prevTouch => {\n        if (curTouch.id === prevTouch.id) {\n          const movedTouch = {\n            x: curTouch.x,\n            y: curTouch.y,\n            px: prevTouch.x,\n            py: prevTouch.y\n          };\n          movedTouches.push(movedTouch);\n        }\n      });\n    });\n\n    this._renderer.prevTouches = this.touches;\n\n    // The idea of using damping is based on the following website. thank you.\n    // https://github.com/freshfork/p5.EasyCam/blob/9782964680f6a5c4c9bee825c475d9f2021d5134/p5.easycam.js#L1124\n\n    // variables for interaction\n    let deltaRadius = 0;\n    let deltaTheta = 0;\n    let deltaPhi = 0;\n    let moveDeltaX = 0;\n    let moveDeltaY = 0;\n    // constants for dampingProcess\n    const damping = 0.85;\n    const rotateAccelerationFactor = 0.6;\n    const moveAccelerationFactor = 0.15;\n    // For touches, the appropriate scale is different\n    // because the distance difference is multiplied.\n    const mouseZoomScaleFactor = 0.01;\n    const touchZoomScaleFactor = 0.0004;\n    const scaleFactor = this.height < this.width ? this.height : this.width;\n    // Flag whether the mouse or touch pointer is inside the canvas\n    let pointersInCanvas = false;\n\n    // calculate and determine flags and variables.\n    if (movedTouches.length > 0) {\n      /* for touch */\n      // if length === 1, rotate\n      // if length > 1, zoom and move\n\n      // for touch, it is calculated based on one moved touch pointer position.\n      pointersInCanvas =\n        movedTouches[0].x > 0 && movedTouches[0].x < this.width &&\n        movedTouches[0].y > 0 && movedTouches[0].y < this.height;\n\n      if (movedTouches.length === 1) {\n        const t = movedTouches[0];\n        deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;\n        deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;\n      } else {\n        const t0 = movedTouches[0];\n        const t1 = movedTouches[1];\n        const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);\n        const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);\n        const changeDist = distWithTouches - prevDistWithTouches;\n        // move the camera farther when the distance between the two touch points\n        // decreases, move the camera closer when it increases.\n        deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;\n        // Move the center of the camera along with the movement of\n        // the center of gravity of the two touch points.\n        moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);\n        moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);\n      }\n      if (this.touches.length > 0) {\n        if (pointersInCanvas) {\n          // Initiate an interaction if touched in the canvas\n          this._renderer.executeRotateAndMove = true;\n          this._renderer.executeZoom = true;\n        }\n      } else {\n        // End an interaction when the touch is released\n        this._renderer.executeRotateAndMove = false;\n        this._renderer.executeZoom = false;\n      }\n    } else {\n      /* for mouse */\n      // if wheelDeltaY !== 0, zoom\n      // if mouseLeftButton is down, rotate\n      // if mouseRightButton is down, move\n\n      // For mouse, it is calculated based on the mouse position.\n      pointersInCanvas =\n        (this.mouseX > 0 && this.mouseX < this.width) &&\n        (this.mouseY > 0 && this.mouseY < this.height);\n\n      if (this._mouseWheelDeltaY !== 0) {\n        // zoom the camera depending on the value of _mouseWheelDeltaY.\n        // move away if positive, move closer if negative\n        deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;\n        deltaRadius *= mouseZoomScaleFactor;\n        this._mouseWheelDeltaY = 0;\n        // start zoom when the mouse is wheeled within the canvas.\n        if (pointersInCanvas) this._renderer.executeZoom = true;\n      } else {\n        // quit zoom when you stop wheeling.\n        this._renderer.executeZoom = false;\n      }\n      if (this.mouseIsPressed) {\n        if (this.mouseButton.left) {\n          deltaTheta = -sensitivityX * this.movedX / scaleFactor;\n          deltaPhi = sensitivityY * this.movedY / scaleFactor;\n        } else if (this.mouseButton.right) {\n          moveDeltaX = this.movedX;\n          moveDeltaY =  this.movedY * cam.yScale;\n        }\n        // start rotate and move when mouse is pressed within the canvas.\n        if (pointersInCanvas) this._renderer.executeRotateAndMove = true;\n      } else {\n        // quit rotate and move if mouse is released.\n        this._renderer.executeRotateAndMove = false;\n      }\n    }\n\n    // interactions\n\n    // zoom process\n    if (deltaRadius !== 0 && this._renderer.executeZoom) {\n      // accelerate zoom velocity\n      this._renderer.zoomVelocity += deltaRadius;\n    }\n    if (Math.abs(this._renderer.zoomVelocity) > 0.001) {\n      // if freeRotation is true, we use _orbitFree() instead of _orbit()\n      if (freeRotation) {\n        cam._orbitFree(\n          0, 0, this._renderer.zoomVelocity\n        );\n      } else {\n        cam._orbit(\n          0, 0, this._renderer.zoomVelocity\n        );\n      }\n      // In orthogonal projection, the scale does not change even if\n      // the distance to the gaze point is changed, so the projection matrix\n      // needs to be modified.\n      if (cam.projMatrix.mat4[15] !== 0) {\n        cam.projMatrix.mat4[0] *= Math.pow(\n          10, -this._renderer.zoomVelocity\n        );\n        cam.projMatrix.mat4[5] *= Math.pow(\n          10, -this._renderer.zoomVelocity\n        );\n        // modify uPMatrix\n        this._renderer.states.setValue('uPMatrix', this._renderer.states.uPMatrix.clone());\n        this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];\n        this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];\n      }\n      // damping\n      this._renderer.zoomVelocity *= damping;\n    } else {\n      this._renderer.zoomVelocity = 0;\n    }\n\n    // rotate process\n    if ((deltaTheta !== 0 || deltaPhi !== 0) &&\n    this._renderer.executeRotateAndMove) {\n      // accelerate rotate velocity\n      this._renderer.rotateVelocity.add(\n        deltaTheta * rotateAccelerationFactor,\n        deltaPhi * rotateAccelerationFactor\n      );\n    }\n    if (this._renderer.rotateVelocity.magSq() > 0.000001) {\n      // if freeRotation is true, the camera always rotates freely in the direction the pointer moves\n      if (freeRotation) {\n        cam._orbitFree(\n          -this._renderer.rotateVelocity.x,\n          this._renderer.rotateVelocity.y,\n          0\n        );\n      } else {\n        cam._orbit(\n          this._renderer.rotateVelocity.x,\n          this._renderer.rotateVelocity.y,\n          0\n        );\n      }\n      // damping\n      this._renderer.rotateVelocity.mult(damping);\n    } else {\n      this._renderer.rotateVelocity.set(0, 0);\n    }\n\n    // move process\n    if ((moveDeltaX !== 0 || moveDeltaY !== 0) &&\n    this._renderer.executeRotateAndMove) {\n      // Normalize movement distance\n      const ndcX = moveDeltaX * 2/this.width;\n      const ndcY = -moveDeltaY * 2/this.height;\n      // accelerate move velocity\n      this._renderer.moveVelocity.add(\n        ndcX * moveAccelerationFactor,\n        ndcY * moveAccelerationFactor\n      );\n    }\n    if (this._renderer.moveVelocity.magSq() > 0.000001) {\n      // Translate the camera so that the entire object moves\n      // perpendicular to the line of sight when the mouse is moved\n      // or when the centers of gravity of the two touch pointers move.\n      const local = cam._getLocalAxes();\n\n      // Calculate the z coordinate in the view coordinates of\n      // the center, that is, the distance to the view point\n      const diffX = cam.eyeX - cam.centerX;\n      const diffY = cam.eyeY - cam.centerY;\n      const diffZ = cam.eyeZ - cam.centerZ;\n      const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);\n\n      // position vector of the center.\n      let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);\n\n      // Calculate the normalized device coordinates of the center.\n      cv = cam.cameraMatrix.multiplyPoint(cv);\n      cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);\n\n      // Move the center by this distance\n      // in the normalized device coordinate system.\n      cv.x -= this._renderer.moveVelocity.x;\n      cv.y -= this._renderer.moveVelocity.y;\n\n      // Calculate the translation vector\n      // in the direction perpendicular to the line of sight of center.\n      let dx, dy;\n      const uP = this._renderer.states.uPMatrix.mat4;\n\n      if (uP[15] === 0) {\n        dx = ((uP[8] + cv.x)/uP[0]) * viewZ;\n        dy = ((uP[9] + cv.y)/uP[5]) * viewZ;\n      } else {\n        dx = (cv.x - uP[12])/uP[0];\n        dy = (cv.y - uP[13])/uP[5];\n      }\n\n      // translate the camera.\n      cam.setPosition(\n        cam.eyeX + dx * local.x[0] + dy * local.y[0],\n        cam.eyeY + dx * local.x[1] + dy * local.y[1],\n        cam.eyeZ + dx * local.x[2] + dy * local.y[2]\n      );\n      // damping\n      this._renderer.moveVelocity.mult(damping);\n    } else {\n      this._renderer.moveVelocity.set(0, 0);\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Adds a grid and an axes icon to clarify orientation in 3D sketches.\n   *\n   * `debugMode()` adds a grid that shows where the “ground” is in a sketch. By\n   * default, the grid will run through the origin `(0, 0, 0)` of the sketch\n   * along the XZ plane. `debugMode()` also adds an axes icon that points along\n   * the positive x-, y-, and z-axes. Calling `debugMode()` displays the grid\n   * and axes icon with their default size and position.\n   *\n   * There are four ways to call `debugMode()` with optional parameters to\n   * customize the debugging environment.\n   *\n   * The first way to call `debugMode()` has one parameter, `mode`. If the\n   * system constant `GRID` is passed, as in `debugMode(GRID)`, then the grid\n   * will be displayed and the axes icon will be hidden. If the constant `AXES`\n   * is passed, as in `debugMode(AXES)`, then the axes icon will be displayed\n   * and the grid will be hidden.\n   *\n   * The second way to call `debugMode()` has six parameters. The first\n   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The\n   * next five parameters, `gridSize`, `gridDivisions`, `xOff`, `yOff`, and\n   * `zOff` are optional. They’re numbers that set the appearance of the grid\n   * (`gridSize` and `gridDivisions`) and the placement of the axes icon\n   * (`xOff`, `yOff`, and `zOff`). For example, calling\n   * `debugMode(20, 5, 10, 10, 10)` sets the `gridSize` to 20 pixels, the number\n   * of `gridDivisions` to 5, and offsets the axes icon by 10 pixels along the\n   * x-, y-, and z-axes.\n   *\n   * The third way to call `debugMode()` has five parameters. The first\n   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The\n   * next four parameters, `axesSize`, `xOff`, `yOff`, and `zOff` are optional.\n   * They’re numbers that set the appearance of the size of the axes icon\n   * (`axesSize`) and its placement (`xOff`, `yOff`, and `zOff`).\n   *\n   * The fourth way to call `debugMode()` has nine optional parameters. The\n   * first five parameters, `gridSize`, `gridDivisions`, `gridXOff`, `gridYOff`,\n   * and `gridZOff` are numbers that set the appearance of the grid. For\n   * example, calling `debugMode(100, 5, 0, 0, 0)` sets the `gridSize` to 100,\n   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that\n   * the grid is centered at the origin. The next four parameters, `axesSize`,\n   * `xOff`, `yOff`, and `zOff` are numbers that set the appearance of the size\n   * of the axes icon (`axesSize`) and its placement (`axesXOff`, `axesYOff`,\n   * and `axesZOff`). For example, calling\n   * `debugMode(100, 5, 0, 0, 0, 50, 10, 10, 10)` sets the `gridSize` to 100,\n   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that\n   * the grid is centered at the origin. It then sets the `axesSize` to 50 and\n   * offsets the icon 10 pixels along each axis.\n   *\n   * @method debugMode\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   debugMode();\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Only display the axes icon.\n   *   debugMode(AXES);\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Only display the grid and customize it:\n   *   // - size: 50\n   *   // - divisions: 10\n   *   // - offsets: 0, 20, 0\n   *   debugMode(GRID, 50, 10, 0, 20, 0);\n   *\n   *   describe('A multicolor box on a gray background. A grid is displayed below the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   // Display the grid and axes icon and customize them:\n   *   // Grid\n   *   // ----\n   *   // - size: 50\n   *   // - divisions: 10\n   *   // - offsets: 0, 20, 0\n   *   // Axes\n   *   // ----\n   *   // - size: 50\n   *   // - offsets: 0, 0, 0\n   *   debugMode(50, 10, 0, 20, 0, 50, 0, 0, 0);\n   *\n   *   describe('A multicolor box on a gray background. A grid is displayed below the box. An axes icon is displayed at the center of the box.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.\n   *   box(20, 40);\n   * }\n   * </code>\n   * </div>\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode either GRID or AXES\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode\n   * @param {Number} [gridSize] side length of the grid.\n   * @param {Number} [gridDivisions] number of divisions in the grid.\n   * @param {Number} [xOff] offset from origin along the x-axis.\n   * @param {Number} [yOff] offset from origin along the y-axis.\n   * @param {Number} [zOff] offset from origin along the z-axis.\n   */\n\n  /**\n   * @method debugMode\n   * @param {(GRID|AXES)} mode\n   * @param {Number} [axesSize] length of axes icon markers.\n   * @param {Number} [xOff]\n   * @param {Number} [yOff]\n   * @param {Number} [zOff]\n   */\n\n  /**\n   * @method debugMode\n   * @param {Number} [gridSize]\n   * @param {Number} [gridDivisions]\n   * @param {Number} [gridXOff] grid offset from the origin along the x-axis.\n   * @param {Number} [gridYOff] grid offset from the origin along the y-axis.\n   * @param {Number} [gridZOff] grid offset from the origin along the z-axis.\n   * @param {Number} [axesSize]\n   * @param {Number} [axesXOff] axes icon offset from the origin along the x-axis.\n   * @param {Number} [axesYOff] axes icon offset from the origin along the y-axis.\n   * @param {Number} [axesZOff] axes icon offset from the origin along the z-axis.\n   */\n\n  fn.debugMode = function(...args) {\n    this._assert3d('debugMode');\n    // p5._validateParameters('debugMode', args);\n\n    // start by removing existing 'post' registered debug methods\n    for (let i = p5.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {\n      // test for equality...\n      if (\n        p5.lifecycleHooks.postdraw[i].toString() === this._grid().toString() ||\n        p5.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()\n      ) {\n        p5.lifecycleHooks.postdraw.splice(i, 1);\n      }\n    }\n\n    // then add new debugMode functions according to the argument list\n    if (args[0] === GRID) {\n      p5.lifecycleHooks.postdraw.push(\n        this._grid(args[1], args[2], args[3], args[4], args[5])\n      );\n    } else if (args[0] === AXES) {\n      p5.lifecycleHooks.postdraw.push(\n        this._axesIcon(args[1], args[2], args[3], args[4])\n      );\n    } else {\n      p5.lifecycleHooks.postdraw.push(\n        this._grid(args[0], args[1], args[2], args[3], args[4])\n      );\n      p5.lifecycleHooks.postdraw.push(\n        this._axesIcon(args[5], args[6], args[7], args[8])\n      );\n    }\n  };\n\n  /**\n   * Turns off <a href=\"#/p5/debugMode\">debugMode()</a> in a 3D sketch.\n   *\n   * @method noDebugMode\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Enable debug mode.\n   *   debugMode();\n   *\n   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box. They disappear when the user double-clicks.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Style the box.\n   *   normalMaterial();\n   *\n   *   // Draw the box.  box(20, 40);\n   * }\n   *\n   * // Disable debug mode when the user double-clicks.\n   * function doubleClicked() {\n   *   noDebugMode();\n   * }\n   * </code>\n   * </div>\n   */\n  fn.noDebugMode = function() {\n    this._assert3d('noDebugMode');\n\n    // start by removing existing 'post' registered debug methods\n    for (let i = p5.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {\n      // test for equality...\n      if (\n        p5.lifecycleHooks.postdraw[i].toString() === this._grid().toString() ||\n        p5.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()\n      ) {\n        p5.lifecycleHooks.postdraw.splice(i, 1);\n      }\n    }\n  };\n\n  /**\n   * For use with debugMode\n   * @private\n   * @method _grid\n   * @param {Number} [size] size of grid sides\n   * @param {Number} [div] number of grid divisions\n   * @param {Number} [xOff] offset of grid center from origin in X axis\n   * @param {Number} [yOff] offset of grid center from origin in Y axis\n   * @param {Number} [zOff] offset of grid center from origin in Z axis\n   */\n  fn._grid = function(size, numDivs, xOff, yOff, zOff) {\n    if (typeof size === 'undefined') {\n      size = this.width / 2;\n    }\n    if (typeof numDivs === 'undefined') {\n      // ensure at least 2 divisions\n      numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);\n    }\n    if (typeof xOff === 'undefined') {\n      xOff = 0;\n    }\n    if (typeof yOff === 'undefined') {\n      yOff = 0;\n    }\n    if (typeof zOff === 'undefined') {\n      zOff = 0;\n    }\n\n    const spacing = size / numDivs;\n    const halfSize = size / 2;\n\n    return function() {\n      this.push();\n      this.stroke(\n        this._renderer.states.curStrokeColor[0] * 255,\n        this._renderer.states.curStrokeColor[1] * 255,\n        this._renderer.states.curStrokeColor[2] * 255\n      );\n      this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());\n      this._renderer.states.uModelMatrix.reset();\n\n      // Lines along X axis\n      for (let q = 0; q <= numDivs; q++) {\n        this.beginShape(this.LINES);\n        this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);\n        this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);\n        this.endShape();\n      }\n\n      // Lines along Z axis\n      for (let i = 0; i <= numDivs; i++) {\n        this.beginShape(this.LINES);\n        this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);\n        this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);\n        this.endShape();\n      }\n\n      this.pop();\n    };\n  };\n\n  /**\n   * For use with debugMode\n   * @private\n   * @method _axesIcon\n   * @param {Number} [size] size of axes icon lines\n   * @param {Number} [xOff] offset of icon from origin in X axis\n   * @param {Number} [yOff] offset of icon from origin in Y axis\n   * @param {Number} [zOff] offset of icon from origin in Z axis\n   */\n  fn._axesIcon = function(size, xOff, yOff, zOff) {\n    if (typeof size === 'undefined') {\n      size = this.width / 20 > 40 ? this.width / 20 : 40;\n    }\n    if (typeof xOff === 'undefined') {\n      xOff = -this.width / 4;\n    }\n    if (typeof yOff === 'undefined') {\n      yOff = xOff;\n    }\n    if (typeof zOff === 'undefined') {\n      zOff = xOff;\n    }\n\n    return () => {\n      this.push();\n      this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());\n      this._renderer.states.uModelMatrix.reset();\n\n      // X axis\n      this.strokeWeight(2);\n      this.stroke(255, 0, 0);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff + size, yOff, zOff);\n      this.endShape();\n      // Y axis\n      this.stroke(0, 255, 0);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff, yOff + size, zOff);\n      this.endShape();\n      // Z axis\n      this.stroke(0, 0, 255);\n      this.beginShape(this.LINES);\n      this.vertex(xOff, yOff, zOff);\n      this.vertex(xOff, yOff, zOff + size);\n      this.endShape();\n      this.pop();\n    };\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  interaction(p5, p5.prototype);\n}\n\nexport { interaction as default };\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA;;;;;CAKC,GAGD,SAAS,YAAY,GAAE,EAAE,EAAE;IACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqJC,GAED,oDAAoD;IACpD,8HAA8H;IAC9H,GAAG,YAAY,GAAG,SAChB,YAAY,EACZ,YAAY,EACZ,YAAY,EACZ,OAAO;QAEP,IAAI,CAAC,SAAS,CAAC;QACf,qDAAqD;QAErD,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS;QAE3C,IAAI,OAAO,iBAAiB,aAAa;YACvC,eAAe;QACjB;QACA,IAAI,OAAO,iBAAiB,aAAa;YACvC,eAAe;QACjB;QACA,IAAI,OAAO,iBAAiB,aAAa;YACvC,eAAe;QACjB;QACA,IAAI,OAAO,YAAY,UAAU;YAC/B,UAAU,CAAC;QACb;QAEA,6EAA6E;QAC7E,+EAA+E;QAC/E,0EAA0E;QAE1E,wEAAwE;QACxE,sBAAsB;QACtB,IAAI,IAAI,CAAC,mBAAmB,KAAK,MAAM;YACrC,IAAI,CAAC,MAAM,CAAC,aAAa,GAAG,IAAM;YAClC,IAAI,CAAC,mBAAmB,GAAG;QAC7B;QAEA,mEAAmE;QACnE,6CAA6C;QAC7C,IAAI,IAAI,CAAC,oBAAoB,KAAK,MAAM;YACtC,IAAI,CAAC,MAAM,CAAC,OAAO,GAAG,IAAM;YAC5B,IAAI,CAAC,oBAAoB,GAAG;QAC9B;QAEA,+DAA+D;QAC/D,6CAA6C;QAC7C,MAAM,EAAE,sBAAsB,IAAI,EAAE,GAAG;QACvC,IAAI,IAAI,CAAC,oBAAoB,KAAK,QAAQ,qBAAqB;YAC7D,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,eAAe,GAAG;YACpC,IAAI,CAAC,oBAAoB,GAAG;QAC9B;QAEA,oFAAoF;QACpF,8DAA8D;QAC9D,MAAM,EAAE,eAAe,KAAK,EAAE,GAAG;QAEjC,qBAAqB;QACrB,MAAM,eAAe,EAAE;QAEvB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;YACnB,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,OAAO,CAAC,CAAA;gBACjC,IAAI,SAAS,EAAE,KAAK,UAAU,EAAE,EAAE;oBAChC,MAAM,aAAa;wBACjB,GAAG,SAAS,CAAC;wBACb,GAAG,SAAS,CAAC;wBACb,IAAI,UAAU,CAAC;wBACf,IAAI,UAAU,CAAC;oBACjB;oBACA,aAAa,IAAI,CAAC;gBACpB;YACF;QACF;QAEA,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC,OAAO;QAEzC,0EAA0E;QAC1E,4GAA4G;QAE5G,4BAA4B;QAC5B,IAAI,cAAc;QAClB,IAAI,aAAa;QACjB,IAAI,WAAW;QACf,IAAI,aAAa;QACjB,IAAI,aAAa;QACjB,+BAA+B;QAC/B,MAAM,UAAU;QAChB,MAAM,2BAA2B;QACjC,MAAM,yBAAyB;QAC/B,kDAAkD;QAClD,iDAAiD;QACjD,MAAM,uBAAuB;QAC7B,MAAM,uBAAuB;QAC7B,MAAM,cAAc,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK;QACvE,+DAA+D;QAC/D,IAAI,mBAAmB;QAEvB,+CAA+C;QAC/C,IAAI,aAAa,MAAM,GAAG,GAAG;YAC3B,aAAa,GACb,0BAA0B;YAC1B,+BAA+B;YAE/B,yEAAyE;YACzE,mBACE,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,IACvD,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,KAAK,YAAY,CAAC,EAAE,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM;YAE1D,IAAI,aAAa,MAAM,KAAK,GAAG;gBAC7B,MAAM,IAAI,YAAY,CAAC,EAAE;gBACzB,aAAa,CAAC,eAAe,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,IAAI;gBAC5C,WAAW,eAAe,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,IAAI;YAC3C,OAAO;gBACL,MAAM,KAAK,YAAY,CAAC,EAAE;gBAC1B,MAAM,KAAK,YAAY,CAAC,EAAE;gBAC1B,MAAM,kBAAkB,KAAK,KAAK,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,GAAG,GAAG,CAAC;gBAC3D,MAAM,sBAAsB,KAAK,KAAK,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,EAAE,GAAG,EAAE,GAAG,GAAG,EAAE;gBACnE,MAAM,aAAa,kBAAkB;gBACrC,yEAAyE;gBACzE,uDAAuD;gBACvD,cAAc,CAAC,aAAa,eAAe;gBAC3C,2DAA2D;gBAC3D,iDAAiD;gBACjD,aAAa,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE;gBACvD,aAAa,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,MAAM,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE;YACzD;YACA,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,GAAG;gBAC3B,IAAI,kBAAkB;oBACpB,mDAAmD;oBACnD,IAAI,CAAC,SAAS,CAAC,oBAAoB,GAAG;oBACtC,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG;gBAC/B;YACF,OAAO;gBACL,gDAAgD;gBAChD,IAAI,CAAC,SAAS,CAAC,oBAAoB,GAAG;gBACtC,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG;YAC/B;QACF,OAAO;YACL,aAAa,GACb,6BAA6B;YAC7B,qCAAqC;YACrC,oCAAoC;YAEpC,2DAA2D;YAC3D,mBACE,AAAC,IAAI,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,IAC3C,IAAI,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM;YAE/C,IAAI,IAAI,CAAC,iBAAiB,KAAK,GAAG;gBAChC,+DAA+D;gBAC/D,iDAAiD;gBACjD,cAAc,KAAK,IAAI,CAAC,IAAI,CAAC,iBAAiB,IAAI;gBAClD,eAAe;gBACf,IAAI,CAAC,iBAAiB,GAAG;gBACzB,0DAA0D;gBAC1D,IAAI,kBAAkB,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG;YACrD,OAAO;gBACL,oCAAoC;gBACpC,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG;YAC/B;YACA,IAAI,IAAI,CAAC,cAAc,EAAE;gBACvB,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;oBACzB,aAAa,CAAC,eAAe,IAAI,CAAC,MAAM,GAAG;oBAC3C,WAAW,eAAe,IAAI,CAAC,MAAM,GAAG;gBAC1C,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE;oBACjC,aAAa,IAAI,CAAC,MAAM;oBACxB,aAAc,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM;gBACxC;gBACA,iEAAiE;gBACjE,IAAI,kBAAkB,IAAI,CAAC,SAAS,CAAC,oBAAoB,GAAG;YAC9D,OAAO;gBACL,6CAA6C;gBAC7C,IAAI,CAAC,SAAS,CAAC,oBAAoB,GAAG;YACxC;QACF;QAEA,eAAe;QAEf,eAAe;QACf,IAAI,gBAAgB,KAAK,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE;YACnD,2BAA2B;YAC3B,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI;QACjC;QACA,IAAI,KAAK,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI,OAAO;YACjD,mEAAmE;YACnE,IAAI,cAAc;gBAChB,IAAI,UAAU,CACZ,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY;YAErC,OAAO;gBACL,IAAI,MAAM,CACR,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,YAAY;YAErC;YACA,8DAA8D;YAC9D,sEAAsE;YACtE,wBAAwB;YACxB,IAAI,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,KAAK,GAAG;gBACjC,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,KAAK,GAAG,CAChC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY;gBAElC,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE,IAAI,KAAK,GAAG,CAChC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY;gBAElC,kBAAkB;gBAClB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK;gBAC/E,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;gBAC/D,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,EAAE;YACjE;YACA,UAAU;YACV,IAAI,CAAC,SAAS,CAAC,YAAY,IAAI;QACjC,OAAO;YACL,IAAI,CAAC,SAAS,CAAC,YAAY,GAAG;QAChC;QAEA,iBAAiB;QACjB,IAAI,CAAC,eAAe,KAAK,aAAa,CAAC,KACvC,IAAI,CAAC,SAAS,CAAC,oBAAoB,EAAE;YACnC,6BAA6B;YAC7B,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,CAC/B,aAAa,0BACb,WAAW;QAEf;QACA,IAAI,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,KAAK,KAAK,UAAU;YACpD,+FAA+F;YAC/F,IAAI,cAAc;gBAChB,IAAI,UAAU,CACZ,CAAC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,EAChC,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,EAC/B;YAEJ,OAAO;gBACL,IAAI,MAAM,CACR,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,EAC/B,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC,EAC/B;YAEJ;YACA,UAAU;YACV,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC;QACrC,OAAO;YACL,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG;QACvC;QAEA,eAAe;QACf,IAAI,CAAC,eAAe,KAAK,eAAe,CAAC,KACzC,IAAI,CAAC,SAAS,CAAC,oBAAoB,EAAE;YACnC,8BAA8B;YAC9B,MAAM,OAAO,aAAa,IAAE,IAAI,CAAC,KAAK;YACtC,MAAM,OAAO,CAAC,aAAa,IAAE,IAAI,CAAC,MAAM;YACxC,2BAA2B;YAC3B,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,CAC7B,OAAO,wBACP,OAAO;QAEX;QACA,IAAI,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,KAAK,UAAU;YAClD,uDAAuD;YACvD,6DAA6D;YAC7D,iEAAiE;YACjE,MAAM,QAAQ,IAAI,aAAa;YAE/B,wDAAwD;YACxD,sDAAsD;YACtD,MAAM,QAAQ,IAAI,IAAI,GAAG,IAAI,OAAO;YACpC,MAAM,QAAQ,IAAI,IAAI,GAAG,IAAI,OAAO;YACpC,MAAM,QAAQ,IAAI,IAAI,GAAG,IAAI,OAAO;YACpC,MAAM,QAAQ,KAAK,IAAI,CAAC,QAAQ,QAAQ,QAAQ,QAAQ,QAAQ;YAEhE,iCAAiC;YACjC,IAAI,KAAK,IAAI,4JAAM,CAAC,IAAI,OAAO,EAAE,IAAI,OAAO,EAAE,IAAI,OAAO;YAEzD,6DAA6D;YAC7D,KAAK,IAAI,YAAY,CAAC,aAAa,CAAC;YACpC,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,yBAAyB,CAAC;YAE9D,mCAAmC;YACnC,8CAA8C;YAC9C,GAAG,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;YACrC,GAAG,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;YAErC,mCAAmC;YACnC,iEAAiE;YACjE,IAAI,IAAI;YACR,MAAM,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI;YAE9C,IAAI,EAAE,CAAC,GAAG,KAAK,GAAG;gBAChB,KAAK,AAAC,CAAC,EAAE,CAAC,EAAE,GAAG,GAAG,CAAC,IAAE,EAAE,CAAC,EAAE,GAAI;gBAC9B,KAAK,AAAC,CAAC,EAAE,CAAC,EAAE,GAAG,GAAG,CAAC,IAAE,EAAE,CAAC,EAAE,GAAI;YAChC,OAAO;gBACL,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,IAAE,EAAE,CAAC,EAAE;gBAC1B,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,GAAG,IAAE,EAAE,CAAC,EAAE;YAC5B;YAEA,wBAAwB;YACxB,IAAI,WAAW,CACb,IAAI,IAAI,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,EAC5C,IAAI,IAAI,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,EAC5C,IAAI,IAAI,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE,GAAG,KAAK,MAAM,CAAC,CAAC,EAAE;YAE9C,UAAU;YACV,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC;QACnC,OAAO;YACL,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG;QACrC;QAEA,OAAO,IAAI;IACb;IAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiLC,GAED;;;GAGC,GAED;;;;;;;;GAQC,GAED;;;;;;;GAOC,GAED;;;;;;;;;;;GAWC,GAED,GAAG,SAAS,GAAG,SAAS,GAAG,IAAI;QAC7B,IAAI,CAAC,SAAS,CAAC;QACf,6CAA6C;QAE7C,6DAA6D;QAC7D,IAAK,IAAI,IAAI,IAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YAC/D,uBAAuB;YACvB,IACE,IAAG,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,OAAO,IAAI,CAAC,KAAK,GAAG,QAAQ,MAClE,IAAG,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,OAAO,IAAI,CAAC,SAAS,GAAG,QAAQ,IACtE;gBACA,IAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG;YACvC;QACF;QAEA,kEAAkE;QAClE,IAAI,IAAI,CAAC,EAAE,KAAK,wJAAI,EAAE;YACpB,IAAG,cAAc,CAAC,QAAQ,CAAC,IAAI,CAC7B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;QAE1D,OAAO,IAAI,IAAI,CAAC,EAAE,KAAK,wJAAI,EAAE;YAC3B,IAAG,cAAc,CAAC,QAAQ,CAAC,IAAI,CAC7B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;QAErD,OAAO;YACL,IAAG,cAAc,CAAC,QAAQ,CAAC,IAAI,CAC7B,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;YAExD,IAAG,cAAc,CAAC,QAAQ,CAAC,IAAI,CAC7B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE;QAErD;IACF;IAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqCC,GACD,GAAG,WAAW,GAAG;QACf,IAAI,CAAC,SAAS,CAAC;QAEf,6DAA6D;QAC7D,IAAK,IAAI,IAAI,IAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,IAAK;YAC/D,uBAAuB;YACvB,IACE,IAAG,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,OAAO,IAAI,CAAC,KAAK,GAAG,QAAQ,MAClE,IAAG,cAAc,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,OAAO,IAAI,CAAC,SAAS,GAAG,QAAQ,IACtE;gBACA,IAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,GAAG;YACvC;QACF;IACF;IAEA;;;;;;;;;GASC,GACD,GAAG,KAAK,GAAG,SAAS,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;QACjD,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO,IAAI,CAAC,KAAK,GAAG;QACtB;QACA,IAAI,OAAO,YAAY,aAAa;YAClC,8BAA8B;YAC9B,UAAU,KAAK,KAAK,CAAC,OAAO,MAAM,IAAI,IAAI,KAAK,KAAK,CAAC,OAAO;QAC9D;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO;QACT;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO;QACT;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO;QACT;QAEA,MAAM,UAAU,OAAO;QACvB,MAAM,WAAW,OAAO;QAExB,OAAO;YACL,IAAI,CAAC,IAAI;YACT,IAAI,CAAC,MAAM,CACT,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,GAAG,KAC1C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,GAAG,KAC1C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,EAAE,GAAG;YAE5C,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK;YACvF,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK;YAExC,qBAAqB;YACrB,IAAK,IAAI,IAAI,GAAG,KAAK,SAAS,IAAK;gBACjC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;gBAC1B,IAAI,CAAC,MAAM,CAAC,CAAC,WAAW,MAAM,MAAM,IAAI,UAAU,WAAW;gBAC7D,IAAI,CAAC,MAAM,CAAC,CAAC,WAAW,MAAM,MAAM,IAAI,UAAU,WAAW;gBAC7D,IAAI,CAAC,QAAQ;YACf;YAEA,qBAAqB;YACrB,IAAK,IAAI,IAAI,GAAG,KAAK,SAAS,IAAK;gBACjC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;gBAC1B,IAAI,CAAC,MAAM,CAAC,IAAI,UAAU,WAAW,MAAM,MAAM,CAAC,WAAW;gBAC7D,IAAI,CAAC,MAAM,CAAC,IAAI,UAAU,WAAW,MAAM,MAAM,CAAC,WAAW;gBAC7D,IAAI,CAAC,QAAQ;YACf;YAEA,IAAI,CAAC,GAAG;QACV;IACF;IAEA;;;;;;;;GAQC,GACD,GAAG,SAAS,GAAG,SAAS,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;QAC5C,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO,IAAI,CAAC,KAAK,GAAG,KAAK,KAAK,IAAI,CAAC,KAAK,GAAG,KAAK;QAClD;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO,CAAC,IAAI,CAAC,KAAK,GAAG;QACvB;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO;QACT;QACA,IAAI,OAAO,SAAS,aAAa;YAC/B,OAAO;QACT;QAEA,OAAO;YACL,IAAI,CAAC,IAAI;YACT,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,gBAAgB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK;YACvF,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,YAAY,CAAC,KAAK;YAExC,SAAS;YACT,IAAI,CAAC,YAAY,CAAC;YAClB,IAAI,CAAC,MAAM,CAAC,KAAK,GAAG;YACpB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;YAC1B,IAAI,CAAC,MAAM,CAAC,MAAM,MAAM;YACxB,IAAI,CAAC,MAAM,CAAC,OAAO,MAAM,MAAM;YAC/B,IAAI,CAAC,QAAQ;YACb,SAAS;YACT,IAAI,CAAC,MAAM,CAAC,GAAG,KAAK;YACpB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;YAC1B,IAAI,CAAC,MAAM,CAAC,MAAM,MAAM;YACxB,IAAI,CAAC,MAAM,CAAC,MAAM,OAAO,MAAM;YAC/B,IAAI,CAAC,QAAQ;YACb,SAAS;YACT,IAAI,CAAC,MAAM,CAAC,GAAG,GAAG;YAClB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;YAC1B,IAAI,CAAC,MAAM,CAAC,MAAM,MAAM;YACxB,IAAI,CAAC,MAAM,CAAC,MAAM,MAAM,OAAO;YAC/B,IAAI,CAAC,QAAQ;YACb,IAAI,CAAC,GAAG;QACV;IACF;AACF;AAEA,IAAG,OAAO,OAAO,aAAY;IAC3B,YAAY,IAAI,GAAG,SAAS;AAC9B","ignoreList":[0]}},
    {"offset": {"line": 4242, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/loading.js"],"sourcesContent":["import { Geometry } from './p5.Geometry.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { a as request } from '../rendering-COLWmJqb.js';\nimport '../constants-Bt1VTUeD.js';\nimport './p5.DataArray.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../creating_reading-p2iQtNm5.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-C-tu2oim.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\n\n/**\n * @module Shape\n * @submodule 3D Models\n * @for p5\n * @requires core\n * @requires p5.Geometry\n */\n\n\nasync function fileExists(url) {\n  try {\n    const response = await fetch(url, { method: 'HEAD' });\n    return response.ok;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction loading(p5, fn){\n  /**\n   * Loads a 3D model to create a\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   *\n   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is\n   * loaded, it can be displayed with the\n   * <a href=\"#/p5/model\">model()</a> function, as in `model(shape)`.\n   *\n   * There are three ways to call `loadModel()` with optional parameters to help\n   * process the model.\n   *\n   * The first parameter, `path`, is a `String` with the path to the file. Paths\n   * to local files should be relative, as in `loadModel('assets/model.obj')`.\n   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser\n   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)\n   * object for more advanced usage.\n   * Note: When loading a `.obj` file that references materials stored in\n   * `.mtl` files, p5.js will attempt to load and apply those materials.\n   * To ensure that the `.obj` file reads the `.mtl` file correctly include the\n   * `.mtl` file alongside it.\n   *\n   * The first way to call `loadModel()` has three optional parameters after the\n   * file path. The first optional parameter, `successCallback`, is a function\n   * to call once the model loads. For example,\n   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`\n   * function once the model loads. The second optional parameter,\n   * `failureCallback`, is a function to call if the model fails to load. For\n   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will\n   * call the `handleFailure()` function if an error occurs while loading. The\n   * third optional parameter, `fileType`, is the model’s file extension as a\n   * string. For example,\n   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to\n   * load the file model as a `.obj` file.\n   *\n   * The second way to call `loadModel()` has four optional parameters after the\n   * file path. The first optional parameter is a `Boolean` value. If `true` is\n   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be\n   * resized to ensure it fits the canvas. The next three parameters are\n   * `successCallback`, `failureCallback`, and `fileType` as described above.\n   *\n   * The third way to call `loadModel()` has one optional parameter after the\n   * file path. The optional parameter, `options`, is an `Object` with options,\n   * as in `loadModel('assets/model.obj', options)`. The `options` object can\n   * have the following properties:\n   *\n   * ```js\n   * let options = {\n   *   // Enables standardized size scaling during loading if set to true.\n   *   normalize: true,\n   *\n   *   // Function to call once the model loads.\n   *   successCallback: handleModel,\n   *\n   *   // Function to call if an error occurs while loading.\n   *   failureCallback: handleError,\n   *\n   *   // Model's file extension.\n   *   fileType: '.stl',\n   *\n   *   // Flips the U texture coordinates of the model.\n   *   flipU: false,\n   *\n   *   // Flips the V texture coordinates of the model.\n   *   flipV: false\n   * };\n   *\n   * // Pass the options object to loadModel().\n   * loadModel('assets/model.obj', options);\n   * ```\n   *\n   * This function returns a `Promise` and should be used in an `async` setup with\n   * `await`. See the examples for the usage syntax.\n   *\n   * Note: There’s no support for colored STL files. STL files with color will\n   * be rendered without color.\n   *\n   * @method loadModel\n   * @param  {String|Request} path      path of the model to be loaded.\n   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.\n   * @param  {Boolean} [normalize]        if `true`, scale the model to fit the canvas.\n   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed\n   *                                                   the <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.\n   * @return {Promise<p5.Geometry>} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * // Normalize the geometry's size to fit the canvas.\n   * async function setup() {\n   *   shape = await loadModel('assets/teapot.obj', true);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and log the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div class='notest'>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   * let options = {\n   *   fileType: '.obj',\n   *   normalize: true,\n   *   successCallback: handleModel,\n   *   failureCallback: handleError\n   * };\n   *\n   * // Load the file and create a p5.Geometry object.\n   * async function setup() {\n   *   await loadModel('assets/teapot.obj', options);\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white teapot drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   *\n   * // Set the shape variable and print the geometry's\n   * // ID to the console.\n   * function handleModel(data) {\n   *   shape = data;\n   *   console.log(shape.gid);\n   * }\n   *\n   * // Print an error message if the file doesn't load.\n   * function handleError(error) {\n   *   console.error('Oops!', error);\n   * }\n   * </code>\n   * </div>\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  /**\n   * @method loadModel\n   * @param  {String|Request} path\n   * @param  {Object} [options] loading options.\n   * @param  {String} [options.fileType]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {Boolean} [options.normalize]\n   * @param  {Boolean} [options.flipU]\n   * @param  {Boolean} [options.flipV]\n   * @return {Promise<p5.Geometry>} new <a href=\"#/p5.Geometry\">p5.Geometry</a> object.\n   */\n  fn.loadModel = async function (\n    path,\n    fileType,\n    normalize,\n    successCallback,\n    failureCallback\n  ) {\n    // p5._validateParameters('loadModel', arguments);\n\n    let flipU = false;\n    let flipV = false;\n\n    if (typeof fileType === 'object') {\n      // Passing in options object\n      normalize = fileType.normalize || false;\n      successCallback = fileType.successCallback;\n      failureCallback = fileType.failureCallback;\n      fileType = fileType.fileType || fileType;\n      flipU = fileType.flipU || false;\n      flipV = fileType.flipV || false;\n\n    } else {\n      // Passing in individual parameters\n      if(typeof arguments[arguments.length-1] === 'function'){\n        if(typeof arguments[arguments.length-2] === 'function'){\n          successCallback = arguments[arguments.length-2];\n          failureCallback = arguments[arguments.length-1];\n        }else {\n          successCallback = arguments[arguments.length-1];\n        }\n      }\n\n      if (typeof fileType === 'string') {\n        if(typeof normalize !== 'boolean') normalize = false;\n\n      } else if (typeof fileType === 'boolean') {\n        normalize = fileType;\n        fileType = path.slice(-4);\n\n      } else {\n        fileType = path.slice(-4);\n        normalize = false;\n      }\n    }\n\n    if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {\n      fileType = '.obj';\n    }\n\n    const model = new Geometry(undefined, undefined, undefined, this._renderer);\n    model.gid = `${path}|${normalize}`;\n\n    async function getMaterials(lines) {\n      const parsedMaterialPromises = [];\n\n      for (let line of lines) {\n        const mtllibMatch = line.match(/^mtllib (.+)/);\n\n        if (mtllibMatch) {\n          // Object has material\n          let mtlPath = '';\n          const mtlFilename = mtllibMatch[1];\n          const objPathParts = path.split('/');\n          if (objPathParts.length > 1) {\n            objPathParts.pop();\n            const objFolderPath = objPathParts.join('/');\n            mtlPath = objFolderPath + '/' + mtlFilename;\n          } else {\n            mtlPath = mtlFilename;\n          }\n\n          parsedMaterialPromises.push(\n            fileExists(mtlPath).then(exists => {\n              if (exists) {\n                return parseMtl(mtlPath);\n              } else {\n                console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);\n                return {};\n\n              }\n            }).catch(error => {\n              console.warn(`Error loading MTL file: ${mtlPath}`, error);\n              return {};\n            })\n          );\n        }\n      }\n\n      try {\n        const parsedMaterials = await Promise.all(parsedMaterialPromises);\n        const materials = Object.assign({}, ...parsedMaterials);\n        return materials;\n      } catch (error) {\n        return {};\n      }\n    }\n\n    try{\n      if (fileType.match(/\\.stl$/i)) {\n        const { data } = await request(path, 'arrayBuffer');\n        parseSTL(model, data);\n\n        if (normalize) {\n          model.normalize();\n        }\n\n        if (flipU) {\n          model.flipU();\n        }\n\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n\n      } else if (fileType.match(/\\.obj$/i)) {\n        const { data } = await request(path, 'text');\n        const lines = data.split('\\n');\n\n        const parsedMaterials = await getMaterials(lines);\n        parseObj(model, lines, parsedMaterials);\n\n        if (normalize) {\n          model.normalize();\n        }\n        if (flipU) {\n          model.flipU();\n        }\n        if (flipV) {\n          model.flipV();\n        }\n        model._makeTriangleEdges();\n\n        if (successCallback) {\n          return successCallback(model);\n        } else {\n          return model;\n        }\n      }\n    } catch(err) {\n      p5._friendlyFileLoadError(3, path);\n      if(failureCallback) {\n        return failureCallback(err);\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  async function parseMtl(mtlPath) {\n    let currentMaterial = null;\n    let materials = {};\n\n    const { data } = await request(mtlPath, 'text');\n    const lines = data.split('\\n');\n\n    for (let line = 0; line < lines.length; ++line) {\n      const tokens = lines[line].trim().split(/\\s+/);\n      if (tokens[0] === 'newmtl') {\n        const materialName = tokens[1];\n        currentMaterial = materialName;\n        materials[currentMaterial] = {};\n      } else if (tokens[0] === 'Kd') {\n        //Diffuse color\n        materials[currentMaterial].diffuseColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ka') {\n        //Ambient Color\n        materials[currentMaterial].ambientColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n      } else if (tokens[0] === 'Ks') {\n        //Specular color\n        materials[currentMaterial].specularColor = [\n          parseFloat(tokens[1]),\n          parseFloat(tokens[2]),\n          parseFloat(tokens[3])\n        ];\n\n      } else if (tokens[0] === 'map_Kd') {\n        //Texture path\n        materials[currentMaterial].texturePath = tokens[1];\n      }\n    }\n\n    return materials;\n  }\n\n  /**\n   * @private\n   * Parse OBJ lines into model. For reference, this is what a simple model of a\n   * square might look like:\n   *\n   * v -0.5 -0.5 0.5\n   * v -0.5 -0.5 -0.5\n   * v -0.5 0.5 -0.5\n   * v -0.5 0.5 0.5\n   *\n   * f 4 3 2 1\n   */\n  function parseObj(model, lines, materials = {}) {\n    // OBJ allows a face to specify an index for a vertex (in the above example),\n    // but it also allows you to specify a custom combination of vertex, UV\n    // coordinate, and vertex normal. So, \"3/4/3\" would mean, \"use vertex 3 with\n    // UV coordinate 4 and vertex normal 3\". In WebGL, every vertex with different\n    // parameters must be a different vertex, so loadedVerts is used to\n    // temporarily store the parsed vertices, normals, etc., and indexedVerts is\n    // used to map a specific combination (keyed on, for example, the string\n    // \"3/4/3\"), to the actual index of the newly created vertex in the final\n    // object.\n    const loadedVerts = {\n      v: [],\n      vt: [],\n      vn: []\n    };\n\n\n    // Map from source index → Map of material → destination index\n    const usedVerts = {}; // Track colored vertices\n    let currentMaterial = null;\n    let hasColoredVertices = false;\n    let hasColorlessVertices = false;\n    for (let line = 0; line < lines.length; ++line) {\n      // Each line is a separate object (vertex, face, vertex normal, etc)\n      // For each line, split it into tokens on whitespace. The first token\n      // describes the type.\n      const tokens = lines[line].trim().split(/\\b\\s+/);\n\n      if (tokens.length > 0) {\n        if (tokens[0] === 'usemtl') {\n          // Switch to a new material\n          currentMaterial = tokens[1];\n        } else if (tokens[0] === 'v' || tokens[0] === 'vn') {\n          // Check if this line describes a vertex or vertex normal.\n          // It will have three numeric parameters.\n          const vertex = new Vector(\n            parseFloat(tokens[1]),\n            parseFloat(tokens[2]),\n            parseFloat(tokens[3])\n          );\n          loadedVerts[tokens[0]].push(vertex);\n        } else if (tokens[0] === 'vt') {\n          // Check if this line describes a texture coordinate.\n          // It will have two numeric parameters U and V (W is omitted).\n          // Because of WebGL texture coordinates rendering behaviour, the V\n          // coordinate is inversed.\n          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];\n          loadedVerts[tokens[0]].push(texVertex);\n        } else if (tokens[0] === 'f') {\n          // Check if this line describes a face.\n          // OBJ faces can have more than three points. Triangulate points.\n          for (let tri = 3; tri < tokens.length; ++tri) {\n            const face = [];\n            const vertexTokens = [1, tri - 1, tri];\n\n            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {\n              // Now, convert the given token into an index\n              const vertString = tokens[vertexTokens[tokenInd]];\n              let vertParts = vertString.split('/');\n\n              // TODO: Faces can technically use negative numbers to refer to the\n              // previous nth vertex. I haven't seen this used in practice, but\n              // it might be good to implement this in the future.\n\n              for (let i = 0; i < vertParts.length; i++) {\n                vertParts[i] = parseInt(vertParts[i]) - 1;\n              }\n\n              if (!usedVerts[vertString]) {\n                usedVerts[vertString] = {};\n              }\n\n              if (usedVerts[vertString][currentMaterial] === undefined) {\n                const vertIndex = model.vertices.length;\n                model.vertices.push(loadedVerts.v[vertParts[0]].copy());\n                model.uvs.push(loadedVerts.vt[vertParts[1]] ?\n                  loadedVerts.vt[vertParts[1]].slice() : [0, 0]);\n                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ?\n                  loadedVerts.vn[vertParts[2]].copy() : new Vector());\n\n                usedVerts[vertString][currentMaterial] = vertIndex;\n                face.push(vertIndex);\n                if (currentMaterial\n                  && materials[currentMaterial]\n                  && materials[currentMaterial].diffuseColor) {\n                  hasColoredVertices = true;\n                  const materialDiffuseColor =\n                    materials[currentMaterial].diffuseColor;\n                  model.vertexColors.push(materialDiffuseColor[0]);\n                  model.vertexColors.push(materialDiffuseColor[1]);\n                  model.vertexColors.push(materialDiffuseColor[2]);\n                  model.vertexColors.push(1);\n                } else {\n                  hasColorlessVertices = true;\n                }\n              } else {\n                face.push(usedVerts[vertString][currentMaterial]);\n              }\n            }\n\n            if (\n              face[0] !== face[1] &&\n              face[0] !== face[2] &&\n              face[1] !== face[2]\n            ) {\n              model.faces.push(face);\n            }\n          }\n        }\n      }\n    }\n    // If the model doesn't have normals, compute the normals\n    if (model.vertexNormals.length === 0) {\n      model.computeNormals();\n    }\n    if (hasColoredVertices === hasColorlessVertices) {\n      // If both are true or both are false, throw an error because the model is inconsistent\n      throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');\n    }\n\n    return model;\n  }\n\n  /**\n   * @private\n   * STL files can be of two types, ASCII and Binary,\n   *\n   * We need to convert the arrayBuffer to an array of strings,\n   * to parse it as an ASCII file.\n   */\n  function parseSTL(model, buffer) {\n    if (isBinary(buffer)) {\n      parseBinarySTL(model, buffer);\n    } else {\n      const reader = new DataView(buffer);\n\n      if (!('TextDecoder' in window)) {\n        console.warn(\n          'Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)'\n        );\n        return model;\n      }\n\n      const decoder = new TextDecoder('utf-8');\n      const lines = decoder.decode(reader);\n      const lineArray = lines.split('\\n');\n      parseASCIISTL(model, lineArray);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * This function checks if the file is in ASCII format or in Binary format\n   *\n   * It is done by searching keyword `solid` at the start of the file.\n   *\n   * An ASCII STL data must begin with `solid` as the first six bytes.\n   * However, ASCII STLs lacking the SPACE after the `d` are known to be\n   * plentiful. So, check the first 5 bytes for `solid`.\n   *\n   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n   * Search for `solid` to start anywhere after those prefixes.\n   */\n  function isBinary(data) {\n    const reader = new DataView(data);\n\n    // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`\n    const solid = [115, 111, 108, 105, 100];\n    for (let off = 0; off < 5; off++) {\n      // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n      if (matchDataViewAt(solid, reader, off)) return false;\n    }\n\n    // Couldn't find \"solid\" text at the beginning; it is binary STL.\n    return true;\n  }\n\n  /**\n   * @private\n   * This function matches the `query` at the provided `offset`\n   */\n  function matchDataViewAt(query, reader, offset) {\n    // Check if each byte in query matches the corresponding byte from the current offset\n    for (let i = 0, il = query.length; i < il; i++) {\n      if (query[i] !== reader.getUint8(offset + i, false)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * @private\n   * This function parses the Binary STL files.\n   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL\n   *\n   * Currently there is no support for the colors provided in STL files.\n   */\n  function parseBinarySTL(model, buffer) {\n    const reader = new DataView(buffer);\n\n    // Number of faces is present following the header\n    const faces = reader.getUint32(80, true);\n    let r,\n      g,\n      b,\n      hasColors = false,\n      colors;\n    let defaultR, defaultG, defaultB;\n\n    // Binary files contain 80-byte header, which is generally ignored.\n    for (let index = 0; index < 80 - 10; index++) {\n      // Check for `COLOR=`\n      if (\n        reader.getUint32(index, false) === 0x434f4c4f /*COLO*/ &&\n        reader.getUint8(index + 4) === 0x52 /*'R'*/ &&\n        reader.getUint8(index + 5) === 0x3d /*'='*/\n      ) {\n        hasColors = true;\n        colors = [];\n\n        defaultR = reader.getUint8(index + 6) / 255;\n        defaultG = reader.getUint8(index + 7) / 255;\n        defaultB = reader.getUint8(index + 8) / 255;\n        // To be used when color support is added\n        // alpha = reader.getUint8(index + 9) / 255;\n      }\n    }\n    const dataOffset = 84;\n    const faceLength = 12 * 4 + 2;\n\n    // Iterate the faces\n    for (let face = 0; face < faces; face++) {\n      const start = dataOffset + face * faceLength;\n      const normalX = reader.getFloat32(start, true);\n      const normalY = reader.getFloat32(start + 4, true);\n      const normalZ = reader.getFloat32(start + 8, true);\n\n      if (hasColors) {\n        const packedColor = reader.getUint16(start + 48, true);\n\n        if ((packedColor & 0x8000) === 0) {\n          // facet has its own unique color\n          r = (packedColor & 0x1f) / 31;\n          g = ((packedColor >> 5) & 0x1f) / 31;\n          b = ((packedColor >> 10) & 0x1f) / 31;\n        } else {\n          r = defaultR;\n          g = defaultG;\n          b = defaultB;\n        }\n      }\n      const newNormal = new Vector(normalX, normalY, normalZ);\n\n      for (let i = 1; i <= 3; i++) {\n        const vertexstart = start + i * 12;\n\n        const newVertex = new Vector(\n          reader.getFloat32(vertexstart, true),\n          reader.getFloat32(vertexstart + 4, true),\n          reader.getFloat32(vertexstart + 8, true)\n        );\n\n        model.vertices.push(newVertex);\n        model.vertexNormals.push(newNormal);\n\n        if (hasColors) {\n          colors.push(r, g, b);\n        }\n      }\n\n      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);\n      model.uvs.push([0, 0], [0, 0], [0, 0]);\n    }\n    return model;\n  }\n\n  /**\n   * @private\n   * ASCII STL file starts with `solid 'nameOfFile'`\n   * Then contain the normal of the face, starting with `facet normal`\n   * Next contain a keyword indicating the start of face vertex, `outer loop`\n   * Next comes the three vertex, starting with `vertex x y z`\n   * Vertices ends with `endloop`\n   * Face ends with `endfacet`\n   * Next face starts with `facet normal`\n   * The end of the file is indicated by `endsolid`\n   */\n  function parseASCIISTL(model, lines) {\n    let state = '';\n    let curVertexIndex = [];\n    let newNormal, newVertex;\n\n    for (let iterator = 0; iterator < lines.length; ++iterator) {\n      const line = lines[iterator].trim();\n      const parts = line.split(' ');\n\n      for (\n        let partsiterator = 0;\n        partsiterator < parts.length;\n        ++partsiterator\n      ) {\n        if (parts[partsiterator] === '') {\n          // Ignoring multiple whitespaces\n          parts.splice(partsiterator, 1);\n        }\n      }\n\n      if (parts.length === 0) {\n        // Remove newline\n        continue;\n      }\n\n      switch (state) {\n        case '': // First run\n          if (parts[0] !== 'solid') {\n            // Invalid state\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"solid\"`);\n            return;\n          } else {\n            state = 'solid';\n          }\n          break;\n\n        case 'solid': // First face\n          if (parts[0] !== 'facet' || parts[1] !== 'normal') {\n            // Invalid state\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"facet normal\"`\n            );\n            return;\n          } else {\n            // Push normal for first face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          }\n          break;\n\n        case 'facet normal': // After normal is defined\n          if (parts[0] !== 'outer' || parts[1] !== 'loop') {\n            // Invalid State\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"outer loop\"`);\n            return;\n          } else {\n            // Next should be vertices\n            state = 'vertex';\n          }\n          break;\n\n        case 'vertex':\n          if (parts[0] === 'vertex') {\n            //Vertex of triangle\n            newVertex = new Vector(\n              parseFloat(parts[1]),\n              parseFloat(parts[2]),\n              parseFloat(parts[3])\n            );\n            model.vertices.push(newVertex);\n            model.uvs.push([0, 0]);\n            curVertexIndex.push(model.vertices.indexOf(newVertex));\n          } else if (parts[0] === 'endloop') {\n            // End of vertices\n            model.faces.push(curVertexIndex);\n            curVertexIndex = [];\n            state = 'endloop';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]}\", should be \"vertex\" or \"endloop\"`\n            );\n            return;\n          }\n          break;\n\n        case 'endloop':\n          if (parts[0] !== 'endfacet') {\n            // End of face\n            console.error(line);\n            console.error(`Invalid state \"${parts[0]}\", should be \"endfacet\"`);\n            return;\n          } else {\n            state = 'endfacet';\n          }\n          break;\n\n        case 'endfacet':\n          if (parts[0] === 'endsolid') ; else if (parts[0] === 'facet' && parts[1] === 'normal') {\n            // Next face\n            newNormal = new Vector(\n              parseFloat(parts[2]),\n              parseFloat(parts[3]),\n              parseFloat(parts[4])\n            );\n            model.vertexNormals.push(newNormal, newNormal, newNormal);\n            state = 'facet normal';\n          } else {\n            // Invalid State\n            console.error(line);\n            console.error(\n              `Invalid state \"${parts[0]\n              }\", should be \"endsolid\" or \"facet normal\"`\n            );\n            return;\n          }\n          break;\n\n        default:\n          console.error(`Invalid state \"${state}\"`);\n          break;\n      }\n    }\n    return model;\n  }\n\n  /**\n   * Draws a <a href=\"#/p5.Geometry\">p5.Geometry</a> object to the canvas.\n   *\n   * The parameter, `model`, is the\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> object to draw.\n   * <a href=\"#/p5.Geometry\">p5.Geometry</a> objects can be built with\n   * <a href=\"#/p5/buildGeometry\">buildGeometry()</a>, or\n   * <a href=\"#/p5/beginGeometry\">beginGeometry()</a> and\n   * <a href=\"#/p5/endGeometry\">endGeometry()</a>. They can also be loaded from\n   * a file with <a href=\"#/p5/loadGeometry\">loadGeometry()</a>.\n   *\n   * Note: `model()` can only be used in WebGL mode.\n   *\n   * @method model\n   * @param  {p5.Geometry} model 3D shape to be drawn.\n   *\n   * @param {Number} [count=1] number of instances to draw.\n   * @example\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createShape);\n   *\n   *   describe('A white cone drawn on a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   * }\n   *\n   * // Create p5.Geometry object from a single cone.\n   * function createShape() {\n   *   cone();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   // Create the p5.Geometry object.\n   *   shape = buildGeometry(createArrow);\n   *\n   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');\n   * }\n   *\n   * function draw() {\n   *   background(50);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Turn on the lights.\n   *   lights();\n   *\n   *   // Style the arrows.\n   *   noStroke();\n   *\n   *   // Draw the p5.Geometry object.\n   *   model(shape);\n   *\n   *   // Translate and rotate the coordinate system.\n   *   translate(30, 0, 0);\n   *   rotateZ(frameCount * 0.01);\n   *\n   *   // Draw the p5.Geometry object again.\n   *   model(shape);\n   * }\n   *\n   * function createArrow() {\n   *   // Add shapes to the p5.Geometry object.\n   *   push();\n   *   rotateX(PI);\n   *   cone(10);\n   *   translate(0, -10, 0);\n   *   cylinder(3, 20);\n   *   pop();\n   * }\n   * </code>\n   * </div>\n   *\n   * <div>\n   * <code>\n   * // Click and drag the mouse to view the scene from different angles.\n   *\n   * let shape;\n   *\n   * async function setup() {\n   *   shape = await loadModel('assets/octahedron.obj');\n   *\n   *   createCanvas(100, 100, WEBGL);\n   *\n   *   describe('A white octahedron drawn against a gray background.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *\n   *   // Enable orbiting with the mouse.\n   *   orbitControl();\n   *\n   *   // Draw the shape.\n   *   model(shape);\n   * }\n   * </code>\n   * </div>\n   */\n  fn.model = function (model, count = 1) {\n    this._assert3d('model');\n    // p5._validateParameters('model', arguments);\n    this._renderer.model(model, count);\n  };\n\n  /**\n   * Load a 3d model from an OBJ or STL string.\n   *\n   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.\n   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.\n   * Further adjustments can be made using the `scale()` function.\n   *\n   * Also, the support for colored STL files is not present. STL files with color will be\n   * rendered without color properties.\n   *\n   * * Options can include:\n   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.\n   * - `fileType`: Defines the file extension of the model.\n   * - `normalize`: Enables standardized size scaling during loading if set to true.\n   * - `successCallback`: Callback for post-loading actions with the 3D model object.\n   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.\n   * - `flipU`: Flips the U texture coordinates of the model.\n   * - `flipV`: Flips the V texture coordinates of the model.\n   *\n   *\n   * @method createModel\n   * @param  {String} modelString         String of the object to be loaded\n   * @param  {String} [fileType]          The file extension of the model\n   *                                      (<code>.stl</code>, <code>.obj</code>).\n   * @param  {Boolean} [normalize]        If true, scale the model to a\n   *                                      standardized size when loading\n   * @param  {function(p5.Geometry)} [successCallback] Function to be called\n   *                                     once the model is loaded. Will be passed\n   *                                     the 3D model object.\n   * @param  {function(Event)} [failureCallback] called with event error if\n   *                                         the model fails to load.\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   *\n   * @example\n   * <div>\n   * <code>\n   * const octahedron_model = `\n   * v 0.000000E+00 0.000000E+00 40.0000\n   * v 22.5000 22.5000 0.000000E+00\n   * v 22.5000 -22.5000 0.000000E+00\n   * v -22.5000 -22.5000 0.000000E+00\n   * v -22.5000 22.5000 0.000000E+00\n   * v 0.000000E+00 0.000000E+00 -40.0000\n   * f     1 2 3\n   * f     1 3 4\n   * f     1 4 5\n   * f     1 5 2\n   * f     6 5 4\n   * f     6 4 3\n   * f     6 3 2\n   * f     6 2 5\n   * `;\n   * //draw a spinning octahedron\n   * let octahedron;\n   *\n   * function setup() {\n   *   createCanvas(100, 100, WEBGL);\n   *   octahedron = createModel(octahedron_model, '.obj');\n   *   describe('Vertically rotating 3D octahedron.');\n   * }\n   *\n   * function draw() {\n   *   background(200);\n   *   rotateX(frameCount * 0.01);\n   *   rotateY(frameCount * 0.01);\n   *   model(octahedron);\n   *}\n   * </code>\n   * </div>\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {function(p5.Geometry)} [successCallback]\n   * @param  {function(Event)} [failureCallback]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  /**\n   * @method createModel\n   * @param  {String} modelString\n   * @param  {String} [fileType]\n   * @param  {Object} [options]\n   * @param  {function(p5.Geometry)} [options.successCallback]\n   * @param  {function(Event)} [options.failureCallback]\n   * @param  {boolean} [options.normalize]\n   * @param  {boolean} [options.flipU]\n   * @param  {boolean} [options.flipV]\n   * @return {p5.Geometry} the <a href=\"#/p5.Geometry\">p5.Geometry</a> object\n   */\n  let modelCounter = 0;\n  fn.createModel = function(modelString, fileType=' ', options) {\n    // p5._validateParameters('createModel', arguments);\n    let normalize= false;\n    let successCallback;\n    let failureCallback;\n    let flipU = false;\n    let flipV = false;\n    if (options && typeof options === 'object') {\n      normalize = options.normalize || false;\n      successCallback = options.successCallback;\n      failureCallback = options.failureCallback;\n      flipU = options.flipU || false;\n      flipV = options.flipV || false;\n    } else if (typeof options === 'boolean') {\n      normalize = options;\n      successCallback = arguments[3];\n      failureCallback = arguments[4];\n    } else {\n      successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;\n      failureCallback = arguments[3];\n    }\n    const model = new p5.Geometry();\n    model.gid = `${fileType}|${normalize}|${modelCounter++}`;\n\n    if (fileType.match(/\\.stl$/i)) {\n      try {\n        let uint8array = new TextEncoder().encode(modelString);\n        let arrayBuffer = uint8array.buffer;\n        parseSTL(model, arrayBuffer);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else if (fileType.match(/\\.obj$/i)) {\n      try {\n        const lines = modelString.split('\\n');\n        parseObj(model, lines);\n      } catch (error) {\n        if (failureCallback) {\n          failureCallback(error);\n        } else {\n          p5._friendlyError('Error during parsing: ' + error.message);\n        }\n        return;\n      }\n    } else {\n      p5._friendlyFileLoadError(3, modelString);\n      if (failureCallback) {\n        failureCallback();\n      } else {\n        p5._friendlyError(\n          'Sorry, the file type is invalid. Only OBJ and STL files are supported.'\n        );\n      }\n    }\n    if (normalize) {\n      model.normalize();\n    }\n\n    if (flipU) {\n      model.flipU();\n    }\n\n    if (flipV) {\n      model.flipV();\n    }\n\n    model._makeTriangleEdges();\n\n    if (typeof successCallback === 'function') {\n      successCallback(model);\n    }\n\n    return model;\n  };\n}\n\nif(typeof p5 !== 'undefined'){\n  loading(p5, p5.prototype);\n}\n\nexport { loading as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5488, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/text.js"],"sourcesContent":["import { T as TEXTURE } from '../constants-Bt1VTUeD.js';\nimport { R as RendererGL } from '../rendering-COLWmJqb.js';\nimport { Vector } from '../math/p5.Vector.js';\nimport { Geometry } from './p5.Geometry.js';\nimport { Font, arrayCommandsToObjects } from '../type/p5.Font.js';\nimport '../creating_reading-p2iQtNm5.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-C-tu2oim.js';\nimport '../image/filters.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/p5.Matrix.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './p5.Quat.js';\nimport './p5.RenderBuffer.js';\nimport './p5.DataArray.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\n\nfunction text(p5, fn) {\n  RendererGL.prototype.maxCachedGlyphs = function() {\n    // TODO: use more than vibes to find a good value for this\n    return 200;\n  };\n\n  Font.prototype._getFontInfo = function(axs) {\n    // For WebGL, a cache of font data to use on the GPU.\n    this._fontInfos = this._fontInfos || {};\n\n    const key = JSON.stringify(axs);\n    if (this._fontInfos[key]) {\n      const val = this._fontInfos[key];\n      return val;\n    } else {\n      const val = new FontInfo(this, { axs });\n      this._fontInfos[key] = val;\n      return val;\n    }\n  };\n\n  // Text/Typography (see src/type/textCore.js)\n  /*\n  RendererGL.prototype.textWidth = function(s) {\n    if (this._isOpenType()) {\n      return this.states.textFont.font._textWidth(s, this.states.textSize);\n    }\n\n    return 0; // TODO: error\n  };\n  */\n\n  // rendering constants\n\n  // the number of rows/columns dividing each glyph\n  const charGridWidth = 9;\n  const charGridHeight = charGridWidth;\n\n  // size of the image holding the bezier stroke info\n  const strokeImageWidth = 64;\n  const strokeImageHeight = 64;\n\n  // size of the image holding the stroke indices for each row/col\n  const gridImageWidth = 64;\n  const gridImageHeight = 64;\n\n  // size of the image holding the offset/length of each row/col stripe\n  const cellImageWidth = 64;\n  const cellImageHeight = 64;\n\n  /**\n   * @private\n   * @class ImageInfos\n   * @param {Integer} width\n   * @param {Integer} height\n   *\n   * the ImageInfos class holds a list of ImageDatas of a given size.\n   */\n  class ImageInfos {\n    constructor(width, height) {\n      this.width = width;\n      this.height = height;\n      this.infos = []; // the list of images\n    }\n    /**\n     *\n     * @param {Integer} space\n     * @return {Object} contains the ImageData, and pixel index into that\n     *                  ImageData where the free space was allocated.\n     *\n     * finds free space of a given size in the ImageData list\n     */\n    findImage(space) {\n      const imageSize = this.width * this.height;\n      if (space > imageSize)\n        throw new Error('font is too complex to render in 3D');\n\n      // search through the list of images, looking for one with\n      // anough unused space.\n      let imageInfo, imageData;\n      for (let ii = this.infos.length - 1; ii >= 0; --ii) {\n        const imageInfoTest = this.infos[ii];\n        if (imageInfoTest.index + space < imageSize) {\n          // found one\n          imageInfo = imageInfoTest;\n          imageData = imageInfoTest.imageData;\n          break;\n        }\n      }\n\n      if (!imageInfo) {\n        try {\n          // create a new image\n          imageData = new ImageData(this.width, this.height);\n        } catch (err) {\n          // for browsers that don't support ImageData constructors (ie IE11)\n          // create an ImageData using the old method\n          let canvas = document.getElementsByTagName('canvas')[0];\n          const created = !canvas;\n          if (!canvas) {\n            // create a temporary canvas\n            canvas = document.createElement('canvas');\n            canvas.style.display = 'none';\n            document.body.appendChild(canvas);\n          }\n          const ctx = canvas.getContext('2d');\n          if (ctx) {\n            imageData = ctx.createImageData(this.width, this.height);\n          }\n          if (created) {\n            // distroy the temporary canvas, if necessary\n            document.body.removeChild(canvas);\n          }\n        }\n        // construct & dd the new image info\n        imageInfo = { index: 0, imageData };\n        this.infos.push(imageInfo);\n      }\n\n      const index = imageInfo.index;\n      imageInfo.index += space; // move to the start of the next image\n      imageData._dirty = true;\n      return { imageData, index };\n    }\n  }\n\n  /**\n   * @function setPixel\n   * @private\n   * @param {Object} imageInfo\n   * @param {Number} r\n   * @param {Number} g\n   * @param {Number} b\n   * @param {Number} a\n   *\n   * writes the next pixel into an indexed ImageData\n   */\n  function setPixel(imageInfo, r, g, b, a) {\n    const imageData = imageInfo.imageData;\n    const pixels = imageData.data;\n    let index = imageInfo.index++ * 4;\n    pixels[index++] = r;\n    pixels[index++] = g;\n    pixels[index++] = b;\n    pixels[index++] = a;\n  }\n\n  const SQRT3 = Math.sqrt(3);\n\n  /**\n   * @private\n   * @class FontInfo\n   * @param {Object} font an opentype.js font object\n   *\n   * contains cached images and glyph information for an opentype font\n   */\n  class FontInfo {\n    constructor(font, { axs } = {}) {\n      this.font = font;\n      this.axs = axs;\n      // the bezier curve coordinates\n      this.strokeImageInfos = new ImageInfos(\n        strokeImageWidth,\n        strokeImageHeight\n      );\n      // lists of curve indices for each row/column slice\n      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);\n      // the offset & length of each row/col slice in the glyph\n      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);\n\n      // the cached information for each glyph\n      this.glyphInfos = {};\n    }\n    /**\n     * @param {Glyph} glyph the x positions of points in the curve\n     * @returns {Object} the glyphInfo for that glyph\n     *\n     * calculates rendering info for a glyph, including the curve information,\n     * row & column stripes compiled into textures.\n     */\n    getGlyphInfo(glyph) {\n      // check the cache\n      let gi = this.glyphInfos[glyph.index];\n      if (gi) return gi;\n\n      const axs = this.axs;\n      const {\n        glyph: {\n          path: { commands }\n        }\n      } = this.font._singleShapeToPath(glyph.shape, { axs });\n      let xMin = Infinity;\n      let xMax = -Infinity;\n      let yMin = Infinity;\n      let yMax = -Infinity;\n\n      for (const cmd of commands) {\n        for (let i = 1; i < cmd.length; i += 2) {\n          xMin = Math.min(xMin, cmd[i]);\n          xMax = Math.max(xMax, cmd[i]);\n          yMin = Math.min(yMin, cmd[i + 1]);\n          yMax = Math.max(yMax, cmd[i + 1]);\n        }\n      }\n\n      // don't bother rendering invisible glyphs\n      if (xMin >= xMax || yMin >= yMax || !commands.length) {\n        return (this.glyphInfos[glyph.index] = {});\n      }\n\n      const gWidth = xMax - xMin;\n      const gHeight = yMax - yMin;\n\n      // Convert arrays to named objects\n      const cmds = arrayCommandsToObjects(commands);\n\n      let i;\n      const strokes = []; // the strokes in this glyph\n      const rows = []; // the indices of strokes in each row\n      const cols = []; // the indices of strokes in each column\n      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);\n      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);\n\n      /**\n       * @function push\n       * @private\n       * @param {Number[]} xs the x positions of points in the curve\n       * @param {Number[]} ys the y positions of points in the curve\n       * @param {Object} v    the curve information\n       *\n       * adds a curve to the rows & columns that it intersects with\n       */\n      function push(xs, ys, v) {\n        const index = strokes.length; // the index of this stroke\n        strokes.push(v); // add this stroke to the list\n\n        /**\n         * @function minMax\n         * @private\n         * @param {Number[]} rg the list of values to compare\n         * @param {Number} min the initial minimum value\n         * @param {Number} max the initial maximum value\n         *\n         * find the minimum & maximum value in a list of values\n         */\n        function minMax(rg, min, max) {\n          for (let i = rg.length; i-- > 0; ) {\n            const v = rg[i];\n            if (min > v) min = v;\n            if (max < v) max = v;\n          }\n          return { min, max };\n        }\n\n        // Expand the bounding box of the glyph by the number of cells below\n        // before rounding. Curves only partially through a cell won't be added\n        // to adjacent cells, but ones that are close will be. This helps fix\n        // small visual glitches that occur when curves are close to grid cell\n        // boundaries.\n        const cellOffset = 0.5;\n\n        // loop through the rows & columns that the curve intersects\n        // adding the curve to those slices\n        const mmX = minMax(xs, 1, 0);\n        const ixMin = Math.max(\n          Math.floor(mmX.min * charGridWidth - cellOffset),\n          0\n        );\n        const ixMax = Math.min(\n          Math.ceil(mmX.max * charGridWidth + cellOffset),\n          charGridWidth\n        );\n        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);\n\n        const mmY = minMax(ys, 1, 0);\n        const iyMin = Math.max(\n          Math.floor(mmY.min * charGridHeight - cellOffset),\n          0\n        );\n        const iyMax = Math.min(\n          Math.ceil(mmY.max * charGridHeight + cellOffset),\n          charGridHeight\n        );\n        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);\n      }\n\n      /**\n       * @function clamp\n       * @private\n       * @param {Number} v the value to clamp\n       * @param {Number} min the minimum value\n       * @param {Number} max the maxmimum value\n       *\n       * clamps a value between a minimum & maximum value\n       */\n      function clamp(v, min, max) {\n        if (v < min) return min;\n        if (v > max) return max;\n        return v;\n      }\n\n      /**\n       * @function byte\n       * @private\n       * @param {Number} v the value to scale\n       *\n       * converts a floating-point number in the range 0-1 to a byte 0-255\n       */\n      function byte(v) {\n        return clamp(255 * v, 0, 255);\n      }\n\n      /**\n       * @private\n       * @class Cubic\n       * @param {Number} p0 the start point of the curve\n       * @param {Number} c0 the first control point\n       * @param {Number} c1 the second control point\n       * @param {Number} p1 the end point\n       *\n       * a cubic curve\n       */\n      class Cubic {\n        constructor(p0, c0, c1, p1) {\n          this.p0 = p0;\n          this.c0 = c0;\n          this.c1 = c1;\n          this.p1 = p1;\n        }\n        /**\n         * @return {Object} the quadratic approximation\n         *\n         * converts the cubic to a quadtratic approximation by\n         * picking an appropriate quadratic control point\n         */\n        toQuadratic() {\n          return {\n            x: this.p0.x,\n            y: this.p0.y,\n            x1: this.p1.x,\n            y1: this.p1.y,\n            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,\n            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4\n          };\n        }\n\n        /**\n         * @return {Number} the error\n         *\n         * calculates the magnitude of error of this curve's\n         * quadratic approximation.\n         */\n        quadError() {\n          return (\n            Vector.sub(\n              Vector.sub(this.p1, this.p0),\n              Vector.mult(Vector.sub(this.c1, this.c0), 3)\n            ).mag() / 2\n          );\n        }\n\n        /**\n         * @param {Number} t the value (0-1) at which to split\n         * @return {Cubic} the second part of the curve\n         *\n         * splits the cubic into two parts at a point 't' along the curve.\n         * this cubic keeps its start point and its end point becomes the\n         * point at 't'. the 'end half is returned.\n         */\n        split(t) {\n          const m1 = Vector.lerp(this.p0, this.c0, t);\n          const m2 = Vector.lerp(this.c0, this.c1, t);\n          const mm1 = Vector.lerp(m1, m2, t);\n\n          this.c1 = Vector.lerp(this.c1, this.p1, t);\n          this.c0 = Vector.lerp(m2, this.c1, t);\n          const pt = Vector.lerp(mm1, this.c0, t);\n          const part1 = new Cubic(this.p0, m1, mm1, pt);\n          this.p0 = pt;\n          return part1;\n        }\n\n        /**\n         * @return {Cubic[]} the non-inflecting pieces of this cubic\n         *\n         * returns an array containing 0, 1 or 2 cubics split resulting\n         * from splitting this cubic at its inflection points.\n         * this cubic is (potentially) altered and returned in the list.\n         */\n        splitInflections() {\n          const a = Vector.sub(this.c0, this.p0);\n          const b = Vector.sub(Vector.sub(this.c1, this.c0), a);\n          const c = Vector.sub(\n            Vector.sub(Vector.sub(this.p1, this.c1), a),\n            Vector.mult(b, 2)\n          );\n\n          const cubics = [];\n\n          // find the derivative coefficients\n          let A = b.x * c.y - b.y * c.x;\n          if (A !== 0) {\n            let B = a.x * c.y - a.y * c.x;\n            let C = a.x * b.y - a.y * b.x;\n            const disc = B * B - 4 * A * C;\n            if (disc >= 0) {\n              if (A < 0) {\n                A = -A;\n                B = -B;\n                C = -C;\n              }\n\n              const Q = Math.sqrt(disc);\n              const t0 = (-B - Q) / (2 * A); // the first inflection point\n              let t1 = (-B + Q) / (2 * A); // the second inflection point\n\n              // test if the first inflection point lies on the curve\n              if (t0 > 0 && t0 < 1) {\n                // split at the first inflection point\n                cubics.push(this.split(t0));\n                // scale t2 into the second part\n                t1 = 1 - (1 - t1) / (1 - t0);\n              }\n\n              // test if the second inflection point lies on the curve\n              if (t1 > 0 && t1 < 1) {\n                // split at the second inflection point\n                cubics.push(this.split(t1));\n              }\n            }\n          }\n\n          cubics.push(this);\n          return cubics;\n        }\n      }\n\n      /**\n       * @function cubicToQuadratics\n       * @private\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} cx0\n       * @param {Number} cy0\n       * @param {Number} cx1\n       * @param {Number} cy1\n       * @param {Number} x1\n       * @param {Number} y1\n       * @returns {Cubic[]} an array of cubics whose quadratic approximations\n       *                    closely match the civen cubic.\n       *\n       * converts a cubic curve to a list of quadratics.\n       */\n      function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {\n        // create the Cubic object and split it at its inflections\n        const cubics = new Cubic(\n          new Vector(x0, y0),\n          new Vector(cx0, cy0),\n          new Vector(cx1, cy1),\n          new Vector(x1, y1)\n        ).splitInflections();\n\n        const qs = []; // the final list of quadratics\n        const precision = 30 / SQRT3;\n\n        // for each of the non-inflected pieces of the original cubic\n        for (let cubic of cubics) {\n          // the cubic is iteratively split in 3 pieces:\n          // the first piece is accumulated in 'qs', the result.\n          // the last piece is accumulated in 'tail', temporarily.\n          // the middle piece is repeatedly split again, while necessary.\n          const tail = [];\n\n          let t3;\n          for (;;) {\n            // calculate this cubic's precision\n            t3 = precision / cubic.quadError();\n            if (t3 >= 0.5 * 0.5 * 0.5) {\n              break; // not too bad, we're done\n            }\n\n            // find a split point based on the error\n            const t = Math.pow(t3, 1.0 / 3.0);\n            // split the cubic in 3\n            const start = cubic.split(t);\n            const middle = cubic.split(1 - t / (1 - t));\n\n            qs.push(start); // the first part\n            tail.push(cubic); // the last part\n            cubic = middle; // iterate on the middle piece\n          }\n\n          if (t3 < 1) {\n            // a little excess error, split the middle in two\n            qs.push(cubic.split(0.5));\n          }\n          // add the middle piece to the result\n          qs.push(cubic);\n\n          // finally add the tail, reversed, onto the result\n          Array.prototype.push.apply(qs, tail.reverse());\n        }\n\n        return qs;\n      }\n\n      /**\n       * @function pushLine\n       * @private\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       *\n       * add a straight line to the row/col grid of a glyph\n       */\n      function pushLine(x0, y0, x1, y1) {\n        const mx = (x0 + x1) / 2;\n        const my = (y0 + y1) / 2;\n        push([x0, x1], [y0, y1], { x: x0, y: y0, cx: mx, cy: my });\n      }\n\n      /**\n       * @function samePoint\n       * @private\n       * @param {Number} x0\n       * @param {Number} y0\n       * @param {Number} x1\n       * @param {Number} y1\n       * @return {Boolean} true if the two points are sufficiently close\n       *\n       * tests if two points are close enough to be considered the same\n       */\n      function samePoint(x0, y0, x1, y1) {\n        return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;\n      }\n\n      let x0, y0, xs, ys;\n\n      for (const cmd of cmds) {\n        // scale the coordinates to the range 0-1\n        const x1 = (cmd.x - xMin) / gWidth;\n        const y1 = (cmd.y - yMin) / gHeight;\n\n        // don't bother if this point is the same as the last\n        if (samePoint(x0, y0, x1, y1)) continue;\n\n        switch (cmd.type) {\n          case 'M': {\n            // move\n            xs = x1;\n            ys = y1;\n            break;\n          }\n          case 'L': {\n            // line\n            pushLine(x0, y0, x1, y1);\n            break;\n          }\n          case 'Q': {\n            // quadratic\n            const cx = (cmd.x1 - xMin) / gWidth;\n            const cy = (cmd.y1 - yMin) / gHeight;\n            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });\n            break;\n          }\n          case 'Z': {\n            // end\n            if (!samePoint(x0, y0, xs, ys)) {\n              // add an extra line closing the loop, if necessary\n              pushLine(x0, y0, xs, ys);\n              strokes.push({ x: xs, y: ys });\n            } else {\n              strokes.push({ x: x0, y: y0 });\n            }\n            break;\n          }\n          case 'C': {\n            // cubic\n            const cx1 = (cmd.x1 - xMin) / gWidth;\n            const cy1 = (cmd.y1 - yMin) / gHeight;\n            const cx2 = (cmd.x2 - xMin) / gWidth;\n            const cy2 = (cmd.y2 - yMin) / gHeight;\n            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);\n            for (let iq = 0; iq < qs.length; iq++) {\n              const q = qs[iq].toQuadratic();\n              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);\n            }\n            break;\n          }\n          default:\n            throw new Error(`unknown command type: ${cmd.type}`);\n        }\n        x0 = x1;\n        y0 = y1;\n      }\n\n      // allocate space for the strokes\n      const strokeCount = strokes.length;\n      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);\n      const strokeOffset = strokeImageInfo.index;\n\n      // fill the stroke image\n      for (let il = 0; il < strokeCount; ++il) {\n        const s = strokes[il];\n        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));\n      }\n\n      /**\n       * @function layout\n       * @private\n       * @param {Number[][]} dim\n       * @param {ImageInfos} dimImageInfos\n       * @param {ImageInfos} cellImageInfos\n       * @return {Object}\n       *\n       * lays out the curves in a dimension (row or col) into two\n       * images, one for the indices of the curves themselves, and\n       * one containing the offset and length of those index spans.\n       */\n      function layout(dim, dimImageInfos, cellImageInfos) {\n        const dimLength = dim.length; // the number of slices in this dimension\n        const dimImageInfo = dimImageInfos.findImage(dimLength);\n        const dimOffset = dimImageInfo.index;\n        // calculate the total number of stroke indices in this dimension\n        let totalStrokes = 0;\n        for (let id = 0; id < dimLength; ++id) {\n          totalStrokes += dim[id].length;\n        }\n\n        // allocate space for the stroke indices\n        const cellImageInfo = cellImageInfos.findImage(totalStrokes);\n\n        // for each slice in the glyph\n        for (let i = 0; i < dimLength; ++i) {\n          const strokeIndices = dim[i];\n          const strokeCount = strokeIndices.length;\n          const cellLineIndex = cellImageInfo.index;\n\n          // write the offset and count into the glyph slice image\n          setPixel(\n            dimImageInfo,\n            cellLineIndex >> 7,\n            cellLineIndex & 0x7f,\n            strokeCount >> 7,\n            strokeCount & 0x7f\n          );\n\n          // for each stroke index in that slice\n          for (let iil = 0; iil < strokeCount; ++iil) {\n            // write the stroke index into the slice's image\n            const strokeIndex = strokeIndices[iil] + strokeOffset;\n            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);\n          }\n        }\n\n        return {\n          cellImageInfo,\n          dimOffset,\n          dimImageInfo\n        };\n      }\n\n      // initialize the info for this glyph\n      gi = this.glyphInfos[glyph.index] = {\n        glyph,\n        uGlyphRect: [xMin, yMin, xMax, yMax],\n        strokeImageInfo,\n        strokes,\n        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),\n        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)\n      };\n      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];\n      return gi;\n    }\n  }\n\n  RendererGL.prototype._renderText = function (line, x, y, maxY, minY) {\n    if (!this.states.textFont || typeof this.states.textFont === 'string') {\n      console.log(\n        'WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.'\n      );\n      return;\n    }\n    if (y >= maxY || !this.states.fillColor) {\n      return; // don't render lines beyond our maxY position\n    }\n\n    if (!p5.Font.hasGlyphData(this.states.textFont)) {\n      console.log(\n        'WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported'\n      );\n      return;\n    }\n\n    this.push(); // fix to #803\n\n    // remember this state, so it can be restored later\n    const doStroke = this.states.strokeColor;\n    const drawMode = this.states.drawMode;\n\n    this.states.setValue('strokeColor', null);\n    this.states.setValue('drawMode', TEXTURE);\n\n    // get the cached FontInfo object\n    const { font } = this.states.textFont;\n    if (!font) {\n      throw new Error(\n        'In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.'\n      );\n    }\n    const axs = font._currentAxes(this);\n    let fontInfo = font._getFontInfo(axs);\n\n    // calculate the alignment and move/scale the view accordingly\n    // TODO: check this\n    const pos = { x, y }; // this.states.textFont._handleAlignment(this, line, x, y);\n    const fontSize = this.states.textSize;\n    const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);\n    this.translate(pos.x, pos.y, 0);\n    this.scale(scale, scale, 1);\n\n    // initialize the font shader\n    const gl = this.GL;\n    const initializeShader = !this._defaultFontShader;\n    const sh = this._getFontShader();\n    sh.init();\n    sh.bindShader(); // first time around, bind the shader fully\n\n    if (initializeShader) {\n      // these are constants, really. just initialize them one-time.\n      sh.setUniform('uGridImageSize', [gridImageWidth, gridImageHeight]);\n      sh.setUniform('uCellsImageSize', [cellImageWidth, cellImageHeight]);\n      sh.setUniform('uStrokeImageSize', [strokeImageWidth, strokeImageHeight]);\n      sh.setUniform('uGridSize', [charGridWidth, charGridHeight]);\n    }\n\n    const curFillColor = this.states.fillSet\n      ? this.states.curFillColor\n      : [0, 0, 0, 255];\n\n    this._setGlobalUniforms(sh);\n    this._applyColorBlend(curFillColor);\n\n    let g = this.geometryBufferCache.getGeometryByID('glyph');\n    if (!g) {\n      // create the geometry for rendering a quad\n      g = this._textGeom = new Geometry(\n        1,\n        1,\n        function () {\n          for (let i = 0; i <= 1; i++) {\n            for (let j = 0; j <= 1; j++) {\n              this.vertices.push(new Vector(j, i, 0));\n              this.uvs.push(j, i);\n            }\n          }\n        },\n        this\n      );\n      g.gid = 'glyph';\n      g.computeFaces().computeNormals();\n      this.geometryBufferCache.ensureCached(g);\n    }\n\n    // bind the shader buffers\n    for (const buff of this.buffers.text) {\n      buff._prepareBuffer(g, sh);\n    }\n    this._bindBuffer(\n      this.geometryBufferCache.cache.glyph.indexBuffer,\n      gl.ELEMENT_ARRAY_BUFFER\n    );\n\n    // this will have to do for now...\n    sh.setUniform('uMaterialColor', curFillColor);\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\n    this.glyphDataCache = this.glyphDataCache || new Set();\n\n    try {\n      // fetch the glyphs in the line of text\n      const glyphs = font._positionGlyphs(line);\n\n      for (const glyph of glyphs) {\n        const gi = fontInfo.getGlyphInfo(glyph);\n        if (gi.uGlyphRect) {\n          const rowInfo = gi.rowInfo;\n          const colInfo = gi.colInfo;\n\n          // Bump the resources for this glyph to the end of the cache list by deleting and re-adding\n          const glyphResources = [\n            gi.strokeImageInfo.imageData,\n            rowInfo.cellImageInfo.imageData,\n            rowInfo.dimImageInfo.imageData,\n            colInfo.cellImageInfo.imageData,\n            colInfo.dimImageInfo.imageData\n          ];\n          for (const resource of glyphResources) {\n            this.glyphDataCache.delete(resource);\n            this.glyphDataCache.add(resource);\n          }\n\n          // If we have too many glyph textures, remove the least recently used\n          // ones from GPU memory. The data still exists on the CPU and will be\n          // re-uploaded if it gets actively used again.\n          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {\n            const data = this.glyphDataCache.values().next().value;\n            this.glyphDataCache.delete(data);\n            const tex = this.textures.get(data);\n            if (tex) {\n              tex.remove();\n              this.textures.delete(data);\n            }\n          }\n\n          sh.setUniform('uSamplerStrokes', gi.strokeImageInfo.imageData);\n          sh.setUniform('uSamplerRowStrokes', rowInfo.cellImageInfo.imageData);\n          sh.setUniform('uSamplerRows', rowInfo.dimImageInfo.imageData);\n          sh.setUniform('uSamplerColStrokes', colInfo.cellImageInfo.imageData);\n          sh.setUniform('uSamplerCols', colInfo.dimImageInfo.imageData);\n          sh.setUniform('uGridOffset', gi.uGridOffset);\n          sh.setUniform('uGlyphRect', gi.uGlyphRect);\n          sh.setUniform('uGlyphOffset', glyph.x);\n\n          sh.bindTextures(); // afterwards, only textures need updating\n\n          // draw it\n          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);\n        }\n      }\n    } finally {\n      // clean up\n      sh.unbindShader();\n\n      this.states.setValue('strokeColor', doStroke);\n      this.states.setValue('drawMode', drawMode);\n      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\n      this.pop();\n    }\n  };\n}\n\nexport { text as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6357, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/webgl/index.js"],"sourcesContent":["import { r as rendererGL, p as primitives3D, l as light, m as material, c as camera, f as framebuffer, s as shader, t as texture } from '../rendering-COLWmJqb.js';\nimport interaction from './interaction.js';\nimport loading from './loading.js';\nimport text from './text.js';\nimport renderBuffer from './p5.RenderBuffer.js';\nimport quat from './p5.Quat.js';\nimport matrix from '../math/p5.Matrix.js';\nimport geometry from './p5.Geometry.js';\nimport dataArray from './p5.DataArray.js';\nimport strands from '../strands/p5.strands.js';\nimport '../constants-Bt1VTUeD.js';\nimport '../creating_reading-p2iQtNm5.js';\nimport 'colorjs.io/fn';\nimport '../color/color_spaces/hsb.js';\nimport '../dom/p5.Element.js';\nimport '../dom/p5.File.js';\nimport '../io/p5.XML.js';\nimport '../p5.Renderer-C-tu2oim.js';\nimport '../image/filters.js';\nimport '../math/p5.Vector.js';\nimport '../shape/custom_shapes.js';\nimport '../core/States.js';\nimport '../io/utilities.js';\nimport 'file-saver';\nimport '../dom/p5.MediaElement.js';\nimport '../shape/2d_primitives.js';\nimport '../core/helpers.js';\nimport '../shape/attributes.js';\nimport '../shape/curves.js';\nimport '../shape/vertex.js';\nimport '../color/setting.js';\nimport 'omggif';\nimport '../io/csv.js';\nimport 'gifenc';\nimport '../image/pixels.js';\nimport '../core/transform.js';\nimport './GeometryBuilder.js';\nimport '../math/Matrices/Matrix.js';\nimport '../math/Matrices/MatrixInterface.js';\nimport './ShapeBuilder.js';\nimport 'libtess';\nimport './GeometryBufferCache.js';\nimport '../image/const.js';\nimport '../math/trigonometry.js';\nimport '../type/p5.Font.js';\nimport '../type/textCore.js';\nimport '@japont/unicode-range';\nimport '../type/unicodeRanges.js';\nimport '../type/lib/Typr.js';\nimport 'pako';\nimport '@davepagurek/bezier-path';\nimport '../strands/strands_glslBackend.js';\nimport '../strands/ir_types.js';\nimport '../strands/ir_dag.js';\nimport '../strands/strands_FES.js';\nimport '../strands/strands_transpiler.js';\nimport 'acorn';\nimport 'acorn-walk';\nimport 'escodegen';\nimport '../strands/ir_cfg.js';\nimport '../strands/strands_codegen.js';\nimport '../strands/strands_api.js';\nimport '../ir_builders-Cn4s8QTL.js';\nimport '../strands/strands_builtins.js';\nimport '../strands/strands_conditionals.js';\nimport '../strands/strands_phi_utils.js';\nimport '../strands/strands_for.js';\n\nfunction webgl(p5){\n  rendererGL(p5, p5.prototype);\n  primitives3D(p5, p5.prototype);\n  interaction(p5, p5.prototype);\n  light(p5, p5.prototype);\n  loading(p5, p5.prototype);\n  material(p5, p5.prototype);\n  text(p5, p5.prototype);\n  renderBuffer(p5, p5.prototype);\n  quat(p5, p5.prototype);\n  matrix(p5, p5.prototype);\n  geometry(p5, p5.prototype);\n  camera(p5, p5.prototype);\n  framebuffer(p5, p5.prototype);\n  dataArray(p5, p5.prototype);\n  shader(p5, p5.prototype);\n  texture(p5, p5.prototype);\n  strands(p5, p5.prototype);\n}\n\nexport { webgl as default };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAS,MAAM,EAAE;IACf,IAAA,wJAAU,EAAC,IAAI,GAAG,SAAS;IAC3B,IAAA,wJAAY,EAAC,IAAI,GAAG,SAAS;IAC7B,IAAA,6JAAW,EAAC,IAAI,GAAG,SAAS;IAC5B,IAAA,wJAAK,EAAC,IAAI,GAAG,SAAS;IACtB,IAAA,yJAAO,EAAC,IAAI,GAAG,SAAS;IACxB,IAAA,wJAAQ,EAAC,IAAI,GAAG,SAAS;IACzB,IAAA,sJAAI,EAAC,IAAI,GAAG,SAAS;IACrB,IAAA,oKAAY,EAAC,IAAI,GAAG,SAAS;IAC7B,IAAA,4JAAI,EAAC,IAAI,GAAG,SAAS;IACrB,IAAA,6KAAM,EAAC,IAAI,GAAG,SAAS;IACvB,IAAA,gKAAQ,EAAC,IAAI,GAAG,SAAS;IACzB,IAAA,wJAAM,EAAC,IAAI,GAAG,SAAS;IACvB,IAAA,wJAAW,EAAC,IAAI,GAAG,SAAS;IAC5B,IAAA,iKAAS,EAAC,IAAI,GAAG,SAAS;IAC1B,IAAA,wJAAM,EAAC,IAAI,GAAG,SAAS;IACvB,IAAA,wJAAO,EAAC,IAAI,GAAG,SAAS;IACxB,IAAA,iKAAO,EAAC,IAAI,GAAG,SAAS;AAC1B","ignoreList":[0]}}]
}