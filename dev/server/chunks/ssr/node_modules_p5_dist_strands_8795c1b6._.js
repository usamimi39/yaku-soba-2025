module.exports = [
"[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BasePriority",
    ()=>BasePriority,
    "BaseType",
    ()=>BaseType,
    "BinarySymbolToName",
    ()=>BinarySymbolToName,
    "BlockType",
    ()=>BlockType,
    "BlockTypeToName",
    ()=>BlockTypeToName,
    "ConstantFolding",
    ()=>ConstantFolding,
    "DataType",
    ()=>DataType,
    "GenType",
    ()=>GenType,
    "NodeType",
    ()=>NodeType,
    "NodeTypeRequiredFields",
    ()=>NodeTypeRequiredFields,
    "NodeTypeToName",
    ()=>NodeTypeToName,
    "OpCode",
    ()=>OpCode,
    "OpCodeToSymbol",
    ()=>OpCodeToSymbol,
    "OperatorTable",
    ()=>OperatorTable,
    "StatementType",
    ()=>StatementType,
    "TypeInfoFromGLSLName",
    ()=>TypeInfoFromGLSLName,
    "UnarySymbolToName",
    ()=>UnarySymbolToName,
    "isNativeType",
    ()=>isNativeType,
    "isStructType",
    ()=>isStructType,
    "structType",
    ()=>structType,
    "typeEquals",
    ()=>typeEquals
]);
/////////////////////
// Enums for nodes //
/////////////////////
const NodeType = {
    OPERATION: 'operation',
    LITERAL: 'literal',
    VARIABLE: 'variable',
    CONSTANT: 'constant',
    STRUCT: 'struct',
    PHI: 'phi',
    STATEMENT: 'statement',
    ASSIGNMENT: 'assignment'
};
const NodeTypeToName = Object.fromEntries(Object.entries(NodeType).map(([key, val])=>[
        val,
        key
    ]));
const NodeTypeRequiredFields = {
    [NodeType.OPERATION]: [
        "opCode",
        "dependsOn",
        "dimension",
        "baseType"
    ],
    [NodeType.LITERAL]: [
        "value",
        "dimension",
        "baseType"
    ],
    [NodeType.VARIABLE]: [
        "identifier",
        "dimension",
        "baseType"
    ],
    [NodeType.CONSTANT]: [
        "value",
        "dimension",
        "baseType"
    ],
    [NodeType.STRUCT]: [
        ""
    ],
    [NodeType.PHI]: [
        "dependsOn",
        "phiBlocks",
        "dimension",
        "baseType"
    ],
    [NodeType.STATEMENT]: [
        "statementType"
    ],
    [NodeType.ASSIGNMENT]: [
        "dependsOn"
    ]
};
const StatementType = {
    DISCARD: 'discard',
    BREAK: 'break',
    EXPRESSION: 'expression',
    EMPTY: 'empty'
};
const BaseType = {
    FLOAT: "float",
    INT: "int",
    BOOL: "bool",
    MAT: "mat",
    DEFER: "defer",
    SAMPLER2D: "sampler2D"
};
const BasePriority = {
    [BaseType.FLOAT]: 3,
    [BaseType.INT]: 2,
    [BaseType.BOOL]: 1,
    [BaseType.MAT]: 0,
    [BaseType.DEFER]: -1,
    [BaseType.SAMPLER2D]: -10
};
const DataType = {
    float1: {
        fnName: "float",
        baseType: BaseType.FLOAT,
        dimension: 1,
        priority: 3
    },
    float2: {
        fnName: "vec2",
        baseType: BaseType.FLOAT,
        dimension: 2,
        priority: 3
    },
    float3: {
        fnName: "vec3",
        baseType: BaseType.FLOAT,
        dimension: 3,
        priority: 3
    },
    float4: {
        fnName: "vec4",
        baseType: BaseType.FLOAT,
        dimension: 4,
        priority: 3
    },
    int1: {
        fnName: "int",
        baseType: BaseType.INT,
        dimension: 1,
        priority: 2
    },
    int2: {
        fnName: "ivec2",
        baseType: BaseType.INT,
        dimension: 2,
        priority: 2
    },
    int3: {
        fnName: "ivec3",
        baseType: BaseType.INT,
        dimension: 3,
        priority: 2
    },
    int4: {
        fnName: "ivec4",
        baseType: BaseType.INT,
        dimension: 4,
        priority: 2
    },
    bool1: {
        fnName: "bool",
        baseType: BaseType.BOOL,
        dimension: 1,
        priority: 1
    },
    bool2: {
        fnName: "bvec2",
        baseType: BaseType.BOOL,
        dimension: 2,
        priority: 1
    },
    bool3: {
        fnName: "bvec3",
        baseType: BaseType.BOOL,
        dimension: 3,
        priority: 1
    },
    bool4: {
        fnName: "bvec4",
        baseType: BaseType.BOOL,
        dimension: 4,
        priority: 1
    },
    mat2: {
        fnName: "mat2x2",
        baseType: BaseType.MAT,
        dimension: 2,
        priority: 0
    },
    mat3: {
        fnName: "mat3x3",
        baseType: BaseType.MAT,
        dimension: 3,
        priority: 0
    },
    mat4: {
        fnName: "mat4x4",
        baseType: BaseType.MAT,
        dimension: 4,
        priority: 0
    },
    defer: {
        fnName: null,
        baseType: BaseType.DEFER,
        dimension: null,
        priority: -1
    },
    sampler2D: {
        fnName: "sampler2D",
        baseType: BaseType.SAMPLER2D,
        dimension: 1,
        priority: -10
    }
};
const structType = function(hookType) {
    let T = hookType.type === undefined ? hookType : hookType.type;
    const structType = {
        name: hookType.name,
        properties: [],
        typeName: T.typeName
    };
    // TODO: handle struct properties that are themselves structs
    for (const prop of T.properties){
        const propType = TypeInfoFromGLSLName[prop.type.typeName];
        structType.properties.push({
            name: prop.name,
            dataType: propType
        });
    }
    return structType;
};
function isStructType(typeName) {
    return !isNativeType(typeName);
}
function isNativeType(typeName) {
    // Check if it's in DataType keys (internal names like 'float4')
    if (Object.keys(DataType).includes(typeName)) {
        return true;
    }
    // Check if it's a GLSL type name (like 'vec4', 'float', etc.)
    const glslNativeTypes = {
        'float': true,
        'vec2': true,
        'vec3': true,
        'vec4': true,
        'int': true,
        'ivec2': true,
        'ivec3': true,
        'ivec4': true,
        'bool': true,
        'bvec2': true,
        'bvec3': true,
        'bvec4': true,
        'mat2': true,
        'mat3': true,
        'mat4': true,
        'sampler2D': true
    };
    return !!glslNativeTypes[typeName];
}
const GenType = {
    FLOAT: {
        baseType: BaseType.FLOAT,
        dimension: null,
        priority: 3
    },
    INT: {
        baseType: BaseType.INT,
        dimension: null,
        priority: 2
    },
    BOOL: {
        baseType: BaseType.BOOL,
        dimension: null,
        priority: 1
    }
};
function typeEquals(nodeA, nodeB) {
    return nodeA.dimension === nodeB.dimension && nodeA.baseType === nodeB.baseType;
}
const TypeInfoFromGLSLName = Object.fromEntries(Object.values(DataType).filter((info)=>info.fnName !== null).map((info)=>[
        info.fnName,
        info
    ]));
const OpCode = {
    Binary: {
        ADD: 0,
        SUBTRACT: 1,
        MULTIPLY: 2,
        DIVIDE: 3,
        MODULO: 4,
        EQUAL: 5,
        NOT_EQUAL: 6,
        GREATER_THAN: 7,
        GREATER_EQUAL: 8,
        LESS_THAN: 9,
        LESS_EQUAL: 10,
        LOGICAL_AND: 11,
        LOGICAL_OR: 12,
        MEMBER_ACCESS: 13
    },
    Unary: {
        LOGICAL_NOT: 100,
        NEGATE: 101,
        PLUS: 102,
        SWIZZLE: 103
    },
    Nary: {
        FUNCTION_CALL: 200,
        CONSTRUCTOR: 201
    },
    ControlFlow: {
        RETURN: 300,
        JUMP: 301,
        BRANCH_IF_FALSE: 302,
        DISCARD: 303,
        BREAK: 304
    }
};
const OperatorTable = [
    {
        arity: "unary",
        name: "not",
        symbol: "!",
        opCode: OpCode.Unary.LOGICAL_NOT
    },
    {
        arity: "unary",
        name: "neg",
        symbol: "-",
        opCode: OpCode.Unary.NEGATE
    },
    {
        arity: "unary",
        name: "plus",
        symbol: "+",
        opCode: OpCode.Unary.PLUS
    },
    {
        arity: "binary",
        name: "add",
        symbol: "+",
        opCode: OpCode.Binary.ADD
    },
    {
        arity: "binary",
        name: "sub",
        symbol: "-",
        opCode: OpCode.Binary.SUBTRACT
    },
    {
        arity: "binary",
        name: "mult",
        symbol: "*",
        opCode: OpCode.Binary.MULTIPLY
    },
    {
        arity: "binary",
        name: "div",
        symbol: "/",
        opCode: OpCode.Binary.DIVIDE
    },
    {
        arity: "binary",
        name: "mod",
        symbol: "%",
        opCode: OpCode.Binary.MODULO
    },
    {
        arity: "binary",
        name: "equalTo",
        symbol: "==",
        opCode: OpCode.Binary.EQUAL
    },
    {
        arity: "binary",
        name: "notEqual",
        symbol: "!=",
        opCode: OpCode.Binary.NOT_EQUAL
    },
    {
        arity: "binary",
        name: "greaterThan",
        symbol: ">",
        opCode: OpCode.Binary.GREATER_THAN
    },
    {
        arity: "binary",
        name: "greaterEqual",
        symbol: ">=",
        opCode: OpCode.Binary.GREATER_EQUAL
    },
    {
        arity: "binary",
        name: "lessThan",
        symbol: "<",
        opCode: OpCode.Binary.LESS_THAN
    },
    {
        arity: "binary",
        name: "lessEqual",
        symbol: "<=",
        opCode: OpCode.Binary.LESS_EQUAL
    },
    {
        arity: "binary",
        name: "and",
        symbol: "&&",
        opCode: OpCode.Binary.LOGICAL_AND
    },
    {
        arity: "binary",
        name: "or",
        symbol: "||",
        opCode: OpCode.Binary.LOGICAL_OR
    }
];
const ConstantFolding = {
    [OpCode.Binary.ADD]: (a, b)=>a + b,
    [OpCode.Binary.SUBTRACT]: (a, b)=>a - b,
    [OpCode.Binary.MULTIPLY]: (a, b)=>a * b,
    [OpCode.Binary.DIVIDE]: (a, b)=>a / b,
    [OpCode.Binary.MODULO]: (a, b)=>a % b,
    [OpCode.Binary.EQUAL]: (a, b)=>a == b,
    [OpCode.Binary.NOT_EQUAL]: (a, b)=>a != b,
    [OpCode.Binary.GREATER_THAN]: (a, b)=>a > b,
    [OpCode.Binary.GREATER_EQUAL]: (a, b)=>a >= b,
    [OpCode.Binary.LESS_THAN]: (a, b)=>a < b,
    [OpCode.Binary.LESS_EQUAL]: (a, b)=>a <= b,
    [OpCode.Binary.LOGICAL_AND]: (a, b)=>a && b,
    [OpCode.Binary.LOGICAL_OR]: (a, b)=>a || b
};
// export const SymbolToOpCode = {};
const OpCodeToSymbol = {};
const UnarySymbolToName = {};
const BinarySymbolToName = {};
for (const { symbol, opCode, name, arity } of OperatorTable){
    // SymbolToOpCode[symbol] = opCode;
    OpCodeToSymbol[opCode] = symbol;
    if (arity === 'unary') {
        UnarySymbolToName[symbol] = name;
    }
    if (arity === 'binary') {
        BinarySymbolToName[symbol] = name;
    }
}
const BlockType = {
    GLOBAL: 'global',
    FUNCTION: 'function',
    BRANCH: 'branch',
    IF_COND: 'if_cond',
    IF_BODY: 'if_body',
    ELSE_COND: 'else_cond',
    SCOPE_START: 'scope_start',
    SCOPE_END: 'scope_end',
    FOR: 'for',
    MERGE: 'merge',
    DEFAULT: 'default'
};
const BlockTypeToName = Object.fromEntries(Object.entries(BlockType).map(([key, val])=>[
        val,
        key
    ]));
;
}),
"[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "internalError",
    ()=>internalError,
    "userError",
    ()=>userError
]);
function internalError(errorMessage) {
    const prefixedMessage = `[p5.strands internal error]: ${errorMessage}`;
    throw new Error(prefixedMessage);
}
function userError(errorType, errorMessage) {
    const prefixedMessage = `[p5.strands ${errorType}]: ${errorMessage}`;
    throw new Error(prefixedMessage);
}
;
}),
"[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDirectedAcyclicGraph",
    ()=>createDirectedAcyclicGraph,
    "createNodeData",
    ()=>createNodeData,
    "extractNodeTypeInfo",
    ()=>extractNodeTypeInfo,
    "getNodeDataFromID",
    ()=>getNodeDataFromID,
    "getOrCreateNode",
    ()=>getOrCreateNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
;
;
/////////////////////////////////
// Public functions for strands runtime
/////////////////////////////////
function createDirectedAcyclicGraph() {
    const graph = {
        nextID: 0,
        cache: new Map(),
        nodeTypes: [],
        baseTypes: [],
        dimensions: [],
        opCodes: [],
        values: [],
        identifiers: [],
        phiBlocks: [],
        dependsOn: [],
        usedBy: [],
        statementTypes: [],
        swizzles: []
    };
    return graph;
}
function getOrCreateNode(graph, node) {
    // const key = getNodeKey(node);
    // const existing = graph.cache.get(key);
    // if (existing !== undefined) {
    // return existing;
    // } else {
    const id = createNode(graph, node);
    // graph.cache.set(key, id);
    return id;
// }
}
function createNodeData(data = {}) {
    const node = {
        nodeType: data.nodeType ?? null,
        baseType: data.baseType ?? null,
        dimension: data.dimension ?? null,
        opCode: data.opCode ?? null,
        value: data.value ?? null,
        identifier: data.identifier ?? null,
        statementType: data.statementType ?? null,
        swizzle: data.swizzle ?? null,
        dependsOn: Array.isArray(data.dependsOn) ? data.dependsOn : [],
        usedBy: Array.isArray(data.usedBy) ? data.usedBy : [],
        phiBlocks: Array.isArray(data.phiBlocks) ? data.phiBlocks : []
    };
    validateNode(node);
    return node;
}
function getNodeDataFromID(graph, id) {
    return {
        id,
        nodeType: graph.nodeTypes[id],
        opCode: graph.opCodes[id],
        value: graph.values[id],
        identifier: graph.identifiers[id],
        dependsOn: graph.dependsOn[id],
        usedBy: graph.usedBy[id],
        phiBlocks: graph.phiBlocks[id],
        dimension: graph.dimensions[id],
        baseType: graph.baseTypes[id],
        statementType: graph.statementTypes[id],
        swizzle: graph.swizzles[id]
    };
}
function extractNodeTypeInfo(dag, nodeID) {
    return {
        baseType: dag.baseTypes[nodeID],
        dimension: dag.dimensions[nodeID],
        priority: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BasePriority"][dag.baseTypes[nodeID]]
    };
}
/////////////////////////////////
// Private functions
/////////////////////////////////
function createNode(graph, node) {
    const id = graph.nextID++;
    graph.nodeTypes[id] = node.nodeType;
    graph.opCodes[id] = node.opCode;
    graph.values[id] = node.value;
    graph.identifiers[id] = node.identifier;
    graph.dependsOn[id] = node.dependsOn.slice();
    graph.usedBy[id] = node.usedBy;
    graph.phiBlocks[id] = node.phiBlocks.slice();
    graph.baseTypes[id] = node.baseType;
    graph.dimensions[id] = node.dimension;
    graph.statementTypes[id] = node.statementType;
    graph.swizzles[id] = node.swizzle;
    for (const dep of node.dependsOn){
        if (!Array.isArray(graph.usedBy[dep])) {
            graph.usedBy[dep] = [];
        }
        graph.usedBy[dep].push(id);
    }
    return id;
}
function validateNode(node) {
    const nodeType = node.nodeType;
    const requiredFields = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeTypeRequiredFields"][nodeType];
    if (requiredFields.length === 2) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])(`Required fields for node type '${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeTypeToName"][nodeType]}' not defined. Please add them to the utils.js file in p5.strands!`);
    }
    const missingFields = [];
    for (const field of requiredFields){
        if (node[field] === null) {
            missingFields.push(field);
        }
    }
    if (node.dependsOn?.some((v)=>v === undefined)) {
        throw new Error('Undefined dependency!');
    }
    if (missingFields.length > 0) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])(`Missing fields ${missingFields.join(', ')} for a node type '${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeTypeToName"][nodeType]}'.`);
    }
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_glslBackend.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "glslBackend",
    ()=>glslBackend
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
;
;
;
function shouldCreateTemp(dag, nodeID) {
    const nodeType = dag.nodeTypes[nodeID];
    if (nodeType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION) return false;
    if (dag.baseTypes[nodeID] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].SAMPLER2D) return false;
    const uses = dag.usedBy[nodeID] || [];
    return uses.length > 1;
}
const TypeNames = {
    'float1': 'float',
    'float2': 'vec2',
    'float3': 'vec3',
    'float4': 'vec4',
    'int1': 'int',
    'int2': 'ivec2',
    'int3': 'ivec3',
    'int4': 'ivec4',
    'bool1': 'bool',
    'bool2': 'bvec2',
    'bool3': 'bvec3',
    'bool4': 'bvec4',
    'mat2': 'mat2x2',
    'mat3': 'mat3x3',
    'mat4': 'mat4x4'
};
const cfgHandlers = {
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT]: (blockID, strandsContext, generationContext)=>{
        const { dag, cfg } = strandsContext;
        const instructions = cfg.blockInstructions[blockID] || [];
        for (const nodeID of instructions){
            const nodeType = dag.nodeTypes[nodeID];
            if (shouldCreateTemp(dag, nodeID)) {
                const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
                generationContext.write(declaration);
            }
            if (nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT) {
                glslBackend.generateStatement(generationContext, dag, nodeID);
            }
            if (nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT) {
                glslBackend.generateAssignment(generationContext, dag, nodeID);
                generationContext.visitedNodes.add(nodeID);
            }
        }
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].BRANCH] (blockID, strandsContext, generationContext) {
        const { dag, cfg } = strandsContext;
        // Find all phi nodes in this branch block and declare them
        const blockInstructions = cfg.blockInstructions[blockID] || [];
        for (const nodeID of blockInstructions){
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
            if (node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].PHI) {
                // Check if the phi node's first dependency already has a temp name
                const dependsOn = node.dependsOn || [];
                if (dependsOn.length > 0) {
                    const firstDependency = dependsOn[0];
                    const existingTempName = generationContext.tempNames[firstDependency];
                    if (existingTempName) {
                        // Reuse the existing temp name instead of creating a new one
                        generationContext.tempNames[nodeID] = existingTempName;
                        continue; // Skip declaration, just alias to existing variable
                    }
                }
                // Otherwise, create a new temp variable for the phi node
                const tmp = `T${generationContext.nextTempID++}`;
                generationContext.tempNames[nodeID] = tmp;
                const T = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractNodeTypeInfo"])(dag, nodeID);
                const typeName = glslBackend.getTypeName(T.baseType, T.dimension);
                generationContext.write(`${typeName} ${tmp};`);
            }
        }
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_COND] (blockID, strandsContext, generationContext) {
        const { dag, cfg } = strandsContext;
        const conditionID = cfg.blockConditions[blockID];
        const condExpr = glslBackend.generateExpression(generationContext, dag, conditionID);
        generationContext.write(`if (${condExpr})`);
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].ELSE_COND] (blockID, strandsContext, generationContext) {
        generationContext.write(`else`);
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_BODY] (blockID, strandsContext, generationContext) {
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
        this.assignPhiNodeValues(blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_START] (blockID, strandsContext, generationContext) {
        generationContext.write(`{`);
        generationContext.indent++;
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_END] (blockID, strandsContext, generationContext) {
        generationContext.indent--;
        generationContext.write(`}`);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].MERGE] (blockID, strandsContext, generationContext) {
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].FUNCTION] (blockID, strandsContext, generationContext) {
        this[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT](blockID, strandsContext, generationContext);
    },
    [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].FOR] (blockID, strandsContext, generationContext) {
        const { dag, cfg } = strandsContext;
        const instructions = cfg.blockInstructions[blockID] || [];
        generationContext.write(`for (`);
        // Set flag to suppress semicolon on the last statement
        const originalSuppressSemicolon = generationContext.suppressSemicolon;
        for(let i = 0; i < instructions.length; i++){
            const nodeID = instructions[i];
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
            const isLast = i === instructions.length - 1;
            // Suppress semicolon on the last statement
            generationContext.suppressSemicolon = isLast;
            if (shouldCreateTemp(dag, nodeID)) {
                const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
                generationContext.write(declaration);
            }
            if (node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT) {
                glslBackend.generateStatement(generationContext, dag, nodeID);
            }
            if (node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT) {
                glslBackend.generateAssignment(generationContext, dag, nodeID);
                generationContext.visitedNodes.add(nodeID);
            }
        }
        // Restore original flag
        generationContext.suppressSemicolon = originalSuppressSemicolon;
        generationContext.write(`)`);
    },
    assignPhiNodeValues (blockID, strandsContext, generationContext) {
        const { dag, cfg } = strandsContext;
        // Find all phi nodes that this block feeds into
        const successors = cfg.outgoingEdges[blockID] || [];
        for (const successorBlockID of successors){
            const instructions = cfg.blockInstructions[successorBlockID] || [];
            for (const nodeID of instructions){
                const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
                if (node.nodeType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].PHI) {
                    // Find which input of this phi node corresponds to our block
                    const branchIndex = node.phiBlocks?.indexOf(blockID);
                    if (branchIndex !== -1 && branchIndex < node.dependsOn.length) {
                        const sourceNodeID = node.dependsOn[branchIndex];
                        const tempName = generationContext.tempNames[nodeID];
                        if (tempName && sourceNodeID !== null) {
                            const sourceExpr = glslBackend.generateExpression(generationContext, dag, sourceNodeID);
                            generationContext.write(`${tempName} = ${sourceExpr};`);
                        }
                    }
                }
            }
        }
    }
};
const glslBackend = {
    hookEntry (hookType) {
        const firstLine = `(${hookType.parameters.flatMap((param)=>{
            return `${param.qualifiers?.length ? param.qualifiers.join(' ') : ''}${param.type.typeName} ${param.name}`;
        }).join(', ')}) {`;
        return firstLine;
    },
    getTypeName (baseType, dimension) {
        const primitiveTypeName = TypeNames[baseType + dimension];
        if (!primitiveTypeName) {
            return baseType;
        }
        return primitiveTypeName;
    },
    generateUniformDeclaration (name, typeInfo) {
        return `${this.getTypeName(typeInfo.baseType, typeInfo.dimension)} ${name}`;
    },
    generateStatement (generationContext, dag, nodeID) {
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
        const semicolon = generationContext.suppressSemicolon ? '' : ';';
        if (node.statementType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].DISCARD) {
            generationContext.write(`discard${semicolon}`);
        } else if (node.statementType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].BREAK) {
            generationContext.write(`break${semicolon}`);
        } else if (node.statementType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EXPRESSION) {
            // Generate the expression followed by semicolon (unless suppressed)
            const exprNodeID = node.dependsOn[0];
            const expr = this.generateExpression(generationContext, dag, exprNodeID);
            generationContext.write(`${expr}${semicolon}`);
        } else if (node.statementType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EMPTY) {
            // Generate just a semicolon (unless suppressed)
            generationContext.write(semicolon);
        }
    },
    generateAssignment (generationContext, dag, nodeID) {
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
        // dependsOn[0] = targetNodeID, dependsOn[1] = sourceNodeID
        const targetNodeID = node.dependsOn[0];
        const sourceNodeID = node.dependsOn[1];
        // Generate the target expression (could be variable or swizzle)
        const targetExpr = this.generateExpression(generationContext, dag, targetNodeID);
        const sourceExpr = this.generateExpression(generationContext, dag, sourceNodeID);
        const semicolon = generationContext.suppressSemicolon ? '' : ';';
        // Generate assignment if we have both target and source
        if (targetExpr && sourceExpr && targetExpr !== sourceExpr) {
            generationContext.write(`${targetExpr} = ${sourceExpr}${semicolon}`);
        }
    },
    generateDeclaration (generationContext, dag, nodeID) {
        const expr = this.generateExpression(generationContext, dag, nodeID);
        const tmp = `T${generationContext.nextTempID++}`;
        generationContext.tempNames[nodeID] = tmp;
        const T = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractNodeTypeInfo"])(dag, nodeID);
        const typeName = this.getTypeName(T.baseType, T.dimension);
        return `${typeName} ${tmp} = ${expr};`;
    },
    generateReturnStatement (strandsContext, generationContext, rootNodeID, returnType) {
        const dag = strandsContext.dag;
        const rootNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, rootNodeID);
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructType"])(rootNode.baseType)) {
            const structTypeInfo = returnType;
            for(let i = 0; i < structTypeInfo.properties.length; i++){
                const prop = structTypeInfo.properties[i];
                const val = this.generateExpression(generationContext, dag, rootNode.dependsOn[i]);
                if (prop.name !== val) {
                    generationContext.write(`${rootNode.identifier}.${prop.name} = ${val};`);
                }
            }
        }
        generationContext.write(`return ${this.generateExpression(generationContext, dag, rootNodeID)};`);
    },
    generateExpression (generationContext, dag, nodeID) {
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, nodeID);
        if (generationContext.tempNames?.[nodeID]) {
            return generationContext.tempNames[nodeID];
        }
        switch(node.nodeType){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].LITERAL:
                if (node.baseType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT) {
                    return node.value.toFixed(4);
                } else {
                    return node.value;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE:
                // Track shared variable usage context
                if (generationContext.shaderContext && generationContext.strandsContext?.sharedVariables?.has(node.identifier)) {
                    const sharedVar = generationContext.strandsContext.sharedVariables.get(node.identifier);
                    if (generationContext.shaderContext === 'vertex') {
                        sharedVar.usedInVertex = true;
                    } else if (generationContext.shaderContext === 'fragment') {
                        sharedVar.usedInFragment = true;
                    }
                }
                return node.identifier;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION:
                const useParantheses = node.usedBy.length > 0;
                if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.CONSTRUCTOR) {
                    // TODO: differentiate casts and constructors for more efficient codegen.
                    // if (node.dependsOn.length === 1 && node.dimension === 1) {
                    //   return this.generateExpression(generationContext, dag, node.dependsOn[0]);
                    // }
                    if (node.baseType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].SAMPLER2D) {
                        return this.generateExpression(generationContext, dag, node.dependsOn[0]);
                    }
                    const T = this.getTypeName(node.baseType, node.dimension);
                    const deps = node.dependsOn.map((dep)=>this.generateExpression(generationContext, dag, dep));
                    return `${T}(${deps.join(', ')})`;
                }
                if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Nary.FUNCTION_CALL) {
                    const functionArgs = node.dependsOn.map((arg)=>this.generateExpression(generationContext, dag, arg));
                    return `${node.identifier}(${functionArgs.join(', ')})`;
                }
                if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Binary.MEMBER_ACCESS) {
                    const [lID, rID] = node.dependsOn;
                    const lName = this.generateExpression(generationContext, dag, lID);
                    const rName = this.generateExpression(generationContext, dag, rID);
                    return `${lName}.${rName}`;
                }
                if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.SWIZZLE) {
                    const parentID = node.dependsOn[0];
                    const parentExpr = this.generateExpression(generationContext, dag, parentID);
                    return `${parentExpr}.${node.swizzle}`;
                }
                if (node.dependsOn.length === 2) {
                    const [lID, rID] = node.dependsOn;
                    const left = this.generateExpression(generationContext, dag, lID);
                    const right = this.generateExpression(generationContext, dag, rID);
                    // Special case for modulo: use mod() function for floats in GLSL
                    if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Binary.MODULO) {
                        const leftNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, lID);
                        const rightNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, rID);
                        // If either operand is float, use mod() function
                        if (leftNode.baseType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT || rightNode.baseType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT) {
                            return `mod(${left}, ${right})`;
                        }
                        // For integers, use % operator
                        return `(${left} % ${right})`;
                    }
                    const opSym = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCodeToSymbol"][node.opCode];
                    if (useParantheses) {
                        return `(${left} ${opSym} ${right})`;
                    } else {
                        return `${left} ${opSym} ${right}`;
                    }
                }
                if (node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.LOGICAL_NOT || node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.NEGATE || node.opCode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.PLUS) {
                    const [i] = node.dependsOn;
                    const val = this.generateExpression(generationContext, dag, i);
                    const sym = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCodeToSymbol"][node.opCode];
                    return `${sym}${val}`;
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].PHI:
                // Phi nodes represent conditional merging of values
                // If this phi node has an identifier (like varying variables), use that
                if (node.identifier) {
                    return node.identifier;
                }
                // Otherwise, they should have been declared as temporary variables
                // and assigned in the appropriate branches
                if (generationContext.tempNames?.[nodeID]) {
                    return generationContext.tempNames[nodeID];
                } else {
                    // If no temp was created, this phi node only has one input
                    // so we can just use that directly
                    const validInputs = node.dependsOn.filter((id)=>id !== null);
                    if (validInputs.length > 0) {
                        return this.generateExpression(generationContext, dag, validInputs[0]);
                    } else {
                        throw new Error(`No valid inputs for node`);
                    }
                }
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])(`ASSIGNMENT nodes should not be used as expressions`);
            default:
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeTypeToName"][node.nodeType]} code generation not implemented yet`);
        }
    },
    generateBlock (blockID, strandsContext, generationContext) {
        const type = strandsContext.cfg.blockTypes[blockID];
        const handler = cfgHandlers[type] || cfgHandlers[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT];
        handler.call(cfgHandlers, blockID, strandsContext, generationContext);
    }
};
;
}),
"[project]/node_modules/p5/dist/strands/strands_transpiler.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "transpileStrandsToJS",
    ()=>transpileStrandsToJS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
;
;
;
;
let blockVarCounter = 0;
function replaceBinaryOperator(codeSource) {
    switch(codeSource){
        case '+':
            return 'add';
        case '-':
            return 'sub';
        case '*':
            return 'mult';
        case '/':
            return 'div';
        case '%':
            return 'mod';
        case '==':
        case '===':
            return 'equalTo';
        case '!=':
        case '!==':
            return 'notEqual';
        case '>':
            return 'greaterThan';
        case '>=':
            return 'greaterEqual';
        case '<':
            return 'lessThan';
        case '<=':
            return 'lessEqual';
        case '&&':
            return 'and';
        case '||':
            return 'or';
    }
}
function nodeIsUniform(ancestor) {
    return ancestor.type === 'CallExpression' && (// Global mode
    ancestor.callee?.type === 'Identifier' && ancestor.callee?.name.startsWith('uniform') || // Instance mode
    ancestor.callee?.type === 'MemberExpression' && ancestor.callee?.property.name.startsWith('uniform'));
}
function nodeIsVarying(node) {
    return node?.type === 'CallExpression' && (// Global mode
    node.callee?.type === 'Identifier' && (node.callee?.name.startsWith('varying') || node.callee?.name.startsWith('shared')) || // Instance mode
    node.callee?.type === 'MemberExpression' && (node.callee?.property.name.startsWith('varying') || node.callee?.property.name.startsWith('shared')));
}
const ASTCallbacks = {
    UnaryExpression (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        const unaryFnName = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnarySymbolToName"][node.operator];
        const standardReplacement = (node)=>{
            node.type = 'CallExpression';
            node.callee = {
                type: 'Identifier',
                name: `__p5.${unaryFnName}`
            };
            node.arguments = [
                node.argument
            ];
        };
        if (node.type === 'MemberExpression') {
            const property = node.argument.property.name;
            const swizzleSets = [
                [
                    'x',
                    'y',
                    'z',
                    'w'
                ],
                [
                    'r',
                    'g',
                    'b',
                    'a'
                ],
                [
                    's',
                    't',
                    'p',
                    'q'
                ]
            ];
            let isSwizzle = swizzleSets.some((set)=>[
                    ...property
                ].every((char)=>set.includes(char))) && node.argument.type === 'MemberExpression';
            if (isSwizzle) {
                node.type = 'MemberExpression';
                node.object = {
                    type: 'CallExpression',
                    callee: {
                        type: 'Identifier',
                        name: `__p5.${unaryFnName}`
                    },
                    arguments: [
                        node.argument.object
                    ]
                };
                node.property = {
                    type: 'Identifier',
                    name: property
                };
            } else {
                standardReplacement(node);
            }
        } else {
            standardReplacement(node);
        }
        delete node.argument;
        delete node.operator;
    },
    BreakStatement (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        node.callee = {
            type: 'Identifier',
            name: '__p5.break'
        };
        node.arguments = [];
        node.type = 'CallExpression';
    },
    VariableDeclarator (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        if (nodeIsUniform(node.init)) {
            const uniformNameLiteral = {
                type: 'Literal',
                value: node.id.name
            };
            node.init.arguments.unshift(uniformNameLiteral);
        }
        if (nodeIsVarying(node.init)) {
            const varyingNameLiteral = {
                type: 'Literal',
                value: node.id.name
            };
            node.init.arguments.unshift(varyingNameLiteral);
            _state.varyings[node.id.name] = varyingNameLiteral;
        }
    },
    Identifier (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        if (_state.varyings[node.name] && !ancestors.some((a)=>a.type === 'AssignmentExpression' && a.left === node)) {
            node.type = 'ExpressionStatement';
            node.expression = {
                type: 'CallExpression',
                callee: {
                    type: 'MemberExpression',
                    object: {
                        type: 'Identifier',
                        name: node.name
                    },
                    property: {
                        type: 'Identifier',
                        name: 'getValue'
                    }
                },
                arguments: []
            };
        }
    },
    // The callbacks for AssignmentExpression and BinaryExpression handle
    // operator overloading including +=, *= assignment expressions
    ArrayExpression (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        const original = JSON.parse(JSON.stringify(node));
        node.type = 'CallExpression';
        node.callee = {
            type: 'Identifier',
            name: '__p5.strandsNode'
        };
        node.arguments = [
            original
        ];
    },
    AssignmentExpression (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        if (node.operator !== '=') {
            const methodName = replaceBinaryOperator(node.operator.replace('=', ''));
            const rightReplacementNode = {
                type: 'CallExpression',
                callee: {
                    type: 'MemberExpression',
                    object: node.left,
                    property: {
                        type: 'Identifier',
                        name: methodName
                    }
                },
                arguments: [
                    node.right
                ]
            };
            node.operator = '=';
            node.right = rightReplacementNode;
        }
        // Handle direct varying variable assignment: myVarying = value
        if (_state.varyings[node.left.name]) {
            node.type = 'ExpressionStatement';
            node.expression = {
                type: 'CallExpression',
                callee: {
                    type: 'MemberExpression',
                    object: {
                        type: 'Identifier',
                        name: node.left.name
                    },
                    property: {
                        type: 'Identifier',
                        name: 'bridge'
                    }
                },
                arguments: [
                    node.right
                ]
            };
        } else if (node.left.type === 'MemberExpression') {
            let varyingName = null;
            // Check if it's a direct identifier: myVarying.xyz
            if (node.left.object.type === 'Identifier' && _state.varyings[node.left.object.name]) {
                varyingName = node.left.object.name;
            } else if (node.left.object.type === 'ExpressionStatement' && node.left.object.expression?.type === 'CallExpression' && node.left.object.expression.callee?.type === 'MemberExpression' && node.left.object.expression.callee.property?.name === 'getValue' && node.left.object.expression.callee.object?.type === 'Identifier' && _state.varyings[node.left.object.expression.callee.object.name]) {
                varyingName = node.left.object.expression.callee.object.name;
            }
            if (varyingName) {
                const swizzlePattern = node.left.property.name;
                node.type = 'ExpressionStatement';
                node.expression = {
                    type: 'CallExpression',
                    callee: {
                        type: 'MemberExpression',
                        object: {
                            type: 'Identifier',
                            name: varyingName
                        },
                        property: {
                            type: 'Identifier',
                            name: 'bridgeSwizzle'
                        }
                    },
                    arguments: [
                        {
                            type: 'Literal',
                            value: swizzlePattern
                        },
                        node.right
                    ]
                };
            }
        }
    },
    BinaryExpression (node, _state, ancestors) {
        // Don't convert uniform default values to node methods, as
        // they should be evaluated at runtime, not compiled.
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        // If the left hand side of an expression is one of these types,
        // we should construct a node from it.
        const unsafeTypes = [
            'Literal',
            'ArrayExpression',
            'Identifier'
        ];
        if (unsafeTypes.includes(node.left.type)) {
            const leftReplacementNode = {
                type: 'CallExpression',
                callee: {
                    type: 'Identifier',
                    name: '__p5.strandsNode'
                },
                arguments: [
                    node.left
                ]
            };
            node.left = leftReplacementNode;
        }
        // Replace the binary operator with a call expression
        // in other words a call to BaseNode.mult(), .div() etc.
        node.type = 'CallExpression';
        node.callee = {
            type: 'MemberExpression',
            object: node.left,
            property: {
                type: 'Identifier',
                name: replaceBinaryOperator(node.operator)
            }
        };
        node.arguments = [
            node.right
        ];
    },
    IfStatement (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        // Transform if statement into strandsIf() call
        // The condition is evaluated directly, not wrapped in a function
        const condition = node.test;
        // Create the then function
        const thenFunction = {
            type: 'ArrowFunctionExpression',
            params: [],
            body: node.consequent.type === 'BlockStatement' ? node.consequent : {
                type: 'BlockStatement',
                body: [
                    node.consequent
                ]
            }
        };
        // Start building the call chain: __p5.strandsIf(condition, then)
        let callExpression = {
            type: 'CallExpression',
            callee: {
                type: 'Identifier',
                name: '__p5.strandsIf'
            },
            arguments: [
                condition,
                thenFunction
            ]
        };
        // Always chain .Else() even if there's no explicit else clause
        // This ensures the conditional completes and returns phi nodes
        let elseFunction;
        if (node.alternate) {
            elseFunction = {
                type: 'ArrowFunctionExpression',
                params: [],
                body: node.alternate.type === 'BlockStatement' ? node.alternate : {
                    type: 'BlockStatement',
                    body: [
                        node.alternate
                    ]
                }
            };
        } else {
            // Create an empty else function
            elseFunction = {
                type: 'ArrowFunctionExpression',
                params: [],
                body: {
                    type: 'BlockStatement',
                    body: []
                }
            };
        }
        callExpression = {
            type: 'CallExpression',
            callee: {
                type: 'MemberExpression',
                object: callExpression,
                property: {
                    type: 'Identifier',
                    name: 'Else'
                }
            },
            arguments: [
                elseFunction
            ]
        };
        // Analyze which outer scope variables are assigned in any branch
        const assignedVars = new Set();
        const analyzeBlock = (body)=>{
            if (body.type !== 'BlockStatement') return;
            // First pass: collect variable declarations within this block
            const localVars = new Set();
            for (const stmt of body.body){
                if (stmt.type === 'VariableDeclaration') {
                    for (const decl of stmt.declarations){
                        if (decl.id.type === 'Identifier') {
                            localVars.add(decl.id.name);
                        }
                    }
                }
            }
            // Second pass: find assignments to non-local variables
            for (const stmt of body.body){
                if (stmt.type === 'ExpressionStatement' && stmt.expression.type === 'AssignmentExpression') {
                    const left = stmt.expression.left;
                    if (left.type === 'Identifier') {
                        // Direct variable assignment: x = value
                        if (!localVars.has(left.name)) {
                            assignedVars.add(left.name);
                        }
                    } else if (left.type === 'MemberExpression' && left.object.type === 'Identifier') {
                        // Property assignment: obj.prop = value
                        if (!localVars.has(left.object.name)) {
                            assignedVars.add(left.object.name);
                        }
                    }
                } else if (stmt.type === 'BlockStatement') {
                    // Recursively analyze nested block statements
                    analyzeBlock(stmt);
                }
            }
        };
        // Analyze all branches for assignments to outer scope variables
        analyzeBlock(thenFunction.body);
        analyzeBlock(elseFunction.body);
        if (assignedVars.size > 0) {
            // Add copying, reference replacement, and return statements to branch functions
            const addCopyingAndReturn = (functionBody, varsToReturn)=>{
                if (functionBody.type === 'BlockStatement') {
                    // Create temporary variables and copy statements
                    const tempVarMap = new Map(); // original name -> temp name
                    const copyStatements = [];
                    for (const varName of varsToReturn){
                        const tempName = `__copy_${varName}_${blockVarCounter++}`;
                        tempVarMap.set(varName, tempName);
                        // let tempName = originalVar.copy()
                        copyStatements.push({
                            type: 'VariableDeclaration',
                            declarations: [
                                {
                                    type: 'VariableDeclarator',
                                    id: {
                                        type: 'Identifier',
                                        name: tempName
                                    },
                                    init: {
                                        type: 'CallExpression',
                                        callee: {
                                            type: 'MemberExpression',
                                            object: {
                                                type: 'Identifier',
                                                name: varName
                                            },
                                            property: {
                                                type: 'Identifier',
                                                name: 'copy'
                                            },
                                            computed: false
                                        },
                                        arguments: []
                                    }
                                }
                            ],
                            kind: 'let'
                        });
                    }
                    // Replace all references to original variables with temp variables
                    // and wrap literal assignments in strandsNode calls
                    const replaceReferences = (node)=>{
                        if (!node || typeof node !== 'object') return;
                        if (node.type === 'Identifier' && tempVarMap.has(node.name)) {
                            node.name = tempVarMap.get(node.name);
                        } else if (node.type === 'MemberExpression' && node.object.type === 'Identifier' && tempVarMap.has(node.object.name)) {
                            node.object.name = tempVarMap.get(node.object.name);
                        }
                        // Handle literal assignments to temp variables
                        if (node.type === 'AssignmentExpression' && node.left.type === 'Identifier' && tempVarMap.has(node.left.name) && (node.right.type === 'Literal' || node.right.type === 'ArrayExpression')) {
                            // Wrap the right hand side in a strandsNode call to make sure
                            // it's not just a literal and has a type
                            node.right = {
                                type: 'CallExpression',
                                callee: {
                                    type: 'Identifier',
                                    name: '__p5.strandsNode'
                                },
                                arguments: [
                                    node.right
                                ]
                            };
                        }
                        // Recursively process all properties
                        for(const key in node){
                            if (node.hasOwnProperty(key) && key !== 'parent') {
                                if (Array.isArray(node[key])) {
                                    node[key].forEach(replaceReferences);
                                } else if (typeof node[key] === 'object') {
                                    replaceReferences(node[key]);
                                }
                            }
                        }
                    };
                    // Apply reference replacement to all statements
                    functionBody.body.forEach(replaceReferences);
                    // Insert copy statements at the beginning
                    functionBody.body.unshift(...copyStatements);
                    // Add return statement with temp variable names
                    const returnObj = {
                        type: 'ObjectExpression',
                        properties: Array.from(varsToReturn).map((varName)=>({
                                type: 'Property',
                                key: {
                                    type: 'Identifier',
                                    name: varName
                                },
                                value: {
                                    type: 'Identifier',
                                    name: tempVarMap.get(varName)
                                },
                                kind: 'init',
                                computed: false,
                                shorthand: false
                            }))
                    };
                    functionBody.body.push({
                        type: 'ReturnStatement',
                        argument: returnObj
                    });
                }
            };
            addCopyingAndReturn(thenFunction.body, assignedVars);
            addCopyingAndReturn(elseFunction.body, assignedVars);
            // Create a block variable to capture the return value
            const blockVar = `__block_${blockVarCounter++}`;
            // Replace with a block statement
            const statements = [];
            // Make sure every assigned variable starts as a node
            for (const varName of assignedVars){
                statements.push({
                    type: 'ExpressionStatement',
                    expression: {
                        type: 'AssignmentExpression',
                        operator: '=',
                        left: {
                            type: 'Identifier',
                            name: varName
                        },
                        right: {
                            type: 'CallExpression',
                            callee: {
                                type: 'Identifier',
                                name: '__p5.strandsNode'
                            },
                            arguments: [
                                {
                                    type: 'Identifier',
                                    name: varName
                                }
                            ]
                        }
                    }
                });
            }
            statements.push({
                type: 'VariableDeclaration',
                declarations: [
                    {
                        type: 'VariableDeclarator',
                        id: {
                            type: 'Identifier',
                            name: blockVar
                        },
                        init: callExpression
                    }
                ],
                kind: 'const'
            });
            // 2. Assignments for each modified variable
            for (const varName of assignedVars){
                statements.push({
                    type: 'ExpressionStatement',
                    expression: {
                        type: 'AssignmentExpression',
                        operator: '=',
                        left: {
                            type: 'Identifier',
                            name: varName
                        },
                        right: {
                            type: 'MemberExpression',
                            object: {
                                type: 'Identifier',
                                name: blockVar
                            },
                            property: {
                                type: 'Identifier',
                                name: varName
                            },
                            computed: false
                        }
                    }
                });
            }
            // Replace the if statement with a block statement
            node.type = 'BlockStatement';
            node.body = statements;
        } else {
            // No assignments, just replace with the call expression
            node.type = 'ExpressionStatement';
            node.expression = callExpression;
        }
        delete node.test;
        delete node.consequent;
        delete node.alternate;
    },
    UpdateExpression (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        // Transform ++var, var++, --var, var-- into assignment expressions
        let operator;
        if (node.operator === '++') {
            operator = '+';
        } else if (node.operator === '--') {
            operator = '-';
        } else {
            return; // Unknown update operator
        }
        // Convert to: var = var + 1 or var = var - 1
        const assignmentExpr = {
            type: 'AssignmentExpression',
            operator: '=',
            left: node.argument,
            right: {
                type: 'BinaryExpression',
                operator: operator,
                left: node.argument,
                right: {
                    type: 'Literal',
                    value: 1
                }
            }
        };
        // Replace the update expression with the assignment expression
        Object.assign(node, assignmentExpr);
        delete node.prefix;
        this.BinaryExpression(node.right, _state, [
            ...ancestors,
            node
        ]);
        this.AssignmentExpression(node, _state, ancestors);
    },
    ForStatement (node, _state, ancestors) {
        if (ancestors.some(nodeIsUniform)) {
            return;
        }
        // Transform for statement into strandsFor() call
        // for (init; test; update) body -> strandsFor(initCb, conditionCb, updateCb, bodyCb, initialVars)
        // Create the initial callback from the for loop's init
        let initialFunction;
        if (node.init && node.init.type === 'VariableDeclaration') {
            // Handle: for (let i = 0; ...)
            const declaration = node.init.declarations[0];
            let initValue = declaration.init;
            const initAst = {
                body: [
                    {
                        type: 'ExpressionStatement',
                        expression: initValue
                    }
                ]
            };
            initValue = initAst.body[0].expression;
            initialFunction = {
                type: 'ArrowFunctionExpression',
                params: [],
                body: {
                    type: 'BlockStatement',
                    body: [
                        {
                            type: 'ReturnStatement',
                            argument: initValue
                        }
                    ]
                }
            };
        } else {
            // Handle other cases - return a default value
            initialFunction = {
                type: 'ArrowFunctionExpression',
                params: [],
                body: {
                    type: 'BlockStatement',
                    body: [
                        {
                            type: 'ReturnStatement',
                            argument: {
                                type: 'Literal',
                                value: 0
                            }
                        }
                    ]
                }
            };
        }
        // Create the condition callback
        let conditionBody = node.test || {
            type: 'Literal',
            value: true
        };
        // Replace loop variable references with the parameter
        if (node.init?.type === 'VariableDeclaration') {
            const loopVarName = node.init.declarations[0].id.name;
            conditionBody = this.replaceIdentifierReferences(conditionBody, loopVarName, 'loopVar');
        }
        const conditionAst = {
            body: [
                {
                    type: 'ExpressionStatement',
                    expression: conditionBody
                }
            ]
        };
        conditionBody = conditionAst.body[0].expression;
        const conditionFunction = {
            type: 'ArrowFunctionExpression',
            params: [
                {
                    type: 'Identifier',
                    name: 'loopVar'
                }
            ],
            body: conditionBody
        };
        // Create the update callback
        let updateFunction;
        if (node.update) {
            let updateExpr = node.update;
            // Replace loop variable references with the parameter
            if (node.init?.type === 'VariableDeclaration') {
                const loopVarName = node.init.declarations[0].id.name;
                updateExpr = this.replaceIdentifierReferences(updateExpr, loopVarName, 'loopVar');
            }
            const updateAst = {
                body: [
                    {
                        type: 'ExpressionStatement',
                        expression: updateExpr
                    }
                ]
            };
            updateExpr = updateAst.body[0].expression;
            updateFunction = {
                type: 'ArrowFunctionExpression',
                params: [
                    {
                        type: 'Identifier',
                        name: 'loopVar'
                    }
                ],
                body: {
                    type: 'BlockStatement',
                    body: [
                        {
                            type: 'ReturnStatement',
                            argument: updateExpr
                        }
                    ]
                }
            };
        } else {
            updateFunction = {
                type: 'ArrowFunctionExpression',
                params: [
                    {
                        type: 'Identifier',
                        name: 'loopVar'
                    }
                ],
                body: {
                    type: 'BlockStatement',
                    body: [
                        {
                            type: 'ReturnStatement',
                            argument: {
                                type: 'Identifier',
                                name: 'loopVar'
                            }
                        }
                    ]
                }
            };
        }
        // Create the body callback
        let bodyBlock = node.body.type === 'BlockStatement' ? node.body : {
            type: 'BlockStatement',
            body: [
                node.body
            ]
        };
        // Replace loop variable references in the body
        if (node.init?.type === 'VariableDeclaration') {
            const loopVarName = node.init.declarations[0].id.name;
            bodyBlock = this.replaceIdentifierReferences(bodyBlock, loopVarName, 'loopVar');
        }
        const bodyFunction = {
            type: 'ArrowFunctionExpression',
            params: [
                {
                    type: 'Identifier',
                    name: 'loopVar'
                },
                {
                    type: 'Identifier',
                    name: 'vars'
                }
            ],
            body: bodyBlock
        };
        // Analyze which outer scope variables are assigned in the loop body
        const assignedVars = new Set();
        const analyzeBlock = (body, parentLocalVars = new Set())=>{
            if (body.type !== 'BlockStatement') return;
            // First pass: collect variable declarations within this block
            const localVars = new Set([
                ...parentLocalVars
            ]);
            for (const stmt of body.body){
                if (stmt.type === 'VariableDeclaration') {
                    for (const decl of stmt.declarations){
                        if (decl.id.type === 'Identifier') {
                            localVars.add(decl.id.name);
                        }
                    }
                }
            }
            // Second pass: find assignments to non-local variables
            for (const stmt of body.body){
                if (stmt.type === 'ExpressionStatement' && stmt.expression.type === 'AssignmentExpression') {
                    const left = stmt.expression.left;
                    if (left.type === 'Identifier') {
                        // Direct variable assignment: x = value
                        if (!localVars.has(left.name)) {
                            assignedVars.add(left.name);
                        }
                    } else if (left.type === 'MemberExpression' && left.object.type === 'Identifier') {
                        // Property assignment: obj.prop = value (includes swizzles)
                        if (!localVars.has(left.object.name)) {
                            assignedVars.add(left.object.name);
                        }
                    }
                } else if (stmt.type === 'BlockStatement') {
                    // Recursively analyze nested block statements, passing down local vars
                    analyzeBlock(stmt, localVars);
                }
            }
        };
        analyzeBlock(bodyFunction.body);
        if (assignedVars.size > 0) {
            // Add copying, reference replacement, and return statements similar to if statements
            const addCopyingAndReturn = (functionBody, varsToReturn)=>{
                if (functionBody.type === 'BlockStatement') {
                    const tempVarMap = new Map();
                    const copyStatements = [];
                    for (const varName of varsToReturn){
                        const tempName = `__copy_${varName}_${blockVarCounter++}`;
                        tempVarMap.set(varName, tempName);
                        copyStatements.push({
                            type: 'VariableDeclaration',
                            declarations: [
                                {
                                    type: 'VariableDeclarator',
                                    id: {
                                        type: 'Identifier',
                                        name: tempName
                                    },
                                    init: {
                                        type: 'CallExpression',
                                        callee: {
                                            type: 'MemberExpression',
                                            object: {
                                                type: 'MemberExpression',
                                                object: {
                                                    type: 'Identifier',
                                                    name: 'vars'
                                                },
                                                property: {
                                                    type: 'Identifier',
                                                    name: varName
                                                },
                                                computed: false
                                            },
                                            property: {
                                                type: 'Identifier',
                                                name: 'copy'
                                            },
                                            computed: false
                                        },
                                        arguments: []
                                    }
                                }
                            ],
                            kind: 'let'
                        });
                    }
                    // Replace references to original variables with temp variables
                    const replaceReferences = (node)=>{
                        if (!node || typeof node !== 'object') return;
                        if (node.type === 'Identifier' && tempVarMap.has(node.name)) {
                            node.name = tempVarMap.get(node.name);
                        }
                        for(const key in node){
                            if (node.hasOwnProperty(key) && key !== 'parent') {
                                if (Array.isArray(node[key])) {
                                    node[key].forEach(replaceReferences);
                                } else if (typeof node[key] === 'object') {
                                    replaceReferences(node[key]);
                                }
                            }
                        }
                    };
                    functionBody.body.forEach(replaceReferences);
                    functionBody.body.unshift(...copyStatements);
                    // Add return statement
                    const returnObj = {
                        type: 'ObjectExpression',
                        properties: Array.from(varsToReturn).map((varName)=>({
                                type: 'Property',
                                key: {
                                    type: 'Identifier',
                                    name: varName
                                },
                                value: {
                                    type: 'Identifier',
                                    name: tempVarMap.get(varName)
                                },
                                kind: 'init',
                                computed: false,
                                shorthand: false
                            }))
                    };
                    functionBody.body.push({
                        type: 'ReturnStatement',
                        argument: returnObj
                    });
                }
            };
            addCopyingAndReturn(bodyFunction.body, assignedVars);
            // Create block variable and assignments similar to if statements
            const blockVar = `__block_${blockVarCounter++}`;
            const statements = [];
            // Create initial vars object from assigned variables
            const initialVarsProperties = [];
            for (const varName of assignedVars){
                initialVarsProperties.push({
                    type: 'Property',
                    key: {
                        type: 'Identifier',
                        name: varName
                    },
                    value: {
                        type: 'CallExpression',
                        callee: {
                            type: 'Identifier',
                            name: '__p5.strandsNode'
                        },
                        arguments: [
                            {
                                type: 'Identifier',
                                name: varName
                            }
                        ]
                    },
                    kind: 'init',
                    method: false,
                    shorthand: false,
                    computed: false
                });
            }
            const initialVarsObject = {
                type: 'ObjectExpression',
                properties: initialVarsProperties
            };
            // Create the strandsFor call
            const callExpression = {
                type: 'CallExpression',
                callee: {
                    type: 'Identifier',
                    name: '__p5.strandsFor'
                },
                arguments: [
                    initialFunction,
                    conditionFunction,
                    updateFunction,
                    bodyFunction,
                    initialVarsObject
                ]
            };
            statements.push({
                type: 'VariableDeclaration',
                declarations: [
                    {
                        type: 'VariableDeclarator',
                        id: {
                            type: 'Identifier',
                            name: blockVar
                        },
                        init: callExpression
                    }
                ],
                kind: 'const'
            });
            // Add assignments back to original variables
            for (const varName of assignedVars){
                statements.push({
                    type: 'ExpressionStatement',
                    expression: {
                        type: 'AssignmentExpression',
                        operator: '=',
                        left: {
                            type: 'Identifier',
                            name: varName
                        },
                        right: {
                            type: 'MemberExpression',
                            object: {
                                type: 'Identifier',
                                name: blockVar
                            },
                            property: {
                                type: 'Identifier',
                                name: varName
                            },
                            computed: false
                        }
                    }
                });
            }
            node.type = 'BlockStatement';
            node.body = statements;
        } else {
            // No assignments, just replace with call expression
            node.type = 'ExpressionStatement';
            node.expression = {
                type: 'CallExpression',
                callee: {
                    type: 'Identifier',
                    name: '__p5.strandsFor'
                },
                arguments: [
                    initialFunction,
                    conditionFunction,
                    updateFunction,
                    bodyFunction,
                    {
                        type: 'ObjectExpression',
                        properties: []
                    }
                ]
            };
        }
        delete node.init;
        delete node.test;
        delete node.update;
    },
    // Helper method to replace identifier references in AST nodes
    replaceIdentifierReferences (node, oldName, newName) {
        if (!node || typeof node !== 'object') return node;
        const replaceInNode = (n)=>{
            if (!n || typeof n !== 'object') return n;
            if (n.type === 'Identifier' && n.name === oldName) {
                return {
                    ...n,
                    name: newName
                };
            }
            // Create a copy and recursively process properties
            const newNode = {
                ...n
            };
            for(const key in n){
                if (n.hasOwnProperty(key) && key !== 'parent') {
                    if (Array.isArray(n[key])) {
                        newNode[key] = n[key].map(replaceInNode);
                    } else if (typeof n[key] === 'object') {
                        newNode[key] = replaceInNode(n[key]);
                    }
                }
            }
            return newNode;
        };
        return replaceInNode(node);
    }
};
function transpileStrandsToJS(p5, sourceString, srcLocations, scope) {
    const ast = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(sourceString, {
        ecmaVersion: 2021,
        locations: srcLocations
    });
    // First pass: transform everything except if/for statements using normal ancestor traversal
    const nonControlFlowCallbacks = {
        ...ASTCallbacks
    };
    delete nonControlFlowCallbacks.IfStatement;
    delete nonControlFlowCallbacks.ForStatement;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ancestor"])(ast, nonControlFlowCallbacks, undefined, {
        varyings: {}
    });
    // Second pass: transform if/for statements in post-order using recursive traversal
    const postOrderControlFlowTransform = {
        IfStatement (node, state, c) {
            // First recursively process children
            if (node.test) c(node.test, state);
            if (node.consequent) c(node.consequent, state);
            if (node.alternate) c(node.alternate, state);
            // Then apply the transformation to this node
            ASTCallbacks.IfStatement(node, state, []);
        },
        ForStatement (node, state, c) {
            // First recursively process children
            if (node.init) c(node.init, state);
            if (node.test) c(node.test, state);
            if (node.update) c(node.update, state);
            if (node.body) c(node.body, state);
            // Then apply the transformation to this node
            ASTCallbacks.ForStatement(node, state, []);
        }
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recursive"])(ast, {
        varyings: {}
    }, postOrderControlFlowTransform);
    const transpiledSource = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].generate(ast);
    const scopeKeys = Object.keys(scope);
    const internalStrandsCallback = new Function(// Create a parameter called __p5, not just p5, because users of instance mode
    // may pass in a variable called p5 as a scope variable. If we rely on a variable called
    // p5, then the scope variable called p5 might accidentally override internal function
    // calls to p5 static methods.
    '__p5', ...scopeKeys, transpiledSource.slice(transpiledSource.indexOf('{') + 1, transpiledSource.lastIndexOf('}')).replaceAll(';', ''));
    return ()=>internalStrandsCallback(p5, ...scopeKeys.map((key)=>scope[key]));
}
;
}),
"[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addEdge",
    ()=>addEdge,
    "createBasicBlock",
    ()=>createBasicBlock,
    "createControlFlowGraph",
    ()=>createControlFlowGraph,
    "getBlockDataFromID",
    ()=>getBlockDataFromID,
    "popBlock",
    ()=>popBlock,
    "printBlockData",
    ()=>printBlockData,
    "pushBlock",
    ()=>pushBlock,
    "pushBlockForModification",
    ()=>pushBlockForModification,
    "recordInBasicBlock",
    ()=>recordInBasicBlock,
    "sortCFG",
    ()=>sortCFG
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
;
;
// Todo: remove edges to simplify. Block order is always ordered already.
function createControlFlowGraph() {
    return {
        // graph structure
        blockTypes: [],
        incomingEdges: [],
        outgoingEdges: [],
        blockInstructions: [],
        // runtime data for constructing graph
        nextID: 0,
        blockStack: [],
        blockOrder: [],
        blockConditions: {},
        currentBlock: -1
    };
}
function pushBlock(graph, blockID) {
    graph.blockStack.push(blockID);
    graph.blockOrder.push(blockID);
    graph.currentBlock = blockID;
}
function popBlock(graph) {
    graph.blockStack.pop();
    const len = graph.blockStack.length;
    graph.currentBlock = graph.blockStack[len - 1];
}
function pushBlockForModification(graph, blockID) {
    graph.blockStack.push(blockID);
    graph.currentBlock = blockID;
}
function createBasicBlock(graph, blockType) {
    const id = graph.nextID++;
    graph.blockTypes[id] = blockType;
    graph.incomingEdges[id] = [];
    graph.outgoingEdges[id] = [];
    graph.blockInstructions[id] = [];
    return id;
}
function addEdge(graph, from, to) {
    graph.outgoingEdges[from].push(to);
    graph.incomingEdges[to].push(from);
}
function recordInBasicBlock(graph, blockID, nodeID) {
    if (nodeID === undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])('undefined nodeID in `recordInBasicBlock()`');
    }
    if (blockID === undefined) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["internalError"])('undefined blockID in `recordInBasicBlock()');
    }
    graph.blockInstructions[blockID] = graph.blockInstructions[blockID] || [];
    graph.blockInstructions[blockID].push(nodeID);
}
function getBlockDataFromID(graph, id) {
    return {
        id,
        blockType: graph.blockTypes[id],
        incomingEdges: graph.incomingEdges[id],
        outgoingEdges: graph.outgoingEdges[id],
        blockInstructions: graph.blockInstructions[id]
    };
}
function printBlockData(graph, id) {
    const block = getBlockDataFromID(graph, id);
    block.blockType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockTypeToName"][block.blockType];
    console.log(block);
}
function sortCFG(adjacencyList, start) {
    const visited = new Set();
    const postOrder = [];
    function dfs(v) {
        if (visited.has(v)) {
            return;
        }
        visited.add(v);
        for (let w of adjacencyList[v].sort((a, b)=>b - a) || []){
            dfs(w);
        }
        postOrder.push(v);
    }
    dfs(start);
    return postOrder.reverse();
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_codegen.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "generateShaderCode",
    ()=>generateShaderCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
;
;
;
function generateShaderCode(strandsContext) {
    const { cfg, backend, vertexDeclarations, fragmentDeclarations } = strandsContext;
    const hooksObj = {
        uniforms: {}
    };
    for (const { name, typeInfo, defaultValue } of strandsContext.uniforms){
        const declaration = backend.generateUniformDeclaration(name, typeInfo);
        hooksObj.uniforms[declaration] = defaultValue;
    }
    for (const { hookType, rootNodeID, entryBlockID, shaderContext } of strandsContext.hooks){
        const generationContext = {
            indent: 1,
            codeLines: [],
            write (line) {
                this.codeLines.push('  '.repeat(this.indent) + line);
            },
            tempNames: {},
            declarations: [],
            nextTempID: 0,
            visitedNodes: new Set(),
            shaderContext,
            strandsContext
        };
        const blocks = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sortCFG"])(cfg.outgoingEdges, entryBlockID);
        for (const blockID of blocks){
            backend.generateBlock(blockID, strandsContext, generationContext);
        }
        // Process any unvisited global assignments to ensure side effects are generated
        for (const assignmentNodeID of strandsContext.globalAssignments){
            if (!generationContext.visitedNodes.has(assignmentNodeID)) {
                // This assignment hasn't been visited yet, so we need to generate it
                backend.generateAssignment(generationContext, strandsContext.dag, assignmentNodeID);
                generationContext.visitedNodes.add(assignmentNodeID);
            }
        }
        // Reset global assignments for next hook
        strandsContext.globalAssignments = [];
        const firstLine = backend.hookEntry(hookType);
        let returnType = hookType.returnType.properties ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structType"])(hookType.returnType) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeInfoFromGLSLName"][hookType.returnType.typeName];
        backend.generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType);
        hooksObj[`${hookType.returnType.typeName} ${hookType.name}`] = [
            firstLine,
            ...generationContext.codeLines,
            '}'
        ].join('\n');
    }
    // Finalize shared variable declarations based on usage
    if (strandsContext.sharedVariables) {
        for (const [varName, varInfo] of strandsContext.sharedVariables){
            if (varInfo.usedInVertex && varInfo.usedInFragment) {
                // Used in both shaders - declare as varying
                vertexDeclarations.add(`OUT ${varInfo.typeInfo.fnName} ${varName};`);
                fragmentDeclarations.add(`IN ${varInfo.typeInfo.fnName} ${varName};`);
            } else if (varInfo.usedInVertex) {
                // Only used in vertex shader - declare as local variable
                vertexDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);
            } else if (varInfo.usedInFragment) {
                // Only used in fragment shader - declare as local variable
                fragmentDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);
            }
        // If not used anywhere, don't declare it
        }
    }
    hooksObj.vertexDeclarations = [
        ...vertexDeclarations
    ].join('\n');
    hooksObj.fragmentDeclarations = [
        ...fragmentDeclarations
    ].join('\n');
    return hooksObj;
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "strandsBuiltinFunctions",
    ()=>strandsBuiltinFunctions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
;
// Need the .js extension because we also import this from a Node script.
// Try to keep this file minimal because of that.
// GLSL Built in functions
// https://docs.gl/el3/abs
const builtInGLSLFunctions = {
    //////////// Trigonometry //////////
    acos: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    acosh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    asin: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    asinh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    atan: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    atanh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    cos: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    cosh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    degrees: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    radians: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    sin: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    sinh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    tan: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    tanh: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    ////////// Mathematics //////////
    abs: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: true
        }
    ],
    ceil: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    clamp: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].int1,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].int1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: false
        }
    ],
    dFdx: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    dFdy: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    exp: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    exp2: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    floor: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    fma: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    fract: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    fwidth: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    inversesqrt: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    // "isinf": [{}],
    // "isnan": [{}],
    log: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    log2: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    max: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].int1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: true
        }
    ],
    min: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].int1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: true
        }
    ],
    mix: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    mod: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    // "modf": [{}],
    pow: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    round: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    roundEven: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    sign: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
            isp5Function: false
        }
    ],
    smoothstep: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    sqrt: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    step: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    trunc: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    ////////// Vector //////////
    cross: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float3,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float3
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float3,
            isp5Function: true
        }
    ],
    distance: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
            isp5Function: true
        }
    ],
    dot: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
            isp5Function: true
        }
    ],
    equal: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        }
    ],
    faceforward: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    length: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1,
            isp5Function: false
        }
    ],
    normalize: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: true
        }
    ],
    notEqual: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].INT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        },
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].BOOL,
            isp5Function: false
        }
    ],
    reflect: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    refract: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GenType"].FLOAT,
            isp5Function: false
        }
    ],
    ////////// Texture sampling //////////
    texture: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].sampler2D,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float2
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float4,
            isp5Function: true
        }
    ],
    getTexture: [
        {
            params: [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].sampler2D,
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float2
            ],
            returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float4,
            isp5Function: true
        }
    ]
};
const strandsBuiltinFunctions = {
    ...builtInGLSLFunctions
};
;
}),
"[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createPhiNode",
    ()=>createPhiNode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
;
;
;
;
function createPhiNode(strandsContext, phiInputs, varName) {
    // Determine the proper dimension and baseType from the inputs
    const validInputs = phiInputs.filter((input)=>input.value.id !== null);
    if (validInputs.length === 0) {
        throw new Error(`No valid inputs for phi node for variable ${varName}`);
    }
    // Get dimension and baseType from first valid input
    const firstInput = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(strandsContext.dag, validInputs[0].value.id);
    const dimension = firstInput.dimension;
    const baseType = firstInput.baseType;
    const nodeData = {
        nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].PHI,
        dimension,
        baseType,
        dependsOn: phiInputs.map((input)=>input.value.id).filter((id)=>id !== null),
        phiBlocks: phiInputs.map((input)=>input.blockId)
    };
    const id = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(strandsContext.dag, nodeData);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(strandsContext.cfg, strandsContext.cfg.currentBlock, id);
    return {
        id,
        dimension,
        baseType
    };
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_conditionals.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StrandsConditional",
    ()=>StrandsConditional
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
class StrandsConditional {
    constructor(strandsContext, condition, branchCallback){
        // Condition must be a node...
        this.branches = [
            {
                condition,
                branchCallback,
                blockType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_BODY
            }
        ];
        this.ctx = strandsContext;
    }
    ElseIf(condition, branchCallback) {
        this.branches.push({
            condition,
            branchCallback,
            blockType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_BODY
        });
        return this;
    }
    Else(branchCallback = ()=>({})) {
        this.branches.push({
            condition: null,
            branchCallback,
            blockType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_BODY
        });
        const phiNodes = buildConditional(this.ctx, this);
        const assignments = {};
        for (const [varName, phiNode] of Object.entries(phiNodes)){
            assignments[varName] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(phiNode.id, phiNode.dimension, this.ctx);
        }
        return assignments;
    }
}
function buildConditional(strandsContext, conditional) {
    const cfg = strandsContext.cfg;
    const branches = conditional.branches;
    const mergeBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].MERGE);
    const results = [];
    const branchEndBlocks = [];
    const mergedAssignments = {};
    const phiBlockDependencies = {};
    // Create a BRANCH block to handle phi node declarations
    const branchBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].BRANCH);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, cfg.currentBlock, branchBlock);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, branchBlock, mergeBlock);
    let previousBlock = branchBlock;
    for(let i = 0; i < branches.length; i++){
        const { condition, branchCallback, blockType } = branches[i];
        if (condition !== null) {
            const conditionBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_COND);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, previousBlock, conditionBlock);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, conditionBlock);
            cfg.blockConditions[conditionBlock] = condition.id;
            previousBlock = conditionBlock;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        } else {
            const elseCondBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].ELSE_COND);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, previousBlock, elseCondBlock);
            previousBlock = elseCondBlock;
        }
        const scopeStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_START);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, previousBlock, scopeStartBlock);
        const branchContentBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, blockType);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeStartBlock, branchContentBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, branchContentBlock);
        const branchResults = branchCallback();
        for(const key in branchResults){
            if (!phiBlockDependencies[key]) {
                phiBlockDependencies[key] = [
                    {
                        value: branchResults[key],
                        blockId: branchContentBlock
                    }
                ];
            } else {
                phiBlockDependencies[key].push({
                    value: branchResults[key],
                    blockId: branchContentBlock
                });
            }
        }
        results.push(branchResults);
        // Create BRANCH_END block for phi assignments
        const branchEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, cfg.currentBlock, branchEndBlock);
        branchEndBlocks.push(branchEndBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        const scopeEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_END);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, branchEndBlock, scopeEndBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeEndBlock, mergeBlock);
        previousBlock = scopeStartBlock;
    }
    // Push the branch block for modification to avoid changing the ordering
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, branchBlock);
    for(const key in phiBlockDependencies){
        mergedAssignments[key] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createPhiNode"])(strandsContext, phiBlockDependencies[key], key);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
    for(let i = 0; i < results.length; i++){
        const branchResult = results[i];
        const branchEndBlockID = branchEndBlocks[i];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, branchEndBlockID);
        for(const key in branchResult){
            if (mergedAssignments[key]) {
                // Create an assignment statement: phiNode = branchResult[key]
                const phiNodeID = mergedAssignments[key].id;
                const sourceNodeID = branchResult[key].id;
                // Create an assignment operation node
                // Use dependsOn[0] for phiNodeID and dependsOn[1] for sourceNodeID
                // This represents: dependsOn[0] = dependsOn[1] (phiNode = sourceNode)
                const assignmentNode = {
                    nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                    dependsOn: [
                        phiNodeID,
                        sourceNodeID
                    ],
                    phiBlocks: []
                };
                const assignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(strandsContext.dag, assignmentNode);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, branchEndBlockID, assignmentID);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
    }
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, mergeBlock);
    return mergedAssignments;
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_for.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StrandsFor",
    ()=>StrandsFor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
class StrandsFor {
    constructor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars){
        this.strandsContext = strandsContext;
        this.initialCb = initialCb;
        this.conditionCb = conditionCb;
        this.updateCb = updateCb;
        this.bodyCb = bodyCb;
        this.initialVars = initialVars;
    }
    build() {
        const cfg = this.strandsContext.cfg;
        const mergeBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].MERGE);
        // Create a BRANCH block to handle phi node declarations
        const branchBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].BRANCH);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, cfg.currentBlock, branchBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, branchBlock, mergeBlock);
        // Initialize loop variable phi node
        const { initialVar, phiNode } = this.initializeLoopVariable(cfg, branchBlock);
        // Execute condition and update callbacks to get nodes for analysis
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, cfg.currentBlock);
        const loopVarNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(phiNode.id, phiNode.dimension, this.strandsContext);
        const conditionNode = this.conditionCb(loopVarNode);
        const updateResult = this.updateCb(loopVarNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // Check if loop has bounded iteration count
        const isBounded = this.loopIsBounded(initialVar, conditionNode, updateResult);
        if (isBounded) {
            this.buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
        } else {
            this.buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
        }
        // Update the phi nodes created in buildBoundedLoop with actual body results
        const finalPhiNodes = this.phiNodesForBody;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, branchBlock);
        for (const [varName, resultNode] of Object.entries(this.bodyResults)){
            if (varName !== 'loopVar' && finalPhiNodes[varName]) {
                // Update the phi node's second input to use the actual body result
                const phiNodeID = finalPhiNodes[varName].id;
                const phiNodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(this.strandsContext.dag, phiNodeID);
                // Update the dependsOn array to include the actual body result
                if (phiNodeData.dependsOn.length > 1) {
                    phiNodeData.dependsOn[1] = resultNode.id;
                }
                if (phiNodeData.phiInputs && phiNodeData.phiInputs.length > 1) {
                    phiNodeData.phiInputs[1].value = resultNode;
                }
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // Create assignment nodes in the branch block for initial values
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, branchBlock);
        for (const [varName, initialValueNode] of Object.entries(this.initialVars)){
            if (varName !== 'loopVar' && finalPhiNodes[varName]) {
                // Create an assignment statement: phiNode = initialValue
                const phiNodeID = finalPhiNodes[varName].id;
                const sourceNodeID = initialValueNode.id;
                // Create an assignment operation node for the initial value
                const assignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                    nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                    dependsOn: [
                        phiNodeID,
                        sourceNodeID
                    ],
                    phiBlocks: []
                });
                const assignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, assignmentNode);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, branchBlock, assignmentID);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // Create assignment nodes in the final block after body execution (following conditionals pattern)
        // After executing the body callback, cfg.currentBlock should be the final block in the control flow
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, this.finalBodyBlock);
        for (const [varName, resultNode] of Object.entries(this.bodyResults)){
            if (varName !== 'loopVar' && finalPhiNodes[varName]) {
                // Create an assignment statement: phiNode = bodyResult[varName]
                const phiNodeID = finalPhiNodes[varName].id;
                const sourceNodeID = resultNode.id;
                // Create an assignment operation node
                // Use dependsOn[0] for phiNodeID and dependsOn[1] for sourceNodeID
                // This represents: dependsOn[0] = dependsOn[1] (phiNode = sourceNode)
                const assignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                    nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                    dependsOn: [
                        phiNodeID,
                        sourceNodeID
                    ],
                    phiBlocks: []
                });
                const assignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, assignmentNode);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, this.finalBodyBlock, assignmentID);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // Convert phi nodes to StrandsNodes for the final result
        const finalBodyResults = {};
        for (const [varName, phiNode] of Object.entries(finalPhiNodes)){
            finalBodyResults[varName] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(phiNode.id, phiNode.dimension, this.strandsContext);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, mergeBlock);
        return finalBodyResults;
    }
    buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
        // For bounded loops, create FOR block with three statements: init, condition, update
        const forBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].FOR);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, branchBlock, forBlock);
        // Now add only the specific nodes we need to the FOR block
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, forBlock);
        // 1. Init statement - assign initial value to phi node (or empty if no initializer)
        if (initialVar) {
            const initAssignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                dependsOn: [
                    phiNode.id,
                    initialVar.id
                ],
                phiBlocks: []
            });
            const initAssignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, initAssignmentNode);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, initAssignmentID);
        }
        // 2. Condition statement - wrap in ExpressionStatement to force generation
        const conditionStatementNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
            statementType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EXPRESSION,
            dependsOn: [
                conditionNode.id
            ],
            phiBlocks: []
        });
        const conditionStatementID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, conditionStatementNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, conditionStatementID);
        // 3. Update statement - create assignment of update result to phi node
        const updateAssignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
            dependsOn: [
                phiNode.id,
                updateResult.id
            ],
            phiBlocks: []
        });
        const updateAssignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, updateAssignmentNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, updateAssignmentID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // Verify we have the right number of statements (2 or 3 depending on initializer)
        const instructions = cfg.blockInstructions[forBlock] || [];
        const expectedLength = initialVar ? 3 : 2;
        if (instructions.length !== expectedLength) {
            throw new Error(`FOR block must have exactly ${expectedLength} statements, got ${instructions.length}`);
        }
        const scopeStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_START);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, forBlock, scopeStartBlock);
        const bodyBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        this.bodyBlock = bodyBlock;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeStartBlock, bodyBlock);
        this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
        const scopeEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_END);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, bodyBlock, scopeEndBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeEndBlock, mergeBlock);
    }
    buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
        // For unbounded loops, create FOR block with infinite loop and break condition
        const forBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].FOR);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, branchBlock, forBlock);
        // Create FOR block with three empty statements for for(;;) syntax
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, forBlock);
        // 1. Init statement - initialize loop variable or empty
        if (initialVar) {
            const initAssignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
                dependsOn: [
                    phiNode.id,
                    initialVar.id
                ],
                phiBlocks: []
            });
            const initAssignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, initAssignmentNode);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, initAssignmentID);
        } else {
            // Create empty statement for init
            const emptyInitNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
                nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
                statementType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EMPTY,
                dependsOn: [],
                phiBlocks: []
            });
            const emptyInitID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, emptyInitNode);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, emptyInitID);
        }
        // 2. Condition statement - empty for infinite loop
        const emptyConditionNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
            statementType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EMPTY,
            dependsOn: [],
            phiBlocks: []
        });
        const emptyConditionID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, emptyConditionNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, emptyConditionID);
        // 3. Update statement - empty for infinite loop
        const emptyUpdateNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
            statementType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].EMPTY,
            dependsOn: [],
            phiBlocks: []
        });
        const emptyUpdateID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, emptyUpdateNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, forBlock, emptyUpdateID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        const scopeStartBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_START);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, forBlock, scopeStartBlock);
        // Add break condition check right after scope start
        const breakCheckBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeStartBlock, breakCheckBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, breakCheckBlock);
        // Generate break statement: if (!condition) break;
        // First, create the logical NOT of the condition: !condition
        const condition = conditionNode;
        const negatedCondition = this.createLogicalNotNode(condition);
        // Create a conditional break using the existing conditional structure
        // We'll create an IF_COND block that leads to a break statement
        const breakConditionBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].IF_COND);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, breakCheckBlock, breakConditionBlock);
        cfg.blockConditions[breakConditionBlock] = negatedCondition.id;
        const breakStatementBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, breakConditionBlock, breakStatementBlock);
        // Create the break statement in the break statement block
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, breakStatementBlock);
        const breakStatementNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].STATEMENT,
            statementType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].BREAK,
            dependsOn: [],
            phiBlocks: []
        });
        const breakStatementID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, breakStatementNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, breakStatementBlock, breakStatementID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        // The break statement block leads to the merge block (exits the loop)
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, breakStatementBlock, mergeBlock);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        const bodyBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        this.bodyBlock = bodyBlock;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, breakCheckBlock, bodyBlock);
        this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
        const updateBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].DEFAULT);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, bodyBlock, updateBlock);
        // Update the loop variable in the update block (like bounded loops)
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, updateBlock);
        const updateAssignmentNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].ASSIGNMENT,
            dependsOn: [
                phiNode.id,
                updateResult.id
            ],
            phiBlocks: []
        });
        const updateAssignmentID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, updateAssignmentNode);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["recordInBasicBlock"])(cfg, updateBlock, updateAssignmentID);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        const scopeEndBlock = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].SCOPE_END);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, updateBlock, scopeEndBlock);
        // Loop back to break check
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, scopeEndBlock, breakCheckBlock);
        // Break condition exits to merge
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, breakCheckBlock, mergeBlock);
    }
    initializeLoopVariable(cfg, branchBlock) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, branchBlock);
        let initialVar = this.initialCb();
        // Convert to StrandsNode if it's not already one
        if (!(initialVar instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"])) {
            const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(this.strandsContext, {
                baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT,
                dimension: 1
            }, initialVar);
            initialVar = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, this.strandsContext);
        }
        // Create phi node for the loop variable in the BRANCH block
        const phiNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createPhiNode"])(this.strandsContext, [
            {
                value: initialVar,
                blockId: branchBlock
            },
            {
                value: initialVar,
                blockId: branchBlock
            } // Placeholder, will be updated later
        ], 'loopVar');
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        return {
            initialVar,
            phiNode
        };
    }
    createLogicalNotNode(conditionNode) {
        const notOperationNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNodeData"])({
            nodeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION,
            opCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OpCode"].Unary.LOGICAL_NOT,
            baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].BOOL,
            dimension: 1,
            dependsOn: [
                conditionNode.id
            ],
            phiBlocks: [],
            usedBy: []
        });
        const notOperationID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getOrCreateNode"])(this.strandsContext.dag, notOperationNode);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(notOperationID, 1, this.strandsContext);
    }
    executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, bodyBlock);
        // Create phi node references to pass to the body callback
        const phiVars = {};
        const phiNodesForBody = {};
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlockForModification"])(cfg, branchBlock);
        for (const [varName, initialValueNode] of Object.entries(this.initialVars)){
            if (varName !== 'loopVar') {
                // Create phi node that will be used for the final result
                const varPhiNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createPhiNode"])(this.strandsContext, [
                    {
                        value: initialValueNode,
                        blockId: branchBlock
                    },
                    {
                        value: initialValueNode,
                        blockId: bodyBlock
                    } // Placeholder - will update after body execution
                ], varName);
                phiNodesForBody[varName] = varPhiNode;
                phiVars[varName] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(varPhiNode.id, varPhiNode.dimension, this.strandsContext);
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        const loopVarNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(phiNode.id, phiNode.dimension, this.strandsContext);
        this.bodyResults = this.bodyCb(loopVarNode, phiVars);
        this.phiNodesForBody = phiNodesForBody;
        // Capture the final block after body execution before popping
        this.finalBodyBlock = cfg.currentBlock;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
    }
    loopIsBounded(initialVar, conditionNode, updateVar) {
        // A loop is considered "bounded" if we can determine at compile time that it will
        // execute a known number of iterations. This happens when:
        // 1. The condition compares the loop variable against a compile-time constant
        // 2. At least one side of the comparison uses only literals (no variables/uniforms)
        if (!conditionNode) return false;
        // Analyze the condition node - it should be a comparison operation
        const conditionData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(this.strandsContext.dag, conditionNode.id);
        if (conditionData.nodeType !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION) {
            return false;
        }
        // For a comparison like "i < bound", we need at least one side to use only literals
        // The condition should have two dependencies: left and right operands
        if (!conditionData.dependsOn || conditionData.dependsOn.length !== 2) {
            return false;
        }
        // Check if either operand uses only literals
        const leftOperand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(conditionData.dependsOn[0], 1, this.strandsContext);
        const rightOperand = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(conditionData.dependsOn[1], 1, this.strandsContext);
        const leftUsesOnlyLiterals = this.nodeUsesOnlyLiterals(leftOperand);
        const rightUsesOnlyLiterals = this.nodeUsesOnlyLiterals(rightOperand);
        // At least one side should use only literals for the loop to be bounded
        return leftUsesOnlyLiterals || rightUsesOnlyLiterals;
    }
    nodeUsesOnlyLiterals(node) {
        // Recursively check if a node and all its dependencies use only literals
        const nodeData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(this.strandsContext.dag, node.id);
        switch(nodeData.nodeType){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].LITERAL:
                return true;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].VARIABLE:
                // Variables (like uniforms) make this branch unbounded
                return false;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].PHI:
                // Phi nodes (like loop variables) are not literals
                return false;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].OPERATION:
                // For operations, all dependencies must use only literals
                if (nodeData.dependsOn) {
                    for (const depId of nodeData.dependsOn){
                        const depNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(depId, 1, this.strandsContext);
                        if (!this.nodeUsesOnlyLiterals(depNode)) {
                            return false;
                        }
                    }
                }
                return true;
            default:
                // Conservative: if we don't know the node type, assume not literal
                return false;
        }
    }
}
;
}),
"[project]/node_modules/p5/dist/strands/strands_api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createShaderHooksFunctions",
    ()=>createShaderHooksFunctions,
    "initGlobalStrandsAPI",
    ()=>initGlobalStrandsAPI
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_conditionals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_conditionals.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_for$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_for.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
var noiseGLSL = "// Based on https://github.com/stegu/webgl-noise/blob/22434e04d7753f7e949e8d724ab3da2864c17a0f/src/noise3D.glsl\n// MIT licensed, adapted for p5.strands\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat baseNoise(vec3 v)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n        dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat noise(vec3 st, int octaves, float ampFalloff) {\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 8; i++) {\n    if (i >= octaves) break;\n    result += amplitude * baseNoise(st * frequency);\n    frequency *= 2.0;\n    amplitude *= ampFalloff;\n  }\n\n  return result;\n}\n";
//////////////////////////////////////////////
// User nodes
//////////////////////////////////////////////
function initGlobalStrandsAPI(p5, fn, strandsContext) {
    // We augment the strands node with operations programatically
    // this means methods like .add, .sub, etc can be chained
    for (const { name, arity, opCode } of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["OperatorTable"]){
        if (arity === 'binary') {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"].prototype[name] = function(...right) {
                const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])(strandsContext, this, right, opCode);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
            };
        }
        if (arity === 'unary') {
            p5[name] = function(nodeOrValue) {
                const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u"])(strandsContext, nodeOrValue, opCode);
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
            };
        }
    }
    //////////////////////////////////////////////
    // Unique Functions
    //////////////////////////////////////////////
    fn.discard = function() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(strandsContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].DISCARD);
    };
    fn.break = function() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(strandsContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StatementType"].BREAK);
    };
    p5.break = fn.break;
    fn.instanceID = function() {
        const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])(strandsContext, {
            baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].INT,
            dimension: 1
        }, 'gl_InstanceID');
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(node.id, node.dimension, strandsContext);
    };
    // Internal methods use p5 static methods; user-facing methods use fn.
    // Some methods need to be used by both.
    p5.strandsIf = function(conditionNode, ifBody) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_conditionals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StrandsConditional"](strandsContext, conditionNode, ifBody);
    };
    fn.strandsIf = p5.strandsIf;
    p5.strandsFor = function(initialCb, conditionCb, updateCb, bodyCb, initialVars) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_for$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["StrandsFor"](strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars).build();
    };
    fn.strandsFor = p5.strandsFor;
    p5.strandsNode = function(...args) {
        if (args.length === 1 && args[0] instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"]) {
            return args[0];
        }
        if (args.length > 4) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])("type error", "It looks like you've tried to construct a p5.strands node implicitly, with more than 4 components. This is currently not supported.");
        }
        const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, {
            baseType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].FLOAT,
            dimension: null
        }, args.flat());
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext); //new StrandsNode(id, dimension, strandsContext);
    };
    //////////////////////////////////////////////
    // Builtins, uniforms, variable constructors
    //////////////////////////////////////////////
    for (const [functionName, overrides] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["strandsBuiltinFunctions"])){
        const isp5Function = overrides[0].isp5Function;
        if (isp5Function) {
            const originalFn = fn[functionName];
            fn[functionName] = function(...args) {
                if (strandsContext.active) {
                    const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(strandsContext, functionName, args);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
                } else {
                    return originalFn.apply(this, args);
                }
            };
        } else {
            fn[functionName] = function(...args) {
                if (strandsContext.active) {
                    const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(strandsContext, functionName, args);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
                } else {
                    p5._friendlyError(`It looks like you've called ${functionName} outside of a shader's modify() function.`);
                }
            };
        }
    }
    // Add GLSL noise. TODO: Replace this with a backend-agnostic implementation
    const originalNoise = fn.noise;
    const originalNoiseDetail = fn.noiseDetail;
    strandsContext._noiseOctaves = null;
    strandsContext._noiseAmpFalloff = null;
    fn.noiseDetail = function(lod, falloff) {
        if (!strandsContext.active) {
            return originalNoiseDetail.apply(this, arguments);
        }
        strandsContext._noiseOctaves = lod;
        strandsContext._noiseAmpFalloff = falloff;
    };
    fn.noise = function(...args) {
        if (!strandsContext.active) {
            return originalNoise.apply(this, args); // fallback to regular p5.js noise
        }
        strandsContext.vertexDeclarations.add(noiseGLSL);
        strandsContext.fragmentDeclarations.add(noiseGLSL);
        // Make each input into a strands node so that we can check their dimensions
        const strandsArgs = args.map((arg)=>p5.strandsNode(arg));
        let nodeArgs;
        if (strandsArgs.length === 3) {
            nodeArgs = [
                fn.vec3(strandsArgs[0], strandsArgs[1], strandsArgs[2])
            ];
        } else if (strandsArgs.length === 2) {
            nodeArgs = [
                fn.vec3(strandsArgs[0], strandsArgs[1], 0)
            ];
        } else if (strandsArgs.length === 1 && strandsArgs[0].dimension <= 3) {
            if (strandsArgs[0].dimension === 3) {
                nodeArgs = strandsArgs;
            } else if (strandsArgs[0].dimension === 2) {
                nodeArgs = [
                    fn.vec3(strandsArgs[0], 0)
                ];
            } else {
                nodeArgs = [
                    fn.vec3(strandsArgs[0], 0, 0)
                ];
            }
        } else {
            p5._friendlyError(`It looks like you've called noise() with ${args.length} arguments. It only supports 1D to 3D input.`);
        }
        const octaves = strandsContext._noiseOctaves !== null ? strandsContext._noiseOctaves : fn._getNoiseOctaves();
        const falloff = strandsContext._noiseAmpFalloff !== null ? strandsContext._noiseAmpFalloff : fn._getNoiseAmpFalloff();
        nodeArgs.push(octaves);
        nodeArgs.push(falloff);
        const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(strandsContext, 'noise', nodeArgs, {
            overloads: [
                {
                    params: [
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float3,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].int1,
                        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
                    ],
                    returnType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"].float1
                }
            ]
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
    };
    // Next is type constructors and uniform functions.
    // For some of them, we have aliases so that you can write either a more human-readable
    // variant or also one more directly translated from GLSL, or to be more compatible with
    // APIs we documented at the release of 2.x and have to continue supporting.
    for(const type in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"]){
        if (type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BaseType"].DEFER) {
            continue;
        }
        const typeInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataType"][type];
        const typeAliases = [];
        let pascalTypeName;
        if (/^[ib]vec/.test(typeInfo.fnName)) {
            pascalTypeName = typeInfo.fnName.slice(0, 2).toUpperCase() + typeInfo.fnName.slice(2).toLowerCase();
            typeAliases.push(pascalTypeName.replace('Vec', 'Vector'));
        } else {
            pascalTypeName = typeInfo.fnName.charAt(0).toUpperCase() + typeInfo.fnName.slice(1);
            if (pascalTypeName === 'Sampler2D') {
                typeAliases.push('Texture');
            } else if (/^vec/.test(typeInfo.fnName)) {
                typeAliases.push(pascalTypeName.replace('Vec', 'Vector'));
            }
        }
        fn[`uniform${pascalTypeName}`] = function(name, defaultValue) {
            const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])(strandsContext, typeInfo, name);
            strandsContext.uniforms.push({
                name,
                typeInfo,
                defaultValue
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
        };
        // Shared variables with smart context detection
        fn[`shared${pascalTypeName}`] = function(name) {
            const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])(strandsContext, typeInfo, name);
            // Initialize shared variables tracking if not present
            if (!strandsContext.sharedVariables) {
                strandsContext.sharedVariables = new Map();
            }
            // Track this shared variable for smart declaration generation
            strandsContext.sharedVariables.set(name, {
                typeInfo,
                usedInVertex: false,
                usedInFragment: false,
                declared: false
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
        };
        // Alias varying* as shared* for backward compatibility
        fn[`varying${pascalTypeName}`] = fn[`shared${pascalTypeName}`];
        for (const typeAlias of typeAliases){
            // For compatibility, also alias uniformVec2 as uniformVector2, what we initially
            // documented these as
            fn[`uniform${typeAlias}`] = fn[`uniform${pascalTypeName}`];
            fn[`varying${typeAlias}`] = fn[`varying${pascalTypeName}`];
            fn[`shared${typeAlias}`] = fn[`shared${pascalTypeName}`];
        }
        const originalp5Fn = fn[typeInfo.fnName];
        fn[typeInfo.fnName] = function(...args) {
            if (strandsContext.active) {
                if (args.length === 1 && args[0].dimension && args[0].dimension === typeInfo.dimension) {
                    const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(strandsContext, typeInfo.fnName, args, {
                        overloads: [
                            {
                                params: [
                                    args[0].typeInfo()
                                ],
                                returnType: typeInfo
                            }
                        ]
                    });
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
                } else {
                    const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, typeInfo, args);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
                }
            } else if (originalp5Fn) {
                return originalp5Fn.apply(this, args);
            } else {
                p5._friendlyError(`It looks like you've called ${typeInfo.fnName} outside of a shader's modify() function.`);
            }
        };
    }
}
//////////////////////////////////////////////
// Per-Hook functions
//////////////////////////////////////////////
function createHookArguments(strandsContext, parameters) {
    const args = [];
    const dag = strandsContext.dag;
    for (const param of parameters){
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructType"])(param.type.typeName)) {
            const structTypeInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structType"])(param);
            const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(strandsContext, structTypeInfo, param.name, []);
            const structNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
            for(let i = 0; i < structTypeInfo.properties.length; i++){
                const propertyType = structTypeInfo.properties[i];
                Object.defineProperty(structNode, propertyType.name, {
                    get () {
                        const propNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(dag, dag.dependsOn[structNode.id][i]);
                        const onRebind = (newFieldID)=>{
                            const oldDeps = dag.dependsOn[structNode.id];
                            const newDeps = oldDeps.slice();
                            newDeps[i] = newFieldID;
                            const rebuilt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(strandsContext, structTypeInfo, param.name, newDeps);
                            structNode.id = rebuilt.id;
                        };
                        // TODO: implement member access operations
                        // const { id, components } = createMemberAccessNode(strandsContext, structNode, componentNodes[i], componentTypeInfo.dataType);
                        // const memberAccessNode = new StrandsNode(id, components);
                        // return memberAccessNode;
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(propNode.id, propNode.dimension, strandsContext, onRebind);
                    },
                    set (val) {
                        const oldDependsOn = dag.dependsOn[structNode.id];
                        const newDependsOn = [
                            ...oldDependsOn
                        ];
                        let newValueID;
                        if (val instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"]) {
                            newValueID = val.id;
                        } else {
                            let newVal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, propertyType.dataType, val);
                            newValueID = newVal.id;
                        }
                        newDependsOn[i] = newValueID;
                        const newStructInfo = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(strandsContext, structTypeInfo, param.name, newDependsOn);
                        structNode.id = newStructInfo.id;
                    }
                });
            }
            args.push(structNode);
        } else /*if(isNativeType(paramType.typeName))*/ {
            const typeInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeInfoFromGLSLName"][param.type.typeName];
            const { id, dimension } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["v"])(strandsContext, typeInfo, param.name);
            const arg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(id, dimension, strandsContext);
            args.push(arg);
        }
    }
    return args;
}
function enforceReturnTypeMatch(strandsContext, expectedType, returned, hookName) {
    if (!(returned instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"])) {
        // try {
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, expectedType, returned);
        return result.id;
    // } catch (e) {
    // FES.userError('type error',
    // `There was a type mismatch for a value returned from ${hookName}.\n` +
    // `The value in question was supposed to be:\n` +
    // `${expectedType.baseType + expectedType.dimension}\n` +
    // `But you returned:\n` +
    // `${returned}`
    // );
    // }
    }
    const dag = strandsContext.dag;
    let returnedNodeID = returned.id;
    const receivedType = {
        baseType: dag.baseTypes[returnedNodeID],
        dimension: dag.dimensions[returnedNodeID]
    };
    if (receivedType.dimension !== expectedType.dimension) {
        if (receivedType.dimension !== 1) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `You have returned a vector with ${receivedType.dimension} components in ${hookName} when a ${expectedType.baseType + expectedType.dimension} was expected!`);
        } else {
            const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, expectedType, returned);
            returnedNodeID = result.id;
        }
    } else if (receivedType.baseType !== expectedType.baseType) {
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(strandsContext, expectedType, returned);
        returnedNodeID = result.id;
    }
    return returnedNodeID;
}
function createShaderHooksFunctions(strandsContext, fn, shader) {
    // Add shader context to hooks before spreading
    const vertexHooksWithContext = Object.fromEntries(Object.entries(shader.hooks.vertex).map(([name, hook])=>[
            name,
            {
                ...hook,
                shaderContext: 'vertex'
            }
        ]));
    const fragmentHooksWithContext = Object.fromEntries(Object.entries(shader.hooks.fragment).map(([name, hook])=>[
            name,
            {
                ...hook,
                shaderContext: 'fragment'
            }
        ]));
    const availableHooks = {
        ...vertexHooksWithContext,
        ...fragmentHooksWithContext
    };
    const hookTypes = Object.keys(availableHooks).map((name)=>shader.hookTypes(name));
    const { cfg, dag } = strandsContext;
    for (const hookType of hookTypes){
        const hookImplementation = function(hookUserCallback) {
            const entryBlockID = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].FUNCTION);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addEdge"])(cfg, cfg.currentBlock, entryBlockID);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(cfg, entryBlockID);
            const args = createHookArguments(strandsContext, hookType.parameters);
            const userReturned = hookUserCallback(...args);
            const expectedReturnType = hookType.returnType;
            let rootNodeID = null;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isStructType"])(expectedReturnType.typeName)) {
                const expectedStructType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["structType"])(expectedReturnType);
                if (userReturned instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["S"]) {
                    const returnedNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getNodeDataFromID"])(strandsContext.dag, userReturned.id);
                    if (returnedNode.baseType !== expectedStructType.typeName) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])("type error", `You have returned a ${userReturned.baseType} from ${hookType.name} when a ${expectedStructType.typeName} was expected.`);
                    }
                    const newDeps = returnedNode.dependsOn.slice();
                    for(let i = 0; i < expectedStructType.properties.length; i++){
                        const expectedType = expectedStructType.properties[i].dataType;
                        const receivedNode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(returnedNode.dependsOn[i], dag.dependsOn[userReturned.id], strandsContext);
                        newDeps[i] = enforceReturnTypeMatch(strandsContext, expectedType, receivedNode, hookType.name);
                    }
                    dag.dependsOn[userReturned.id] = newDeps;
                    rootNodeID = userReturned.id;
                } else {
                    const expectedProperties = expectedStructType.properties;
                    const newStructDependencies = [];
                    for(let i = 0; i < expectedProperties.length; i++){
                        const expectedProp = expectedProperties[i];
                        const propName = expectedProp.name;
                        const receivedValue = userReturned[propName];
                        if (receivedValue === undefined) {
                            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["userError"])('type error', `You've returned an incomplete struct from ${hookType.name}.\n` + `Expected: { ${expectedReturnType.properties.map((p)=>p.name).join(', ')} }\n` + `Received: { ${Object.keys(userReturned).join(', ')} }\n` + `All of the properties are required!`);
                        }
                        const expectedTypeInfo = expectedProp.dataType;
                        const returnedPropID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, receivedValue, hookType.name);
                        newStructDependencies.push(returnedPropID);
                    }
                    const newStruct = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(strandsContext, expectedStructType, newStructDependencies);
                    rootNodeID = newStruct.id;
                }
            } else /*if(isNativeType(expectedReturnType.typeName))*/ {
                const expectedTypeInfo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeInfoFromGLSLName"][expectedReturnType.typeName];
                rootNodeID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, userReturned, hookType.name);
            }
            const fullHookName = `${hookType.returnType.typeName} ${hookType.name}`;
            const hookInfo = availableHooks[fullHookName];
            strandsContext.hooks.push({
                hookType,
                entryBlockID,
                rootNodeID,
                shaderContext: hookInfo?.shaderContext
            });
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(cfg);
        };
        strandsContext.windowOverrides[hookType.name] = window[hookType.name];
        strandsContext.fnOverrides[hookType.name] = fn[hookType.name];
        window[hookType.name] = hookImplementation;
        fn[hookType.name] = hookImplementation;
    }
}
;
}),
"[project]/node_modules/p5/dist/strands/p5.strands.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>strands
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_glslBackend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_glslBackend.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_transpiler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_transpiler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_codegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_codegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_conditionals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_conditionals.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_for$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_for.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
* @module 3D
* @submodule strands
* @for p5
* @requires core
*/ function strands(p51, fn) {
    //////////////////////////////////////////////
    // Global Runtime
    //////////////////////////////////////////////
    function initStrandsContext(ctx, backend, { active = false } = {}) {
        ctx.dag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDirectedAcyclicGraph"])();
        ctx.cfg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createControlFlowGraph"])();
        ctx.uniforms = [];
        ctx.vertexDeclarations = new Set();
        ctx.fragmentDeclarations = new Set();
        ctx.hooks = [];
        ctx.globalAssignments = [];
        ctx.backend = backend;
        ctx.active = active;
        ctx.previousFES = p51.disableFriendlyErrors;
        ctx.windowOverrides = {};
        ctx.fnOverrides = {};
        if (active) {
            p51.disableFriendlyErrors = true;
        }
    }
    function deinitStrandsContext(ctx) {
        ctx.dag = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDirectedAcyclicGraph"])();
        ctx.cfg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createControlFlowGraph"])();
        ctx.uniforms = [];
        ctx.vertexDeclarations = new Set();
        ctx.fragmentDeclarations = new Set();
        ctx.hooks = [];
        ctx.globalAssignments = [];
        ctx.active = false;
        p51.disableFriendlyErrors = ctx.previousFES;
        for(const key in ctx.windowOverrides){
            window[key] = ctx.windowOverrides[key];
        }
        for(const key in ctx.fnOverrides){
            fn[key] = ctx.fnOverrides[key];
        }
    }
    const strandsContext = {};
    initStrandsContext(strandsContext);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["initGlobalStrandsAPI"])(p51, fn, strandsContext);
    //////////////////////////////////////////////
    // Entry Point
    //////////////////////////////////////////////
    const oldModify = p51.Shader.prototype.modify;
    p51.Shader.prototype.modify = function(shaderModifier, scope = {}) {
        if (shaderModifier instanceof Function) {
            try {
                // Reset the context object every time modify is called;
                // const backend = glslBackend;
                initStrandsContext(strandsContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_glslBackend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["glslBackend"], {
                    active: true
                });
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createShaderHooksFunctions"])(strandsContext, fn, this);
                // TODO: expose this, is internal for debugging for now.
                const options = {
                    parser: true,
                    srcLocations: false
                };
                // 1. Transpile from strands DSL to JS
                let strandsCallback;
                if (options.parser) {
                    // #7955 Wrap function declaration code in brackets so anonymous functions are not top level statements, which causes an error in acorn when parsing
                    // https://github.com/acornjs/acorn/issues/1385
                    const sourceString = `(${shaderModifier.toString()})`;
                    strandsCallback = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_transpiler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["transpileStrandsToJS"])(p51, sourceString, options.srcLocations, scope);
                }
                // 2. Build the IR from JavaScript API
                const globalScope = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createBasicBlock"])(strandsContext.cfg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BlockType"].GLOBAL);
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pushBlock"])(strandsContext.cfg, globalScope);
                strandsCallback();
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["popBlock"])(strandsContext.cfg);
                // 3. Generate shader code hooks object from the IR
                // .......
                const hooksObject = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_codegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["generateShaderCode"])(strandsContext);
                // Call modify with the generated hooks object
                return oldModify.call(this, hooksObject);
            } finally{
                // Reset the strands runtime context
                deinitStrandsContext(strandsContext);
            }
        } else {
            return oldModify.call(this, shaderModifier);
        }
    };
}
if (typeof p5 !== 'undefined') {
    p5.registerAddon(strands);
}
;
}),
];

//# sourceMappingURL=node_modules_p5_dist_strands_8795c1b6._.js.map