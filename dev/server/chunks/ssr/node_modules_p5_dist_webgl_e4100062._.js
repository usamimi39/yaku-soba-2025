module.exports = [
"[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DataArray",
    ()=>DataArray,
    "default",
    ()=>dataArray
]);
class DataArray {
    constructor(initialLength = 128){
        this.length = 0;
        this.data = new Float32Array(initialLength);
        this.initialLength = initialLength;
    }
    /**
   * Returns a Float32Array window sized to the exact length of the data
   */ dataArray() {
        return this.subArray(0, this.length);
    }
    /**
   * A "soft" clear, which keeps the underlying storage size the same, but
   * empties the contents of its dataArray()
   */ clear() {
        this.length = 0;
    }
    /**
   * Can be used to scale a DataArray back down to fit its contents.
   */ rescale() {
        if (this.length < this.data.length / 2) {
            // Find the power of 2 size that fits the data
            const targetLength = 1 << Math.ceil(Math.log2(this.length));
            const newData = new Float32Array(targetLength);
            newData.set(this.data.subarray(0, this.length), 0);
            this.data = newData;
        }
    }
    /**
   * A full reset, which allocates a new underlying Float32Array at its initial
   * length
   */ reset() {
        this.clear();
        this.data = new Float32Array(this.initialLength);
    }
    /**
   * Adds values to the DataArray, expanding its internal storage to
   * accommodate the new items.
   */ push(...values) {
        this.ensureLength(this.length + values.length);
        this.data.set(values, this.length);
        this.length += values.length;
    }
    /**
   * Returns a copy of the data from the index `from`, inclusive, to the index
   * `to`, exclusive
   */ slice(from, to) {
        return this.data.slice(from, Math.min(to, this.length));
    }
    /**
   * Returns a mutable Float32Array window from the index `from`, inclusive, to
   * the index `to`, exclusive
   */ subArray(from, to) {
        return this.data.subarray(from, Math.min(to, this.length));
    }
    /**
   * Expand capacity of the internal storage until it can fit a target size
   */ ensureLength(target) {
        while(this.data.length < target){
            const newData = new Float32Array(this.data.length * 2);
            newData.set(this.data, 0);
            this.data = newData;
        }
    }
}
function dataArray(p51, fn) {
    /**
   * An internal class to store data that will be sent to a p5.RenderBuffer.
   * Those need to eventually go into a Float32Array, so this class provides a
   * variable-length array container backed by a Float32Array so that it can be
   * sent to the GPU without allocating a new array each frame.
   *
   * Like a C++ vector, its fixed-length Float32Array backing its contents will
   * double in size when it goes over its capacity.
   *
   * @example
   * <div>
   * <code>
   * // Initialize storage with a capacity of 4
   * const storage = new DataArray(4);
   * console.log(storage.data.length); // 4
   * console.log(storage.length); // 0
   * console.log(storage.dataArray()); // Empty Float32Array
   *
   * storage.push(1, 2, 3, 4, 5, 6);
   * console.log(storage.data.length); // 8
   * console.log(storage.length); // 6
   * console.log(storage.dataArray()); // Float32Array{1, 2, 3, 4, 5, 6}
   * </code>
   * </div>
   */ p51.DataArray = DataArray;
}
if (typeof p5 !== 'undefined') {
    dataArray(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Geometry",
    ()=>Geometry,
    "default",
    ()=>geometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
;
;
;
;
/**
 * @module Shape
 * @submodule 3D Primitives
 * @for p5
 * @requires core
 * @requires p5.Geometry
 */ class Geometry {
    constructor(detailX, detailY, callback, renderer){
        this.renderer = renderer;
        this.vertices = [];
        this.boundingBoxCache = null;
        //an array containing every vertex for stroke drawing
        this.lineVertices = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataArray"]();
        // The tangents going into or out of a vertex on a line. Along a straight
        // line segment, both should be equal. At an endpoint, one or the other
        // will not exist and will be all 0. In joins between line segments, they
        // may be different, as they will be the tangents on either side of the join.
        this.lineTangentsIn = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataArray"]();
        this.lineTangentsOut = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataArray"]();
        // When drawing lines with thickness, entries in this buffer represent which
        // side of the centerline the vertex will be placed. The sign of the number
        // will represent the side of the centerline, and the absolute value will be
        // used as an enum to determine which part of the cap or join each vertex
        // represents. See the doc comments for _addCap and _addJoin for diagrams.
        this.lineSides = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataArray"]();
        this.vertexNormals = [];
        this.faces = [];
        this.uvs = [];
        // a 2D array containing edge connectivity pattern for create line vertices
        //based on faces for most objects;
        this.edges = [];
        this.vertexColors = [];
        // One color per vertex representing the stroke color at that vertex
        this.vertexStrokeColors = [];
        this.userVertexProperties = {};
        // One color per line vertex, generated automatically based on
        // vertexStrokeColors in _edgesToVertices()
        this.lineVertexColors = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DataArray"]();
        this.detailX = detailX !== undefined ? detailX : 1;
        this.detailY = detailY !== undefined ? detailY : 1;
        this.dirtyFlags = {};
        this._hasFillTransparency = undefined;
        this._hasStrokeTransparency = undefined;
        this.gid = `_p5_Geometry_${Geometry.nextId}`;
        Geometry.nextId++;
        if (callback instanceof Function) {
            callback.call(this);
        }
    }
    /**
   * Calculates the position and size of the smallest box that contains the geometry.
   *
   * A bounding box is the smallest rectangular prism that contains the entire
   * geometry. It's defined by the box's minimum and maximum coordinates along
   * each axis, as well as the size (length) and offset (center).
   *
   * Calling `myGeometry.calculateBoundingBox()` returns an object with four
   * properties that describe the bounding box:
   *
   * ```js
   * // Get myGeometry's bounding box.
   * let bbox = myGeometry.calculateBoundingBox();
   *
   * // Print the bounding box to the console.
   * console.log(bbox);
   *
   * // {
   * //  // The minimum coordinate along each axis.
   * //  min: { x: -1, y: -2, z: -3 },
   * //
   * //  // The maximum coordinate along each axis.
   * //  max: { x: 1, y: 2, z: 3},
   * //
   * //  // The size (length) along each axis.
   * //  size: { x: 2, y: 4, z: 6},
   * //
   * //  // The offset (center) along each axis.
   * //  offset: { x: 0, y: 0, z: 0}
   * // }
   * ```
   *
   * @returns {Object} bounding box of the geometry.
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let particles;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a new p5.Geometry object with random spheres.
   *   particles = buildGeometry(createParticles);
   *
   *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the particles.
   *   noStroke();
   *   fill(255);
   *
   *   // Draw the particles.
   *   model(particles);
   *
   *   // Calculate the bounding box.
   *   let bbox = particles.calculateBoundingBox();
   *
   *   // Translate to the bounding box's center.
   *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);
   *
   *   // Style the bounding box.
   *   stroke(255);
   *   noFill();
   *
   *   // Draw the bounding box.
   *   box(bbox.size.x, bbox.size.y, bbox.size.z);
   * }
   *
   * function createParticles() {
   *   for (let i = 0; i < 10; i += 1) {
   *     // Calculate random coordinates.
   *     let x = randomGaussian(0, 15);
   *     let y = randomGaussian(0, 15);
   *     let z = randomGaussian(0, 15);
   *
   *     push();
   *     // Translate to the particle's coordinates.
   *     translate(x, y, z);
   *     // Draw the particle.
   *     sphere(3);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   */ calculateBoundingBox() {
        if (this.boundingBoxCache) {
            return this.boundingBoxCache; // Return cached result if available
        }
        let minVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        let maxVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
        for(let i = 0; i < this.vertices.length; i++){
            let vertex = this.vertices[i];
            minVertex.x = Math.min(minVertex.x, vertex.x);
            minVertex.y = Math.min(minVertex.y, vertex.y);
            minVertex.z = Math.min(minVertex.z, vertex.z);
            maxVertex.x = Math.max(maxVertex.x, vertex.x);
            maxVertex.y = Math.max(maxVertex.y, vertex.y);
            maxVertex.z = Math.max(maxVertex.z, vertex.z);
        }
        // Calculate size and offset properties
        let size = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](maxVertex.x - minVertex.x, maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);
        let offset = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"]((minVertex.x + maxVertex.x) / 2, (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);
        // Cache the result for future access
        this.boundingBoxCache = {
            min: minVertex,
            max: maxVertex,
            size: size,
            offset: offset
        };
        return this.boundingBoxCache;
    }
    reset() {
        this._hasFillTransparency = undefined;
        this._hasStrokeTransparency = undefined;
        this.lineVertices.clear();
        this.lineTangentsIn.clear();
        this.lineTangentsOut.clear();
        this.lineSides.clear();
        this.vertices.length = 0;
        this.edges.length = 0;
        this.vertexColors.length = 0;
        this.vertexStrokeColors.length = 0;
        this.lineVertexColors.clear();
        this.vertexNormals.length = 0;
        this.uvs.length = 0;
        for(const propName in this.userVertexProperties){
            this.userVertexProperties[propName].delete();
        }
        this.userVertexProperties = {};
        this.dirtyFlags = {};
    }
    hasFillTransparency() {
        if (this._hasFillTransparency === undefined) {
            this._hasFillTransparency = false;
            for(let i = 0; i < this.vertexColors.length; i += 4){
                if (this.vertexColors[i + 3] < 1) {
                    this._hasFillTransparency = true;
                    break;
                }
            }
        }
        return this._hasFillTransparency;
    }
    hasStrokeTransparency() {
        if (this._hasStrokeTransparency === undefined) {
            this._hasStrokeTransparency = false;
            for(let i = 0; i < this.lineVertexColors.length; i += 4){
                if (this.lineVertexColors[i + 3] < 1) {
                    this._hasStrokeTransparency = true;
                    break;
                }
            }
        }
        return this._hasStrokeTransparency;
    }
    /**
   * Removes the geometry’s internal colors.
   *
   * `p5.Geometry` objects can be created with "internal colors" assigned to
   * vertices or the entire shape. When a geometry has internal colors,
   * <a href="#/p5/fill">fill()</a> has no effect. Calling
   * `myGeometry.clearColors()` allows the
   * <a href="#/p5/fill">fill()</a> function to apply color to the geometry.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Geometry object.
   *   // Set its internal color to red.
   *   let myGeometry = buildGeometry(function() {
   *     fill(255, 0, 0);
   *     plane(20);
   *   });
   *
   *   // Style the shape.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object (center).
   *   model(myGeometry);
   *
   *   // Translate the origin to the bottom-right.
   *   translate(25, 25, 0);
   *
   *   // Try to fill the geometry with green.
   *   fill(0, 255, 0);
   *
   *   // Draw the geometry again (bottom-right).
   *   model(myGeometry);
   *
   *   // Clear the geometry's colors.
   *   myGeometry.clearColors();
   *
   *   // Fill the geometry with blue.
   *   fill(0, 0, 255);
   *
   *   // Translate the origin up.
   *   translate(0, -50, 0);
   *
   *   // Draw the geometry again (top-right).
   *   model(myGeometry);
   *
   *   describe(
   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'
   *   );
   * }
   * </code>
   * </div>
   */ clearColors() {
        this.vertexColors = [];
        return this;
    }
    /**
   * The `saveObj()` function exports `p5.Geometry` objects as
   * 3D models in the Wavefront .obj file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,
   * as well as its texture coordinates and normals, if it has them.
   *
   * @method saveObj
   * @param {String} [fileName='model.obj'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.obj'.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function()) {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn = createButton('Save .obj');
   *   saveBtn.mousePressed(() => myModel.saveObj());
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */ saveObj(fileName = 'model.obj') {
        let objStr = '';
        // Vertices
        this.vertices.forEach((v)=>{
            objStr += `v ${v.x} ${v.y} ${v.z}\n`;
        });
        // Texture Coordinates (UVs)
        if (this.uvs && this.uvs.length > 0) {
            for(let i = 0; i < this.uvs.length; i += 2){
                objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}\n`;
            }
        }
        // Vertex Normals
        if (this.vertexNormals && this.vertexNormals.length > 0) {
            this.vertexNormals.forEach((n)=>{
                objStr += `vn ${n.x} ${n.y} ${n.z}\n`;
            });
        }
        // Faces, obj vertex indices begin with 1 and not 0
        // texture coordinate (uvs) and vertexNormal indices
        // are indicated with trailing ints vertex/normal/uv
        // ex 1/1/1 or 2//2 for vertices without uvs
        this.faces.forEach((face)=>{
            let faceStr = 'f';
            face.forEach((index)=>{
                faceStr += ' ';
                faceStr += index + 1;
                if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
                    faceStr += '/';
                    if (this.uvs.length > 0) {
                        faceStr += index + 1;
                    }
                    faceStr += '/';
                    if (this.vertexNormals.length > 0) {
                        faceStr += index + 1;
                    }
                }
            });
            objStr += faceStr + '\n';
        });
        const blob = new Blob([
            objStr
        ], {
            type: 'text/plain'
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["downloadFile"])(blob, fileName, 'obj');
    }
    /**
   * The `saveStl()` function exports `p5.Geometry` objects as
   * 3D models in the STL stereolithography file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.
   *
   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact
   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.
   *
   * @method saveStl
   * @param {String} [fileName='model.stl'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.stl'.
   * @param {Object} [options] Optional settings.
   * @param {Boolean} [options.binary=false] Whether or not a binary .stl file is saved.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn1;
   * let saveBtn2;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function() {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn1 = createButton('Save .stl');
   *   saveBtn1.mousePressed(function() {
   *     myModel.saveStl();
   *   });
   *   saveBtn2 = createButton('Save binary .stl');
   *   saveBtn2.mousePressed(function() {
   *     myModel.saveStl('model.stl', { binary: true });
   *   });
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */ saveStl(fileName = 'model.stl', { binary = false } = {}) {
        let modelOutput;
        let name = fileName.substring(0, fileName.lastIndexOf('.'));
        let faceNormals = [];
        for (let f of this.faces){
            const U = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.vertices[f[1]], this.vertices[f[0]]);
            const V = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.vertices[f[2]], this.vertices[f[0]]);
            const nx = U.y * V.z - U.z * V.y;
            const ny = U.z * V.x - U.x * V.z;
            const nz = U.x * V.y - U.y * V.x;
            faceNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](nx, ny, nz).normalize());
        }
        if (binary) {
            let offset = 80;
            const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
            const arrayBuffer = new ArrayBuffer(bufferLength);
            modelOutput = new DataView(arrayBuffer);
            modelOutput.setUint32(offset, this.faces.length, true);
            offset += 4;
            for (const [key, f] of Object.entries(this.faces)){
                const norm = faceNormals[key];
                modelOutput.setFloat32(offset, norm.x, true);
                offset += 4;
                modelOutput.setFloat32(offset, norm.y, true);
                offset += 4;
                modelOutput.setFloat32(offset, norm.z, true);
                offset += 4;
                for (let vertexIndex of f){
                    const vert = this.vertices[vertexIndex];
                    modelOutput.setFloat32(offset, vert.x, true);
                    offset += 4;
                    modelOutput.setFloat32(offset, vert.y, true);
                    offset += 4;
                    modelOutput.setFloat32(offset, vert.z, true);
                    offset += 4;
                }
                modelOutput.setUint16(offset, 0, true);
                offset += 2;
            }
        } else {
            modelOutput = 'solid ' + name + '\n';
            for (const [key, f] of Object.entries(this.faces)){
                const norm = faceNormals[key];
                modelOutput += ' facet norm ' + norm.x + ' ' + norm.y + ' ' + norm.z + '\n';
                modelOutput += '  outer loop' + '\n';
                for (let vertexIndex of f){
                    const vert = this.vertices[vertexIndex];
                    modelOutput += '   vertex ' + vert.x + ' ' + vert.y + ' ' + vert.z + '\n';
                }
                modelOutput += '  endloop' + '\n';
                modelOutput += ' endfacet' + '\n';
            }
            modelOutput += 'endsolid ' + name + '\n';
        }
        const blob = new Blob([
            modelOutput
        ], {
            type: 'text/plain'
        });
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["downloadFile"])(blob, fileName, 'stl');
    }
    /**
   * Flips the geometry’s texture u-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates
   * so that the texture appears mirrored horizontally.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipU()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the u-coordinates.
   * myGeometry.flipU();
   *
   * // Print the flipped texture coordinates.
   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]
   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]
   * ```
   *
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's U texture coordinates.
   *   geom2.flipU();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ flipU() {
        this.uvs = this.uvs.flat().map((val, index)=>{
            if (index % 2 === 0) {
                return 1 - val;
            } else {
                return val;
            }
        });
    }
    /**
   * Flips the geometry’s texture v-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates
   * so that the texture appears mirrored vertically.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipV()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the v-coordinates.
   * myGeometry.flipV();
   *
   * // Print the flipped texture coordinates.
   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Left vertices: [0, 0] <--> [1, 0]
   * // Right vertices: [1, 0] <--> [1, 1]
   * ```
   *
   * @method flipV
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's V texture coordinates.
   *   geom2.flipV();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ flipV() {
        this.uvs = this.uvs.flat().map((val, index)=>{
            if (index % 2 === 0) {
                return val;
            } else {
                return 1 - val;
            }
        });
    }
    /**
   * Computes the geometry's faces using its vertices.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles that
   * are stitched together. Each triangular patch on the geometry's surface is
   * called a *face*. `myGeometry.computeFaces()` performs the math needed to
   * define each face based on the distances between vertices.
   *
   * The geometry's vertices are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the <a href="#/p5.Geometry/vertices">myGeometry.vertices</a>
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * Calling `myGeometry.computeFaces()` fills the
   * <a href="#/p5.Geometry/faces">myGeometry.faces</a> array with three-element
   * arrays that list the vertices that form each face. For example, a geometry
   * made from a rectangle has two faces because a rectangle is made by joining
   * two triangles. <a href="#/p5.Geometry/faces">myGeometry.faces</a> for a
   * rectangle would be the two-dimensional array
   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the
   * array `[0, 1, 2]` because it's formed by connecting
   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the
   * array `[2, 1, 3]` because it's formed by connecting
   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and
   * `myGeometry.vertices[3]`.
   *
   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to myGeometry's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute myGeometry's faces array.
   *   myGeometry.computeFaces();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   * }
   * </code>
   * </div>
   */ computeFaces() {
        this.faces.length = 0;
        const sliceCount = this.detailX + 1;
        let a, b, c, d;
        for(let i = 0; i < this.detailY; i++){
            for(let j = 0; j < this.detailX; j++){
                a = i * sliceCount + j; // + offset;
                b = i * sliceCount + j + 1; // + offset;
                c = (i + 1) * sliceCount + j + 1; // + offset;
                d = (i + 1) * sliceCount + j; // + offset;
                this.faces.push([
                    a,
                    b,
                    d
                ]);
                this.faces.push([
                    d,
                    b,
                    c
                ]);
            }
        }
        return this;
    }
    _getFaceNormal(faceId) {
        //This assumes that vA->vB->vC is a counter-clockwise ordering
        const face = this.faces[faceId];
        const vA = this.vertices[face[0]];
        const vB = this.vertices[face[1]];
        const vC = this.vertices[face[2]];
        const ab = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(vB, vA);
        const ac = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(vC, vA);
        const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].cross(ab, ac);
        const ln = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mag(n);
        let sinAlpha = ln / (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mag(ab) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mag(ac));
        if (sinAlpha === 0 || isNaN(sinAlpha)) {
            console.warn('p5.Geometry.prototype._getFaceNormal:', 'face has colinear sides or a repeated vertex');
            return n;
        }
        if (sinAlpha > 1) sinAlpha = 1; // handle float rounding error
        return n.mult(Math.asin(sinAlpha) / ln);
    }
    /**
   * Calculates the normal vector for each vertex on the geometry.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to create triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*. `myGeometry.computeNormals()` performs the
   * math needed to orient each face. Orientation is important for lighting
   * and other effects.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal vector.
   * Then it calculates the normal vector for each vertex by averaging the
   * normal vectors of the faces surrounding the vertex. The vertex normals
   * are stored as <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertexNormals">myGeometry.vertexNormals</a> array.
   *
   * The first parameter, `shadingType`, is optional. Passing the constant
   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring
   * faces with their own copies of the vertices they share. Surfaces appear
   * tiled with flat shading. Passing the constant `SMOOTH`, as in
   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their
   * shared vertices. Surfaces appear smoother with smooth shading. By
   * default, `shadingType` is `FLAT`.
   *
   * The second parameter, `options`, is also optional. If an object with a
   * `roundToPrecision` property is passed, as in
   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the
   * number of decimal places to use for calculations. By default,
   * `roundToPrecision` uses 3 decimal places.
   *
   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.
   * @param {Object} [options] shading options.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus();
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     "A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices."
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   stroke(0);
   *
   *   // Display the helix.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 5);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using default (FLAT) shading.
   *   myGeometry.computeNormals(FLAT);
   *
   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Create an options object.
   *   let options = { roundToPrecision: 5 };
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH, options);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   */ computeNormals(shadingType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["F"], { roundToPrecision = 3 } = {}) {
        const vertexNormals = this.vertexNormals;
        let vertices = this.vertices;
        const faces = this.faces;
        let iv;
        if (shadingType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["y"]) {
            const vertexIndices = {};
            const uniqueVertices = [];
            const power = Math.pow(10, roundToPrecision);
            const rounded = (val)=>Math.round(val * power) / power;
            const getKey = (vert)=>`${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
            // loop through each vertex and add uniqueVertices
            for(let i = 0; i < vertices.length; i++){
                const vertex = vertices[i];
                const key = getKey(vertex);
                if (vertexIndices[key] === undefined) {
                    vertexIndices[key] = uniqueVertices.length;
                    uniqueVertices.push(vertex);
                }
            }
            // update face indices to use the deduplicated vertex indices
            faces.forEach((face)=>{
                for(let fv = 0; fv < 3; ++fv){
                    const originalVertexIndex = face[fv];
                    const originalVertex = vertices[originalVertexIndex];
                    const key = getKey(originalVertex);
                    face[fv] = vertexIndices[key];
                }
            });
            // update edge indices to use the deduplicated vertex indices
            this.edges.forEach((edge)=>{
                for(let ev = 0; ev < 2; ++ev){
                    const originalVertexIndex = edge[ev];
                    const originalVertex = vertices[originalVertexIndex];
                    const key = getKey(originalVertex);
                    edge[ev] = vertexIndices[key];
                }
            });
            // update the deduplicated vertices
            this.vertices = vertices = uniqueVertices;
        }
        // initialize the vertexNormals array with empty vectors
        vertexNormals.length = 0;
        for(iv = 0; iv < vertices.length; ++iv){
            vertexNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"]());
        }
        // loop through all the faces adding its normal to the normal
        // of each of its vertices
        faces.forEach((face, f)=>{
            const faceNormal = this._getFaceNormal(f);
            // all three vertices get the normal added
            for(let fv = 0; fv < 3; ++fv){
                const vertexIndex = face[fv];
                vertexNormals[vertexIndex].add(faceNormal);
            }
        });
        // normalize the normals
        for(iv = 0; iv < vertices.length; ++iv){
            vertexNormals[iv].normalize();
        }
        return this;
    }
    /**
   * Averages the vertex normals. Used in curved
   * surfaces
   * @private
   * @chainable
   */ averageNormals() {
        for(let i = 0; i <= this.detailY; i++){
            const offset = this.detailX + 1;
            let temp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].add(this.vertexNormals[i * offset], this.vertexNormals[i * offset + this.detailX]);
            temp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].div(temp, 2);
            this.vertexNormals[i * offset] = temp;
            this.vertexNormals[i * offset + this.detailX] = temp;
        }
        return this;
    }
    /**
   * Averages pole normals.  Used in spherical primitives
   * @private
   * @chainable
   */ averagePoleNormals() {
        //average the north pole
        let sum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0);
        for(let i = 0; i < this.detailX; i++){
            sum.add(this.vertexNormals[i]);
        }
        sum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].div(sum, this.detailX);
        for(let i = 0; i < this.detailX; i++){
            this.vertexNormals[i] = sum;
        }
        //average the south pole
        sum = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0);
        for(let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--){
            sum.add(this.vertexNormals[i]);
        }
        sum = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].div(sum, this.detailX);
        for(let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--){
            this.vertexNormals[i] = sum;
        }
        return this;
    }
    /**
   * Create a 2D array for establishing stroke connections
   * @private
   * @chainable
   */ _makeTriangleEdges() {
        this.edges.length = 0;
        for(let j = 0; j < this.faces.length; j++){
            this.edges.push([
                this.faces[j][0],
                this.faces[j][1]
            ]);
            this.edges.push([
                this.faces[j][1],
                this.faces[j][2]
            ]);
            this.edges.push([
                this.faces[j][2],
                this.faces[j][0]
            ]);
        }
        return this;
    }
    /**
   * @example
   * <div>
   * <code>
   * let tetrahedron;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   describe('A rotating tetrahedron');
   *
   *   tetrahedron = new p5.Geometry();
   *
   *   // Give each geometry a unique gid
   *   tetrahedron.gid = 'tetrahedron';
   *
   *   // Add four points of the tetrahedron
   *
   *   let radius = 50;
   *   // A 2D triangle:
   *   tetrahedron.vertices.push(createVector(radius, 0, 0));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));
   *   // Add a tip in the z axis:
   *   tetrahedron.vertices.push(createVector(0, 0, radius));
   *
   *   // Create the four faces by connecting the sets of three points
   *   tetrahedron.faces.push([0, 1, 2]);
   *   tetrahedron.faces.push([0, 1, 3]);
   *   tetrahedron.faces.push([0, 2, 3]);
   *   tetrahedron.faces.push([1, 2, 3]);
   *   tetrahedron.makeEdgesFromFaces();
   * }
   * function draw() {
   *   background(200);
   *   strokeWeight(2);
   *   orbitControl();
   *   rotateY(millis() * 0.001);
   *   model(tetrahedron);
   * }
   * </code>
   * </div>
   */ makeEdgesFromFaces() {
        this._makeTriangleEdges();
    }
    /**
   * Converts each line segment into the vertices and vertex attributes needed
   * to turn the line into a polygon on screen. This will include:
   * - Two triangles line segment to create a rectangle
   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment
   *   shader is responsible for displaying the appropriate cap style within
   *   that rectangle.
   * - Four triangles per join between adjacent line segments, creating a quad on
   *   either side of the join, perpendicular to the lines. A vertex shader will
   *   discard the quad in the "elbow" of the join, and a fragment shader will
   *   display the appropriate join style within the remaining quad.
   *
   * @private
   * @chainable
   */ _edgesToVertices() {
        this.lineVertices.clear();
        this.lineTangentsIn.clear();
        this.lineTangentsOut.clear();
        this.lineSides.clear();
        const potentialCaps = new Map();
        const connected = new Set();
        let lastValidDir;
        for(let i = 0; i < this.edges.length; i++){
            const prevEdge = this.edges[i - 1];
            const currEdge = this.edges[i];
            const begin = this.vertices[currEdge[0]];
            const end = this.vertices[currEdge[1]];
            const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(prevEdge[1] * 4, (prevEdge[1] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[0] * 4, (currEdge[0] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[1] * 4, (currEdge[1] + 1) * 4) : [
                0,
                0,
                0,
                0
            ];
            const dir = end.copy().sub(begin).normalize();
            const dirOK = dir.magSq() > 0;
            if (dirOK) {
                this._addSegment(begin, end, fromColor, toColor, dir);
            }
            if (!this.renderer?._simpleLines) {
                if (i > 0 && prevEdge[1] === currEdge[0]) {
                    if (!connected.has(currEdge[0])) {
                        connected.add(currEdge[0]);
                        potentialCaps.delete(currEdge[0]);
                        // Add a join if this segment shares a vertex with the previous. Skip
                        // actually adding join vertices if either the previous segment or this
                        // one has a length of 0.
                        //
                        // Don't add a join if the tangents point in the same direction, which
                        // would mean the edges line up exactly, and there is no need for a join.
                        if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {
                            this._addJoin(begin, lastValidDir, dir, fromColor);
                        }
                    }
                } else {
                    // Start a new line
                    if (dirOK && !connected.has(currEdge[0])) {
                        const existingCap = potentialCaps.get(currEdge[0]);
                        if (existingCap) {
                            this._addJoin(begin, existingCap.dir, dir, fromColor);
                            potentialCaps.delete(currEdge[0]);
                            connected.add(currEdge[0]);
                        } else {
                            potentialCaps.set(currEdge[0], {
                                point: begin,
                                dir: dir.copy().mult(-1),
                                color: fromColor
                            });
                        }
                    }
                    if (lastValidDir && !connected.has(prevEdge[1])) {
                        const existingCap = potentialCaps.get(prevEdge[1]);
                        if (existingCap) {
                            this._addJoin(this.vertices[prevEdge[1]], lastValidDir, existingCap.dir.copy().mult(-1), prevColor);
                            potentialCaps.delete(prevEdge[1]);
                            connected.add(prevEdge[1]);
                        } else {
                            // Close off the last segment with a cap
                            potentialCaps.set(prevEdge[1], {
                                point: this.vertices[prevEdge[1]],
                                dir: lastValidDir,
                                color: prevColor
                            });
                        }
                        lastValidDir = undefined;
                    }
                }
                if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {
                    const existingCap = potentialCaps.get(currEdge[1]);
                    if (existingCap) {
                        this._addJoin(end, dir, existingCap.dir.copy().mult(-1), toColor);
                        potentialCaps.delete(currEdge[1]);
                        connected.add(currEdge[1]);
                    } else {
                        potentialCaps.set(currEdge[1], {
                            point: end,
                            dir,
                            color: toColor
                        });
                    }
                }
                if (dirOK) {
                    lastValidDir = dir;
                }
            }
        }
        for (const { point, dir, color } of potentialCaps.values()){
            this._addCap(point, dir, color);
        }
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for two triangles making a rectangle
   * for a straight line segment. A vertex shader is responsible for picking
   * proper coordinates on the screen given the centerline positions, the tangent,
   * and the side of the centerline each vertex belongs to. Sides follow the
   * following scheme:
   *
   *  -1            -1
   *   o-------------o
   *   |             |
   *   o-------------o
   *   1             1
   *
   * @private
   * @chainable
   */ _addSegment(begin, end, fromColor, toColor, dir) {
        const a = begin.array();
        const b = end.array();
        const dirArr = dir.array();
        this.lineSides.push(1, 1, -1, 1, -1, -1);
        for (const tangents of [
            this.lineTangentsIn,
            this.lineTangentsOut
        ]){
            for(let i = 0; i < 6; i++){
                tangents.push(...dirArr);
            }
        }
        this.lineVertices.push(...a, ...b, ...a, ...b, ...b, ...a);
        if (!this.renderer?._simpleLines) {
            this.lineVertexColors.push(...fromColor, ...toColor, ...fromColor, ...toColor, ...toColor, ...fromColor);
        }
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for two triangles representing the
   * stroke cap of a line. A fragment shader is responsible for displaying the
   * appropriate cap style within the rectangle they make.
   *
   * The lineSides buffer will include the following values for the points on
   * the cap rectangle:
   *
   *           -1  -2
   * -----------o---o
   *            |   |
   * -----------o---o
   *            1   2
   * @private
   * @chainable
   */ _addCap(point, tangent, color) {
        const ptArray = point.array();
        const tanInArray = tangent.array();
        const tanOutArray = [
            0,
            0,
            0
        ];
        for(let i = 0; i < 6; i++){
            this.lineVertices.push(...ptArray);
            this.lineTangentsIn.push(...tanInArray);
            this.lineTangentsOut.push(...tanOutArray);
            this.lineVertexColors.push(...color);
        }
        this.lineSides.push(-1, 2, -2, 1, 2, -1);
        return this;
    }
    /**
   * Adds the vertices and vertex attributes for four triangles representing a
   * join between two adjacent line segments. This creates a quad on either side
   * of the shared vertex of the two line segments, with each quad perpendicular
   * to the lines. A vertex shader will discard all but the quad in the "elbow" of
   * the join, and a fragment shader will display the appropriate join style
   * within the remaining quad.
   *
   * The lineSides buffer will include the following values for the points on
   * the join rectangles:
   *
   *            -1     -2
   * -------------o----o
   *              |    |
   *       1 o----o----o -3
   *         |    | 0  |
   * --------o----o    |
   *        2|    3    |
   *         |         |
   *         |         |
   * @private
   * @chainable
   */ _addJoin(point, fromTangent, toTangent, color) {
        const ptArray = point.array();
        const tanInArray = fromTangent.array();
        const tanOutArray = toTangent.array();
        for(let i = 0; i < 12; i++){
            this.lineVertices.push(...ptArray);
            this.lineTangentsIn.push(...tanInArray);
            this.lineTangentsOut.push(...tanOutArray);
            this.lineVertexColors.push(...color);
        }
        this.lineSides.push(-1, -3, -2, -1, 0, -3);
        this.lineSides.push(3, 1, 2, 3, 0, 1);
        return this;
    }
    /**
   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box
   * centered at the origin.
   *
   * Calling `myGeometry.normalize()` translates the geometry's vertices so that
   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so
   * that they fill a 100×100×100 box. As a result, small geometries will grow
   * and large geometries will shrink.
   *
   * Note: `myGeometry.normalize()` only works when called in the
   * <a href="#/p5/setup">setup()</a> function.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a very small torus.
   *   myGeometry = buildGeometry(function() {;
   *     torus(1, 0.25);
   *   });
   *
   *   // Normalize the torus so its vertices fill
   *   // the range [-100, 100].
   *   myGeometry.normalize();
   *
   *   describe('A white torus rotates slowly against a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   noStroke();
   *
   *   // Draw the torus.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */ normalize() {
        if (this.vertices.length > 0) {
            // Find the corners of our bounding box
            const maxPosition = this.vertices[0].copy();
            const minPosition = this.vertices[0].copy();
            for(let i = 0; i < this.vertices.length; i++){
                maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);
                minPosition.x = Math.min(minPosition.x, this.vertices[i].x);
                maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);
                minPosition.y = Math.min(minPosition.y, this.vertices[i].y);
                maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);
                minPosition.z = Math.min(minPosition.z, this.vertices[i].z);
            }
            const center = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(maxPosition, minPosition, 0.5);
            const dist = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(maxPosition, minPosition);
            const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);
            const scale = 200 / longestDist;
            for(let i = 0; i < this.vertices.length; i++){
                this.vertices[i].sub(center);
                this.vertices[i].mult(scale);
            }
        }
        return this;
    }
    /** Sets the shader's vertex property or attribute variables.
   *
   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some
   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are
   * set using <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/normal">normal()</a>
   * and <a href="#/p5/fill">fill()</a> respectively. Custom properties can also
   * be defined within <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * The first parameter, `propertyName`, is a string with the property's name.
   * This is the same variable name which should be declared in the shader, as in
   * `in vec3 aProperty`, similar to .`setUniform()`.
   *
   * The second parameter, `data`, is the value assigned to the shader variable. This value
   * will be pushed directly onto the Geometry object. There should be the same number
   * of custom property values as vertices, this method should be invoked once for each
   * vertex.
   *
   * The `data` can be a Number or an array of numbers. Tn the shader program the type
   * can be declared according to the WebGL specification. Common types include `float`,
   * `vec2`, `vec3`, `vec4` or matrices.
   *
   * See also the global <a href="#/p5/vertexProperty">vertexProperty()</a> function.
   *
   * @example
   * <div>
   * <code>
   * let geo;
   *
   * function cartesianToSpherical(x, y, z) {
   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
   *   let theta = acos(z / r);
   *   let phi = atan2(y, x);
   *   return { theta, phi };
   * }
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Modify the material shader to display roughness.
   *   const myShader = baseMaterialShader().modify({
   *     vertexDeclarations:`in float aRoughness;
   *                         out float vRoughness;`,
   *     fragmentDeclarations: 'in float vRoughness;',
   *     'void afterVertex': `() {
   *         vRoughness = aRoughness;
   *     }`,
   *     'vec4 combineColors': `(ColorComponents components) {
   *             vec4 color = vec4(0.);
   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);
   *             color.rgb += components.ambient * components.ambientColor;
   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);
   *             color.a = components.opacity;
   *             return color;
   *     }`
   *   });
   *
   *   // Create the Geometry object.
   *   geo = buildGeometry(function() {
   *     fill('hotpink');
   *     sphere(45, 50, 50);
   *   });
   *
   *   // Set the roughness value for every vertex.
   *   for (let v of geo.vertices){
   *
   *     // convert coordinates to spherical coordinates
   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);
   *
   *     // Set the custom roughness vertex property.
   *     let roughness = noise(spherical.theta*5, spherical.phi*5);
   *     geo.vertexProperty('aRoughness', roughness);
   *   }
   *
   *   // Use the custom shader.
   *   shader(myShader);
   *
   *   describe('A rough pink sphere rotating on a blue background.');
   * }
   *
   * function draw() {
   *   // Set some styles and lighting
   *   background('lightblue');
   *   noStroke();
   *
   *   specularMaterial(255,125,100);
   *   shininess(2);
   *
   *   directionalLight('white', -1, 1, -1);
   *   ambientLight(320);
   *
   *   rotateY(millis()*0.001);
   *
   *   // Draw the geometry
   *   model(geo);
   * }
   * </code>
   * </div>
   *
   * @param {String} propertyName the name of the vertex property.
   * @param {Number|Number[]} data the data tied to the vertex property.
   * @param {Number} [size] optional size of each unit of data.
   */ vertexProperty(propertyName, data, size) {
        let prop;
        if (!this.userVertexProperties[propertyName]) {
            prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data, size);
        }
        prop = this.userVertexProperties[propertyName];
        if (size) {
            prop.pushDirect(data);
        } else {
            prop.setCurrentData(data);
            prop.pushCurrentData();
        }
    }
    _userVertexPropertyHelper(propertyName, data, size) {
        const geometryInstance = this;
        const prop = this.userVertexProperties[propertyName] = {
            name: propertyName,
            dataSize: size ? size : data.length ? data.length : 1,
            geometry: geometryInstance,
            // Getters
            getName () {
                return this.name;
            },
            getCurrentData () {
                if (this.currentData === undefined) {
                    this.currentData = new Array(this.getDataSize()).fill(0);
                }
                return this.currentData;
            },
            getDataSize () {
                return this.dataSize;
            },
            getSrcName () {
                const src = this.name.concat('Src');
                return src;
            },
            getDstName () {
                const dst = this.name.concat('Buffer');
                return dst;
            },
            getSrcArray () {
                const srcName = this.getSrcName();
                return this.geometry[srcName];
            },
            //Setters
            setCurrentData (data) {
                data.length ? data.length : 1;
                // if (size != this.getDataSize()){
                //   p5._friendlyError(`Custom vertex property '${this.name}' has been set with various data sizes. You can change it's name, or if it was an accident, set '${this.name}' to have the same number of inputs each time!`, 'vertexProperty()');
                // }
                this.currentData = data;
            },
            // Utilities
            pushCurrentData () {
                const data = this.getCurrentData();
                this.pushDirect(data);
            },
            pushDirect (data) {
                if (data.length) {
                    this.getSrcArray().push(...data);
                } else {
                    this.getSrcArray().push(data);
                }
            },
            resetSrcArray () {
                this.geometry[this.getSrcName()] = [];
            },
            delete () {
                const srcName = this.getSrcName();
                delete this.geometry[srcName];
                delete this;
            }
        };
        this[prop.getSrcName()] = [];
        return this.userVertexProperties[propertyName];
    }
}
/**
 * Keeps track of how many custom geometry objects have been made so that each
 * can be assigned a unique ID.
 */ Geometry.nextId = 0;
function geometry(p51, fn) {
    /**
   * A class to describe a 3D shape.
   *
   * Each `p5.Geometry` object represents a 3D shape as a set of connected
   * points called *vertices*. All 3D shapes are made by connecting vertices to
   * form triangles that are stitched together. Each triangular patch on the
   * geometry's surface is called a *face*. The geometry stores information
   * about its vertices and faces for use with effects such as lighting and
   * texture mapping.
   *
   * The first parameter, `detailX`, is optional. If a number is passed, as in
   * `new p5.Geometry(24)`, it sets the number of triangle subdivisions to use
   * along the geometry's x-axis. By default, `detailX` is 1.
   *
   * The second parameter, `detailY`, is also optional. If a number is passed,
   * as in `new p5.Geometry(24, 16)`, it sets the number of triangle
   * subdivisions to use along the geometry's y-axis. By default, `detailX` is
   * 1.
   *
   * The third parameter, `callback`, is also optional. If a function is passed,
   * as in `new p5.Geometry(24, 16, createShape)`, it will be called once to add
   * vertices to the new 3D shape.
   *
   * @class p5.Geometry
   * @param  {Integer} [detailX] number of vertices along the x-axis.
   * @param  {Integer} [detailY] number of vertices along the y-axis.
   * @param {Function} [callback] function to call once the geometry is created.
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2);
   *
   *   // Add an array to list which vertices belong to the face.
   *   // Vertices are listed in clockwise "winding" order from
   *   // left to top to right.
   *   this.faces.push([0, 1, 2]);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2);
   *
   *   // Add an array to list which vertices belong to the face.
   *   // Vertices are listed in clockwise "winding" order from
   *   // left to top to right.
   *   this.faces.push([0, 1, 2]);
   *
   *   // Compute the surface normals to help with lighting.
   *   this.computeNormals();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * // Adapted from Paul Wheeler's wonderful p5.Geometry tutorial.
   * // https://www.paulwheeler.us/articles/custom-3d-geometry-in-p5js/
   * // CC-BY-SA 4.0
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   // Set detailX to 48 and detailY to 2.
   *   // >>> try changing them.
   *   myGeometry = new p5.Geometry(48, 2, createShape);
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the p5.Geometry object.
   *   strokeWeight(0.2);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // "this" refers to the p5.Geometry object being created.
   *
   *   // Define the Möbius strip with a few parameters.
   *   let spread = 0.1;
   *   let radius = 30;
   *   let stripWidth = 15;
   *   let xInterval = 4 * PI / this.detailX;
   *   let yOffset = -stripWidth / 2;
   *   let yInterval = stripWidth / this.detailY;
   *
   *   for (let j = 0; j <= this.detailY; j += 1) {
   *     // Calculate the "vertical" point along the strip.
   *     let v = yOffset + yInterval * j;
   *
   *     for (let i = 0; i <= this.detailX; i += 1) {
   *       // Calculate the angle of rotation around the strip.
   *       let u = i * xInterval;
   *
   *       // Calculate the coordinates of the vertex.
   *       let x = (radius + v * cos(u / 2)) * cos(u) - sin(u / 2) * 2 * spread;
   *       let y = (radius + v * cos(u / 2)) * sin(u);
   *       if (u < TWO_PI) {
   *         y += sin(u) * spread;
   *       } else {
   *         y -= sin(u) * spread;
   *       }
   *       let z = v * sin(u / 2) + sin(u / 4) * 4 * spread;
   *
   *       // Create a p5.Vector object to position the vertex.
   *       let vert = createVector(x, y, z);
   *
   *       // Add the vertex to the p5.Geometry object's vertices array.
   *       this.vertices.push(vert);
   *     }
   *   }
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   *
   *   // Compute the surface normals to help with lighting.
   *   this.computeNormals();
   * }
   * </code>
   * </div>
   */ p51.Geometry = Geometry;
/**
   * An array with the geometry's vertices.
   *
   * The geometry's vertices are stored as
   * <a href="#/p5.Vector">p5.Vector</a> objects in the `myGeometry.vertices`
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * @property vertices
   * @for p5.Geometry
   * @name vertices
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2);
   *
   *   describe('A white triangle drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus(30, 15, 10, 8);
   *   });
   *
   *   describe('A white torus rotates slowly against a dark gray background. Red spheres mark its vertices.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the p5.Geometry object.
   *   fill(255);
   *   stroke(0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   *
   *   // Style the vertices.
   *   fill(255, 0, 0);
   *   noStroke();
   *
   *   // Iterate over the vertices array.
   *   for (let v of myGeometry.vertices) {
   *     // Draw a sphere to mark the vertex.
   *     push();
   *     translate(v);
   *     sphere(2.5);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * An array with the vectors that are normal to the geometry's vertices.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal
   * vector. Then it calculates the normal vector for each vertex by
   * averaging the normal vectors of the faces surrounding the vertex. The
   * vertex normals are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the `myGeometry.vertexNormals` array.
   *
   * @property vertexNormals
   * @name vertexNormals
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus(30, 15, 10, 8);
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     'A white torus rotates against a dark gray background. Red lines extend outward from its vertices.'
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the p5.Geometry object.
   *   stroke(0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 8);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Display the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */ /**
   * An array that lists which of the geometry's vertices form each of its
   * faces.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*.
   *
   * The geometry's vertices are stored as
   * <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertices">myGeometry.vertices</a> array. The
   * geometry's first vertex is the <a href="#/p5.Vector">p5.Vector</a>
   * object at `myGeometry.vertices[0]`, its second vertex is
   * `myGeometry.vertices[1]`, its third vertex is `myGeometry.vertices[2]`,
   * and so on.
   *
   * For example, a geometry made from a rectangle has two faces because a
   * rectangle is made by joining two triangles. `myGeometry.faces` for a
   * rectangle would be the two-dimensional array `[[0, 1, 2], [2, 1, 3]]`.
   * The first face, `myGeometry.faces[0]`, is the array `[0, 1, 2]` because
   * it's formed by connecting `myGeometry.vertices[0]`,
   * `myGeometry.vertices[1]`,and `myGeometry.vertices[2]`. The second face,
   * `myGeometry.faces[1]`, is the array `[2, 1, 3]` because it's formed by
   * connecting `myGeometry.vertices[2]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[3]`.
   *
   * @property faces
   * @name faces
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     sphere();
   *   });
   *
   *   describe("A sphere drawn on a gray background. The sphere's surface is a grayscale patchwork of triangles.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *
   *   // Set a random seed.
   *   randomSeed(1234);
   *
   *   // Iterate over the faces array.
   *   for (let face of myGeometry.faces) {
   *
   *     // Style the face.
   *     let g = random(0, 255);
   *     fill(g);
   *
   *     // Draw the face.
   *     beginShape();
   *     // Iterate over the vertices that form the face.
   *     for (let f of face) {
   *       // Get the vertex's p5.Vector object.
   *       let v = myGeometry.vertices[f];
   *       vertex(v.x, v.y, v.z);
   *     }
   *     endShape();
   *
   *   }
   * }
   * </code>
   * </div>
   */ /**
   * An array that lists the texture coordinates for each of the geometry's
   * vertices.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a
   * rectangular image that's used as a texture. The geometry's vertex at
   * coordinates `(x, y, z)` maps to the texture image's pixel at coordinates
   * `(u, v)`.
   *
   * The `myGeometry.uvs` array stores the `(u, v)` coordinates for each
   * vertex in the order it was added to the geometry. For example, the
   * first vertex, `myGeometry.vertices[0]`, has its `(u, v)` coordinates
   * stored at `myGeometry.uvs[0]` and `myGeometry.uvs[1]`.
   *
   * @property uvs
   * @name uvs
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Set geom2's texture coordinates.
   *   geom2.uvs = [0.25, 0.25, 0.75, 0.25, 0.25, 0.75, 0.75, 0.75];
   *
   *   // Right (zoomed in).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photo on the right zooms in to the center of the photo.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */ /**
   * A unique identifier for this geometry. The renderer will use this to cache resources.
   *
   * @property {String} gid
   * @for p5.Geometry
   */ }
if (typeof p5 !== 'undefined') {
    geometry(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>GeometryBuilder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
/**
 * @private
 * A class responsible for converting successive WebGL draw calls into a single
 * `p5.Geometry` that can be reused and drawn with `model()`.
 */ class GeometryBuilder {
    constructor(renderer){
        this.renderer = renderer;
        renderer._pInst.push();
        this.identityMatrix = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](4);
        renderer.states.setValue('uModelMatrix', new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Matrix"](4));
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this.renderer);
        this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;
        GeometryBuilder.nextGeometryId++;
        this.hasTransform = false;
    }
    /**
   * @private
   * Applies the current transformation matrix to each vertex.
   */ transformVertices(vertices) {
        if (!this.hasTransform) return vertices;
        return vertices.map((v)=>this.renderer.states.uModelMatrix.multiplyPoint(v));
    }
    /**
   * @private
   * Applies the current normal matrix to each normal.
   */ transformNormals(normals) {
        if (!this.hasTransform) return normals;
        return normals.map((v)=>this.renderer.scratchMat3.multiplyVec(v) // this is a vec3
        );
    }
    /**
   * @private
   * Adds a p5.Geometry to the builder's combined geometry, flattening
   * transformations.
   */ addGeometry(input) {
        this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v, i)=>v === this.identityMatrix.mat4[i]);
        if (this.hasTransform) {
            this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);
        }
        let startIdx = this.geometry.vertices.length;
        this.geometry.vertices.push(...this.transformVertices(input.vertices));
        this.geometry.vertexNormals.push(...this.transformNormals(input.vertexNormals));
        this.geometry.uvs.push(...input.uvs);
        const inputUserVertexProps = input.userVertexProperties;
        const builtUserVertexProps = this.geometry.userVertexProperties;
        const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
        for(const propName in builtUserVertexProps){
            if (propName in inputUserVertexProps) {
                continue;
            }
            const prop = builtUserVertexProps[propName];
            const size = prop.getDataSize();
            const numMissingValues = size * input.vertices.length;
            const missingValues = Array(numMissingValues).fill(0);
            prop.pushDirect(missingValues);
        }
        for(const propName in inputUserVertexProps){
            const prop = inputUserVertexProps[propName];
            const data = prop.getSrcArray();
            const size = prop.getDataSize();
            if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
                const numMissingValues = size * numPreviousVertices;
                const missingValues = Array(numMissingValues).fill(0);
                this.geometry.vertexProperty(propName, missingValues, size);
            }
            this.geometry.vertexProperty(propName, data, size);
        }
        if (this.renderer.states.fillColor) {
            this.geometry.faces.push(...input.faces.map((f)=>f.map((idx)=>idx + startIdx)));
        }
        if (this.renderer.states.strokeColor) {
            this.geometry.edges.push(...input.edges.map((edge)=>edge.map((idx)=>idx + startIdx)));
        }
        const vertexColors = [
            ...input.vertexColors
        ];
        while(vertexColors.length < input.vertices.length * 4){
            vertexColors.push(...this.renderer.states.curFillColor);
        }
        this.geometry.vertexColors.push(...vertexColors);
    }
    /**
   * Adds geometry from the renderer's immediate mode into the builder's
   * combined geometry.
   */ addImmediate(geometry, shapeMode, { validateFaces = false } = {}) {
        const faces = [];
        if (this.renderer.states.fillColor) {
            if (shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"] || shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]) {
                for(let i = 2; i < geometry.vertices.length; i++){
                    if (i % 2 === 0) {
                        faces.push([
                            i,
                            i - 1,
                            i - 2
                        ]);
                    } else {
                        faces.push([
                            i,
                            i - 2,
                            i - 1
                        ]);
                    }
                }
            } else if (shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"]) {
                for(let i = 2; i < geometry.vertices.length; i++){
                    faces.push([
                        0,
                        i - 1,
                        i
                    ]);
                }
            } else if (shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]) {
                for(let i = 0; i < geometry.vertices.length; i += 3){
                    if (!validateFaces || geometry.vertices[i].copy().sub(geometry.vertices[i + 1]).cross(geometry.vertices[i].copy().sub(geometry.vertices[i + 2])).magSq() > 0) {
                        faces.push([
                            i,
                            i + 1,
                            i + 2
                        ]);
                    }
                }
            }
        }
        this.addGeometry(Object.assign({}, geometry, {
            faces
        }));
    }
    /**
   * Adds geometry from the renderer's retained mode into the builder's
   * combined geometry.
   */ addRetained(geometry) {
        this.addGeometry(geometry);
    }
    /**
   * Cleans up the state of the renderer and returns the combined geometry that
   * was built.
   * @returns p5.Geometry The flattened, combined geometry
   */ finish() {
        this.renderer._pInst.pop();
        return this.geometry;
    }
}
/**
 * Keeps track of how many custom geometry objects have been made so that each
 * can be assigned a unique ID.
 */ GeometryBuilder.nextGeometryId = 0;
;
}),
"[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Quat",
    ()=>Quat,
    "default",
    ()=>quat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
;
;
/**
 * @module Math
 * @submodule Quaternion
 */ class Quat {
    constructor(w, x, y, z){
        this.w = w;
        this.vec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x, y, z);
    }
    /**
   * Returns a Quaternion for the
   * axis angle representation of the rotation
   *
   * @method fromAxisAngle
   * @param {Number} [angle] Angle with which the points needs to be rotated
   * @param {Number} [x] x component of the axis vector
   * @param {Number} [y] y component of the axis vector
   * @param {Number} [z] z component of the axis vector
   * @chainable
   */ static fromAxisAngle(angle, x, y, z) {
        const w = Math.cos(angle / 2);
        const vec = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x, y, z).normalize().mult(Math.sin(angle / 2));
        return new Quat(w, vec.x, vec.y, vec.z);
    }
    conjugate() {
        return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
    }
    /**
   * Multiplies a quaternion with other quaternion.
   * @method mult
   * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.
   * @chainable
   */ multiply(quat) {
        return new Quat(this.w * quat.w - this.vec.x * quat.vec.x - this.vec.y * quat.vec.y - this.vec.z - quat.vec.z, this.w * quat.vec.x + this.vec.x * quat.w + this.vec.y * quat.vec.z - this.vec.z * quat.vec.y, this.w * quat.vec.y - this.vec.x * quat.vec.z + this.vec.y * quat.w + this.vec.z * quat.vec.x, this.w * quat.vec.z + this.vec.x * quat.vec.y - this.vec.y * quat.vec.x + this.vec.z * quat.w);
    }
    /**
   * This is similar to quaternion multiplication
   * but when multipying vector with quaternion
   * the multiplication can be simplified to the below formula.
   * This was taken from the below stackexchange link
   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545
   * @private
   * @param {p5.Vector} [p] vector to rotate on the axis quaternion
   */ rotateVector(p) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mult(p, this.w * this.w - this.vec.dot(this.vec)).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mult(this.vec, 2 * p.dot(this.vec))).add(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mult(this.vec, 2 * this.w).cross(p)).clampToZero();
    }
    /**
   * Rotates the Quaternion by the quaternion passed
   * which contains the axis of roation and angle of rotation
   *
   * @method rotateBy
   * @param {p5.Quat} [axesQuat] axis quaternion which contains
   *  the axis of rotation and angle of rotation
   * @chainable
   */ rotateBy(axesQuat) {
        return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
    }
}
function quat(p51, fn) {
    /**
   * A class to describe a Quaternion
   * for vector rotations in the p5js webgl renderer.
   * Please refer the following link for details on the implementation
   * https://danceswithcode.net/engineeringnotes/quaternions/quaternions.html
   * @class p5.Quat
   * @constructor
   * @param {Number} [w] Scalar part of the quaternion
   * @param {Number} [x] x component of imaginary part of quaternion
   * @param {Number} [y] y component of imaginary part of quaternion
   * @param {Number} [z] z component of imaginary part of quaternion
   * @private
   */ p51.Quat = Quat;
}
if (typeof p5 !== 'undefined') {
    quat(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "RenderBuffer",
    ()=>RenderBuffer,
    "default",
    ()=>renderBuffer
]);
class RenderBuffer {
    constructor(size, src, dst, attr, renderer, map){
        this.size = size; // the number of FLOATs in each vertex
        this.src = src; // the name of the model's source array
        this.dst = dst; // the name of the geometry's buffer
        this.attr = attr; // the name of the vertex attribute
        this._renderer = renderer;
        this.map = map; // optional, a transformation function to apply to src
    }
    /**
   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.
   * Must always be done prior to drawing geometry in WebGL.
   * @param {p5.Geometry} geometry Geometry that is going to be drawn
   * @param {p5.Shader} shader Active shader
   * @private
   */ _prepareBuffer(geometry, shader) {
        const attributes = shader.attributes;
        const gl = this._renderer.GL;
        const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry);
        // loop through each of the buffer definitions
        const attr = attributes[this.attr];
        if (!attr) {
            return;
        }
        // check if the geometry has the appropriate source array
        let buffer = glBuffers[this.dst];
        const src = geometry[this.src];
        if (src && src.length > 0) {
            // check if we need to create the GL buffer
            const createBuffer = !buffer;
            if (createBuffer) {
                // create and remember the buffer
                glBuffers[this.dst] = buffer = gl.createBuffer();
            }
            // bind the buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            // check if we need to fill the buffer with data
            if (createBuffer || geometry.dirtyFlags[this.src] !== false) {
                const map = this.map;
                // get the values from the geometry, possibly transformed
                const values = map ? map(src) : src;
                // fill the buffer with the values
                this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
                // mark the geometry's source array as clean
                geometry.dirtyFlags[this.src] = false;
            }
            // enable the attribute
            shader.enableAttrib(attr, this.size);
        } else {
            const loc = attr.location;
            if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {
                return;
            }
            // Disable register corresponding to unused attribute
            gl.disableVertexAttribArray(loc);
            // Record register availability
            this._renderer.registerEnabled.delete(loc);
        }
    }
}
function renderBuffer(p51, fn) {
    p51.RenderBuffer = RenderBuffer;
}
if (typeof p5 !== 'undefined') {
    renderBuffer(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShapeBuilder",
    ()=>ShapeBuilder
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
const INITIAL_BUFFER_STRIDES = {
    vertices: 1,
    vertexNormals: 1,
    vertexColors: 4,
    vertexStrokeColors: 4,
    uvs: 2
};
// The total number of properties per vertex, before additional
// user attributes are added.
const INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next)=>acc + next);
class ShapeBuilder {
    constructor(renderer){
        this.renderer = renderer;
        this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"];
        this.geometry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this.renderer);
        this.geometry.gid = '__IMMEDIATE_MODE_GEOMETRY__';
        this.contourIndices = [];
        this._useUserVertexProperties = undefined;
        this._bezierVertex = [];
        this._quadraticVertex = [];
        this._curveVertex = [];
        // Used to distinguish between user calls to vertex() and internal calls
        this.isProcessingVertices = false;
        // Used for converting shape outlines into triangles for rendering
        this._tessy = this._initTessy();
        this.tessyVertexSize = INITIAL_VERTEX_SIZE;
        this.bufferStrides = {
            ...INITIAL_BUFFER_STRIDES
        };
    }
    constructFromContours(shape, contours) {
        if (this._useUserVertexProperties) {
            this._resetUserVertexProperties();
        }
        this.geometry.reset();
        this.contourIndices = [];
        // TODO: handle just some contours having non-PATH mode
        this.shapeMode = shape.contours[0].kind;
        const shouldProcessEdges = !!this.renderer.states.strokeColor;
        const userVertexPropertyHelpers = {};
        if (shape.userVertexProperties) {
            this._useUserVertexProperties = true;
            for(const key in shape.userVertexProperties){
                const name = shape.vertexPropertyName(key);
                const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);
                userVertexPropertyHelpers[key] = prop;
                this.tessyVertexSize += prop.getDataSize();
                this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
                this.renderer.buffers.user.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RenderBuffer"](prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer));
            }
        } else {
            this._useUserVertexProperties = false;
        }
        for (const contour of contours){
            this.contourIndices.push(this.geometry.vertices.length);
            for (const vertex of contour){
                // WebGL doesn't support QUADS or QUAD_STRIP, so we duplicate data to turn
                // QUADS into TRIANGLES and QUAD_STRIP into TRIANGLE_STRIP. (There is no extra
                // work to convert QUAD_STRIP here, since the only difference is in how edges
                // are rendered.)
                if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Q"]) {
                    // A finished quad turned into triangles should leave 6 vertices in the
                    // buffer:
                    // 0--3     0   3--5
                    // |  | --> | \  \ |
                    // 1--2     1--2   4
                    // When vertex index 3 is being added, add the necessary duplicates.
                    if (this.geometry.vertices.length % 6 === 3) {
                        for(const key in this.bufferStrides){
                            const stride = this.bufferStrides[key];
                            const buffer = this.geometry[key];
                            buffer.push(...buffer.slice(buffer.length - 3 * stride, buffer.length - 2 * stride), ...buffer.slice(buffer.length - stride, buffer.length));
                        }
                    }
                }
                this.geometry.vertices.push(vertex.position);
                this.geometry.vertexNormals.push(vertex.normal || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](0, 0, 0));
                this.geometry.uvs.push(vertex.textureCoordinates.x, vertex.textureCoordinates.y);
                if (this.renderer.states.fillColor) {
                    this.geometry.vertexColors.push(...vertex.fill.array());
                } else {
                    this.geometry.vertexColors.push(0, 0, 0, 0);
                }
                if (this.renderer.states.strokeColor) {
                    this.geometry.vertexStrokeColors.push(...vertex.stroke.array());
                } else {
                    this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
                }
                for(const key in userVertexPropertyHelpers){
                    const prop = userVertexPropertyHelpers[key];
                    if (key in vertex) {
                        prop.setCurrentData(vertex[key]);
                    }
                    prop.pushCurrentData();
                }
            }
        }
        if (shouldProcessEdges) {
            this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);
        }
        if (shouldProcessEdges && !this.renderer.geometryBuilder) {
            this.geometry._edgesToVertices();
        }
        if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"]) {
            this.isProcessingVertices = true;
            this._tesselateShape();
            this.isProcessingVertices = false;
        } else if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]) {
            // The only difference between these two modes is which edges are
            // displayed, so after we've updated the edges, we switch the mode
            // to one that native WebGL knows how to render.
            this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"];
        } else if (this.shapeMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Q"]) {
            // We translate QUADS to TRIANGLES when vertices are being added,
            // since QUADS is just a p5 mode, whereas TRIANGLES is also a mode
            // that native WebGL knows how to render. Once we've processed edges,
            // everything should be set up for TRIANGLES mode.
            this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"];
        }
        if (this.renderer.states.textureMode === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a1"] && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {
            this.geometry.uvs = this.geometry.uvs.map((val, i)=>{
                if (i % 2 === 0) {
                    return val / this.renderer.states._tex.width;
                } else {
                    return val / this.renderer.states._tex.height;
                }
            });
        }
    }
    _resetUserVertexProperties() {
        const properties = this.geometry.userVertexProperties;
        for(const propName in properties){
            const prop = properties[propName];
            delete this.bufferStrides[propName];
            prop.delete();
        }
        this._useUserVertexProperties = false;
        this.tessyVertexSize = INITIAL_VERTEX_SIZE;
        this.geometry.userVertexProperties = {};
    }
    /**
   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and
   * tesselates shapes when applicable.
   * @private
   * @returns  {Number[]} indices for custom shape vertices indicating edges.
   */ _calculateEdges(shapeMode, verts) {
        const res = [];
        let i = 0;
        const contourIndices = this.contourIndices.slice();
        let contourStart = -1;
        switch(shapeMode){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"]:
                for(i = 0; i < verts.length - 2; i++){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i,
                        i + 2
                    ]);
                }
                res.push([
                    i,
                    i + 1
                ]);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["q"]:
                for(i = 1; i < verts.length - 1; i++){
                    res.push([
                        0,
                        i
                    ]);
                    res.push([
                        i,
                        i + 1
                    ]);
                }
                res.push([
                    0,
                    verts.length - 1
                ]);
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"]:
                for(i = 0; i < verts.length - 2; i = i + 3){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 2
                    ]);
                    res.push([
                        i + 2,
                        i
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["L"]:
                for(i = 0; i < verts.length - 1; i = i + 2){
                    res.push([
                        i,
                        i + 1
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Q"]:
                // Quads have been broken up into two triangles by `vertex()`:
                // 0   3--5
                // | \  \ |
                // 1--2   4
                for(i = 0; i < verts.length - 5; i += 6){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 2
                    ]);
                    res.push([
                        i + 2,
                        i + 5
                    ]);
                    res.push([
                        i + 5,
                        i
                    ]);
                }
                break;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"]:
                // 0---2---4
                // |   |   |
                // 1---3---5
                for(i = 0; i < verts.length - 2; i += 2){
                    res.push([
                        i,
                        i + 1
                    ]);
                    res.push([
                        i + 1,
                        i + 3
                    ]);
                    res.push([
                        i,
                        i + 2
                    ]);
                }
                res.push([
                    i,
                    i + 1
                ]);
                break;
            default:
                // TODO: handle contours in other modes too
                for(i = 0; i < verts.length; i++){
                    if (i === contourIndices[0]) {
                        contourStart = contourIndices.shift();
                    } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {
                        res.push([
                            i - 1,
                            contourStart
                        ]);
                    } else {
                        res.push([
                            i - 1,
                            i
                        ]);
                    }
                }
                break;
        }
        return res;
    }
    /**
   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.
   * @private
   */ _tesselateShape() {
        // const contours = [[]];
        const contours = [];
        for(let i = 0; i < this.geometry.vertices.length; i++){
            if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {
                this.contourIndices.shift();
                contours.push([]);
            }
            contours[contours.length - 1].push(this.geometry.vertices[i].x, this.geometry.vertices[i].y, this.geometry.vertices[i].z, this.geometry.uvs[i * 2], this.geometry.uvs[i * 2 + 1], this.geometry.vertexColors[i * 4], this.geometry.vertexColors[i * 4 + 1], this.geometry.vertexColors[i * 4 + 2], this.geometry.vertexColors[i * 4 + 3], this.geometry.vertexNormals[i].x, this.geometry.vertexNormals[i].y, this.geometry.vertexNormals[i].z);
            for(const propName in this.geometry.userVertexProperties){
                const prop = this.geometry.userVertexProperties[propName];
                const start = i * prop.getDataSize();
                const end = start + prop.getDataSize();
                const vals = prop.getSrcArray().slice(start, end);
                contours[contours.length - 1].push(...vals);
            }
        }
        const polyTriangles = this._triangulate(contours);
        // If there were no valid faces, we still want to use the original vertices
        // for strokes, so we'll stop here.
        if (polyTriangles.length === 0) {
            return;
        }
        // TODO: handle non-PATH shape modes that have contours
        this.shapeMode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"];
        const originalVertices = this.geometry.vertices;
        this.geometry.vertices = [];
        this.geometry.vertexNormals = [];
        this.geometry.uvs = [];
        for(const propName in this.geometry.userVertexProperties){
            const prop = this.geometry.userVertexProperties[propName];
            prop.resetSrcArray();
        }
        const colors = [];
        for(let j = 0, polyTriLength = polyTriangles.length; j < polyTriLength; j = j + this.tessyVertexSize){
            colors.push(...polyTriangles.slice(j + 5, j + 9));
            this.geometry.vertexNormals.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](...polyTriangles.slice(j + 9, j + 12)));
            {
                let offset = 12;
                for(const propName in this.geometry.userVertexProperties){
                    const prop = this.geometry.userVertexProperties[propName];
                    const size = prop.getDataSize();
                    const start = j + offset;
                    const end = start + size;
                    prop.setCurrentData(polyTriangles.slice(start, end));
                    prop.pushCurrentData();
                    offset += size;
                }
            }
            this.geometry.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](...polyTriangles.slice(j, j + 3)));
            this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));
        }
        if (this.renderer.geometryBuilder) {
            // Tesselating the face causes the indices of edge vertices to stop being
            // correct. When rendering, this is not a problem, since _edgesToVertices
            // will have been called before this, and edge vertex indices are no longer
            // needed. However, the geometry builder still needs this information, so
            // when one is active, we need to update the indices.
            //
            // We record index mappings in a Map so that once we have found a
            // corresponding vertex, we don't need to loop to find it again.
            const newIndex = new Map();
            this.geometry.edges = this.geometry.edges.map((edge)=>edge.map((origIdx)=>{
                    if (!newIndex.has(origIdx)) {
                        const orig = originalVertices[origIdx];
                        let newVertIndex = this.geometry.vertices.findIndex((v)=>orig.x === v.x && orig.y === v.y && orig.z === v.z);
                        if (newVertIndex === -1) {
                            // The tesselation process didn't output a vertex with the exact
                            // coordinate as before, potentially due to numerical issues. This
                            // doesn't happen often, but in this case, pick the closest point
                            let closestDist = Infinity;
                            let closestIndex = 0;
                            for(let i = 0; i < this.geometry.vertices.length; i++){
                                const vert = this.geometry.vertices[i];
                                const dX = orig.x - vert.x;
                                const dY = orig.y - vert.y;
                                const dZ = orig.z - vert.z;
                                const dist = dX * dX + dY * dY + dZ * dZ;
                                if (dist < closestDist) {
                                    closestDist = dist;
                                    closestIndex = i;
                                }
                            }
                            newVertIndex = closestIndex;
                        }
                        newIndex.set(origIdx, newVertIndex);
                    }
                    return newIndex.get(origIdx);
                }));
        }
        this.geometry.vertexColors = colors;
    }
    _initTessy() {
        // function called for each vertex of tesselator output
        function vertexCallback(data, polyVertArray) {
            for (const element of data){
                polyVertArray.push(element);
            }
        }
        function begincallback(type) {
            if (type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].primitiveType.GL_TRIANGLES) {
                console.log(`expected TRIANGLES but got type: ${type}`);
            }
        }
        function errorcallback(errno) {
            console.log('error callback');
            console.log(`error number: ${errno}`);
        }
        // callback for when segments intersect and must be split
        const combinecallback = (coords, data, weight)=>{
            const result = new Array(this.tessyVertexSize).fill(0);
            for(let i = 0; i < weight.length; i++){
                for(let j = 0; j < result.length; j++){
                    if (weight[i] === 0 || !data[i]) continue;
                    result[j] += data[i][j] * weight[i];
                }
            }
            return result;
        };
        function edgeCallback(flag) {
        // don't really care about the flag, but need no-strip/no-fan behavior
        }
        const tessy = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].GluTesselator();
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_BEGIN, begincallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_ERROR, errorcallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_COMBINE, combinecallback);
        tessy.gluTessCallback(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
        tessy.gluTessProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].gluEnum.GLU_TESS_WINDING_RULE, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].windingRule.GLU_TESS_WINDING_NONZERO);
        return tessy;
    }
    /**
   * Runs vertices through libtess to convert them into triangles
   * @private
   */ _triangulate(contours) {
        // libtess will take 3d verts and flatten to a plane for tesselation.
        // libtess is capable of calculating a plane to tesselate on, but
        // if all of the vertices have the same z values, we'll just
        // assume the face is facing the camera, letting us skip any performance
        // issues or bugs in libtess's automatic calculation.
        const z = contours[0] ? contours[0][2] : undefined;
        let allSameZ = true;
        for (const contour of contours){
            for(let j = 0; j < contour.length; j += this.tessyVertexSize){
                if (contour[j + 2] !== z) {
                    allSameZ = false;
                    break;
                }
            }
        }
        if (allSameZ) {
            this._tessy.gluTessNormal(0, 0, 1);
        } else {
            // Let libtess pick a plane for us
            this._tessy.gluTessNormal(0, 0, 0);
        }
        const triangleVerts = [];
        this._tessy.gluTessBeginPolygon(triangleVerts);
        for (const contour of contours){
            this._tessy.gluTessBeginContour();
            for(let j = 0; j < contour.length; j += this.tessyVertexSize){
                const coords = contour.slice(j, j + this.tessyVertexSize);
                this._tessy.gluTessVertex(coords, coords);
            }
            this._tessy.gluTessEndContour();
        }
        // finish polygon
        this._tessy.gluTessEndPolygon();
        return triangleVerts;
    }
}
;
}),
"[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GeometryBufferCache",
    ()=>GeometryBufferCache
]);
class GeometryBufferCache {
    constructor(renderer){
        this.renderer = renderer;
        this.cache = {};
    }
    numCached() {
        return Object.keys(this.cache).length;
    }
    isCached(gid) {
        return this.cache[gid] !== undefined;
    }
    getGeometryByID(gid) {
        return this.cache[gid]?.geometry;
    }
    getCached(model) {
        return this.getCachedID(model.gid);
    }
    getCachedID(gid) {
        return this.cache[gid];
    }
    ensureCached(geometry) {
        const gid = geometry.gid;
        if (!gid) {
            throw new Error('The p5.Geometry you passed in has no gid property!');
        }
        if (this.isCached(geometry.gid)) return this.getCached(geometry);
        const gl = this.renderer.GL;
        //initialize the gl buffers for our geom groups
        this.freeBuffers(gid);
        if (Object.keys(this.cache).length > 1000) {
            const key = Object.keys(this.cache)[0];
            this.freeBuffers(key);
        }
        //create a new entry in our cache
        const buffers = {};
        this.cache[gid] = buffers;
        buffers.geometry = geometry;
        let indexBuffer = buffers.indexBuffer;
        if (geometry.faces.length) {
            // allocate space for faces
            if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();
            const vals = geometry.faces.flat();
            // If any face references a vertex with an index greater than the maximum
            // un-singed 16 bit integer, then we need to use a Uint32Array instead of a
            // Uint16Array
            const hasVertexIndicesOverMaxUInt16 = vals.some((v)=>v > 65535);
            let type = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
            this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type);
            // If we're using a Uint32Array for our indexBuffer we will need to pass a
            // different enum value to WebGL draw triangles. This happens in
            // the _drawElements function.
            buffers.indexBufferType = hasVertexIndicesOverMaxUInt16 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
        } else {
            // the index buffer is unused, remove it
            if (indexBuffer) {
                gl.deleteBuffer(indexBuffer);
                buffers.indexBuffer = null;
            }
        }
        return buffers;
    }
    freeBuffers(gid) {
        const buffers = this.cache[gid];
        if (!buffers) {
            return;
        }
        delete this.cache[gid];
        const gl = this.renderer.GL;
        if (buffers.indexBuffer) {
            gl.deleteBuffer(buffers.indexBuffer);
        }
        function freeBuffers(defs) {
            for (const def of defs){
                if (buffers[def.dst]) {
                    gl.deleteBuffer(buffers[def.dst]);
                    buffers[def.dst] = null;
                }
            }
        }
        // free all the buffers
        freeBuffers(this.renderer.buffers.stroke);
        freeBuffers(this.renderer.buffers.fill);
        freeBuffers(this.renderer.buffers.user);
    }
}
;
}),
"[project]/node_modules/p5/dist/webgl/interaction.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>interaction
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
;
;
/**
 * @module 3D
 * @submodule Interaction
 * @for p5
 * @requires core
 */ function interaction(p51, fn) {
    /**
   * Allows the user to orbit around a 3D sketch using a mouse, trackpad, or
   * touchscreen.
   *
   * 3D sketches are viewed through an imaginary camera. Calling
   * `orbitControl()` within the <a href="#/p5/draw">draw()</a> function allows
   * the user to change the camera’s position:
   *
   * ```js
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Rest of sketch.
   * }
   * ```
   *
   * Left-clicking and dragging or swipe motion will rotate the camera position
   * about the center of the sketch. Right-clicking and dragging or multi-swipe
   * will pan the camera position without rotation. Using the mouse wheel
   * (scrolling) or pinch in/out will move the camera further or closer from the
   * center of the sketch.
   *
   * The first three parameters, `sensitivityX`, `sensitivityY`, and
   * `sensitivityZ`, are optional. They’re numbers that set the sketch’s
   * sensitivity to movement along each axis. For example, calling
   * `orbitControl(1, 2, -1)` keeps movement along the x-axis at its default
   * value, makes the sketch twice as sensitive to movement along the y-axis,
   * and reverses motion along the z-axis. By default, all sensitivity values
   * are 1.
   *
   * The fourth parameter, `options`, is also optional. It’s an object that
   * changes the behavior of orbiting. For example, calling
   * `orbitControl(1, 1, 1, options)` keeps the default sensitivity values while
   * changing the behaviors set with `options`. The object can have the
   * following properties:
   *
   * ```js
   * let options = {
   *   // Setting this to false makes mobile interactions smoother by
   *   // preventing accidental interactions with the page while orbiting.
   *   // By default, it's true.
   *   disableTouchActions: true,
   *
   *   // Setting this to true makes the camera always rotate in the
   *   // direction the mouse/touch is moving.
   *   // By default, it's false.
   *   freeRotation: false
   * };
   *
   * orbitControl(1, 1, 1, options);
   * ```
   *
   * @method orbitControl
   * @for p5
   * @param  {Number} [sensitivityX] sensitivity to movement along the x-axis. Defaults to 1.
   * @param  {Number} [sensitivityY] sensitivity to movement along the y-axis. Defaults to 1.
   * @param  {Number} [sensitivityZ] sensitivity to movement along the z-axis. Defaults to 1.
   * @param  {Object} [options] Settings for orbitControl:
   * @param {Boolean} [options.disableTouchActions=true] Prevent accidental interactions with the page while orbiting.
   * @param {Boolean} [options.freeRotation=false] Rotate in the drag direction instead of on principal axes.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   // Make the interactions 3X sensitive.
   *   orbitControl(3, 3, 3);
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A multicolor box on a gray background. The camera angle changes when the user interacts using a mouse, trackpad, or touchscreen.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create an options object.
   *   let options = {
   *     disableTouchActions: false,
   *     freeRotation: true
   *   };
   *
   *   // Enable orbiting with the mouse.
   *   // Prevent accidental touch actions on touchscreen devices
   *   // and enable free rotation.
   *   orbitControl(1, 1, 1, options);
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(30, 50);
   * }
   * </code>
   * </div>
   */ // implementation based on three.js 'orbitControls':
    // https://github.com/mrdoob/three.js/blob/6afb8595c0bf8b2e72818e42b64e6fe22707d896/examples/jsm/controls/OrbitControls.js#L22
    fn.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options) {
        this._assert3d('orbitControl');
        // p5._validateParameters('orbitControl', arguments);
        const cam = this._renderer.states.curCamera;
        if (typeof sensitivityX === 'undefined') {
            sensitivityX = 1;
        }
        if (typeof sensitivityY === 'undefined') {
            sensitivityY = sensitivityX;
        }
        if (typeof sensitivityZ === 'undefined') {
            sensitivityZ = 1;
        }
        if (typeof options !== 'object') {
            options = {};
        }
        // default right-mouse and mouse-wheel behaviors (context menu and scrolling,
        // respectively) are disabled here to allow use of those events for panning and
        // zooming. However, whether or not to disable touch actions is an option.
        // disable context menu for canvas element and add 'contextMenuDisabled'
        // flag to p5 instance
        if (this.contextMenuDisabled !== true) {
            this.canvas.oncontextmenu = ()=>false;
            this.contextMenuDisabled = true;
        }
        // disable default scrolling behavior on the canvas element and add
        // 'wheelDefaultDisabled' flag to p5 instance
        if (this.wheelDefaultDisabled !== true) {
            this.canvas.onwheel = ()=>false;
            this.wheelDefaultDisabled = true;
        }
        // disable default touch behavior on the canvas element and add
        // 'touchActionsDisabled' flag to p5 instance
        const { disableTouchActions = true } = options;
        if (this.touchActionsDisabled !== true && disableTouchActions) {
            this.canvas.style['touch-action'] = 'none';
            this.touchActionsDisabled = true;
        }
        // If option.freeRotation is true, the camera always rotates freely in the direction
        // the pointer moves. default value is false (normal behavior)
        const { freeRotation = false } = options;
        // get moved touches.
        const movedTouches = [];
        this.touches.forEach((curTouch)=>{
            this._renderer.prevTouches.forEach((prevTouch)=>{
                if (curTouch.id === prevTouch.id) {
                    const movedTouch = {
                        x: curTouch.x,
                        y: curTouch.y,
                        px: prevTouch.x,
                        py: prevTouch.y
                    };
                    movedTouches.push(movedTouch);
                }
            });
        });
        this._renderer.prevTouches = this.touches;
        // The idea of using damping is based on the following website. thank you.
        // https://github.com/freshfork/p5.EasyCam/blob/9782964680f6a5c4c9bee825c475d9f2021d5134/p5.easycam.js#L1124
        // variables for interaction
        let deltaRadius = 0;
        let deltaTheta = 0;
        let deltaPhi = 0;
        let moveDeltaX = 0;
        let moveDeltaY = 0;
        // constants for dampingProcess
        const damping = 0.85;
        const rotateAccelerationFactor = 0.6;
        const moveAccelerationFactor = 0.15;
        // For touches, the appropriate scale is different
        // because the distance difference is multiplied.
        const mouseZoomScaleFactor = 0.01;
        const touchZoomScaleFactor = 0.0004;
        const scaleFactor = this.height < this.width ? this.height : this.width;
        // Flag whether the mouse or touch pointer is inside the canvas
        let pointersInCanvas = false;
        // calculate and determine flags and variables.
        if (movedTouches.length > 0) {
            /* for touch */ // if length === 1, rotate
            // if length > 1, zoom and move
            // for touch, it is calculated based on one moved touch pointer position.
            pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
            if (movedTouches.length === 1) {
                const t = movedTouches[0];
                deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;
                deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;
            } else {
                const t0 = movedTouches[0];
                const t1 = movedTouches[1];
                const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);
                const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);
                const changeDist = distWithTouches - prevDistWithTouches;
                // move the camera farther when the distance between the two touch points
                // decreases, move the camera closer when it increases.
                deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;
                // Move the center of the camera along with the movement of
                // the center of gravity of the two touch points.
                moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);
                moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);
            }
            if (this.touches.length > 0) {
                if (pointersInCanvas) {
                    // Initiate an interaction if touched in the canvas
                    this._renderer.executeRotateAndMove = true;
                    this._renderer.executeZoom = true;
                }
            } else {
                // End an interaction when the touch is released
                this._renderer.executeRotateAndMove = false;
                this._renderer.executeZoom = false;
            }
        } else {
            /* for mouse */ // if wheelDeltaY !== 0, zoom
            // if mouseLeftButton is down, rotate
            // if mouseRightButton is down, move
            // For mouse, it is calculated based on the mouse position.
            pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && this.mouseY > 0 && this.mouseY < this.height;
            if (this._mouseWheelDeltaY !== 0) {
                // zoom the camera depending on the value of _mouseWheelDeltaY.
                // move away if positive, move closer if negative
                deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
                deltaRadius *= mouseZoomScaleFactor;
                this._mouseWheelDeltaY = 0;
                // start zoom when the mouse is wheeled within the canvas.
                if (pointersInCanvas) this._renderer.executeZoom = true;
            } else {
                // quit zoom when you stop wheeling.
                this._renderer.executeZoom = false;
            }
            if (this.mouseIsPressed) {
                if (this.mouseButton.left) {
                    deltaTheta = -sensitivityX * this.movedX / scaleFactor;
                    deltaPhi = sensitivityY * this.movedY / scaleFactor;
                } else if (this.mouseButton.right) {
                    moveDeltaX = this.movedX;
                    moveDeltaY = this.movedY * cam.yScale;
                }
                // start rotate and move when mouse is pressed within the canvas.
                if (pointersInCanvas) this._renderer.executeRotateAndMove = true;
            } else {
                // quit rotate and move if mouse is released.
                this._renderer.executeRotateAndMove = false;
            }
        }
        // interactions
        // zoom process
        if (deltaRadius !== 0 && this._renderer.executeZoom) {
            // accelerate zoom velocity
            this._renderer.zoomVelocity += deltaRadius;
        }
        if (Math.abs(this._renderer.zoomVelocity) > 0.001) {
            // if freeRotation is true, we use _orbitFree() instead of _orbit()
            if (freeRotation) {
                cam._orbitFree(0, 0, this._renderer.zoomVelocity);
            } else {
                cam._orbit(0, 0, this._renderer.zoomVelocity);
            }
            // In orthogonal projection, the scale does not change even if
            // the distance to the gaze point is changed, so the projection matrix
            // needs to be modified.
            if (cam.projMatrix.mat4[15] !== 0) {
                cam.projMatrix.mat4[0] *= Math.pow(10, -this._renderer.zoomVelocity);
                cam.projMatrix.mat4[5] *= Math.pow(10, -this._renderer.zoomVelocity);
                // modify uPMatrix
                this._renderer.states.setValue('uPMatrix', this._renderer.states.uPMatrix.clone());
                this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
                this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
            }
            // damping
            this._renderer.zoomVelocity *= damping;
        } else {
            this._renderer.zoomVelocity = 0;
        }
        // rotate process
        if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) {
            // accelerate rotate velocity
            this._renderer.rotateVelocity.add(deltaTheta * rotateAccelerationFactor, deltaPhi * rotateAccelerationFactor);
        }
        if (this._renderer.rotateVelocity.magSq() > 0.000001) {
            // if freeRotation is true, the camera always rotates freely in the direction the pointer moves
            if (freeRotation) {
                cam._orbitFree(-this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
            } else {
                cam._orbit(this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
            }
            // damping
            this._renderer.rotateVelocity.mult(damping);
        } else {
            this._renderer.rotateVelocity.set(0, 0);
        }
        // move process
        if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
            // Normalize movement distance
            const ndcX = moveDeltaX * 2 / this.width;
            const ndcY = -moveDeltaY * 2 / this.height;
            // accelerate move velocity
            this._renderer.moveVelocity.add(ndcX * moveAccelerationFactor, ndcY * moveAccelerationFactor);
        }
        if (this._renderer.moveVelocity.magSq() > 0.000001) {
            // Translate the camera so that the entire object moves
            // perpendicular to the line of sight when the mouse is moved
            // or when the centers of gravity of the two touch pointers move.
            const local = cam._getLocalAxes();
            // Calculate the z coordinate in the view coordinates of
            // the center, that is, the distance to the view point
            const diffX = cam.eyeX - cam.centerX;
            const diffY = cam.eyeY - cam.centerY;
            const diffZ = cam.eyeZ - cam.centerZ;
            const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
            // position vector of the center.
            let cv = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](cam.centerX, cam.centerY, cam.centerZ);
            // Calculate the normalized device coordinates of the center.
            cv = cam.cameraMatrix.multiplyPoint(cv);
            cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
            // Move the center by this distance
            // in the normalized device coordinate system.
            cv.x -= this._renderer.moveVelocity.x;
            cv.y -= this._renderer.moveVelocity.y;
            // Calculate the translation vector
            // in the direction perpendicular to the line of sight of center.
            let dx, dy;
            const uP = this._renderer.states.uPMatrix.mat4;
            if (uP[15] === 0) {
                dx = (uP[8] + cv.x) / uP[0] * viewZ;
                dy = (uP[9] + cv.y) / uP[5] * viewZ;
            } else {
                dx = (cv.x - uP[12]) / uP[0];
                dy = (cv.y - uP[13]) / uP[5];
            }
            // translate the camera.
            cam.setPosition(cam.eyeX + dx * local.x[0] + dy * local.y[0], cam.eyeY + dx * local.x[1] + dy * local.y[1], cam.eyeZ + dx * local.x[2] + dy * local.y[2]);
            // damping
            this._renderer.moveVelocity.mult(damping);
        } else {
            this._renderer.moveVelocity.set(0, 0);
        }
        return this;
    };
    /**
   * Adds a grid and an axes icon to clarify orientation in 3D sketches.
   *
   * `debugMode()` adds a grid that shows where the “ground” is in a sketch. By
   * default, the grid will run through the origin `(0, 0, 0)` of the sketch
   * along the XZ plane. `debugMode()` also adds an axes icon that points along
   * the positive x-, y-, and z-axes. Calling `debugMode()` displays the grid
   * and axes icon with their default size and position.
   *
   * There are four ways to call `debugMode()` with optional parameters to
   * customize the debugging environment.
   *
   * The first way to call `debugMode()` has one parameter, `mode`. If the
   * system constant `GRID` is passed, as in `debugMode(GRID)`, then the grid
   * will be displayed and the axes icon will be hidden. If the constant `AXES`
   * is passed, as in `debugMode(AXES)`, then the axes icon will be displayed
   * and the grid will be hidden.
   *
   * The second way to call `debugMode()` has six parameters. The first
   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The
   * next five parameters, `gridSize`, `gridDivisions`, `xOff`, `yOff`, and
   * `zOff` are optional. They’re numbers that set the appearance of the grid
   * (`gridSize` and `gridDivisions`) and the placement of the axes icon
   * (`xOff`, `yOff`, and `zOff`). For example, calling
   * `debugMode(20, 5, 10, 10, 10)` sets the `gridSize` to 20 pixels, the number
   * of `gridDivisions` to 5, and offsets the axes icon by 10 pixels along the
   * x-, y-, and z-axes.
   *
   * The third way to call `debugMode()` has five parameters. The first
   * parameter, `mode`, selects either `GRID` or `AXES` to be displayed. The
   * next four parameters, `axesSize`, `xOff`, `yOff`, and `zOff` are optional.
   * They’re numbers that set the appearance of the size of the axes icon
   * (`axesSize`) and its placement (`xOff`, `yOff`, and `zOff`).
   *
   * The fourth way to call `debugMode()` has nine optional parameters. The
   * first five parameters, `gridSize`, `gridDivisions`, `gridXOff`, `gridYOff`,
   * and `gridZOff` are numbers that set the appearance of the grid. For
   * example, calling `debugMode(100, 5, 0, 0, 0)` sets the `gridSize` to 100,
   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that
   * the grid is centered at the origin. The next four parameters, `axesSize`,
   * `xOff`, `yOff`, and `zOff` are numbers that set the appearance of the size
   * of the axes icon (`axesSize`) and its placement (`axesXOff`, `axesYOff`,
   * and `axesZOff`). For example, calling
   * `debugMode(100, 5, 0, 0, 0, 50, 10, 10, 10)` sets the `gridSize` to 100,
   * the number of `gridDivisions` to 5, and sets all the offsets to 0 so that
   * the grid is centered at the origin. It then sets the `axesSize` to 50 and
   * offsets the icon 10 pixels along each axis.
   *
   * @method debugMode
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   debugMode();
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Only display the axes icon.
   *   debugMode(AXES);
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Only display the grid and customize it:
   *   // - size: 50
   *   // - divisions: 10
   *   // - offsets: 0, 20, 0
   *   debugMode(GRID, 50, 10, 0, 20, 0);
   *
   *   describe('A multicolor box on a gray background. A grid is displayed below the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   // Display the grid and axes icon and customize them:
   *   // Grid
   *   // ----
   *   // - size: 50
   *   // - divisions: 10
   *   // - offsets: 0, 20, 0
   *   // Axes
   *   // ----
   *   // - size: 50
   *   // - offsets: 0, 0, 0
   *   debugMode(50, 10, 0, 20, 0, 50, 0, 0, 0);
   *
   *   describe('A multicolor box on a gray background. A grid is displayed below the box. An axes icon is displayed at the center of the box.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.
   *   box(20, 40);
   * }
   * </code>
   * </div>
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode either GRID or AXES
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode
   * @param {Number} [gridSize] side length of the grid.
   * @param {Number} [gridDivisions] number of divisions in the grid.
   * @param {Number} [xOff] offset from origin along the x-axis.
   * @param {Number} [yOff] offset from origin along the y-axis.
   * @param {Number} [zOff] offset from origin along the z-axis.
   */ /**
   * @method debugMode
   * @param {(GRID|AXES)} mode
   * @param {Number} [axesSize] length of axes icon markers.
   * @param {Number} [xOff]
   * @param {Number} [yOff]
   * @param {Number} [zOff]
   */ /**
   * @method debugMode
   * @param {Number} [gridSize]
   * @param {Number} [gridDivisions]
   * @param {Number} [gridXOff] grid offset from the origin along the x-axis.
   * @param {Number} [gridYOff] grid offset from the origin along the y-axis.
   * @param {Number} [gridZOff] grid offset from the origin along the z-axis.
   * @param {Number} [axesSize]
   * @param {Number} [axesXOff] axes icon offset from the origin along the x-axis.
   * @param {Number} [axesYOff] axes icon offset from the origin along the y-axis.
   * @param {Number} [axesZOff] axes icon offset from the origin along the z-axis.
   */ fn.debugMode = function(...args) {
        this._assert3d('debugMode');
        // p5._validateParameters('debugMode', args);
        // start by removing existing 'post' registered debug methods
        for(let i = p51.lifecycleHooks.postdraw.length - 1; i >= 0; i--){
            // test for equality...
            if (p51.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p51.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
                p51.lifecycleHooks.postdraw.splice(i, 1);
            }
        }
        // then add new debugMode functions according to the argument list
        if (args[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["G"]) {
            p51.lifecycleHooks.postdraw.push(this._grid(args[1], args[2], args[3], args[4], args[5]));
        } else if (args[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["A"]) {
            p51.lifecycleHooks.postdraw.push(this._axesIcon(args[1], args[2], args[3], args[4]));
        } else {
            p51.lifecycleHooks.postdraw.push(this._grid(args[0], args[1], args[2], args[3], args[4]));
            p51.lifecycleHooks.postdraw.push(this._axesIcon(args[5], args[6], args[7], args[8]));
        }
    };
    /**
   * Turns off <a href="#/p5/debugMode">debugMode()</a> in a 3D sketch.
   *
   * @method noDebugMode
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Enable debug mode.
   *   debugMode();
   *
   *   describe('A multicolor box on a gray background. A grid and axes icon are displayed near the box. They disappear when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Style the box.
   *   normalMaterial();
   *
   *   // Draw the box.  box(20, 40);
   * }
   *
   * // Disable debug mode when the user double-clicks.
   * function doubleClicked() {
   *   noDebugMode();
   * }
   * </code>
   * </div>
   */ fn.noDebugMode = function() {
        this._assert3d('noDebugMode');
        // start by removing existing 'post' registered debug methods
        for(let i = p51.lifecycleHooks.postdraw.length - 1; i >= 0; i--){
            // test for equality...
            if (p51.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p51.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
                p51.lifecycleHooks.postdraw.splice(i, 1);
            }
        }
    };
    /**
   * For use with debugMode
   * @private
   * @method _grid
   * @param {Number} [size] size of grid sides
   * @param {Number} [div] number of grid divisions
   * @param {Number} [xOff] offset of grid center from origin in X axis
   * @param {Number} [yOff] offset of grid center from origin in Y axis
   * @param {Number} [zOff] offset of grid center from origin in Z axis
   */ fn._grid = function(size, numDivs, xOff, yOff, zOff) {
        if (typeof size === 'undefined') {
            size = this.width / 2;
        }
        if (typeof numDivs === 'undefined') {
            // ensure at least 2 divisions
            numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
        }
        if (typeof xOff === 'undefined') {
            xOff = 0;
        }
        if (typeof yOff === 'undefined') {
            yOff = 0;
        }
        if (typeof zOff === 'undefined') {
            zOff = 0;
        }
        const spacing = size / numDivs;
        const halfSize = size / 2;
        return function() {
            this.push();
            this.stroke(this._renderer.states.curStrokeColor[0] * 255, this._renderer.states.curStrokeColor[1] * 255, this._renderer.states.curStrokeColor[2] * 255);
            this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());
            this._renderer.states.uModelMatrix.reset();
            // Lines along X axis
            for(let q = 0; q <= numDivs; q++){
                this.beginShape(this.LINES);
                this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
                this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
                this.endShape();
            }
            // Lines along Z axis
            for(let i = 0; i <= numDivs; i++){
                this.beginShape(this.LINES);
                this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);
                this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);
                this.endShape();
            }
            this.pop();
        };
    };
    /**
   * For use with debugMode
   * @private
   * @method _axesIcon
   * @param {Number} [size] size of axes icon lines
   * @param {Number} [xOff] offset of icon from origin in X axis
   * @param {Number} [yOff] offset of icon from origin in Y axis
   * @param {Number} [zOff] offset of icon from origin in Z axis
   */ fn._axesIcon = function(size, xOff, yOff, zOff) {
        if (typeof size === 'undefined') {
            size = this.width / 20 > 40 ? this.width / 20 : 40;
        }
        if (typeof xOff === 'undefined') {
            xOff = -this.width / 4;
        }
        if (typeof yOff === 'undefined') {
            yOff = xOff;
        }
        if (typeof zOff === 'undefined') {
            zOff = xOff;
        }
        return ()=>{
            this.push();
            this._renderer.states.setValue('uModelMatrix', this._renderer.states.uModelMatrix.clone());
            this._renderer.states.uModelMatrix.reset();
            // X axis
            this.strokeWeight(2);
            this.stroke(255, 0, 0);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff + size, yOff, zOff);
            this.endShape();
            // Y axis
            this.stroke(0, 255, 0);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff, yOff + size, zOff);
            this.endShape();
            // Z axis
            this.stroke(0, 0, 255);
            this.beginShape(this.LINES);
            this.vertex(xOff, yOff, zOff);
            this.vertex(xOff, yOff, zOff + size);
            this.endShape();
            this.pop();
        };
    };
}
if (typeof p5 !== 'undefined') {
    interaction(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/loading.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>loading
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
/**
 * @module Shape
 * @submodule 3D Models
 * @for p5
 * @requires core
 * @requires p5.Geometry
 */ async function fileExists(url) {
    try {
        const response = await fetch(url, {
            method: 'HEAD'
        });
        return response.ok;
    } catch (error) {
        return false;
    }
}
function loading(p51, fn) {
    /**
   * Loads a 3D model to create a
   * <a href="#/p5.Geometry">p5.Geometry</a> object.
   *
   * `loadModel()` can load 3D models from OBJ and STL files. Once the model is
   * loaded, it can be displayed with the
   * <a href="#/p5/model">model()</a> function, as in `model(shape)`.
   *
   * There are three ways to call `loadModel()` with optional parameters to help
   * process the model.
   *
   * The first parameter, `path`, is a `String` with the path to the file. Paths
   * to local files should be relative, as in `loadModel('assets/model.obj')`.
   * URLs such as `'https://example.com/model.obj'` may be blocked due to browser
   * security. The `path` parameter can also be defined as a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request)
   * object for more advanced usage.
   * Note: When loading a `.obj` file that references materials stored in
   * `.mtl` files, p5.js will attempt to load and apply those materials.
   * To ensure that the `.obj` file reads the `.mtl` file correctly include the
   * `.mtl` file alongside it.
   *
   * The first way to call `loadModel()` has three optional parameters after the
   * file path. The first optional parameter, `successCallback`, is a function
   * to call once the model loads. For example,
   * `loadModel('assets/model.obj', handleModel)` will call the `handleModel()`
   * function once the model loads. The second optional parameter,
   * `failureCallback`, is a function to call if the model fails to load. For
   * example, `loadModel('assets/model.obj', handleModel, handleFailure)` will
   * call the `handleFailure()` function if an error occurs while loading. The
   * third optional parameter, `fileType`, is the model’s file extension as a
   * string. For example,
   * `loadModel('assets/model', handleModel, handleFailure, '.obj')` will try to
   * load the file model as a `.obj` file.
   *
   * The second way to call `loadModel()` has four optional parameters after the
   * file path. The first optional parameter is a `Boolean` value. If `true` is
   * passed, as in `loadModel('assets/model.obj', true)`, then the model will be
   * resized to ensure it fits the canvas. The next three parameters are
   * `successCallback`, `failureCallback`, and `fileType` as described above.
   *
   * The third way to call `loadModel()` has one optional parameter after the
   * file path. The optional parameter, `options`, is an `Object` with options,
   * as in `loadModel('assets/model.obj', options)`. The `options` object can
   * have the following properties:
   *
   * ```js
   * let options = {
   *   // Enables standardized size scaling during loading if set to true.
   *   normalize: true,
   *
   *   // Function to call once the model loads.
   *   successCallback: handleModel,
   *
   *   // Function to call if an error occurs while loading.
   *   failureCallback: handleError,
   *
   *   // Model's file extension.
   *   fileType: '.stl',
   *
   *   // Flips the U texture coordinates of the model.
   *   flipU: false,
   *
   *   // Flips the V texture coordinates of the model.
   *   flipV: false
   * };
   *
   * // Pass the options object to loadModel().
   * loadModel('assets/model.obj', options);
   * ```
   *
   * This function returns a `Promise` and should be used in an `async` setup with
   * `await`. See the examples for the usage syntax.
   *
   * Note: There’s no support for colored STL files. STL files with color will
   * be rendered without color.
   *
   * @method loadModel
   * @param  {String|Request} path      path of the model to be loaded.
   * @param  {String} [fileType]          model’s file extension. Either `'.obj'` or `'.stl'`.
   * @param  {Boolean} [normalize]        if `true`, scale the model to fit the canvas.
   * @param  {function(p5.Geometry)} [successCallback] function to call once the model is loaded. Will be passed
   *                                                   the <a href="#/p5.Geometry">p5.Geometry</a> object.
   * @param  {function(Event)} [failureCallback] function to call if the model fails to load. Will be passed an `Error` event object.
   * @return {Promise<p5.Geometry>} the <a href="#/p5.Geometry">p5.Geometry</a> object
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   shape = await loadModel('assets/teapot.obj');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * // Normalize the geometry's size to fit the canvas.
   * async function setup() {
   *   shape = await loadModel('assets/teapot.obj', true);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', true, handleModel);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and log the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', true, handleModel, handleError);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', '.obj', true, handleModel, handleError);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   * let options = {
   *   fileType: '.obj',
   *   normalize: true,
   *   successCallback: handleModel,
   *   failureCallback: handleError
   * };
   *
   * // Load the file and create a p5.Geometry object.
   * async function setup() {
   *   await loadModel('assets/teapot.obj', options);
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white teapot drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   *
   * // Set the shape variable and print the geometry's
   * // ID to the console.
   * function handleModel(data) {
   *   shape = data;
   *   console.log(shape.gid);
   * }
   *
   * // Print an error message if the file doesn't load.
   * function handleError(error) {
   *   console.error('Oops!', error);
   * }
   * </code>
   * </div>
   */ /**
   * @method loadModel
   * @param  {String|Request} path
   * @param  {String} [fileType]
   * @param  {function(p5.Geometry)} [successCallback]
   * @param  {function(Event)} [failureCallback]
   * @return {Promise<p5.Geometry>} new <a href="#/p5.Geometry">p5.Geometry</a> object.
   */ /**
   * @method loadModel
   * @param  {String|Request} path
   * @param  {Object} [options] loading options.
   * @param  {String} [options.fileType]
   * @param  {function(p5.Geometry)} [options.successCallback]
   * @param  {function(Event)} [options.failureCallback]
   * @param  {Boolean} [options.normalize]
   * @param  {Boolean} [options.flipU]
   * @param  {Boolean} [options.flipV]
   * @return {Promise<p5.Geometry>} new <a href="#/p5.Geometry">p5.Geometry</a> object.
   */ fn.loadModel = async function(path, fileType, normalize, successCallback, failureCallback) {
        // p5._validateParameters('loadModel', arguments);
        let flipU = false;
        let flipV = false;
        if (typeof fileType === 'object') {
            // Passing in options object
            normalize = fileType.normalize || false;
            successCallback = fileType.successCallback;
            failureCallback = fileType.failureCallback;
            fileType = fileType.fileType || fileType;
            flipU = fileType.flipU || false;
            flipV = fileType.flipV || false;
        } else {
            // Passing in individual parameters
            if (typeof arguments[arguments.length - 1] === 'function') {
                if (typeof arguments[arguments.length - 2] === 'function') {
                    successCallback = arguments[arguments.length - 2];
                    failureCallback = arguments[arguments.length - 1];
                } else {
                    successCallback = arguments[arguments.length - 1];
                }
            }
            if (typeof fileType === 'string') {
                if (typeof normalize !== 'boolean') normalize = false;
            } else if (typeof fileType === 'boolean') {
                normalize = fileType;
                fileType = path.slice(-4);
            } else {
                fileType = path.slice(-4);
                normalize = false;
            }
        }
        if (fileType.toLowerCase() !== '.obj' && fileType.toLowerCase() !== '.stl') {
            fileType = '.obj';
        }
        const model = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"](undefined, undefined, undefined, this._renderer);
        model.gid = `${path}|${normalize}`;
        async function getMaterials(lines) {
            const parsedMaterialPromises = [];
            for (let line of lines){
                const mtllibMatch = line.match(/^mtllib (.+)/);
                if (mtllibMatch) {
                    // Object has material
                    let mtlPath = '';
                    const mtlFilename = mtllibMatch[1];
                    const objPathParts = path.split('/');
                    if (objPathParts.length > 1) {
                        objPathParts.pop();
                        const objFolderPath = objPathParts.join('/');
                        mtlPath = objFolderPath + '/' + mtlFilename;
                    } else {
                        mtlPath = mtlFilename;
                    }
                    parsedMaterialPromises.push(fileExists(mtlPath).then((exists)=>{
                        if (exists) {
                            return parseMtl(mtlPath);
                        } else {
                            console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
                            return {};
                        }
                    }).catch((error)=>{
                        console.warn(`Error loading MTL file: ${mtlPath}`, error);
                        return {};
                    }));
                }
            }
            try {
                const parsedMaterials = await Promise.all(parsedMaterialPromises);
                const materials = Object.assign({}, ...parsedMaterials);
                return materials;
            } catch (error) {
                return {};
            }
        }
        try {
            if (fileType.match(/\.stl$/i)) {
                const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(path, 'arrayBuffer');
                parseSTL(model, data);
                if (normalize) {
                    model.normalize();
                }
                if (flipU) {
                    model.flipU();
                }
                if (flipV) {
                    model.flipV();
                }
                model._makeTriangleEdges();
                if (successCallback) {
                    return successCallback(model);
                } else {
                    return model;
                }
            } else if (fileType.match(/\.obj$/i)) {
                const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(path, 'text');
                const lines = data.split('\n');
                const parsedMaterials = await getMaterials(lines);
                parseObj(model, lines, parsedMaterials);
                if (normalize) {
                    model.normalize();
                }
                if (flipU) {
                    model.flipU();
                }
                if (flipV) {
                    model.flipV();
                }
                model._makeTriangleEdges();
                if (successCallback) {
                    return successCallback(model);
                } else {
                    return model;
                }
            }
        } catch (err) {
            p51._friendlyFileLoadError(3, path);
            if (failureCallback) {
                return failureCallback(err);
            } else {
                throw err;
            }
        }
    };
    /**
   * @private
   */ async function parseMtl(mtlPath) {
        let currentMaterial = null;
        let materials = {};
        const { data } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(mtlPath, 'text');
        const lines = data.split('\n');
        for(let line = 0; line < lines.length; ++line){
            const tokens = lines[line].trim().split(/\s+/);
            if (tokens[0] === 'newmtl') {
                const materialName = tokens[1];
                currentMaterial = materialName;
                materials[currentMaterial] = {};
            } else if (tokens[0] === 'Kd') {
                //Diffuse color
                materials[currentMaterial].diffuseColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'Ka') {
                //Ambient Color
                materials[currentMaterial].ambientColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'Ks') {
                //Specular color
                materials[currentMaterial].specularColor = [
                    parseFloat(tokens[1]),
                    parseFloat(tokens[2]),
                    parseFloat(tokens[3])
                ];
            } else if (tokens[0] === 'map_Kd') {
                //Texture path
                materials[currentMaterial].texturePath = tokens[1];
            }
        }
        return materials;
    }
    /**
   * @private
   * Parse OBJ lines into model. For reference, this is what a simple model of a
   * square might look like:
   *
   * v -0.5 -0.5 0.5
   * v -0.5 -0.5 -0.5
   * v -0.5 0.5 -0.5
   * v -0.5 0.5 0.5
   *
   * f 4 3 2 1
   */ function parseObj(model, lines, materials = {}) {
        // OBJ allows a face to specify an index for a vertex (in the above example),
        // but it also allows you to specify a custom combination of vertex, UV
        // coordinate, and vertex normal. So, "3/4/3" would mean, "use vertex 3 with
        // UV coordinate 4 and vertex normal 3". In WebGL, every vertex with different
        // parameters must be a different vertex, so loadedVerts is used to
        // temporarily store the parsed vertices, normals, etc., and indexedVerts is
        // used to map a specific combination (keyed on, for example, the string
        // "3/4/3"), to the actual index of the newly created vertex in the final
        // object.
        const loadedVerts = {
            v: [],
            vt: [],
            vn: []
        };
        // Map from source index → Map of material → destination index
        const usedVerts = {}; // Track colored vertices
        let currentMaterial = null;
        let hasColoredVertices = false;
        let hasColorlessVertices = false;
        for(let line = 0; line < lines.length; ++line){
            // Each line is a separate object (vertex, face, vertex normal, etc)
            // For each line, split it into tokens on whitespace. The first token
            // describes the type.
            const tokens = lines[line].trim().split(/\b\s+/);
            if (tokens.length > 0) {
                if (tokens[0] === 'usemtl') {
                    // Switch to a new material
                    currentMaterial = tokens[1];
                } else if (tokens[0] === 'v' || tokens[0] === 'vn') {
                    // Check if this line describes a vertex or vertex normal.
                    // It will have three numeric parameters.
                    const vertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
                    loadedVerts[tokens[0]].push(vertex);
                } else if (tokens[0] === 'vt') {
                    // Check if this line describes a texture coordinate.
                    // It will have two numeric parameters U and V (W is omitted).
                    // Because of WebGL texture coordinates rendering behaviour, the V
                    // coordinate is inversed.
                    const texVertex = [
                        parseFloat(tokens[1]),
                        1 - parseFloat(tokens[2])
                    ];
                    loadedVerts[tokens[0]].push(texVertex);
                } else if (tokens[0] === 'f') {
                    // Check if this line describes a face.
                    // OBJ faces can have more than three points. Triangulate points.
                    for(let tri = 3; tri < tokens.length; ++tri){
                        const face = [];
                        const vertexTokens = [
                            1,
                            tri - 1,
                            tri
                        ];
                        for(let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd){
                            // Now, convert the given token into an index
                            const vertString = tokens[vertexTokens[tokenInd]];
                            let vertParts = vertString.split('/');
                            // TODO: Faces can technically use negative numbers to refer to the
                            // previous nth vertex. I haven't seen this used in practice, but
                            // it might be good to implement this in the future.
                            for(let i = 0; i < vertParts.length; i++){
                                vertParts[i] = parseInt(vertParts[i]) - 1;
                            }
                            if (!usedVerts[vertString]) {
                                usedVerts[vertString] = {};
                            }
                            if (usedVerts[vertString][currentMaterial] === undefined) {
                                const vertIndex = model.vertices.length;
                                model.vertices.push(loadedVerts.v[vertParts[0]].copy());
                                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [
                                    0,
                                    0
                                ]);
                                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"]());
                                usedVerts[vertString][currentMaterial] = vertIndex;
                                face.push(vertIndex);
                                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
                                    hasColoredVertices = true;
                                    const materialDiffuseColor = materials[currentMaterial].diffuseColor;
                                    model.vertexColors.push(materialDiffuseColor[0]);
                                    model.vertexColors.push(materialDiffuseColor[1]);
                                    model.vertexColors.push(materialDiffuseColor[2]);
                                    model.vertexColors.push(1);
                                } else {
                                    hasColorlessVertices = true;
                                }
                            } else {
                                face.push(usedVerts[vertString][currentMaterial]);
                            }
                        }
                        if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {
                            model.faces.push(face);
                        }
                    }
                }
            }
        }
        // If the model doesn't have normals, compute the normals
        if (model.vertexNormals.length === 0) {
            model.computeNormals();
        }
        if (hasColoredVertices === hasColorlessVertices) {
            // If both are true or both are false, throw an error because the model is inconsistent
            throw new Error('Model coloring is inconsistent. Either all vertices should have colors or none should.');
        }
        return model;
    }
    /**
   * @private
   * STL files can be of two types, ASCII and Binary,
   *
   * We need to convert the arrayBuffer to an array of strings,
   * to parse it as an ASCII file.
   */ function parseSTL(model, buffer) {
        if (isBinary(buffer)) {
            parseBinarySTL(model, buffer);
        } else {
            const reader = new DataView(buffer);
            if (!('TextDecoder' in window)) {
                console.warn('Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)');
                return model;
            }
            const decoder = new TextDecoder('utf-8');
            const lines = decoder.decode(reader);
            const lineArray = lines.split('\n');
            parseASCIISTL(model, lineArray);
        }
        return model;
    }
    /**
   * @private
   * This function checks if the file is in ASCII format or in Binary format
   *
   * It is done by searching keyword `solid` at the start of the file.
   *
   * An ASCII STL data must begin with `solid` as the first six bytes.
   * However, ASCII STLs lacking the SPACE after the `d` are known to be
   * plentiful. So, check the first 5 bytes for `solid`.
   *
   * Several encodings, such as UTF-8, precede the text with up to 5 bytes:
   * https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding
   * Search for `solid` to start anywhere after those prefixes.
   */ function isBinary(data) {
        const reader = new DataView(data);
        // US-ASCII ordinal values for `s`, `o`, `l`, `i`, `d`
        const solid = [
            115,
            111,
            108,
            105,
            100
        ];
        for(let off = 0; off < 5; off++){
            // If "solid" text is matched to the current offset, declare it to be an ASCII STL.
            if (matchDataViewAt(solid, reader, off)) return false;
        }
        // Couldn't find "solid" text at the beginning; it is binary STL.
        return true;
    }
    /**
   * @private
   * This function matches the `query` at the provided `offset`
   */ function matchDataViewAt(query, reader, offset) {
        // Check if each byte in query matches the corresponding byte from the current offset
        for(let i = 0, il = query.length; i < il; i++){
            if (query[i] !== reader.getUint8(offset + i, false)) return false;
        }
        return true;
    }
    /**
   * @private
   * This function parses the Binary STL files.
   * https://en.wikipedia.org/wiki/STL_%28file_format%29#Binary_STL
   *
   * Currently there is no support for the colors provided in STL files.
   */ function parseBinarySTL(model, buffer) {
        const reader = new DataView(buffer);
        // Number of faces is present following the header
        const faces = reader.getUint32(80, true);
        let r, g, b, hasColors = false, colors;
        let defaultR, defaultG, defaultB;
        // Binary files contain 80-byte header, which is generally ignored.
        for(let index = 0; index < 80 - 10; index++){
            // Check for `COLOR=`
            if (reader.getUint32(index, false) === 0x434f4c4f /*COLO*/  && reader.getUint8(index + 4) === 0x52 /*'R'*/  && reader.getUint8(index + 5) === 0x3d /*'='*/ ) {
                hasColors = true;
                colors = [];
                defaultR = reader.getUint8(index + 6) / 255;
                defaultG = reader.getUint8(index + 7) / 255;
                defaultB = reader.getUint8(index + 8) / 255;
            // To be used when color support is added
            // alpha = reader.getUint8(index + 9) / 255;
            }
        }
        const dataOffset = 84;
        const faceLength = 12 * 4 + 2;
        // Iterate the faces
        for(let face = 0; face < faces; face++){
            const start = dataOffset + face * faceLength;
            const normalX = reader.getFloat32(start, true);
            const normalY = reader.getFloat32(start + 4, true);
            const normalZ = reader.getFloat32(start + 8, true);
            if (hasColors) {
                const packedColor = reader.getUint16(start + 48, true);
                if ((packedColor & 0x8000) === 0) {
                    // facet has its own unique color
                    r = (packedColor & 0x1f) / 31;
                    g = (packedColor >> 5 & 0x1f) / 31;
                    b = (packedColor >> 10 & 0x1f) / 31;
                } else {
                    r = defaultR;
                    g = defaultG;
                    b = defaultB;
                }
            }
            const newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](normalX, normalY, normalZ);
            for(let i = 1; i <= 3; i++){
                const vertexstart = start + i * 12;
                const newVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](reader.getFloat32(vertexstart, true), reader.getFloat32(vertexstart + 4, true), reader.getFloat32(vertexstart + 8, true));
                model.vertices.push(newVertex);
                model.vertexNormals.push(newNormal);
                if (hasColors) {
                    colors.push(r, g, b);
                }
            }
            model.faces.push([
                3 * face,
                3 * face + 1,
                3 * face + 2
            ]);
            model.uvs.push([
                0,
                0
            ], [
                0,
                0
            ], [
                0,
                0
            ]);
        }
        return model;
    }
    /**
   * @private
   * ASCII STL file starts with `solid 'nameOfFile'`
   * Then contain the normal of the face, starting with `facet normal`
   * Next contain a keyword indicating the start of face vertex, `outer loop`
   * Next comes the three vertex, starting with `vertex x y z`
   * Vertices ends with `endloop`
   * Face ends with `endfacet`
   * Next face starts with `facet normal`
   * The end of the file is indicated by `endsolid`
   */ function parseASCIISTL(model, lines) {
        let state = '';
        let curVertexIndex = [];
        let newNormal, newVertex;
        for(let iterator = 0; iterator < lines.length; ++iterator){
            const line = lines[iterator].trim();
            const parts = line.split(' ');
            for(let partsiterator = 0; partsiterator < parts.length; ++partsiterator){
                if (parts[partsiterator] === '') {
                    // Ignoring multiple whitespaces
                    parts.splice(partsiterator, 1);
                }
            }
            if (parts.length === 0) {
                continue;
            }
            switch(state){
                case '':
                    if (parts[0] !== 'solid') {
                        // Invalid state
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "solid"`);
                        return;
                    } else {
                        state = 'solid';
                    }
                    break;
                case 'solid':
                    if (parts[0] !== 'facet' || parts[1] !== 'normal') {
                        // Invalid state
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "facet normal"`);
                        return;
                    } else {
                        // Push normal for first face
                        newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                        model.vertexNormals.push(newNormal, newNormal, newNormal);
                        state = 'facet normal';
                    }
                    break;
                case 'facet normal':
                    if (parts[0] !== 'outer' || parts[1] !== 'loop') {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
                        return;
                    } else {
                        // Next should be vertices
                        state = 'vertex';
                    }
                    break;
                case 'vertex':
                    if (parts[0] === 'vertex') {
                        //Vertex of triangle
                        newVertex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
                        model.vertices.push(newVertex);
                        model.uvs.push([
                            0,
                            0
                        ]);
                        curVertexIndex.push(model.vertices.indexOf(newVertex));
                    } else if (parts[0] === 'endloop') {
                        // End of vertices
                        model.faces.push(curVertexIndex);
                        curVertexIndex = [];
                        state = 'endloop';
                    } else {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "vertex" or "endloop"`);
                        return;
                    }
                    break;
                case 'endloop':
                    if (parts[0] !== 'endfacet') {
                        // End of face
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
                        return;
                    } else {
                        state = 'endfacet';
                    }
                    break;
                case 'endfacet':
                    if (parts[0] === 'endsolid') ;
                    else if (parts[0] === 'facet' && parts[1] === 'normal') {
                        // Next face
                        newNormal = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
                        model.vertexNormals.push(newNormal, newNormal, newNormal);
                        state = 'facet normal';
                    } else {
                        // Invalid State
                        console.error(line);
                        console.error(`Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`);
                        return;
                    }
                    break;
                default:
                    console.error(`Invalid state "${state}"`);
                    break;
            }
        }
        return model;
    }
    /**
   * Draws a <a href="#/p5.Geometry">p5.Geometry</a> object to the canvas.
   *
   * The parameter, `model`, is the
   * <a href="#/p5.Geometry">p5.Geometry</a> object to draw.
   * <a href="#/p5.Geometry">p5.Geometry</a> objects can be built with
   * <a href="#/p5/buildGeometry">buildGeometry()</a>, or
   * <a href="#/p5/beginGeometry">beginGeometry()</a> and
   * <a href="#/p5/endGeometry">endGeometry()</a>. They can also be loaded from
   * a file with <a href="#/p5/loadGeometry">loadGeometry()</a>.
   *
   * Note: `model()` can only be used in WebGL mode.
   *
   * @method model
   * @param  {p5.Geometry} model 3D shape to be drawn.
   *
   * @param {Number} [count=1] number of instances to draw.
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   shape = buildGeometry(createShape);
   *
   *   describe('A white cone drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the p5.Geometry object.
   *   model(shape);
   * }
   *
   * // Create p5.Geometry object from a single cone.
   * function createShape() {
   *   cone();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the p5.Geometry object.
   *   shape = buildGeometry(createArrow);
   *
   *   describe('Two white arrows drawn on a gray background. The arrow on the right rotates slowly.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the arrows.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object.
   *   model(shape);
   *
   *   // Translate and rotate the coordinate system.
   *   translate(30, 0, 0);
   *   rotateZ(frameCount * 0.01);
   *
   *   // Draw the p5.Geometry object again.
   *   model(shape);
   * }
   *
   * function createArrow() {
   *   // Add shapes to the p5.Geometry object.
   *   push();
   *   rotateX(PI);
   *   cone(10);
   *   translate(0, -10, 0);
   *   cylinder(3, 20);
   *   pop();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let shape;
   *
   * async function setup() {
   *   shape = await loadModel('assets/octahedron.obj');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A white octahedron drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Draw the shape.
   *   model(shape);
   * }
   * </code>
   * </div>
   */ fn.model = function(model, count = 1) {
        this._assert3d('model');
        // p5._validateParameters('model', arguments);
        this._renderer.model(model, count);
    };
    /**
   * Load a 3d model from an OBJ or STL string.
   *
   * OBJ and STL files lack a built-in sense of scale, causing models exported from different programs to vary in size.
   * If your model doesn't display correctly, consider using `loadModel()` with `normalize` set to `true` to standardize its size.
   * Further adjustments can be made using the `scale()` function.
   *
   * Also, the support for colored STL files is not present. STL files with color will be
   * rendered without color properties.
   *
   * * Options can include:
   * - `modelString`: Specifies the plain text string of either an stl or obj file to be loaded.
   * - `fileType`: Defines the file extension of the model.
   * - `normalize`: Enables standardized size scaling during loading if set to true.
   * - `successCallback`: Callback for post-loading actions with the 3D model object.
   * - `failureCallback`: Handles errors if model loading fails, receiving an event error.
   * - `flipU`: Flips the U texture coordinates of the model.
   * - `flipV`: Flips the V texture coordinates of the model.
   *
   *
   * @method createModel
   * @param  {String} modelString         String of the object to be loaded
   * @param  {String} [fileType]          The file extension of the model
   *                                      (<code>.stl</code>, <code>.obj</code>).
   * @param  {Boolean} [normalize]        If true, scale the model to a
   *                                      standardized size when loading
   * @param  {function(p5.Geometry)} [successCallback] Function to be called
   *                                     once the model is loaded. Will be passed
   *                                     the 3D model object.
   * @param  {function(Event)} [failureCallback] called with event error if
   *                                         the model fails to load.
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   *
   * @example
   * <div>
   * <code>
   * const octahedron_model = `
   * v 0.000000E+00 0.000000E+00 40.0000
   * v 22.5000 22.5000 0.000000E+00
   * v 22.5000 -22.5000 0.000000E+00
   * v -22.5000 -22.5000 0.000000E+00
   * v -22.5000 22.5000 0.000000E+00
   * v 0.000000E+00 0.000000E+00 -40.0000
   * f     1 2 3
   * f     1 3 4
   * f     1 4 5
   * f     1 5 2
   * f     6 5 4
   * f     6 4 3
   * f     6 3 2
   * f     6 2 5
   * `;
   * //draw a spinning octahedron
   * let octahedron;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   octahedron = createModel(octahedron_model, '.obj');
   *   describe('Vertically rotating 3D octahedron.');
   * }
   *
   * function draw() {
   *   background(200);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   model(octahedron);
   *}
   * </code>
   * </div>
   */ /**
   * @method createModel
   * @param  {String} modelString
   * @param  {String} [fileType]
   * @param  {function(p5.Geometry)} [successCallback]
   * @param  {function(Event)} [failureCallback]
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   */ /**
   * @method createModel
   * @param  {String} modelString
   * @param  {String} [fileType]
   * @param  {Object} [options]
   * @param  {function(p5.Geometry)} [options.successCallback]
   * @param  {function(Event)} [options.failureCallback]
   * @param  {boolean} [options.normalize]
   * @param  {boolean} [options.flipU]
   * @param  {boolean} [options.flipV]
   * @return {p5.Geometry} the <a href="#/p5.Geometry">p5.Geometry</a> object
   */ let modelCounter = 0;
    fn.createModel = function(modelString, fileType = ' ', options) {
        // p5._validateParameters('createModel', arguments);
        let normalize = false;
        let successCallback;
        let failureCallback;
        let flipU = false;
        let flipV = false;
        if (options && typeof options === 'object') {
            normalize = options.normalize || false;
            successCallback = options.successCallback;
            failureCallback = options.failureCallback;
            flipU = options.flipU || false;
            flipV = options.flipV || false;
        } else if (typeof options === 'boolean') {
            normalize = options;
            successCallback = arguments[3];
            failureCallback = arguments[4];
        } else {
            successCallback = typeof arguments[2] === 'function' ? arguments[2] : undefined;
            failureCallback = arguments[3];
        }
        const model = new p51.Geometry();
        model.gid = `${fileType}|${normalize}|${modelCounter++}`;
        if (fileType.match(/\.stl$/i)) {
            try {
                let uint8array = new TextEncoder().encode(modelString);
                let arrayBuffer = uint8array.buffer;
                parseSTL(model, arrayBuffer);
            } catch (error) {
                if (failureCallback) {
                    failureCallback(error);
                } else {
                    p51._friendlyError('Error during parsing: ' + error.message);
                }
                return;
            }
        } else if (fileType.match(/\.obj$/i)) {
            try {
                const lines = modelString.split('\n');
                parseObj(model, lines);
            } catch (error) {
                if (failureCallback) {
                    failureCallback(error);
                } else {
                    p51._friendlyError('Error during parsing: ' + error.message);
                }
                return;
            }
        } else {
            p51._friendlyFileLoadError(3, modelString);
            if (failureCallback) {
                failureCallback();
            } else {
                p51._friendlyError('Sorry, the file type is invalid. Only OBJ and STL files are supported.');
            }
        }
        if (normalize) {
            model.normalize();
        }
        if (flipU) {
            model.flipU();
        }
        if (flipV) {
            model.flipV();
        }
        model._makeTriangleEdges();
        if (typeof successCallback === 'function') {
            successCallback(model);
        }
        return model;
    };
}
if (typeof p5 !== 'undefined') {
    loading(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/webgl/text.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>text
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function text(p5, fn) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype.maxCachedGlyphs = function() {
        // TODO: use more than vibes to find a good value for this
        return 200;
    };
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Font"].prototype._getFontInfo = function(axs) {
        // For WebGL, a cache of font data to use on the GPU.
        this._fontInfos = this._fontInfos || {};
        const key = JSON.stringify(axs);
        if (this._fontInfos[key]) {
            const val = this._fontInfos[key];
            return val;
        } else {
            const val = new FontInfo(this, {
                axs
            });
            this._fontInfos[key] = val;
            return val;
        }
    };
    // Text/Typography (see src/type/textCore.js)
    /*
  RendererGL.prototype.textWidth = function(s) {
    if (this._isOpenType()) {
      return this.states.textFont.font._textWidth(s, this.states.textSize);
    }

    return 0; // TODO: error
  };
  */ // rendering constants
    // the number of rows/columns dividing each glyph
    const charGridWidth = 9;
    const charGridHeight = charGridWidth;
    // size of the image holding the bezier stroke info
    const strokeImageWidth = 64;
    const strokeImageHeight = 64;
    // size of the image holding the stroke indices for each row/col
    const gridImageWidth = 64;
    const gridImageHeight = 64;
    // size of the image holding the offset/length of each row/col stripe
    const cellImageWidth = 64;
    const cellImageHeight = 64;
    /**
   * @private
   * @class ImageInfos
   * @param {Integer} width
   * @param {Integer} height
   *
   * the ImageInfos class holds a list of ImageDatas of a given size.
   */ class ImageInfos {
        constructor(width, height){
            this.width = width;
            this.height = height;
            this.infos = []; // the list of images
        }
        /**
     *
     * @param {Integer} space
     * @return {Object} contains the ImageData, and pixel index into that
     *                  ImageData where the free space was allocated.
     *
     * finds free space of a given size in the ImageData list
     */ findImage(space) {
            const imageSize = this.width * this.height;
            if (space > imageSize) throw new Error('font is too complex to render in 3D');
            // search through the list of images, looking for one with
            // anough unused space.
            let imageInfo, imageData;
            for(let ii = this.infos.length - 1; ii >= 0; --ii){
                const imageInfoTest = this.infos[ii];
                if (imageInfoTest.index + space < imageSize) {
                    // found one
                    imageInfo = imageInfoTest;
                    imageData = imageInfoTest.imageData;
                    break;
                }
            }
            if (!imageInfo) {
                try {
                    // create a new image
                    imageData = new ImageData(this.width, this.height);
                } catch (err) {
                    // for browsers that don't support ImageData constructors (ie IE11)
                    // create an ImageData using the old method
                    let canvas = document.getElementsByTagName('canvas')[0];
                    const created = !canvas;
                    if (!canvas) {
                        // create a temporary canvas
                        canvas = document.createElement('canvas');
                        canvas.style.display = 'none';
                        document.body.appendChild(canvas);
                    }
                    const ctx = canvas.getContext('2d');
                    if (ctx) {
                        imageData = ctx.createImageData(this.width, this.height);
                    }
                    if (created) {
                        // distroy the temporary canvas, if necessary
                        document.body.removeChild(canvas);
                    }
                }
                // construct & dd the new image info
                imageInfo = {
                    index: 0,
                    imageData
                };
                this.infos.push(imageInfo);
            }
            const index = imageInfo.index;
            imageInfo.index += space; // move to the start of the next image
            imageData._dirty = true;
            return {
                imageData,
                index
            };
        }
    }
    /**
   * @function setPixel
   * @private
   * @param {Object} imageInfo
   * @param {Number} r
   * @param {Number} g
   * @param {Number} b
   * @param {Number} a
   *
   * writes the next pixel into an indexed ImageData
   */ function setPixel(imageInfo, r, g, b, a) {
        const imageData = imageInfo.imageData;
        const pixels = imageData.data;
        let index = imageInfo.index++ * 4;
        pixels[index++] = r;
        pixels[index++] = g;
        pixels[index++] = b;
        pixels[index++] = a;
    }
    const SQRT3 = Math.sqrt(3);
    /**
   * @private
   * @class FontInfo
   * @param {Object} font an opentype.js font object
   *
   * contains cached images and glyph information for an opentype font
   */ class FontInfo {
        constructor(font, { axs } = {}){
            this.font = font;
            this.axs = axs;
            // the bezier curve coordinates
            this.strokeImageInfos = new ImageInfos(strokeImageWidth, strokeImageHeight);
            // lists of curve indices for each row/column slice
            this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
            this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
            // the offset & length of each row/col slice in the glyph
            this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
            this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
            // the cached information for each glyph
            this.glyphInfos = {};
        }
        /**
     * @param {Glyph} glyph the x positions of points in the curve
     * @returns {Object} the glyphInfo for that glyph
     *
     * calculates rendering info for a glyph, including the curve information,
     * row & column stripes compiled into textures.
     */ getGlyphInfo(glyph) {
            // check the cache
            let gi = this.glyphInfos[glyph.index];
            if (gi) return gi;
            const axs = this.axs;
            const { glyph: { path: { commands } } } = this.font._singleShapeToPath(glyph.shape, {
                axs
            });
            let xMin = Infinity;
            let xMax = -Infinity;
            let yMin = Infinity;
            let yMax = -Infinity;
            for (const cmd of commands){
                for(let i = 1; i < cmd.length; i += 2){
                    xMin = Math.min(xMin, cmd[i]);
                    xMax = Math.max(xMax, cmd[i]);
                    yMin = Math.min(yMin, cmd[i + 1]);
                    yMax = Math.max(yMax, cmd[i + 1]);
                }
            }
            // don't bother rendering invisible glyphs
            if (xMin >= xMax || yMin >= yMax || !commands.length) {
                return this.glyphInfos[glyph.index] = {};
            }
            const gWidth = xMax - xMin;
            const gHeight = yMax - yMin;
            // Convert arrays to named objects
            const cmds = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayCommandsToObjects"])(commands);
            let i;
            const strokes = []; // the strokes in this glyph
            const rows = []; // the indices of strokes in each row
            const cols = []; // the indices of strokes in each column
            for(i = charGridWidth - 1; i >= 0; --i)cols.push([]);
            for(i = charGridHeight - 1; i >= 0; --i)rows.push([]);
            /**
       * @function push
       * @private
       * @param {Number[]} xs the x positions of points in the curve
       * @param {Number[]} ys the y positions of points in the curve
       * @param {Object} v    the curve information
       *
       * adds a curve to the rows & columns that it intersects with
       */ function push(xs, ys, v) {
                const index = strokes.length; // the index of this stroke
                strokes.push(v); // add this stroke to the list
                /**
         * @function minMax
         * @private
         * @param {Number[]} rg the list of values to compare
         * @param {Number} min the initial minimum value
         * @param {Number} max the initial maximum value
         *
         * find the minimum & maximum value in a list of values
         */ function minMax(rg, min, max) {
                    for(let i = rg.length; i-- > 0;){
                        const v = rg[i];
                        if (min > v) min = v;
                        if (max < v) max = v;
                    }
                    return {
                        min,
                        max
                    };
                }
                // Expand the bounding box of the glyph by the number of cells below
                // before rounding. Curves only partially through a cell won't be added
                // to adjacent cells, but ones that are close will be. This helps fix
                // small visual glitches that occur when curves are close to grid cell
                // boundaries.
                const cellOffset = 0.5;
                // loop through the rows & columns that the curve intersects
                // adding the curve to those slices
                const mmX = minMax(xs, 1, 0);
                const ixMin = Math.max(Math.floor(mmX.min * charGridWidth - cellOffset), 0);
                const ixMax = Math.min(Math.ceil(mmX.max * charGridWidth + cellOffset), charGridWidth);
                for(let iCol = ixMin; iCol < ixMax; ++iCol)cols[iCol].push(index);
                const mmY = minMax(ys, 1, 0);
                const iyMin = Math.max(Math.floor(mmY.min * charGridHeight - cellOffset), 0);
                const iyMax = Math.min(Math.ceil(mmY.max * charGridHeight + cellOffset), charGridHeight);
                for(let iRow = iyMin; iRow < iyMax; ++iRow)rows[iRow].push(index);
            }
            /**
       * @function clamp
       * @private
       * @param {Number} v the value to clamp
       * @param {Number} min the minimum value
       * @param {Number} max the maxmimum value
       *
       * clamps a value between a minimum & maximum value
       */ function clamp(v, min, max) {
                if (v < min) return min;
                if (v > max) return max;
                return v;
            }
            /**
       * @function byte
       * @private
       * @param {Number} v the value to scale
       *
       * converts a floating-point number in the range 0-1 to a byte 0-255
       */ function byte(v) {
                return clamp(255 * v, 0, 255);
            }
            /**
       * @private
       * @class Cubic
       * @param {Number} p0 the start point of the curve
       * @param {Number} c0 the first control point
       * @param {Number} c1 the second control point
       * @param {Number} p1 the end point
       *
       * a cubic curve
       */ class Cubic {
                constructor(p0, c0, c1, p1){
                    this.p0 = p0;
                    this.c0 = c0;
                    this.c1 = c1;
                    this.p1 = p1;
                }
                /**
         * @return {Object} the quadratic approximation
         *
         * converts the cubic to a quadtratic approximation by
         * picking an appropriate quadratic control point
         */ toQuadratic() {
                    return {
                        x: this.p0.x,
                        y: this.p0.y,
                        x1: this.p1.x,
                        y1: this.p1.y,
                        cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
                        cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
                    };
                }
                /**
         * @return {Number} the error
         *
         * calculates the magnitude of error of this curve's
         * quadratic approximation.
         */ quadError() {
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.p1, this.p0), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mult(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.c1, this.c0), 3)).mag() / 2;
                }
                /**
         * @param {Number} t the value (0-1) at which to split
         * @return {Cubic} the second part of the curve
         *
         * splits the cubic into two parts at a point 't' along the curve.
         * this cubic keeps its start point and its end point becomes the
         * point at 't'. the 'end half is returned.
         */ split(t) {
                    const m1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(this.p0, this.c0, t);
                    const m2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(this.c0, this.c1, t);
                    const mm1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(m1, m2, t);
                    this.c1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(this.c1, this.p1, t);
                    this.c0 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(m2, this.c1, t);
                    const pt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].lerp(mm1, this.c0, t);
                    const part1 = new Cubic(this.p0, m1, mm1, pt);
                    this.p0 = pt;
                    return part1;
                }
                /**
         * @return {Cubic[]} the non-inflecting pieces of this cubic
         *
         * returns an array containing 0, 1 or 2 cubics split resulting
         * from splitting this cubic at its inflection points.
         * this cubic is (potentially) altered and returned in the list.
         */ splitInflections() {
                    const a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.c0, this.p0);
                    const b = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.c1, this.c0), a);
                    const c = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].sub(this.p1, this.c1), a), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"].mult(b, 2));
                    const cubics = [];
                    // find the derivative coefficients
                    let A = b.x * c.y - b.y * c.x;
                    if (A !== 0) {
                        let B = a.x * c.y - a.y * c.x;
                        let C = a.x * b.y - a.y * b.x;
                        const disc = B * B - 4 * A * C;
                        if (disc >= 0) {
                            if (A < 0) {
                                A = -A;
                                B = -B;
                                C = -C;
                            }
                            const Q = Math.sqrt(disc);
                            const t0 = (-B - Q) / (2 * A); // the first inflection point
                            let t1 = (-B + Q) / (2 * A); // the second inflection point
                            // test if the first inflection point lies on the curve
                            if (t0 > 0 && t0 < 1) {
                                // split at the first inflection point
                                cubics.push(this.split(t0));
                                // scale t2 into the second part
                                t1 = 1 - (1 - t1) / (1 - t0);
                            }
                            // test if the second inflection point lies on the curve
                            if (t1 > 0 && t1 < 1) {
                                // split at the second inflection point
                                cubics.push(this.split(t1));
                            }
                        }
                    }
                    cubics.push(this);
                    return cubics;
                }
            }
            /**
       * @function cubicToQuadratics
       * @private
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} cx0
       * @param {Number} cy0
       * @param {Number} cx1
       * @param {Number} cy1
       * @param {Number} x1
       * @param {Number} y1
       * @returns {Cubic[]} an array of cubics whose quadratic approximations
       *                    closely match the civen cubic.
       *
       * converts a cubic curve to a list of quadratics.
       */ function cubicToQuadratics(x0, y0, cx0, cy0, cx1, cy1, x1, y1) {
                // create the Cubic object and split it at its inflections
                const cubics = new Cubic(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x0, y0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](cx0, cy0), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](cx1, cy1), new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](x1, y1)).splitInflections();
                const qs = []; // the final list of quadratics
                const precision = 30 / SQRT3;
                // for each of the non-inflected pieces of the original cubic
                for (let cubic of cubics){
                    // the cubic is iteratively split in 3 pieces:
                    // the first piece is accumulated in 'qs', the result.
                    // the last piece is accumulated in 'tail', temporarily.
                    // the middle piece is repeatedly split again, while necessary.
                    const tail = [];
                    let t3;
                    for(;;){
                        // calculate this cubic's precision
                        t3 = precision / cubic.quadError();
                        if (t3 >= 0.5 * 0.5 * 0.5) {
                            break; // not too bad, we're done
                        }
                        // find a split point based on the error
                        const t = Math.pow(t3, 1.0 / 3.0);
                        // split the cubic in 3
                        const start = cubic.split(t);
                        const middle = cubic.split(1 - t / (1 - t));
                        qs.push(start); // the first part
                        tail.push(cubic); // the last part
                        cubic = middle; // iterate on the middle piece
                    }
                    if (t3 < 1) {
                        // a little excess error, split the middle in two
                        qs.push(cubic.split(0.5));
                    }
                    // add the middle piece to the result
                    qs.push(cubic);
                    // finally add the tail, reversed, onto the result
                    Array.prototype.push.apply(qs, tail.reverse());
                }
                return qs;
            }
            /**
       * @function pushLine
       * @private
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} x1
       * @param {Number} y1
       *
       * add a straight line to the row/col grid of a glyph
       */ function pushLine(x0, y0, x1, y1) {
                const mx = (x0 + x1) / 2;
                const my = (y0 + y1) / 2;
                push([
                    x0,
                    x1
                ], [
                    y0,
                    y1
                ], {
                    x: x0,
                    y: y0,
                    cx: mx,
                    cy: my
                });
            }
            /**
       * @function samePoint
       * @private
       * @param {Number} x0
       * @param {Number} y0
       * @param {Number} x1
       * @param {Number} y1
       * @return {Boolean} true if the two points are sufficiently close
       *
       * tests if two points are close enough to be considered the same
       */ function samePoint(x0, y0, x1, y1) {
                return Math.abs(x1 - x0) < 0.00001 && Math.abs(y1 - y0) < 0.00001;
            }
            let x0, y0, xs, ys;
            for (const cmd of cmds){
                // scale the coordinates to the range 0-1
                const x1 = (cmd.x - xMin) / gWidth;
                const y1 = (cmd.y - yMin) / gHeight;
                // don't bother if this point is the same as the last
                if (samePoint(x0, y0, x1, y1)) continue;
                switch(cmd.type){
                    case 'M':
                        {
                            // move
                            xs = x1;
                            ys = y1;
                            break;
                        }
                    case 'L':
                        {
                            // line
                            pushLine(x0, y0, x1, y1);
                            break;
                        }
                    case 'Q':
                        {
                            // quadratic
                            const cx = (cmd.x1 - xMin) / gWidth;
                            const cy = (cmd.y1 - yMin) / gHeight;
                            push([
                                x0,
                                x1,
                                cx
                            ], [
                                y0,
                                y1,
                                cy
                            ], {
                                x: x0,
                                y: y0,
                                cx,
                                cy
                            });
                            break;
                        }
                    case 'Z':
                        {
                            // end
                            if (!samePoint(x0, y0, xs, ys)) {
                                // add an extra line closing the loop, if necessary
                                pushLine(x0, y0, xs, ys);
                                strokes.push({
                                    x: xs,
                                    y: ys
                                });
                            } else {
                                strokes.push({
                                    x: x0,
                                    y: y0
                                });
                            }
                            break;
                        }
                    case 'C':
                        {
                            // cubic
                            const cx1 = (cmd.x1 - xMin) / gWidth;
                            const cy1 = (cmd.y1 - yMin) / gHeight;
                            const cx2 = (cmd.x2 - xMin) / gWidth;
                            const cy2 = (cmd.y2 - yMin) / gHeight;
                            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
                            for(let iq = 0; iq < qs.length; iq++){
                                const q = qs[iq].toQuadratic();
                                push([
                                    q.x,
                                    q.x1,
                                    q.cx
                                ], [
                                    q.y,
                                    q.y1,
                                    q.cy
                                ], q);
                            }
                            break;
                        }
                    default:
                        throw new Error(`unknown command type: ${cmd.type}`);
                }
                x0 = x1;
                y0 = y1;
            }
            // allocate space for the strokes
            const strokeCount = strokes.length;
            const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
            const strokeOffset = strokeImageInfo.index;
            // fill the stroke image
            for(let il = 0; il < strokeCount; ++il){
                const s = strokes[il];
                setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
            }
            /**
       * @function layout
       * @private
       * @param {Number[][]} dim
       * @param {ImageInfos} dimImageInfos
       * @param {ImageInfos} cellImageInfos
       * @return {Object}
       *
       * lays out the curves in a dimension (row or col) into two
       * images, one for the indices of the curves themselves, and
       * one containing the offset and length of those index spans.
       */ function layout(dim, dimImageInfos, cellImageInfos) {
                const dimLength = dim.length; // the number of slices in this dimension
                const dimImageInfo = dimImageInfos.findImage(dimLength);
                const dimOffset = dimImageInfo.index;
                // calculate the total number of stroke indices in this dimension
                let totalStrokes = 0;
                for(let id = 0; id < dimLength; ++id){
                    totalStrokes += dim[id].length;
                }
                // allocate space for the stroke indices
                const cellImageInfo = cellImageInfos.findImage(totalStrokes);
                // for each slice in the glyph
                for(let i = 0; i < dimLength; ++i){
                    const strokeIndices = dim[i];
                    const strokeCount = strokeIndices.length;
                    const cellLineIndex = cellImageInfo.index;
                    // write the offset and count into the glyph slice image
                    setPixel(dimImageInfo, cellLineIndex >> 7, cellLineIndex & 0x7f, strokeCount >> 7, strokeCount & 0x7f);
                    // for each stroke index in that slice
                    for(let iil = 0; iil < strokeCount; ++iil){
                        // write the stroke index into the slice's image
                        const strokeIndex = strokeIndices[iil] + strokeOffset;
                        setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 0x7f, 0, 0);
                    }
                }
                return {
                    cellImageInfo,
                    dimOffset,
                    dimImageInfo
                };
            }
            // initialize the info for this glyph
            gi = this.glyphInfos[glyph.index] = {
                glyph,
                uGlyphRect: [
                    xMin,
                    yMin,
                    xMax,
                    yMax
                ],
                strokeImageInfo,
                strokes,
                colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
                rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
            };
            gi.uGridOffset = [
                gi.colInfo.dimOffset,
                gi.rowInfo.dimOffset
            ];
            return gi;
        }
    }
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["R"].prototype._renderText = function(line, x, y, maxY, minY) {
        if (!this.states.textFont || typeof this.states.textFont === 'string') {
            console.log('WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.');
            return;
        }
        if (y >= maxY || !this.states.fillColor) {
            return; // don't render lines beyond our maxY position
        }
        if (!p5.Font.hasGlyphData(this.states.textFont)) {
            console.log('WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported');
            return;
        }
        this.push(); // fix to #803
        // remember this state, so it can be restored later
        const doStroke = this.states.strokeColor;
        const drawMode = this.states.drawMode;
        this.states.setValue('strokeColor', null);
        this.states.setValue('drawMode', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["T"]);
        // get the cached FontInfo object
        const { font } = this.states.textFont;
        if (!font) {
            throw new Error('In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.');
        }
        const axs = font._currentAxes(this);
        let fontInfo = font._getFontInfo(axs);
        // calculate the alignment and move/scale the view accordingly
        // TODO: check this
        const pos = {
            x,
            y
        }; // this.states.textFont._handleAlignment(this, line, x, y);
        const fontSize = this.states.textSize;
        const scale = fontSize / (font.data?.head?.unitsPerEm || 1000);
        this.translate(pos.x, pos.y, 0);
        this.scale(scale, scale, 1);
        // initialize the font shader
        const gl = this.GL;
        const initializeShader = !this._defaultFontShader;
        const sh = this._getFontShader();
        sh.init();
        sh.bindShader(); // first time around, bind the shader fully
        if (initializeShader) {
            // these are constants, really. just initialize them one-time.
            sh.setUniform('uGridImageSize', [
                gridImageWidth,
                gridImageHeight
            ]);
            sh.setUniform('uCellsImageSize', [
                cellImageWidth,
                cellImageHeight
            ]);
            sh.setUniform('uStrokeImageSize', [
                strokeImageWidth,
                strokeImageHeight
            ]);
            sh.setUniform('uGridSize', [
                charGridWidth,
                charGridHeight
            ]);
        }
        const curFillColor = this.states.fillSet ? this.states.curFillColor : [
            0,
            0,
            0,
            255
        ];
        this._setGlobalUniforms(sh);
        this._applyColorBlend(curFillColor);
        let g = this.geometryBufferCache.getGeometryByID('glyph');
        if (!g) {
            // create the geometry for rendering a quad
            g = this._textGeom = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Geometry"](1, 1, function() {
                for(let i = 0; i <= 1; i++){
                    for(let j = 0; j <= 1; j++){
                        this.vertices.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Vector"](j, i, 0));
                        this.uvs.push(j, i);
                    }
                }
            }, this);
            g.gid = 'glyph';
            g.computeFaces().computeNormals();
            this.geometryBufferCache.ensureCached(g);
        }
        // bind the shader buffers
        for (const buff of this.buffers.text){
            buff._prepareBuffer(g, sh);
        }
        this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
        // this will have to do for now...
        sh.setUniform('uMaterialColor', curFillColor);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.glyphDataCache = this.glyphDataCache || new Set();
        try {
            // fetch the glyphs in the line of text
            const glyphs = font._positionGlyphs(line);
            for (const glyph of glyphs){
                const gi = fontInfo.getGlyphInfo(glyph);
                if (gi.uGlyphRect) {
                    const rowInfo = gi.rowInfo;
                    const colInfo = gi.colInfo;
                    // Bump the resources for this glyph to the end of the cache list by deleting and re-adding
                    const glyphResources = [
                        gi.strokeImageInfo.imageData,
                        rowInfo.cellImageInfo.imageData,
                        rowInfo.dimImageInfo.imageData,
                        colInfo.cellImageInfo.imageData,
                        colInfo.dimImageInfo.imageData
                    ];
                    for (const resource of glyphResources){
                        this.glyphDataCache.delete(resource);
                        this.glyphDataCache.add(resource);
                    }
                    // If we have too many glyph textures, remove the least recently used
                    // ones from GPU memory. The data still exists on the CPU and will be
                    // re-uploaded if it gets actively used again.
                    while(this.glyphDataCache.size > this.maxCachedGlyphs()){
                        const data = this.glyphDataCache.values().next().value;
                        this.glyphDataCache.delete(data);
                        const tex = this.textures.get(data);
                        if (tex) {
                            tex.remove();
                            this.textures.delete(data);
                        }
                    }
                    sh.setUniform('uSamplerStrokes', gi.strokeImageInfo.imageData);
                    sh.setUniform('uSamplerRowStrokes', rowInfo.cellImageInfo.imageData);
                    sh.setUniform('uSamplerRows', rowInfo.dimImageInfo.imageData);
                    sh.setUniform('uSamplerColStrokes', colInfo.cellImageInfo.imageData);
                    sh.setUniform('uSamplerCols', colInfo.dimImageInfo.imageData);
                    sh.setUniform('uGridOffset', gi.uGridOffset);
                    sh.setUniform('uGlyphRect', gi.uGlyphRect);
                    sh.setUniform('uGlyphOffset', glyph.x);
                    sh.bindTextures(); // afterwards, only textures need updating
                    // draw it
                    gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
                }
            }
        } finally{
            // clean up
            sh.unbindShader();
            this.states.setValue('strokeColor', doStroke);
            this.states.setValue('drawMode', drawMode);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            this.pop();
        }
    };
}
;
}),
"[project]/node_modules/p5/dist/webgl/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>webgl
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/rendering-COLWmJqb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$interaction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/interaction.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$loading$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/loading.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$text$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/text.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.RenderBuffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Quat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Matrix.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.Geometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/p5.DataArray.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$p5$2e$strands$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/p5.strands.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$creating_reading$2d$p2iQtNm5$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/creating_reading-p2iQtNm5.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$color_spaces$2f$hsb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/color_spaces/hsb.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$Element$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.Element.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$File$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.File.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$p5$2e$XML$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/p5.XML.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$p5$2e$Renderer$2d$C$2d$tu2oim$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/p5.Renderer-C-tu2oim.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$filters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/filters.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$custom_shapes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/custom_shapes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$States$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/States.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$utilities$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/utilities.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$file$2d$saver$2f$FileSaver$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/file-saver/FileSaver.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$dom$2f$p5$2e$MediaElement$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/dom/p5.MediaElement.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$2d_primitives$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/2d_primitives.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$attributes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/attributes.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$curves$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/curves.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$shape$2f$vertex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/shape/vertex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$color$2f$setting$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/color/setting.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$omggif$2f$omggif$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/omggif/omggif.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$io$2f$csv$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/io/csv.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$gifenc$2f$dist$2f$gifenc$2e$esm$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/gifenc/dist/gifenc.esm.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$pixels$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/pixels.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$core$2f$transform$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/core/transform.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$ShapeBuilder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/ShapeBuilder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$libtess$2f$libtess$2e$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/libtess/libtess.min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$GeometryBufferCache$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/webgl/GeometryBufferCache.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$image$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/image/const.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$p5$2e$Font$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/p5.Font.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$textCore$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/textCore.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$japont$2f$unicode$2d$range$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@japont/unicode-range/lib/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$unicodeRanges$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/unicodeRanges.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$type$2f$lib$2f$Typr$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/type/lib/Typr.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$pako$2f$dist$2f$pako$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/pako/dist/pako.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$davepagurek$2f$bezier$2d$path$2f$build$2f$bezier$2d$path$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@davepagurek/bezier-path/build/bezier-path.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_glslBackend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_glslBackend.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_types$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_types.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_dag$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_dag.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_FES$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_FES.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_transpiler$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_transpiler.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2f$dist$2f$acorn$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn/dist/acorn.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$acorn$2d$walk$2f$dist$2f$walk$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/acorn-walk/dist/walk.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$escodegen$2f$escodegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/escodegen/escodegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$ir_cfg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/ir_cfg.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_codegen$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_codegen.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$ir_builders$2d$Cn4s8QTL$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/ir_builders-Cn4s8QTL.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_builtins$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_builtins.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_conditionals$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_conditionals.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_phi_utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_phi_utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$strands_for$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/strands/strands_for.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
function webgl(p5) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["r"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["p"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$interaction$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$loading$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["m"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$text$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$RenderBuffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Quat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Matrix$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$Geometry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$webgl$2f$p5$2e$DataArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["s"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$rendering$2d$COLWmJqb$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["t"])(p5, p5.prototype);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$strands$2f$p5$2e$strands$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(p5, p5.prototype);
}
;
}),
];

//# sourceMappingURL=node_modules_p5_dist_webgl_e4100062._.js.map