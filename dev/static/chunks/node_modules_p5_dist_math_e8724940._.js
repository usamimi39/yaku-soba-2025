(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Vector",
    ()=>Vector,
    "default",
    ()=>vector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-client] (ecmascript)");
;
/**
 * @module Math
 * @requires constants
 */ /// HELPERS FOR REMAINDER METHOD
const calculateRemainder2D = function(xComponent, yComponent) {
    if (xComponent !== 0) {
        this.x = this.x % xComponent;
    }
    if (yComponent !== 0) {
        this.y = this.y % yComponent;
    }
    return this;
};
const calculateRemainder3D = function(xComponent, yComponent, zComponent) {
    if (xComponent !== 0) {
        this.x = this.x % xComponent;
    }
    if (yComponent !== 0) {
        this.y = this.y % yComponent;
    }
    if (zComponent !== 0) {
        this.z = this.z % zComponent;
    }
    return this;
};
class Vector {
    // This is how it comes in with createVector()
    // This check if the first argument is a function
    constructor(...args){
        let values = args; // .map(arg => arg || 0);
        if (typeof args[0] === 'function') {
            this.isPInst = true;
            this._fromRadians = args[0];
            this._toRadians = args[1];
            values = args.slice(2); // .map(arg => arg || 0);
        }
        let dimensions = values.length; // TODO: make default 3 if no arguments
        if (dimensions === 0) {
            this.dimensions = 2;
            this._values = [
                0,
                0,
                0
            ];
        } else {
            this.dimensions = dimensions;
            this._values = values;
        }
    }
    /**
   * Gets the values of the N-dimensional vector.
   *
   * This method returns an array of numbers that represent the vector.
   * Each number in the array corresponds to a different component of the vector,
   * like its position in different directions (e.g., x, y, z).
   *
   * @returns {Array<number>} The array of values representing the vector.
   */ get values() {
        return this._values;
    }
    /**
   * Sets the values of the vector.
   *
   * This method allows you to update the entire vector with a new set of values.
   * You need to provide an array of numbers, where each number represents a component
   * of the vector (e.g., x, y, z). The length of the array should match the number of
   * dimensions of the vector. If the array is shorter, the missing components will be
   * set to 0. If the array is longer, the extra values will be ignored.
   *
   * @param {Array<number>} newValues - An array of numbers representing the new values for the vector.
   *
   */ set values(newValues) {
        let dimensions = newValues.length;
        if (dimensions === 0) {
            this.dimensions = 2;
            this._values = [
                0,
                0,
                0
            ];
        } else {
            this.dimensions = dimensions;
            this._values = newValues.slice();
        }
    }
    /**
   * Gets the x component of the vector.
   *
   * This method returns the value of the x component of the vector.
   * Think of the x component as the horizontal position or the first number in the vector.
   * If the x component is not defined, it will return 0.
   *
   * @returns {Number} The x component of the vector. Returns 0 if the value is not defined.
   */ get x() {
        return this._values[0] || 0;
    }
    /**
   * Retrieves the value at the specified index from the vector.
   *
   * This method allows you to get the value of a specific component of the vector
   * by providing its index. Think of the vector as a list of numbers, where each
   * number represents a different direction (like x, y, or z). The index is just
   * the position of the number in that list.
   *
   * For example, if you have a vector with values 10, 20, 30 the index 0 would
   * give you the first value 10, index 1 would give you the second value 20,
   * and so on.
   *
   * @param {Number} index - The position of the value you want to get from the vector.
   * @returns {Number} The value at the specified position in the vector.
   * @throws Will throw an error if the index is out of bounds, meaning if you try to
   *          get a value from a position that doesn't exist in the vector.
   */ getValue(index) {
        if (index < this._values.length) {
            return this._values[index];
        } else {
            p5._friendlyError('The index parameter is trying to set a value outside the bounds of the vector', 'p5.Vector.setValue');
        }
    }
    /**
   * Sets the value at the specified index of the vector.
   *
   * This method allows you to change a specific component of the vector by providing its index and the new value you want to set.
   * Think of the vector as a list of numbers, where each number represents a different direction (like x, y, or z).
   * The index is just the position of the number in that list.
   *
   * For example, if you have a vector with values [0, 20, 30], and you want to change the second value (20) to 50,
   * you would use this method with index 1 (since indexes start at 0) and value 50.
   *
   * @param {Number} index - The position in the vector where you want to set the new value.
   * @param {Number} value - The new value you want to set at the specified position.
   * @throws Will throw an error if the index is outside the bounds of the vector, meaning if you try to set a value at a position that doesn't exist in the vector.
   */ setValue(index, value) {
        if (index < this._values.length) {
            this._values[index] = value;
        } else {
            p5._friendlyError('The index parameter is trying to set a value outside the bounds of the vector', 'p5.Vector.setValue');
        }
    }
    /**
   * Gets the y component of the vector.
   *
   * This method returns the value of the y component of the vector.
   * Think of the y component as the vertical position or the second number in the vector.
   * If the y component is not defined, it will return 0.
   *
   * @returns {Number} The y component of the vector. Returns 0 if the value is not defined.
   */ get y() {
        return this._values[1] || 0;
    }
    /**
   * Gets the z component of the vector.
   *
   * This method returns the value of the z component of the vector.
   * Think of the z component as the depth or the third number in the vector.
   * If the z component is not defined, it will return 0.
   *
   * @returns {Number} The z component of the vector. Returns 0 if the value is not defined.
   */ get z() {
        return this._values[2] || 0;
    }
    /**
   * Gets the w component of the vector.
   *
   * This method returns the value of the w component of the vector.
   * Think of the w component as the fourth number in the vector.
   * If the w component is not defined, it will return 0.
   *
   * @returns {Number} The w component of the vector. Returns 0 if the value is not defined.
   */ get w() {
        return this._values[3] || 0;
    }
    /**
   * Sets the x component of the vector.
   *
   * This method allows you to change the x value of the vector.
   * The x value is the first number in the vector, representing the horizontal position.
   * By calling this method, you can update the x value to a new number.
   *
   * @param {Number} xVal - The new value for the x component.
   */ set x(xVal) {
        if (this._values.length > 1) {
            this._values[0] = xVal;
        }
    }
    /**
   * Sets the y component of the vector.
   *
   * This method allows you to change the y value of the vector.
   * The y value is the second number in the vector, representing the vertical position.
   * By calling this method, you can update the y value to a new number.
   *
   * @param {Number} yVal - The new value for the y component.
   */ set y(yVal) {
        if (this._values.length > 1) {
            this._values[1] = yVal;
        }
    }
    /**
   * Sets the z component of the vector.
   *
   * This method allows you to change the z value of the vector.
   * The z value is the third number in the vector, representing the depth or the third dimension.
   * By calling this method, you can update the z value to a new number.
   *
   * @param {Number} zVal - The new value for the z component.
   */ set z(zVal) {
        if (this._values.length > 2) {
            this._values[2] = zVal;
        }
    }
    /**
   * Sets the w component of the vector.
   *
   * This method allows you to change the w value of the vector.
   * The w value is the fourth number in the vector, representing the fourth dimension.
   * By calling this method, you can update the w value to a new number.
   *
   * @param {Number} wVal - The new value for the w component.
   */ set w(wVal) {
        if (this._values.length > 3) {
            this._values[3] = wVal;
        }
    }
    /**
   * Returns a string representation of a vector.
   *
   * Calling `toString()` is useful for printing vectors to the console while
   * debugging.
   *
   * @return {String} string representation of the vector.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   let v = createVector(20, 30);
   *
   *   // Prints 'vector[20, 30, 0]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */ toString() {
        return `vector[${this._values.join(', ')}]`;
    }
    /**
   * Sets the vector's `x`, `y`, and `z` components.
   *
   * `set()` can use separate numbers, as in `v.set(1, 2, 3)`, a
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.set(v2)`, or an
   * array of numbers, as in `v.set([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it will be set to 0. For
   * example, `v.set(4, 5)` sets `v.x` to 4, `v.y` to 5, and `v.z` to 0.
   * Calling `set()` with no arguments, as in `v.set()`, sets all the vector's
   * components to 0.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // set() with numbers.
   *   pos.set(75, 25);
   *   point(pos);
   *
   *   // Bottom right.
   *   // set() with a p5.Vector.
   *   let p2 = createVector(75, 75);
   *   pos.set(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // set() with an array.
   *   let arr = [25, 75];
   *   pos.set(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   */ /**
   * @param {p5.Vector|Number[]} value vector to set.
   * @chainable
   */ set(...args) {
        if (args[0] instanceof Vector) {
            this._values = args[0].values.slice();
        } else if (Array.isArray(args[0])) {
            this._values = args[0].map((arg)=>arg || 0);
        } else {
            this._values = args.map((arg)=>arg || 0);
        }
        this.dimensions = this._values.length;
        return this;
    }
    /**
   * Returns a copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @return {p5.Vector} copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100 ,100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let pos = createVector(50, 50);
   *
   *   // Make a copy.
   *   let pc = pos.copy();
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(pc);
   *
   *   describe('A black point drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ copy() {
        if (this.isPInst) {
            return new Vector(this._fromRadians, this._toRadians, ...this._values);
        } else {
            return new Vector(...this._values);
        }
    }
    /**
   * Adds to a vector's components.
   *
   * `add()` can use separate numbers, as in `v.add(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.add(v2)`, or
   * an array of numbers, as in `v.add([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.add(4, 5)` adds 4 to `v.x`, 5 to `v.y`, and 0 to `v.z`.
   * Calling `add()` with no arguments, as in `v.add()`, has no effect.
   *
   * This method supports N-dimensional vectors.
   *
   * The static version of `add()`, as in `p5.Vector.add(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number|Array} x   x component of the vector to be added or an array of components.
   * @param  {Number} [y] y component of the vector to be added.
   * @param  {Number} [z] z component of the vector to be added.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // Add numbers.
   *   pos.add(50, 0);
   *   point(pos);
   *
   *   // Bottom right.
   *   // Add a p5.Vector.
   *   let p2 = createVector(0, 50);
   *   pos.add(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Add an array.
   *   let arr = [-50, 0];
   *   pos.add(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top left.
   *   let p1 = createVector(25, 25);
   *
   *   // Center.
   *   let p2 = createVector(50, 50);
   *
   *   // Bottom right.
   *   // Add p1 and p2.
   *   let p3 = p5.Vector.add(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red arrow extends from the top left corner to the center. A blue arrow extends from the tip of the red arrow. A purple arrow extends from the origin to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(-30, 20);
   *   drawArrow(v1, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.add(v1, v2);
   *   drawArrow(origin, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {p5.Vector|Number[]} value The vector to add
   * @chainable
   */ add(...args) {
        if (args[0] instanceof Vector) {
            args = args[0].values;
        } else if (Array.isArray(args[0])) {
            args = args[0];
        }
        args.forEach((value, index)=>{
            this._values[index] = (this._values[index] || 0) + (value || 0);
        });
        return this;
    }
    /**
   * Performs modulo (remainder) division with a vector's `x`, `y`, and `z`
   * components.
   *
   * `rem()` can use separate numbers, as in `v.rem(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.rem(v2)`, or
   * an array of numbers, as in `v.rem([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.rem(2)`, then all the components
   * will be set to their values modulo 2. If two values are provided, as in
   * `v.rem(2, 3)`, then `v.z` won't change. Calling `rem()` with no
   * arguments, as in `v.rem()`, has no effect.
   *
   * The static version of `rem()`, as in `p5.Vector.rem(v2, v1)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param {Number} x x component of divisor vector.
   * @param {Number} y y component of divisor vector.
   * @param {Number} z z component of divisor vector.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2);
   *
   *   // Prints 'p5.Vector Object : [1, 0, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 5]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3, 4);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide a p5.Vector.
   *   v1.rem(v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide an array.
   *   let arr = [2, 3, 4];
   *   v.rem(arr);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide without modifying the original vectors.
   *   let v3 = p5.Vector.rem(v1, v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v3.toString());
   * }
   * </code>
   * </div>
   */ /**
   * @param {p5.Vector | Number[]}  value  divisor vector.
   * @chainable
   */ rem(x, y, z) {
        if (x instanceof Vector) {
            if ([
                x.x,
                x.y,
                x.z
            ].every(Number.isFinite)) {
                const xComponent = parseFloat(x.x);
                const yComponent = parseFloat(x.y);
                const zComponent = parseFloat(x.z);
                return calculateRemainder3D.call(this, xComponent, yComponent, zComponent);
            }
        } else if (Array.isArray(x)) {
            if (x.every((element)=>Number.isFinite(element))) {
                if (x.length === 2) {
                    return calculateRemainder2D.call(this, x[0], x[1]);
                }
                if (x.length === 3) {
                    return calculateRemainder3D.call(this, x[0], x[1], x[2]);
                }
            }
        } else if (arguments.length === 1) {
            if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
                this.x = this.x % arguments[0];
                this.y = this.y % arguments[0];
                this.z = this.z % arguments[0];
                return this;
            }
        } else if (arguments.length === 2) {
            const vectorComponents = [
                ...arguments
            ];
            if (vectorComponents.every((element)=>Number.isFinite(element))) {
                if (vectorComponents.length === 2) {
                    return calculateRemainder2D.call(this, vectorComponents[0], vectorComponents[1]);
                }
            }
        } else if (arguments.length === 3) {
            const vectorComponents = [
                ...arguments
            ];
            if (vectorComponents.every((element)=>Number.isFinite(element))) {
                if (vectorComponents.length === 3) {
                    return calculateRemainder3D.call(this, vectorComponents[0], vectorComponents[1], vectorComponents[2]);
                }
            }
        }
    }
    /**
   * Subtracts from a vector's `x`, `y`, and `z` components.
   *
   * `sub()` can use separate numbers, as in `v.sub(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.sub(v2)`, or an array
   * of numbers, as in `v.sub([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.sub(4, 5)` subtracts 4 from `v.x`, 5 from `v.y`, and 0 from `v.z`.
   * Calling `sub()` with no arguments, as in `v.sub()`, has no effect.
   *
   * The static version of `sub()`, as in `p5.Vector.sub(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number} x   x component of the vector to subtract.
   * @param  {Number} [y] y component of the vector to subtract.
   * @param  {Number} [z] z component of the vector to subtract.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom right.
   *   let pos = createVector(75, 75);
   *   point(pos);
   *
   *   // Top right.
   *   // Subtract numbers.
   *   pos.sub(0, 50);
   *   point(pos);
   *
   *   // Top left.
   *   // Subtract a p5.Vector.
   *   let p2 = createVector(50, 0);
   *   pos.sub(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Subtract an array.
   *   let arr = [0, -50];
   *   pos.sub(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let p1 = createVector(75, 75);
   *   let p2 = createVector(50, 50);
   *
   *   // Subtract with modifying the original vectors.
   *   let p3 = p5.Vector.sub(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {p5.Vector|Number[]} value the vector to subtract
   * @chainable
   */ sub(...args) {
        if (args[0] instanceof Vector) {
            args[0].values.forEach((value, index)=>{
                this._values[index] -= value || 0;
            });
        } else if (Array.isArray(args[0])) {
            args[0].forEach((value, index)=>{
                this._values[index] -= value || 0;
            });
        } else {
            args.forEach((value, index)=>{
                this._values[index] -= value || 0;
            });
        }
        return this;
    }
    /**
   * Multiplies a vector's `x`, `y`, and `z` components.
   *
   * `mult()` can use separate numbers, as in `v.mult(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.mult(v2)`, or an array
   * of numbers, as in `v.mult([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.mult(2)`, then all the components
   * will be multiplied by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.mult(4, 5)` multiplies `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `mult()` with no arguments, as in `v.mult()`, has
   * no effect.
   *
   * The static version of `mult()`, as in `p5.Vector.mult(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number} n The number to multiply with the vector
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Center.
   *   // Multiply all components by 2.
   *   p.mult(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   p.mult(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   let arr = [2, 3];
   *   p.mult(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * p2.x and p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   p.mult(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x * p2.x
   *   // p3.y = p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.mult(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is twice the length of the red arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(25, 25);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.mult(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {Number} x number to multiply with the x component of the vector.
   * @param  {Number} y number to multiply with the y component of the vector.
   * @param  {Number} [z] number to multiply with the z component of the vector.
   * @chainable
   */ /**
   * @param  {Number[]} arr array to multiply with the components of the vector.
   * @chainable
   */ /**
   * @param  {p5.Vector} v vector to multiply with the components of the original vector.
   * @chainable
   */ mult(...args) {
        if (args.length === 1 && args[0] instanceof Vector) {
            const v = args[0];
            const maxLen = Math.min(this._values.length, v.values.length);
            for(let i = 0; i < maxLen; i++){
                if (Number.isFinite(v.values[i]) && typeof v.values[i] === 'number') {
                    this._values[i] *= v.values[i];
                } else {
                    console.warn('p5.Vector.prototype.mult:', 'v contains components that are either undefined or not finite numbers');
                    return this;
                }
            }
        } else if (args.length === 1 && Array.isArray(args[0])) {
            const arr = args[0];
            const maxLen = Math.min(this._values.length, arr.length);
            for(let i = 0; i < maxLen; i++){
                if (Number.isFinite(arr[i]) && typeof arr[i] === 'number') {
                    this._values[i] *= arr[i];
                } else {
                    console.warn('p5.Vector.prototype.mult:', 'arr contains elements that are either undefined or not finite numbers');
                    return this;
                }
            }
        } else if (args.length === 1 && typeof args[0] === 'number' && Number.isFinite(args[0])) {
            for(let i = 0; i < this._values.length; i++){
                this._values[i] *= args[0];
            }
        }
        return this;
    }
    /**
   * Divides a vector's `x`, `y`, and `z` components.
   *
   * `div()` can use separate numbers, as in `v.div(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.div(v2)`, or an array
   * of numbers, as in `v.div([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.div(2)`, then all the components
   * will be divided by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.div(4, 5)` divides `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `div()` with no arguments, as in `v.div()`, has
   * no effect.
   *
   * The static version of `div()`, as in `p5.Vector.div(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number}    n The number to divide the vector by
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Center.
   *   let p = createVector(50, 50);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 2
   *   p.div(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   p.div(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let arr = [2, 3];
   *   p.div(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let p2 = createVector(2, 3);
   *   p.div(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x / p2.x
   *   // p3.y = p.y / p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.div(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.div(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is half the length of the red arrow.');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {Number} x number to divide with the x component of the vector.
   * @param  {Number} y number to divide with the y component of the vector.
   * @param  {Number} [z] number to divide with the z component of the vector.
   * @chainable
   */ /**
   * @param  {Number[]} arr array to divide the components of the vector by.
   * @chainable
   */ /**
   * @param  {p5.Vector} v vector to divide the components of the original vector by.
   * @chainable
   */ div(...args) {
        if (args.length === 0) return this;
        if (args.length === 1 && args[0] instanceof Vector) {
            const v = args[0];
            if (v._values.every((val)=>Number.isFinite(val) && typeof val === 'number')) {
                if (v._values.some((val)=>val === 0)) {
                    console.warn('p5.Vector.prototype.div:', 'divide by 0');
                    return this;
                }
                this._values = this._values.map((val, i)=>val / v._values[i]);
            } else {
                console.warn('p5.Vector.prototype.div:', 'vector contains components that are either undefined or not finite numbers');
            }
            return this;
        }
        if (args.length === 1 && Array.isArray(args[0])) {
            const arr = args[0];
            if (arr.every((val)=>Number.isFinite(val) && typeof val === 'number')) {
                if (arr.some((val)=>val === 0)) {
                    console.warn('p5.Vector.prototype.div:', 'divide by 0');
                    return this;
                }
                this._values = this._values.map((val, i)=>val / arr[i]);
            } else {
                console.warn('p5.Vector.prototype.div:', 'array contains components that are either undefined or not finite numbers');
            }
            return this;
        }
        if (args.every((val)=>Number.isFinite(val) && typeof val === 'number')) {
            if (args.some((val)=>val === 0)) {
                console.warn('p5.Vector.prototype.div:', 'divide by 0');
                return this;
            }
            this._values = this._values.map((val, i)=>val / args[0]);
        } else {
            console.warn('p5.Vector.prototype.div:', 'arguments contain components that are either undefined or not finite numbers');
        }
        return this;
    }
    /**
   * Calculates the magnitude (length) of the vector.
   *
   * Use <a href="#/p5/mag">mag()</a> to calculate the magnitude of a 2D vector
   * using components as in `mag(x, y)`.
   *
   * @return {Number} magnitude of the vector.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude.
   *   let m = p.mag();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 50 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */ mag() {
        return Math.sqrt(this.magSq());
    }
    /**
   * Calculates the magnitude (length) of the vector squared.
   *
   * @return {Number} squared magnitude of the vector.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude squared.
   *   let m = p.magSq();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 2500 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */ magSq() {
        return this._values.reduce((sum, component)=>sum + component * component, 0);
    }
    /**
   * Calculates the dot product of two vectors.
   *
   * The dot product is a number that describes the overlap between two vectors.
   * Visually, the dot product can be thought of as the "shadow" one vector
   * casts on another. The dot product's magnitude is largest when two vectors
   * point in the same or opposite directions. Its magnitude is 0 when two
   * vectors form a right angle.
   *
   * The version of `dot()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `dot()` with multiple parameters interprets them as the
   * `x`, `y`, and `z` components of another vector.
   *
   * The static version of `dot()`, as in `p5.Vector.dot(v1, v2)`, is the same
   * as calling `v1.dot(v2)`.
   *
   * @param  {Number} x   x component of the vector.
   * @param  {Number} [y] y component of the vector.
   * @param  {Number} [z] z component of the vector.
   * @return {Number}     dot product.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4);
   *   let v2 = createVector(3, 0);
   *
   *   // Calculate the dot product.
   *   let dp = v1.dot(v2);
   *
   *   // Prints "9" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the dot product.
   *   let dp = p5.Vector.dot(v1, v2);
   *
   *   // Prints "0" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows drawn on a gray square. A black arrow points to the right and a red arrow follows the mouse. The text "v1 • v2 = something" changes as the mouse moves.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   let v1 = createVector(30, 0);
   *   drawArrow(v0, v1, 'black');
   *
   *   // Draw the red arrow.
   *   let v2 = createVector(mouseX - 50, mouseY - 50);
   *   drawArrow(v0, v2, 'red');
   *
   *   // Display the dot product.
   *   let dp = v2.dot(v1);
   *   text(`v2 • v1 = ${dp}`, 10, 20);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be dotted.
   * @return {Number}
   */ dot(...args) {
        if (args[0] instanceof Vector) {
            return this.dot(...args[0]._values);
        }
        return this._values.reduce((sum, component, index)=>{
            return sum + component * (args[index] || 0);
        }, 0);
    }
    /**
   * Calculates the cross product of two vectors.
   *
   * The cross product is a vector that points straight out of the plane created
   * by two vectors. The cross product's magnitude is the area of the parallelogram
   * formed by the original two vectors.
   *
   * The static version of `cross()`, as in `p5.Vector.cross(v1, v2)`, is the same
   * as calling `v1.cross(v2)`.
   *
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be crossed.
   * @return {p5.Vector}   cross product as a <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = v1.cross(v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = p5.Vector.cross(v1, v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   */ cross(v) {
        const x = this.y * v.z - this.z * v.y;
        const y = this.z * v.x - this.x * v.z;
        const z = this.x * v.y - this.y * v.x;
        if (this.isPInst) {
            return new Vector(this._fromRadians, this._toRadians, x, y, z);
        } else {
            return new Vector(x, y, z);
        }
    }
    /**
   * Calculates the distance between two points represented by vectors.
   *
   * A point's coordinates can be represented by the components of a vector
   * that extends from the origin to the point.
   *
   * The static version of `dist()`, as in `p5.Vector.dist(v1, v2)`, is the same
   * as calling `v1.dist(v2)`.
   *
   * Use <a href="#/p5/dist">dist()</a> to calculate the distance between points
   * using coordinates as in `dist(x1, y1, x2, y2)`.
   *
   * @submodule p5.Vector
   * @param  {p5.Vector} v x, y, and z coordinates of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}      distance.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = v1.dist(v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = p5.Vector.dist(v1, v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow. The number 36 is written in black near the purple arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *
   *   // Display the magnitude. The same as floor(v3.mag());
   *   let m = floor(p5.Vector.dist(v1, v2));
   *   text(m, 50, 75);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ dist(v) {
        return v.copy().sub(this).mag();
    }
    /**
   * Scales the components of a <a href="#/p5.Vector">p5.Vector</a> object so
   * that its magnitude is 1.
   *
   * The static version of `normalize()`,  as in `p5.Vector.normalize(v)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @return {p5.Vector} normalized <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v = createVector(10, 20, 2);
   *
   *   // Normalize.
   *   v.normalize();
   *
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a normalized copy.
   *   let v1 = p5.Vector.normalize(v0);
   *
   *   // Prints "p5.Vector Object : [10, 20, 2]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow's length is fixed to the circle's radius.");
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   v1.normalize();
   *   drawArrow(v0, v1.mult(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ normalize() {
        const len = this.mag();
        // here we multiply by the reciprocal instead of calling 'div()'
        // since div duplicates this zero check.
        if (len !== 0) this.mult(1 / len);
        return this;
    }
    /**
   * Limits a vector's magnitude to a maximum value.
   *
   * The static version of `limit()`, as in `p5.Vector.limit(v, 5)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    max maximum magnitude for the vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(10, 20, 2);
   *
   *   // Limit its magnitude.
   *   v.limit(5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a copy an limit its magintude.
   *   let v1 = p5.Vector.limit(v0, 5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow never crosses the circle's edge.");
   * }
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1.limit(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ limit(max) {
        const mSq = this.magSq();
        if (mSq > max * max) {
            this.div(Math.sqrt(mSq)) //normalize it
            .mult(max);
        }
        return this;
    }
    /**
   * Sets a vector's magnitude to a given value.
   *
   * The static version of `setMag()`, as in `p5.Vector.setMag(v, 10)`, returns
   * a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    len new length for this vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 0);
   *
   *   // Prints "5" to the console.
   *   print(v.mag());
   *
   *   // Set its magnitude to 10.
   *   v.setMag(10);
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 4, 0);
   *
   *   // Create a copy with a magnitude of 10.
   *   let v1 = p5.Vector.setMag(v0, 10);
   *
   *   // Prints "5" to the console.
   *   print(v0.mag());
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the top left corner of a square toward its center. The red arrow reaches the center and the blue arrow only extends part of the way.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the red arrow.
   *   drawArrow(origin, v, 'red');
   *
   *   // Set v's magnitude to 30.
   *   v.setMag(30);
   *
   *   // Draw the blue arrow.
   *   drawArrow(origin, v, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ setMag(n) {
        return this.normalize().mult(n);
    }
    /**
   * Calculates the angle a 2D vector makes with the positive x-axis.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `heading()` returns angles
   * in the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `heading()`, as in `p5.Vector.heading(v)`, works the
   * same way.
   *
   * @return {Number} angle of rotation.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(v.heading());
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(p5.Vector.heading(v));
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(p5.Vector.heading(v));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the top left of a square to its center. The text "Radians: 0.79" and "Degrees: 45" is written near the tip of the arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   drawArrow(origin, v, 'black');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the heading in radians.
   *   let h = round(v.heading(), 2);
   *   text(`Radians: ${h}`, 20, 70);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the heading in degrees.
   *   h = v.heading();
   *   text(`Degrees: ${h}`, 20, 85);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ heading() {
        const h = Math.atan2(this.y, this.x);
        if (this.isPInst) return this._fromRadians(h);
        return h;
    }
    /**
   * Rotates a 2D vector to a specific angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `setHeading()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(PI);
   *
   *   // Prints "3.141..." to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(180);
   *
   *   // Prints "180" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. The red arrow points to the right and the blue arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Point down.
   *   v1.setHeading(HALF_PI);
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ setHeading(a) {
        if (this.isPInst) a = this._toRadians(a);
        let m = this.mag();
        this.x = m * Math.cos(a);
        this.y = m * Math.sin(a);
        return this;
    }
    /**
   * Rotates a 2D vector by an angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `rotate()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `rotate()`, as in `p5.Vector.rotate(v, PI)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(HALF_PI);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(90);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, HALF_PI);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, 90);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let v0;
   * let v1;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create p5.Vector objects.
   *   v0 = createVector(50, 50);
   *   v1 = createVector(30, 0);
   *
   *   describe('A black arrow extends from the center of a gray square. The arrow rotates clockwise.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Rotate v1.
   *   v1.rotate(0.01);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ rotate(a) {
        let newHeading = this.heading() + a;
        if (this.isPInst) newHeading = this._toRadians(newHeading);
        const mag = this.mag();
        this.x = Math.cos(newHeading) * mag;
        this.y = Math.sin(newHeading) * mag;
        return this;
    }
    /**
   * Calculates the angle between two vectors.
   *
   * The angles returned are signed, which means that
   * `v1.angleBetween(v2) === -v2.angleBetween(v1)`.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `angleBetween()` returns
   * angles in the units of the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {p5.Vector}    value x, y, and z components of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}       angle between the vectors.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-90" to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-90" to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. A red arrow points to the right and a blue arrow points down. The text "Radians: 1.57" and "Degrees: 90" is written above the arrows.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the angle in radians.
   *   let angle = round(v1.angleBetween(v2), 2);
   *   text(`Radians: ${angle}`, 20, 20);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the angle in degrees.
   *   angle = round(v1.angleBetween(v2), 2);
   *   text(`Degrees: ${angle}`, 20, 35);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ angleBetween(v) {
        const magSqMult = this.magSq() * v.magSq();
        // Returns NaN if either vector is the zero vector.
        if (magSqMult === 0) {
            return NaN;
        }
        const u = this.cross(v);
        // The dot product computes the cos value, and the cross product computes
        // the sin value. Find the angle based on them. In addition, in the case of
        // 2D vectors, a sign is added according to the direction of the vector.
        let angle = Math.atan2(u.mag(), this.dot(v)) * Math.sign(u.z || 1);
        if (this.isPInst) {
            angle = this._fromRadians(angle);
        }
        return angle;
    }
    /**
   * Calculates new `x`, `y`, and `z` components that are proportionally the
   * same distance between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps all components equal to the old vector's, 0.5 is
   * halfway between, and 1.0 sets all components equal to the new vector's.
   *
   * The static version of `lerp()`, as in `p5.Vector.lerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    x   x component.
   * @param  {Number}    y   y component.
   * @param  {Number}    z   z component.
   * @param  {Number}    amt amount of interpolation between 0.0 (old vector)
   *                         and 1.0 (new vector). 0.5 is halfway between.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   v0.lerp(v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v0.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1, 1);
   *
   *   // Interpolate.
   *   v.lerp(3, 3, 3, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   let v2 = p5.Vector.lerp(v0, v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v2.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points down, and a purple arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Interpolate.
   *   let v3 = p5.Vector.lerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ /**
   * @param  {p5.Vector} v  <a href="#/p5.Vector">p5.Vector</a> to lerp toward.
   * @param  {Number}    amt
   * @chainable
   */ lerp(x, y, z, amt) {
        if (x instanceof Vector) {
            return this.lerp(x.x, x.y, x.z, y);
        }
        this.x += (x - this.x) * amt || 0;
        this.y += (y - this.y) * amt || 0;
        this.z += (z - this.z) * amt || 0;
        return this;
    }
    /**
   * Calculates a new heading and magnitude that are between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps the heading and magnitude equal to the old
   * vector's, 0.5 sets them halfway between, and 1.0 sets the heading and
   * magnitude equal to the new vector's.
   *
   * `slerp()` differs from <a href="#/p5.Vector/lerp">lerp()</a> because
   * it interpolates magnitude. Calling `v0.slerp(v1, 0.5)` sets `v0`'s
   * magnitude to a value halfway between its original magnitude and `v1`'s.
   * Calling `v0.lerp(v1, 0.5)` makes no such guarantee.
   *
   * The static version of `slerp()`, as in `p5.Vector.slerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to slerp toward.
   * @param {Number} amt  amount of interpolation between 0.0 (old vector)
   *                      and 1.0 (new vector). 0.5 is halfway between.
   * @return {p5.Vector}
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Interpolate halfway between v0 and v1.
   *   v0.slerp(v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v0.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Create a p5.Vector that's halfway between v0 and v1.
   *   let v3 = p5.Vector.slerp(v0, v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v3.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v3.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points to the left, and a purple arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(20, 0);
   *   let v2 = createVector(-40, 0);
   *
   *   // Create a p5.Vector that's halfway between v1 and v2.
   *   let v3 = p5.Vector.slerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ slerp(v, amt) {
        // edge cases.
        if (amt === 0) {
            return this;
        }
        if (amt === 1) {
            return this.set(v);
        }
        // calculate magnitudes
        const selfMag = this.mag();
        const vMag = v.mag();
        const magmag = selfMag * vMag;
        // if either is a zero vector, linearly interpolate by these vectors
        if (magmag === 0) {
            this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
            return this;
        }
        // the cross product of 'this' and 'v' is the axis of rotation
        const axis = this.cross(v);
        const axisMag = axis.mag();
        // Calculates the angle between 'this' and 'v'
        const theta = Math.atan2(axisMag, this.dot(v));
        // However, if the norm of axis is 0, normalization cannot be performed,
        // so we will divide the cases
        if (axisMag > 0) {
            axis.x /= axisMag;
            axis.y /= axisMag;
            axis.z /= axisMag;
        } else if (theta < Math.PI * 0.5) {
            // if the norm is 0 and the angle is less than PI/2,
            // the angle is very close to 0, so do linear interpolation.
            this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
            return this;
        } else {
            // If the norm is 0 and the angle is more than PI/2, the angle is
            // very close to PI.
            // In this case v can be regarded as '-this', so take any vector
            // that is orthogonal to 'this' and use that as the axis.
            if (this.z === 0 && v.z === 0) {
                // if both this and v are 2D vectors, use (0,0,1)
                // this makes the result also a 2D vector.
                axis.set(0, 0, 1);
            } else if (this.x !== 0) {
                // if the x components is not 0, use (y, -x, 0)
                axis.set(this.y, -this.x, 0).normalize();
            } else {
                // if the x components is 0, use (1,0,0)
                axis.set(1, 0, 0);
            }
        }
        // Since 'axis' is a unit vector, ey is a vector of the same length as 'this'.
        const ey = axis.cross(this);
        // interpolate the length with 'this' and 'v'.
        const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
        // imagine a situation where 'axis', 'this', and 'ey' are pointing
        // along the z, x, and y axes, respectively.
        // rotates 'this' around 'axis' by amt * theta towards 'ey'.
        const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
        const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
        // then, calculate 'result'.
        this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
        this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
        this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
        return this;
    }
    /**
   * Reflects a vector about a line in 2D or a plane in 3D.
   *
   * The orientation of the line or plane is described by a normal vector that
   * points away from the shape.
   *
   * The static version of `reflect()`, as in `p5.Vector.reflect(v, n)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {p5.Vector} surfaceNormal  <a href="#/p5.Vector">p5.Vector</a>
   *                                    to reflect about.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *   // Create a vector to reflect.
   *   let v = createVector(4, 6);
   *
   *   // Reflect v about n.
   *   v.reflect(n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *
   *   // Create a vector to reflect.
   *   let v0 = createVector(4, 6);
   *
   *   // Create a reflected vector.
   *   let v1 = p5.Vector.reflect(v0, n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square with a vertical line down its middle. A black arrow points to the right, a blue arrow points to the bottom left, and a red arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Draw a vertical line.
   *   line(50, 0, 50, 100);
   *
   *   // Create a normal vector.
   *   let n = createVector(1, 0);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a vector to reflect.
   *   let v1 = createVector(30, 40);
   *
   *   // Create a reflected vector.
   *   let v2 = p5.Vector.reflect(v1, n);
   *
   *   // Scale the normal vector for drawing.
   *   n.setMag(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, n, 'black');
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ reflect(surfaceNormal) {
        const surfaceNormalCopy = Vector.normalize(surfaceNormal);
        return this.sub(surfaceNormalCopy.mult(2 * this.dot(surfaceNormalCopy)));
    }
    /**
   * Returns the vector's components as an array of numbers.
   *
   * @return {Number[]} array with the vector's components.
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(20, 30);
   *
   *   // Prints "[20, 30, 0]" to the console.
   *   print(v.array());
   * }
   * </code>
   * </div>
   */ array() {
        return [
            this.x || 0,
            this.y || 0,
            this.z || 0
        ];
    }
    /**
   * Checks whether all the vector's components are equal to another vector's.
   *
   * `equals()` returns `true` if the vector's components are all the same as another
   * vector's and `false` if not.
   *
   * The version of `equals()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `equals()` with multiple parameters interprets them as the
   * components of another vector. Any missing parameters are assigned the value
   * 0.
   *
   * The static version of `equals()`, as in `p5.Vector.equals(v0, v1)`,
   * interprets both parameters as <a href="#/p5.Vector">p5.Vector</a> objects.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @return {Boolean} whether the vectors are equal.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2));
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(5, 10, 20);
   *   let v1 = createVector(5, 10, 20);
   *   let v2 = createVector(13, 10, 19);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1.x, v1.y, v1.z));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2.x, v2.y, v2.z));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(p5.Vector.equals(v0, v1));
   *
   *   // Prints "false" to the console.
   *   print(p5.Vector.equals(v0, v2));
   * }
   * </code>
   * </div>
   */ /**
   * @param {p5.Vector|Array} value vector to compare.
   * @return {Boolean}
   */ equals(...args) {
        let values;
        if (args[0] instanceof Vector) {
            values = args[0]._values;
        } else if (Array.isArray(args[0])) {
            values = args[0];
        } else {
            values = args;
        }
        for(let i = 0; i < this._values.length; i++){
            if (this._values[i] !== (values[i] || 0)) {
                return false;
            }
        }
        return true;
    }
    /**
   * Replaces the components of a <a href="#/p5.Vector">p5.Vector</a> that are very close to zero with zero.
   *
   * In computers, handling numbers with decimals can give slightly imprecise answers due to the way those numbers are represented.
   * This can make it hard to check if a number is zero, as it may be close but not exactly zero.
   * This method rounds very close numbers to zero to make those checks easier
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
   *
   * @return {p5.Vector} with components very close to zero replaced with zero.
   * @chainable
   */ clampToZero() {
        for(let i = 0; i < this._values.length; i++){
            this._values[i] = this._clampToZero(this._values[i]);
        }
        return this;
    }
    /**
   * Helper function for clampToZero
   * @private
   */ _clampToZero(val) {
        return Math.abs((val || 0) - 0) <= Number.EPSILON ? 0 : val;
    }
    // Static Methods
    /**
   * Creates a new 2D vector from an angle.
   *
   * @static
   * @param {Number}     angle desired angle, in radians. Unaffected by <a href="#/p5/angleMode">angleMode()</a>.
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}       new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0, 30);
   *
   *   // Prints "p5.Vector Object : [30, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the center of a gray square. It points to the right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a p5.Vector with an angle 0 and magnitude 30.
   *   let v1 = p5.Vector.fromAngle(0, 30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ static fromAngle(angle, length) {
        if (typeof length === 'undefined') {
            length = 1;
        }
        return new Vector(length * Math.cos(angle), length * Math.sin(angle));
    }
    /**
   * Creates a new 3D vector from a pair of ISO spherical angles.
   *
   * @static
   * @param {Number}     theta    polar angle in radians (zero is up).
   * @param {Number}     phi      azimuthal angle in radians
   *                               (zero is out of the screen).
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}          new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(0, 0);
   *
   *   // Prints "p5.Vector Object : [0, -1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A light shines on a pink sphere as it orbits.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Calculate the ISO angles.
   *   let theta = frameCount *  0.05;
   *   let phi = 0;
   *
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(theta, phi, 100);
   *
   *   // Create a point light using the p5.Vector.
   *   let c = color('deeppink');
   *   pointLight(c, v);
   *
   *   // Style the sphere.
   *   fill(255);
   *   noStroke();
   *
   *   // Draw the sphere.
   *   sphere(35);
   * }
   * </code>
   * </div>
   */ static fromAngles(theta, phi, length) {
        if (typeof length === 'undefined') {
            length = 1;
        }
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        return new Vector(length * sinTheta * sinPhi, -length * cosTheta, length * sinTheta * cosPhi);
    }
    /**
   * Creates a new 2D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random2D();
   *
   *   // Prints "p5.Vector Object : [x, y]" to the console
   *   // where x and y are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(1);
   *
   *   describe('A black arrow in extends from the center of a gray square. It changes direction once per second.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a random p5.Vector.
   *   let v1 = p5.Vector.random2D();
   *
   *   // Scale v1 for drawing.
   *   v1.mult(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */ static random2D() {
        return this.fromAngle(Math.random() * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"]);
    }
    /**
   * Creates a new 3D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random3D();
   *
   *   // Prints "p5.Vector Object : [x, y, z]" to the console
   *   // where x, y, and z are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */ static random3D() {
        const angle = Math.random() * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"];
        const vz = Math.random() * 2 - 1;
        const vzBase = Math.sqrt(1 - vz * vz);
        const vx = vzBase * Math.cos(angle);
        const vy = vzBase * Math.sin(angle);
        return new Vector(vx, vy, vz);
    }
    // Returns a copy of a vector.
    /**
   * @static
   * @param  {p5.Vector} v the <a href="#/p5.Vector">p5.Vector</a> to create a copy of
   * @return {p5.Vector} the copy of the <a href="#/p5.Vector">p5.Vector</a> object
   */ static copy(v) {
        return v.copy(v);
    }
    // Adds two vectors together and returns a new one.
    /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} resulting <a href="#/p5.Vector">p5.Vector</a>.
   */ static add(v1, v2, target) {
        if (!target) {
            target = v1.copy();
            if (arguments.length === 3) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.add');
            }
        } else {
            target.set(v1);
        }
        target.add(v2);
        return target;
    }
    // Returns a vector remainder when it is divided by another vector
    /**
   * @static
   * @param  {p5.Vector} v1 The dividend <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The divisor <a href="#/p5.Vector">p5.Vector</a>
   */ /**
   * @static
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} v2
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */ static rem(v1, v2) {
        if (v1 instanceof Vector && v2 instanceof Vector) {
            let target = v1.copy();
            target.rem(v2);
            return target;
        }
    }
    /*
   * Subtracts one <a href="#/p5.Vector">p5.Vector</a> from another and returns a new one.  The second
   * vector (`v2`) is subtracted from the first (`v1`), resulting in `v1-v2`.
   */ /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to subtract from
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to subtract
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */ static sub(v1, v2, target) {
        if (!target) {
            target = v1.copy();
            if (arguments.length === 3) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.sub');
            }
        } else {
            target.set(v1);
        }
        target.sub(v2);
        return target;
    }
    /**
   * Multiplies a vector by a scalar and returns a new vector.
   */ /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} resulting new <a href="#/p5.Vector">p5.Vector</a>.
   */ /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] vector to receive the result.
   */ /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */ /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */ static mult(v, n, target) {
        if (!target) {
            target = v.copy();
            if (arguments.length === 3) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.mult');
            }
        } else {
            target.set(v);
        }
        target.mult(n);
        return target;
    }
    /**
   * Rotates the vector (only 2D vectors) by the given angle; magnitude remains the same. Returns a new vector.
   */ /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number} angle
   * @param  {p5.Vector} [target] The vector to receive the result
   */ static rotate(v, a, target) {
        if (arguments.length === 2) {
            target = v.copy();
        } else {
            if (!(target instanceof Vector)) {
                p5._friendlyError('The target parameter should be of type p5.Vector', 'p5.Vector.rotate');
            }
            target.set(v);
        }
        target.rotate(a);
        return target;
    }
    /**
   * Divides a vector by a scalar and returns a new vector.
   */ /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} The resulting new <a href="#/p5.Vector">p5.Vector</a>
   */ /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] The vector to receive the result
   */ /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */ /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */ static div(v, n, target) {
        if (!target) {
            target = v.copy();
            if (arguments.length === 3) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.div');
            }
        } else {
            target.set(v);
        }
        target.div(n);
        return target;
    }
    /**
   * Calculates the dot product of two vectors.
   */ /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}     dot product.
   */ static dot(v1, v2) {
        return v1.dot(v2);
    }
    /**
   * Calculates the cross product of two vectors.
   */ /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}     cross product.
   */ static cross(v1, v2) {
        return v1.cross(v2);
    }
    /**
   * Calculates the Euclidean distance between two points (considering a
   * point as a vector object).
   */ /**
   * @static
   * @param  {p5.Vector} v1 The first <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The second <a href="#/p5.Vector">p5.Vector</a>
   * @return {Number}     The distance
   */ static dist(v1, v2) {
        return v1.dist(v2);
    }
    /**
   * Linear interpolate a vector to another vector and return the result as a
   * new vector.
   */ /**
   * @static
   * @param {p5.Vector} v1
   * @param {p5.Vector} v2
   * @param {Number} amt
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}      The lerped value
   */ static lerp(v1, v2, amt, target) {
        if (!target) {
            target = v1.copy();
            if (arguments.length === 4) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.lerp');
            }
        } else {
            target.set(v1);
        }
        target.lerp(v2, amt);
        return target;
    }
    /**
   * Performs spherical linear interpolation with the other vector
   * and returns the resulting vector.
   * This works in both 3D and 2D. As for 2D, the result of slerping
   * between 2D vectors is always a 2D vector.
   */ /**
   * @static
   * @param {p5.Vector} v1 old vector.
   * @param {p5.Vector} v2 new vector.
   * @param {Number} amt
   * @param {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} slerped vector between v1 and v2
   */ static slerp(v1, v2, amt, target) {
        if (!target) {
            target = v1.copy();
            if (arguments.length === 4) {
                p5._friendlyError('The target parameter is undefined, it should be of type p5.Vector', 'p5.Vector.slerp');
            }
        } else {
            target.set(v1);
        }
        target.slerp(v2, amt);
        return target;
    }
    /**
   * Calculates the magnitude (length) of the vector and returns the result as
   * a float (this is simply the equation `sqrt(x*x + y*y + z*z)`.)
   */ /**
   * @static
   * @param {p5.Vector} vecT The vector to return the magnitude of
   * @return {Number}        The magnitude of vecT
   */ static mag(vecT) {
        return vecT.mag();
    }
    /**
   * Calculates the squared magnitude of the vector and returns the result
   * as a float (this is simply the equation <em>(x\*x + y\*y + z\*z)</em>.)
   * Faster if the real length is not required in the
   * case of comparing vectors, etc.
   */ /**
   * @static
   * @param {p5.Vector} vecT the vector to return the squared magnitude of
   * @return {Number}        the squared magnitude of vecT
   */ static magSq(vecT) {
        return vecT.magSq();
    }
    /**
   * Normalize the vector to length 1 (make it a unit vector).
   */ /**
   * @static
   * @param {p5.Vector} v  The vector to normalize
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}   The vector v, normalized to a length of 1
   */ static normalize(v, target) {
        if (arguments.length < 2) {
            target = v.copy();
        } else {
            if (!(target instanceof Vector)) {
                p5._friendlyError('The target parameter should be of type p5.Vector', 'p5.Vector.normalize');
            }
            target.set(v);
        }
        return target.normalize();
    }
    /**
   * Limit the magnitude of the vector to the value used for the <b>max</b>
   * parameter.
   */ /**
   * @static
   * @param {p5.Vector} v  the vector to limit
   * @param {Number}    max
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude limited to max
   */ static limit(v, max, target) {
        if (arguments.length < 3) {
            target = v.copy();
        } else {
            if (!(target instanceof Vector)) {
                p5._friendlyError('The target parameter should be of type p5.Vector', 'p5.Vector.limit');
            }
            target.set(v);
        }
        return target.limit(max);
    }
    /**
   * Set the magnitude of the vector to the value used for the <b>len</b>
   * parameter.
   */ /**
   * @static
   * @param {p5.Vector} v  the vector to set the magnitude of
   * @param {Number}    len
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude set to len
   */ static setMag(v, len, target) {
        if (arguments.length < 3) {
            target = v.copy();
        } else {
            if (!(target instanceof Vector)) {
                p5._friendlyError('The target parameter should be of type p5.Vector', 'p5.Vector.setMag');
            }
            target.set(v);
        }
        return target.setMag(len);
    }
    /**
   * Calculate the angle of rotation for this vector (only 2D vectors).
   * p5.Vectors created using <a href="#/p5/createVector">createVector()</a>
   * will take the current <a href="#/p5/angleMode">angleMode</a> into
   * consideration, and give the angle in radians or degrees accordingly.
   */ /**
   * @static
   * @param {p5.Vector} v the vector to find the angle of
   * @return {Number} the angle of rotation
   */ static heading(v) {
        return v.heading();
    }
    /**
   * Calculates and returns the angle between two vectors. This function will take
   * the <a href="#/p5/angleMode">angleMode</a> on v1 into consideration, and
   * give the angle in radians or degrees accordingly.
   */ /**
   * @static
   * @param  {p5.Vector}    v1 the first vector.
   * @param  {p5.Vector}    v2 the second vector.
   * @return {Number}       angle between the two vectors.
   */ static angleBetween(v1, v2) {
        return v1.angleBetween(v2);
    }
    /**
   * Reflect a vector about a normal to a line in 2D, or about a normal to a
   * plane in 3D.
   */ /**
   * @static
   * @param  {p5.Vector} incidentVector vector to be reflected.
   * @param  {p5.Vector} surfaceNormal
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} the reflected vector
   */ static reflect(incidentVector, surfaceNormal, target) {
        if (arguments.length < 3) {
            target = incidentVector.copy();
        } else {
            if (!(target instanceof Vector)) {
                p5._friendlyError('The target parameter should be of type p5.Vector', 'p5.Vector.reflect');
            }
            target.set(incidentVector);
        }
        return target.reflect(surfaceNormal);
    }
    /**
   * Return a representation of this vector as a float array. This is only
   * for temporary use. If used in any other fashion, the contents should be
   * copied by using the <b>p5.Vector.<a href="#/p5.Vector/copy">copy()</a></b>
   * method to copy into your own vector.
   */ /**
   * @static
   * @param  {p5.Vector} v the vector to convert to an array
   * @return {Number[]} an Array with the 3 values
   */ static array(v) {
        return v.array();
    }
    /**
   * Equality check against a <a href="#/p5.Vector">p5.Vector</a>
   */ /**
   * @static
   * @param {p5.Vector|Array} v1 the first vector to compare
   * @param {p5.Vector|Array} v2 the second vector to compare
   * @return {Boolean}
   */ static equals(v1, v2) {
        let v;
        if (v1 instanceof Vector) {
            v = v1;
        } else if (v1 instanceof Array) {
            v = new Vector().set(v1);
        } else {
            p5._friendlyError('The v1 parameter should be of type Array or p5.Vector', 'p5.Vector.equals');
        }
        return v.equals(v2);
    }
}
function vector(p51, fn) {
    /**
   * A class to describe a two or three-dimensional vector.
   *
   * A vector can be thought of in different ways. In one view, a vector is like
   * an arrow pointing in space. Vectors have both magnitude (length) and
   * direction.
   *
   * `p5.Vector` objects are often used to program motion because they simplify
   * the math. For example, a moving ball has a position and a velocity.
   * Position describes where the ball is in space. The ball's position vector
   * extends from the origin to the ball's center. Velocity describes the ball's
   * speed and the direction it's moving. If the ball is moving straight up, its
   * velocity vector points straight up. Adding the ball's velocity vector to
   * its position vector moves it, as in `pos.add(vel)`. Vector math relies on
   * methods inside the `p5.Vector` class.
   *
   * Note: <a href="#/p5/createVector">createVector()</a> is the recommended way
   * to make an instance of this class.
   *
   * @class p5.Vector
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let p1 = createVector(25, 25);
   *   let p2 = createVector(75, 75);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Draw the first point using a p5.Vector.
   *   point(p1);
   *
   *   // Draw the second point using a p5.Vector's components.
   *   point(p2.x, p2.y);
   *
   *   describe('Two black dots on a gray square, one at the top left and the other at the bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pos;
   * let vel;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create p5.Vector objects.
   *   pos = createVector(50, 100);
   *   vel = createVector(0, -1);
   *
   *   describe('A black dot moves from bottom to top on a gray square. The dot reappears at the bottom when it reaches the top.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add velocity to position.
   *   pos.add(vel);
   *
   *   // If the dot reaches the top of the canvas,
   *   // restart from the bottom.
   *   if (pos.y < 0) {
   *     pos.y = 100;
   *   }
   *
   *   // Draw the dot.
   *   strokeWeight(5);
   *   point(pos);
   * }
   * </code>
   * </div>
   */ p51.Vector = Vector;
/**
   * The x component of the vector
   * @type {Number}
   * @for p5.Vector
   * @property x
   * @name x
   */ /**
   * The y component of the vector
   * @type {Number}
   * @for p5.Vector
   * @property y
   * @name y
   */ /**
   * The z component of the vector
   * @type {Number}
   * @for p5.Vector
   * @property z
   * @name z
   */ }
if (typeof p5 !== 'undefined') {
    vector(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GLMAT_ARRAY_TYPE",
    ()=>GLMAT_ARRAY_TYPE,
    "MatrixInterface",
    ()=>MatrixInterface,
    "isMatrixArray",
    ()=>isMatrixArray
]);
let GLMAT_ARRAY_TYPE = Array;
let isMatrixArray = (x)=>Array.isArray(x);
if (typeof Float32Array !== 'undefined') {
    GLMAT_ARRAY_TYPE = Float32Array;
    isMatrixArray = (x)=>Array.isArray(x) || x instanceof Float32Array;
}
class MatrixInterface {
    // Private field to store the matrix
    #matrix = null;
    constructor(...args){
        if (this.constructor === MatrixInterface) {
            throw new Error("Class is of abstract type and can't be instantiated");
        }
    // TODO: don't check this at runtime but still at compile time
    /*const methods = [
      'add',
      'setElement',
      'reset',
      'set',
      'get',
      'copy',
      'clone',
      'diagonal',
      'row',
      'column',
      'transpose',
      'mult',
      'multiplyVec',
      'invert',
      'createSubMatrix3x3',
      'inverseTranspose4x4',
      'apply',
      'scale',
      'rotate4x4',
      'translate',
      'rotateX',
      'rotateY',
      'rotateZ',
      'perspective',
      'ortho',
      'multiplyVec4',
      'multiplyPoint',
      'multiplyAndNormalizePoint',
      'multiplyDirection',
      'multiplyVec3'
    ];

    methods.forEach(method => {
      if (this[method] === undefined) {
        throw new Error(`${method}() method must be implemented`);
      }
    });*/ }
}
;
}),
"[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GLMAT_ARRAY_TYPE",
    ()=>GLMAT_ARRAY_TYPE,
    "Matrix",
    ()=>Matrix,
    "isMatrixArray",
    ()=>isMatrixArray
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-client] (ecmascript)");
;
;
;
/**
 * @module Math
 */ const isPerfectSquare = (arr)=>{
    const sqDimention = Math.sqrt(arr.length);
    if (sqDimention % 1 !== 0) {
        throw new Error('Array length must be a perfect square.');
    }
    return true;
};
let GLMAT_ARRAY_TYPE = Array;
let isMatrixArray = (x)=>Array.isArray(x);
if (typeof Float32Array !== 'undefined') {
    GLMAT_ARRAY_TYPE = Float32Array;
    isMatrixArray = (x)=>Array.isArray(x) || x instanceof Float32Array;
}
class Matrix extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MatrixInterface"] {
    matrix;
    #sqDimention;
    constructor(...args){
        super(...args);
        // This is default behavior when object
        // instantiated using createMatrix()
        if (isMatrixArray(args[0]) && isPerfectSquare(args[0])) {
            const sqDimention = Math.sqrt(args[0].length);
            this.#sqDimention = sqDimention;
            this.matrix = GLMAT_ARRAY_TYPE.from(args[0]);
        } else if (typeof args[0] === 'number') {
            this.#sqDimention = Number(args[0]);
            this.matrix = this.#createIdentityMatrix(args[0]);
        }
        return this;
    }
    /**
   * Returns the 3x3 matrix if the dimensions are 3x3, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 3x3.
   * If the matrix is not 3x3, it returns `undefined`.
   *
   * @returns {Array|undefined} The 3x3 matrix or `undefined` if the matrix is not 3x3.
   */ get mat3() {
        if (this.#sqDimention === 3) {
            return this.matrix;
        } else {
            return undefined;
        }
    }
    /**
   * Returns the 4x4 matrix if the dimensions are 4x4, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 4x4.
   * If the matrix is not 4x4, it returns `undefined`.
   *
   * @returns {Array|undefined} The 4x4 matrix or `undefined` if the matrix is not 4x4.
   */ get mat4() {
        if (this.#sqDimention === 4) {
            return this.matrix;
        } else {
            return undefined;
        }
    }
    /**
   * Adds the corresponding elements of the given matrix to this matrix, if the dimentions are the same.
   *
   * @param {Matrix} matrix - The matrix to add to this matrix. It must have the same dimensions as this matrix.
   * @returns {Matrix} The resulting matrix after addition.
   * @throws {Error} If the matrices do not have the same dimensions.
   *
   * @example
   * const matrix1 = new p5.Matrix([1, 2, 3]);
   * const matrix2 = new p5.Matrix([4, 5, 6]);
   * matrix1.add(matrix2); // matrix1 is now [5, 7, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   *   const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   *   matrix1.add(matrix2);
   *   console.log(matrix1.matrix); // Output: [6, 8, 10, 12]
   * }
   * </code></div>
   */ add(matrix) {
        if (this.matrix.length !== matrix.matrix.length) {
            throw new Error('Matrices must be of the same dimension to add.');
        }
        for(let i = 0; i < this.matrix.length; i++){
            this.matrix[i] += matrix.matrix[i];
        }
        return this;
    }
    /**
   * Sets the value of a specific element in the matrix in column-major order.
   *
   * A matrix is stored in column-major order, meaning elements are arranged column by column.
   * This function allows you to update or change the value of a specific element
   * in the matrix by specifying its index in the column-major order and the new value.
   *
   * Parameters:
   * - `index` (number): The position in the matrix where the value should be set.
   *   Indices start from 0 and follow column-major order.
   * - `value` (any): The new value you want to assign to the specified element.
   *
   * Example:
   * If you have the following 3x3 matrix stored in column-major order:
   * ```
   * [
   *   1, 4, 7,  // Column 1
   *   2, 5, 8,  // Column 2
   *   3, 6, 9   // Column 3
   * ]
   * ```
   * Calling `setElement(4, 10)` will update the element at index 4
   * (which corresponds to row 2, column 2 in row-major order) to `10`.
   * The updated matrix will look like this:
   * ```
   * [
   *   1, 4, 7,
   *   2, 10, 8,
   *   3, 6, 9
   * ]
   * ```
   *
   * This function is useful for modifying specific parts of the matrix without
   * having to recreate the entire structure.
   *
   * @param {Number} index - The position in the matrix where the value should be set.
   *                         Must be a non-negative integer less than the length of the matrix.
   * @param {Number} value - The new value to be assigned to the specified position in the matrix.
   * @returns {Matrix} The current instance of the Matrix, allowing for method chaining.
   *
   * @example
   * // Assuming matrix is an instance of Matrix with initial values [1, 2, 3, 4] matrix.setElement(2, 99);
   * // Now the matrix values are [1, 2, 99, 4]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   matrix.setElement(2, 99);
   *   console.log(matrix.matrix); // Output: [1, 2, 99, 4]
   * }
   * </code></div>
   */ setElement(index, value) {
        if (index >= 0 && index < this.matrix.length) {
            this.matrix[index] = value;
        }
        return this;
    }
    /**
   * Resets the current matrix to an identity matrix.
   *
   * This method replaces the current matrix with an identity matrix of the same dimensions.
   * An identity matrix is a square matrix with ones on the main diagonal and zeros elsewhere.
   * This is useful for resetting transformations or starting fresh with a clean matrix.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Resetting a 4x4 matrix to an identity matrix
   * const matrix = new p5.Matrix(4);
   * matrix.scale(2, 2, 2); // Apply some transformations
   * console.log(matrix.matrix); // Output: Transformed matrix
   * matrix.reset(); // Reset to identity matrix
   * console.log(matrix.matrix); // Output: Identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4);
   *   matrix.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Before reset:", matrix.matrix);
   *   matrix.reset(); // Reset to identity matrix
   *   console.log("After reset:", matrix.matrix);
   * }
   * </code></div>
   */ reset() {
        this.matrix = this.#createIdentityMatrix(this.#sqDimention);
        return this;
    }
    /**
   * Replace the entire contents of a NxN matrix.
   *
   * This method allows you to replace the values of the current matrix with
   * those from another matrix, an array, or individual arguments. The input
   * can be a `Matrix` instance, an array of numbers, or individual numbers
   * that match the dimensions of the current matrix. The values are copied
   * without referencing the source object, ensuring that the original input
   * remains unchanged.
   *
   * If the input dimensions do not match the current matrix, an error will
   * be thrown to ensure consistency.
   *
   * @param {Matrix|Float32Array|Number[]} [inMatrix] - The input matrix, array,
   * or individual numbers to replace the current matrix values.
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Replacing the contents of a matrix with another matrix
   * const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   * const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   * matrix1.set(matrix2);
   * console.log(matrix1.matrix); // Output: [5, 6, 7, 8]
   *
   * // Replacing the contents of a matrix with an array
   * const matrix = new p5.Matrix([1, 2, 3, 4]);
   * matrix.set([9, 10, 11, 12]);
   * console.log(matrix.matrix); // Output: [9, 10, 11, 12]
   *
   * // Replacing the contents of a matrix with individual numbers
   * const matrix = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix.set(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
   * console.log(matrix.matrix); // Output: [1, 2, 3, ..., 16]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   console.log("Before set:", matrix.matrix);
   *   matrix.set([5, 6, 7, 8]);
   *   console.log("After set:", matrix.matrix); // Output: [5, 6, 7, 8]
   * }
   * </code></div>
   */ set(inMatrix) {
        let refArray = GLMAT_ARRAY_TYPE.from([
            ...arguments
        ]);
        if (inMatrix instanceof Matrix) {
            refArray = GLMAT_ARRAY_TYPE.from(inMatrix.matrix);
        } else if (isMatrixArray(inMatrix)) {
            refArray = GLMAT_ARRAY_TYPE.from(inMatrix);
        }
        if (refArray.length !== this.matrix.length) {
            p5._friendlyError(`Expected same dimensions values but received different ${refArray.length}.`, 'p5.Matrix.set');
            return this;
        }
        this.matrix = refArray;
        return this;
    }
    /**
   * Gets a copy of the matrix, returns a p5.Matrix object.
   *
   * This method creates a new instance of the `Matrix` class and copies the
   * current matrix values into it. The returned matrix is independent of the
   * original, meaning changes to the copy will not affect the original matrix.
   *
   * This is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate.
   *
   * @return {p5.Matrix} A new instance of the `Matrix` class containing the
   *                     same values as the original matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4]);
   *   const copiedMatrix = originalMatrix.get();
   *   console.log("Original Matrix:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   *   console.log("Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 3, 4]
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(2, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 99, 4]
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   * }
   * </code></div>
   */ get() {
        return new Matrix(this.matrix); // TODO: Pass p5
    }
    /**
   * Return a copy of this matrix.
   * If this matrix is 4x4, a 4x4 matrix with exactly the same entries will be
   * generated. The same is true if this matrix is 3x3 or any NxN matrix.
   *
   * This method is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate. The returned matrix is independent
   * of the original, meaning changes to the copy will not affect the original matrix.
   *
   * @return {p5.Matrix}   The result matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const copiedMatrix = originalMatrix.copy();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Copied Matrix:", copiedMatrix.matrix);
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(4, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */ copy() {
        return new Matrix(this.matrix);
    }
    /**
   * Creates a copy of the current matrix instance.
   * This method is useful when you need a duplicate of the matrix
   * without modifying the original one.
   *
   * @returns {Matrix} A new matrix instance that is a copy of the current matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const clonedMatrix = originalMatrix.clone();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Cloned Matrix:", clonedMatrix.matrix);
   *
   *   // Modify the cloned matrix
   *   clonedMatrix.setElement(4, 99);
   *   console.log("Modified Cloned Matrix:", clonedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */ clone() {
        return this.copy();
    }
    /**
   * Returns the diagonal elements of the matrix in the form of an array.
   * A NxN matrix will return an array of length N.
   *
   * This method extracts the diagonal elements of the matrix, which are the
   * elements where the row index equals the column index. For example, in a
   * 3x3 matrix:
   * ```
   * [
   *   1, 2, 3,
   *   4, 5, 6,
   *   7, 8, 9
   * ]
   * ```
   * The diagonal elements are [1, 5, 9].
   *
   * This is useful for operations that require the main diagonal of a matrix,
   * such as calculating the trace of a matrix or verifying if a matrix is diagonal.
   *
   * @return {Number[]} An array obtained by arranging the diagonal elements
   *                    of the matrix in ascending order of index.
   *
   * @example
   * // Extracting the diagonal elements of a matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const diagonal = matrix.diagonal(); // [1, 5, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const diagonal = matrix.diagonal();
   *   console.log("Diagonal elements:", diagonal); // Output: [1, 5, 9]
   * }
   * </code></div>
   */ diagonal() {
        const diagonal = [];
        for(let i = 0; i < this.#sqDimention; i++){
            diagonal.push(this.matrix[i * (this.#sqDimention + 1)]);
        }
        return diagonal;
    }
    /**
   * This function is only for 3x3 matrices A function that returns a row vector of a NxN matrix.
   *
   * This method extracts a specific row from the matrix and returns it as a `p5.Vector`.
   * The row is determined by the `columnIndex` parameter, which specifies the column
   * index of the matrix. This is useful for operations that require working with
   * individual rows of a matrix, such as row transformations or dot products.
   *
   * @param {Number} columnIndex - The index of the column to extract as a row vector.
   *                               Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted row of the matrix.
   *
   * @example
   * // Extracting a row vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const rowVector = matrix.row(1); // Returns a vector [2, 5, 8]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const rowVector = matrix.row(1); // Extract the second row (index 1)
   *   console.log("Row Vector:", rowVector.toString()); // Output: Row Vector: [2, 5, 8]
   * }
   * </code></div>
   */ row(columnIndex) {
        const columnVector = [];
        for(let i = 0; i < this.#sqDimention; i++){
            columnVector.push(this.matrix[i * this.#sqDimention + columnIndex]);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](...columnVector);
    }
    /**
   * A function that returns a column vector of a NxN matrix.
   *
   * This method extracts a specific column from the matrix and returns it as a `p5.Vector`.
   * The column is determined by the `rowIndex` parameter, which specifies the row index
   * of the matrix. This is useful for operations that require working with individual
   * columns of a matrix, such as column transformations or dot products.
   *
   * @param {Number} rowIndex - The index of the row to extract as a column vector.
   *                             Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted column of the matrix.
   *
   * @example
   * // Extracting a column vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const columnVector = matrix.column(1); // Returns a vector [4, 5, 6]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const columnVector = matrix.column(1); // Extract the second column (index 1)
   *   console.log("Column Vector:", columnVector.toString()); // Output: Column Vector: [4, 5, 6]
   * }
   * </code></div>
   */ column(rowIndex) {
        const rowVector = [];
        for(let i = 0; i < this.#sqDimention; i++){
            rowVector.push(this.matrix[rowIndex * this.#sqDimention + i]);
        }
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](...rowVector);
    }
    /**
   * Transposes the given matrix `a` based on the square dimension of the matrix.
   *
   * This method rearranges the elements of the matrix such that the rows become columns
   * and the columns become rows. It handles matrices of different dimensions (4x4, 3x3, NxN)
   * by delegating to specific transpose methods for each case.
   *
   * If no argument is provided, the method transposes the current matrix instance.
   * If an argument is provided, it transposes the given matrix `a` and updates the current matrix.
   *
   * @param {Array} [a] - The matrix to be transposed. It should be a 2D array where each sub-array represents a row.
   *                      If omitted, the current matrix instance is transposed.
   * @returns {Matrix} - The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Transposing a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * matrix.transpose();
   * console.log(matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   *
   * // Transposing a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4);
   * matrix4x4.transpose();
   * console.log(matrix4x4.matrix); // Output: Transposed 4x4 identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Before transpose:", matrix.matrix);
   *   matrix.transpose();
   *   console.log("After transpose:", matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   * }
   * </code></div>
   */ transpose(a) {
        if (this.#sqDimention === 4) {
            return this.#transpose4x4(a);
        } else if (this.#sqDimention === 3) {
            return this.#transpose3x3(a);
        } else {
            return this.#transposeNxN(a);
        }
    }
    /**
   * Multiplies the current matrix with another matrix or matrix-like array.
   *
   * This method supports several types of input:
   * - Another Matrix instance
   * - A matrix-like array (must be a perfect square, e.g., 4x4 or 3x3)
   * - Multiple arguments that form a perfect square matrix
   *
   * If the input is the same as the current matrix, a copy is made to avoid modifying the original matrix.
   *
   * The method determines the appropriate multiplication strategy based on the dimensions of the current matrix
   * and the input matrix. It supports 3x3, 4x4, and NxN matrices.
   *
   * @param {Matrix|Array|...number} multMatrix - The matrix or matrix-like array to multiply with.
   * @returns {Matrix|undefined} The resulting matrix after multiplication, or undefined if the input is invalid.
   * @chainable
   *
   * @example
   * // Multiplying two 3x3 matrices
   * const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   * matrix1.mult(matrix2);
   * console.log(matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   *
   * // Multiplying a 4x4 matrix with another 4x4 matrix
   * const matrix4x4_1 = new p5.Matrix(4); // Identity matrix
   * const matrix4x4_2 = new p5.Matrix([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]);
   * matrix4x4_1.mult(matrix4x4_2);
   * console.log(matrix4x4_1.matrix); // Output: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   *   console.log("Before multiplication:", matrix1.matrix);
   *   matrix1.mult(matrix2);
   *   console.log("After multiplication:", matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   * }
   * </code></div>
   */ mult(multMatrix) {
        let _src;
        if (multMatrix === this || multMatrix === this.matrix) {
            _src = this.copy().matrix; // only need to allocate in this rare case
        } else if (multMatrix instanceof Matrix) {
            _src = multMatrix.matrix;
        } else if (isMatrixArray(multMatrix) && isPerfectSquare(multMatrix)) {
            _src = multMatrix;
        } else if (isPerfectSquare(Array.from(arguments))) {
            _src = Array.from(arguments);
        } else ;
        if (this.#sqDimention === 4 && _src.length === 16) {
            return this.#mult4x4(_src);
        } else if (this.#sqDimention === 3 && _src.length === 9) {
            return this.#mult3x3(_src);
        } else {
            return this.#multNxN(_src);
        }
    }
    /**
   * Takes a vector and returns the vector resulting from multiplying to that vector by this matrix from left. This function is only for 3x3 matrices.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const vector = new p5.Vector(1, 2, 3);
   *   const result = matrix.multiplyVec(vector);
   *   console.log("Original Vector:", vector.toString()); // Output : Original Vector: [1, 2, 3]
   *   console.log("Transformed Vector:", result.toString()); // Output : Transformed Vector: [30, 36, 42]
   * }
   * </code></div>
   */ multiplyVec(multVector, target) {
        if (target === undefined) {
            target = multVector.copy();
        }
        for(let i = 0; i < this.#sqDimention; i++){
            target.values[i] = this.row(i).dot(multVector);
        }
        return target;
    }
    /**
   * Inverts a given matrix.
   *
   * This method inverts a matrix based on its dimensions. Currently, it supports
   * 3x3 and 4x4 matrices. If the matrix dimension is greater than 4, an error is thrown.
   *
   * For 4x4 matrices, it uses a specialized algorithm to compute the inverse.
   * For 3x3 matrices, it uses a different algorithm optimized for smaller matrices.
   *
   * If the matrix is singular (non-invertible), the method will return `null`.
   *
   * @param {Array} a - The matrix to be inverted. It should be a 2D array representing the matrix.
   * @returns {Array|null} - The inverted matrix, or `null` if the matrix is singular.
   * @throws {Error} - Throws an error if the matrix dimension is greater than 4.
   *
   * @example
   * // Inverting a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   * const invertedMatrix = matrix.invert();
   * console.log(invertedMatrix.matrix); // Output: Inverted 3x3 matrix
   *
   * // Inverting a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Identity matrix
   * matrix4x4.scale(2, 2, 2);
   * const invertedMatrix4x4 = matrix4x4.invert();
   * console.log(invertedMatrix4x4.matrix); // Output: Inverted 4x4 matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   *   console.log("Original Matrix:", matrix.matrix);
   *   const invertedMatrix = matrix.invert();
   *   if (invertedMatrix) {
   *     console.log("Inverted Matrix:", invertedMatrix.matrix);
   *   } else {
   *     console.log("Matrix is singular and cannot be inverted.");
   *   }
   * }
   * </code></div>
   */ invert(a) {
        if (this.#sqDimention === 4) {
            return this.#invert4x4(a);
        } else if (this.#sqDimention === 3) {
            return this.#invert3x3(a);
        } else {
            throw new Error('Invert is not implemented for N>4 at the moment, we are working on it');
        }
    }
    /**
   * Creates a 3x3 matrix whose entries are the top left 3x3 part and returns it. This function is only for 4x4 matrices.
   *
   * This method extracts the top-left 3x3 portion of a 4x4 matrix and creates a new
   * 3x3 matrix from it. This is particularly useful in 3D graphics for operations
   * that require only the rotational or scaling components of a transformation matrix.
   *
   * If the current matrix is not 4x4, an error is thrown to ensure the method is used
   * correctly. The resulting 3x3 matrix is independent of the original matrix, meaning
   * changes to the new matrix will not affect the original.
   *
   * @return {p5.Matrix} A new 3x3 matrix containing the top-left portion of the original 4x4 matrix.
   * @throws {Error} If the current matrix is not 4x4.
   *
   * @example
   * // Extracting a 3x3 submatrix from a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   * const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   * console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   * console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   *   matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   *
   *   const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   *   console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   * }
   * </code></div>
   */ createSubMatrix3x3() {
        if (this.#sqDimention === 4) {
            const result = new Matrix(3);
            result.mat3[0] = this.matrix[0];
            result.mat3[1] = this.matrix[1];
            result.mat3[2] = this.matrix[2];
            result.mat3[3] = this.matrix[4];
            result.mat3[4] = this.matrix[5];
            result.mat3[5] = this.matrix[6];
            result.mat3[6] = this.matrix[8];
            result.mat3[7] = this.matrix[9];
            result.mat3[8] = this.matrix[10];
            return result;
        } else {
            throw new Error('Matrix dimension must be 4 to create a 3x3 submatrix.');
        }
    }
    /**
   * Converts a 4×4 matrix to its 3×3 inverse transpose transform.
   * This is commonly used in MVMatrix to NMatrix conversions, particularly
   * in 3D graphics for transforming normal vectors.
   *
   * This method extracts the top-left 3×3 portion of a 4×4 matrix, inverts it,
   * and then transposes the result. If the matrix is singular (non-invertible),
   * the resulting matrix will be zeroed out.
   *
   * @param  {p5.Matrix} mat4 - The 4×4 matrix to be converted.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   * @throws {Error} If the current matrix is not 3×3.
   *
   * @example
   * // Converting a 4×4 matrix to its 3×3 inverse transpose
   * const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   * mat4.scale(2, 2, 2); // Apply scaling transformation
   * const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   * mat3.inverseTranspose4x4(mat4);
   * console.log("Converted 3×3 Matrix:", mat3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   *   mat4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4×4 Matrix:", mat4.matrix);
   *
   *   const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   *   mat3.inverseTranspose4x4(mat4);
   *   console.log("Converted 3×3 Matrix:", mat3.matrix);
   * }
   * </code></div>
   */ inverseTranspose4x4({ mat4 }) {
        if (this.#sqDimention !== 3) {
            throw new Error('This function only works with 3×3 matrices.');
        } else {
            // Convert mat4 -> mat3 by extracting the top-left 3×3 portion
            this.matrix[0] = mat4[0];
            this.matrix[1] = mat4[1];
            this.matrix[2] = mat4[2];
            this.matrix[3] = mat4[4];
            this.matrix[4] = mat4[5];
            this.matrix[5] = mat4[6];
            this.matrix[6] = mat4[8];
            this.matrix[7] = mat4[9];
            this.matrix[8] = mat4[10];
        }
        const inverse = this.invert();
        // Check if inversion succeeded
        if (inverse) {
            inverse.transpose(this.matrix);
        } else {
            // In case of singularity, zero out the matrix
            for(let i = 0; i < 9; i++){
                this.matrix[i] = 0;
            }
        }
        return this;
    }
    /**
   * Applies a transformation matrix to the current matrix.
   *
   * This method multiplies the current matrix by another matrix, which can be provided
   * in several forms: another Matrix instance, an array representing a matrix, or as
   * individual arguments representing the elements of a 4x4 matrix.
   *
   * This operation is useful for combining transformations such as translation, rotation,
   * scaling, and perspective projection into a single matrix. By applying a transformation
   * matrix, you can modify the current matrix to represent a new transformation.
   *
   * @param {Matrix|Array|number} multMatrix - The matrix to multiply with. This can be:
   *   - An instance of the Matrix class.
   *   - An array of 16 numbers representing a 4x4 matrix.
   *   - 16 individual numbers representing the elements of a 4x4 matrix.
   * @returns {Matrix} The current matrix after applying the transformation.
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *
   * // Assuming `matrix` is an instance of Matrix
   * const anotherMatrix = new p5.Matrix(4);
   * const anotherMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(anotherMatrix);
   *
   * // Applying a transformation using an array
   * const matrixArray = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(matrixArray);
   *
   * // Applying a transformation using individual arguments
   * matrix.apply(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
   *
   *
   *   // Create a 4x4 identity matrix
   *   const matrix = new p5.Matrix(4);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Create a scaling transformation matrix
   *   const scalingMatrix = new p5.Matrix([2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1]);
   *
   *   // Apply the scaling transformation
   *   matrix.apply(scalingMatrix);
   *   console.log("After Scaling Transformation:", matrix.matrix);
   *
   *   // Apply a translation transformation using an array
   *   const translationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 5, 5, 5, 1];
   *   matrix.apply(translationMatrix);
   *   console.log("After Translation Transformation:", matrix.matrix);
   * }
   * </code></div>
   */ apply(multMatrix) {
        let _src;
        if (multMatrix === this || multMatrix === this.matrix) {
            _src = this.copy().matrix; // only need to allocate in this rare case
        } else if (multMatrix instanceof Matrix) {
            _src = multMatrix.matrix;
        } else if (isMatrixArray(multMatrix)) {
            _src = multMatrix;
        } else if (arguments.length === 16) {
            _src = arguments;
        } else {
            return; // nothing to do.
        }
        const mat4 = this.matrix;
        // each row is used for the multiplier
        const m0 = mat4[0];
        const m4 = mat4[4];
        const m8 = mat4[8];
        const m12 = mat4[12];
        mat4[0] = _src[0] * m0 + _src[1] * m4 + _src[2] * m8 + _src[3] * m12;
        mat4[4] = _src[4] * m0 + _src[5] * m4 + _src[6] * m8 + _src[7] * m12;
        mat4[8] = _src[8] * m0 + _src[9] * m4 + _src[10] * m8 + _src[11] * m12;
        mat4[12] = _src[12] * m0 + _src[13] * m4 + _src[14] * m8 + _src[15] * m12;
        const m1 = mat4[1];
        const m5 = mat4[5];
        const m9 = mat4[9];
        const m13 = mat4[13];
        mat4[1] = _src[0] * m1 + _src[1] * m5 + _src[2] * m9 + _src[3] * m13;
        mat4[5] = _src[4] * m1 + _src[5] * m5 + _src[6] * m9 + _src[7] * m13;
        mat4[9] = _src[8] * m1 + _src[9] * m5 + _src[10] * m9 + _src[11] * m13;
        mat4[13] = _src[12] * m1 + _src[13] * m5 + _src[14] * m9 + _src[15] * m13;
        const m2 = mat4[2];
        const m6 = mat4[6];
        const m10 = mat4[10];
        const m14 = mat4[14];
        mat4[2] = _src[0] * m2 + _src[1] * m6 + _src[2] * m10 + _src[3] * m14;
        mat4[6] = _src[4] * m2 + _src[5] * m6 + _src[6] * m10 + _src[7] * m14;
        mat4[10] = _src[8] * m2 + _src[9] * m6 + _src[10] * m10 + _src[11] * m14;
        mat4[14] = _src[12] * m2 + _src[13] * m6 + _src[14] * m10 + _src[15] * m14;
        const m3 = mat4[3];
        const m7 = mat4[7];
        const m11 = mat4[11];
        const m15 = mat4[15];
        mat4[3] = _src[0] * m3 + _src[1] * m7 + _src[2] * m11 + _src[3] * m15;
        mat4[7] = _src[4] * m3 + _src[5] * m7 + _src[6] * m11 + _src[7] * m15;
        mat4[11] = _src[8] * m3 + _src[9] * m7 + _src[10] * m11 + _src[11] * m15;
        mat4[15] = _src[12] * m3 + _src[13] * m7 + _src[14] * m11 + _src[15] * m15;
        return this;
    }
    /**
   * Scales a p5.Matrix by scalars or a vector.
   *
   * This method applies a scaling transformation to the current matrix.
   * Scaling is a transformation that enlarges or shrinks objects by a scale factor
   * along the x, y, and z axes. The scale factors can be provided as individual
   * numbers, an array, or a `p5.Vector`.
   *
   * If a `p5.Vector` or an array is provided, the x, y, and z components are extracted
   * from it. If the z component is not provided, it defaults to 1 (no scaling along the z-axis).
   *
   * @param {p5.Vector|Float32Array|Number[]} s - The vector or scalars to scale by.
   *                                              Can be a `p5.Vector`, an array, or individual numbers.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Scaling a matrix by individual scalars
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.scale(2, 3, 4); // Scale by 2 along x, 3 along y, and 4 along z
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by a p5.Vector
   * const scaleVector = new p5.Vector(2, 3, 4);
   * matrix.scale(scaleVector);
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by an array
   * const scaleArray = [2, 3, 4];
   * matrix.scale(scaleArray);
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Scale the matrix by individual scalars
   *   matrix.scale(2, 3, 4);
   *   console.log("Scaled Matrix (2, 3, 4):", matrix.matrix);
   *
   *   // Scale the matrix by a p5.Vector
   *   const scaleVector = new p5.Vector(1.5, 2.5, 3.5);
   *   matrix.scale(scaleVector);
   *   console.log("Scaled Matrix (Vector):", matrix.matrix);
   *
   *   // Scale the matrix by an array
   *   const scaleArray = [0.5, 0.5, 0.5];
   *   matrix.scale(scaleArray);
   *   console.log("Scaled Matrix (Array):", matrix.matrix);
   * }
   * </code></div>
   */ scale(x, y, z) {
        if (x instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"]) {
            // x is a vector, extract the components from it.
            y = x.y;
            z = x.z;
            x = x.x; // must be last
        } else if (x instanceof Array) {
            // x is an array, extract the components from it.
            y = x[1];
            z = x[2];
            x = x[0]; // must be last
        }
        this.matrix[0] *= x;
        this.matrix[1] *= x;
        this.matrix[2] *= x;
        this.matrix[3] *= x;
        this.matrix[4] *= y;
        this.matrix[5] *= y;
        this.matrix[6] *= y;
        this.matrix[7] *= y;
        this.matrix[8] *= z;
        this.matrix[9] *= z;
        this.matrix[10] *= z;
        this.matrix[11] *= z;
        return this;
    }
    /**
   * Rotate the Matrix around a specified axis by a given angle.
   *
   * This method applies a rotation transformation to the matrix, modifying its orientation
   * in 3D space. The rotation is performed around the provided axis, which can be defined
   * as a `p5.Vector` or an array of numbers representing the x, y, and z components of the axis.
   * Rotate our Matrix around an axis by the given angle.
   * @param  {Number} a The angle of rotation in radians.
   *                    Angles in radians are a measure of rotation, where 2π radians
   *                    represent a full circle (360 degrees). For example:
   *                    - π/2 radians = 90 degrees (quarter turn)
   *                    - π radians = 180 degrees (half turn)
   *                    - 2π radians = 360 degrees (full turn)
   *                    Use `Math.PI` for π or `p5`'s `PI` constant if using p5.js.
   * @param  {p5.Vector|Number[]} axis The axis or axes to rotate around.
   *                                   This defines the direction of the rotation.
   *                                   - If using a `p5.Vector`, it should represent
   *                                     the x, y, and z components of the axis.
   *                                   - If using an array, it should be in the form
   *                                     [x, y, z], where x, y, and z are numbers.
   *                                   For example:
   *                                   - [1, 0, 0] rotates around the x-axis.
   *                                   - [0, 1, 0] rotates around the y-axis.
   *                                   - [0, 0, 1] rotates around the z-axis.   *
   * @chainable
   * inspired by Toji's gl-matrix lib, mat4 rotation
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.rotate4x4(Math.PI, [1,0,0]);
   *   console.log("After rotation of PI degrees on vector [1,0,0]:", matrix.matrix.slice().toString()); // [1,0,0,0,0,-1,1.2246468525851679e-16,0,0,-1.2246468525851679e-16,-1,0,0,0,0,1]
   * }
   * </code></div>
   */ rotate4x4(a, x, y, z) {
        if (x instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"]) {
            // x is a vector, extract the components from it.
            y = x.y;
            z = x.z;
            x = x.x; //must be last
        } else if (x instanceof Array) {
            // x is an array, extract the components from it.
            y = x[1];
            z = x[2];
            x = x[0]; //must be last
        }
        const len = Math.sqrt(x * x + y * y + z * z);
        x *= 1 / len;
        y *= 1 / len;
        z *= 1 / len;
        const a00 = this.matrix[0];
        const a01 = this.matrix[1];
        const a02 = this.matrix[2];
        const a03 = this.matrix[3];
        const a10 = this.matrix[4];
        const a11 = this.matrix[5];
        const a12 = this.matrix[6];
        const a13 = this.matrix[7];
        const a20 = this.matrix[8];
        const a21 = this.matrix[9];
        const a22 = this.matrix[10];
        const a23 = this.matrix[11];
        //sin,cos, and tan of respective angle
        const sA = Math.sin(a);
        const cA = Math.cos(a);
        const tA = 1 - cA;
        // Construct the elements of the rotation matrix
        const b00 = x * x * tA + cA;
        const b01 = y * x * tA + z * sA;
        const b02 = z * x * tA - y * sA;
        const b10 = x * y * tA - z * sA;
        const b11 = y * y * tA + cA;
        const b12 = z * y * tA + x * sA;
        const b20 = x * z * tA + y * sA;
        const b21 = y * z * tA - x * sA;
        const b22 = z * z * tA + cA;
        // rotation-specific matrix multiplication
        this.matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
        this.matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
        this.matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
        this.matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
        this.matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
        this.matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
        this.matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
        this.matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
        this.matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
        this.matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
        this.matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
        this.matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return this;
    }
    /**
   * Translates the current matrix by a given vector.
   *
   * This method applies a translation transformation to the current matrix.
   * Translation moves the matrix by a specified amount along the x, y, and z axes.
   * The input vector can be a 2D or 3D vector. If the z-component is not provided,
   * it defaults to 0, meaning no translation along the z-axis.
   *
   * @param {Number[]} v - A vector representing the translation. It should be an array
   *                       with two or three elements: [x, y, z]. The z-component is optional.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Translating a matrix by a 3D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.translate([10, 20, 30]); // Translate by 10 units along x, 20 along y, and 30 along z
   * console.log(matrix.matrix);
   *
   * // Translating a matrix by a 2D vector
   * matrix.translate([5, 15]); // Translate by 5 units along x and 15 along y
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.translate([10, 20, 30]);
   *   console.log("After 3D Translation (10, 20, 30):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,10,20,30,1]
   *
   *   // Translate the matrix by a 2D vector
   *   matrix.translate([5, 15]);
   *   console.log("After 2D Translation (5, 15):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,15,35,30,1]
   * }
   * </code></div>
   */ translate(v) {
        const x = v[0], y = v[1], z = v[2] || 0;
        this.matrix[12] += this.matrix[0] * x + this.matrix[4] * y + this.matrix[8] * z;
        this.matrix[13] += this.matrix[1] * x + this.matrix[5] * y + this.matrix[9] * z;
        this.matrix[14] += this.matrix[2] * x + this.matrix[6] * y + this.matrix[10] * z;
        this.matrix[15] += this.matrix[3] * x + this.matrix[7] * y + this.matrix[11] * z;
        return this;
    }
    /**
   * Rotates the matrix around the X-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the X-axis. The rotation angle is specified in radians.
   *
   * Rotating around the X-axis means that the Y and Z coordinates of the matrix
   * are transformed while the X coordinates remain unchanged. This is commonly
   * used in 3D graphics to create animations or transformations along the X-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by.
   *
   * @example
   * // Rotating a matrix around the X-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateX(Math.PI / 4); // Rotate 45 degrees around the X-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the X-axis
   *   matrix.rotateX(Math.PI / 4);
   *   console.log("After Rotation (X-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */ rotateX(a) {
        this.rotate4x4(a, 1, 0, 0);
    }
    /**
   * Rotates the matrix around the Y-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Y-axis. The rotation is performed in 3D space, and the angle
   * is specified in radians. Rotating around the Y-axis means that the X and Z
   * coordinates of the matrix are transformed while the Y coordinates remain
   * unchanged. This is commonly used in 3D graphics to create animations or
   * transformations along the Y-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @example
   * // Rotating a matrix around the Y-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Y-axis
   *   matrix.rotateY(Math.PI / 4);
   *   console.log("After Rotation (Y-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */ rotateY(a) {
        this.rotate4x4(a, 0, 1, 0);
    }
    /**
   * Rotates the matrix around the Z-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Z-axis. The rotation is performed in a 4x4 matrix context, which
   * is commonly used in 3D graphics to handle transformations. Rotating around
   * the Z-axis means that the X and Y coordinates of the matrix are transformed
   * while the Z coordinates remain unchanged.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Rotating a matrix around the Z-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateZ(Math.PI / 4); // Rotate 45 degrees around the Z-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Z-axis
   *   matrix.rotateZ(Math.PI / 4);
   *   console.log("After Rotation (Z-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */ rotateZ(a) {
        this.rotate4x4(a, 0, 0, 1);
    }
    /**
   * Sets the perspective projection matrix.
   *
   * This method modifies the current matrix to represent a perspective projection.
   * Perspective projection is commonly used in 3D graphics to simulate the effect
   * of objects appearing smaller as they move further away from the camera.
   *
   * The perspective matrix is defined by the field of view (fovy), aspect ratio,
   * and the near and far clipping planes. The near and far clipping planes define
   * the range of depth that will be rendered, with anything outside this range
   * being clipped.
   *
   * @param {Number} fovy - The field of view in the y direction, in radians.
   * @param {Number} aspect - The aspect ratio of the viewport (width / height).
   * @param {Number} near - The distance to the near clipping plane. Must be greater than 0.
   * @param {Number} far - The distance to the far clipping plane. Must be greater than the near value.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Setting a perspective projection matrix
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.perspective(Math.PI / 4, 1.5, 0.1, 100); // Set perspective projection
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Set a perspective projection with a 45-degree field of view,
   *   // an aspect ratio of 1.5, and near/far clipping planes at 0.1 and 100.
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Perspective Matrix:", matrix.matrix);
   * }
   * </code></div>
   */ perspective(fovy, aspect, near, far) {
        const f = 1.0 / Math.tan(fovy / 2), nf = 1 / (near - far);
        this.matrix[0] = f / aspect;
        this.matrix[1] = 0;
        this.matrix[2] = 0;
        this.matrix[3] = 0;
        this.matrix[4] = 0;
        this.matrix[5] = f;
        this.matrix[6] = 0;
        this.matrix[7] = 0;
        this.matrix[8] = 0;
        this.matrix[9] = 0;
        this.matrix[10] = (far + near) * nf;
        this.matrix[11] = -1;
        this.matrix[12] = 0;
        this.matrix[13] = 0;
        this.matrix[14] = 2 * far * near * nf;
        this.matrix[15] = 0;
        return this;
    }
    /**
   * Sets this matrix to an orthographic projection matrix.
   *
   * An orthographic projection matrix is used to create a 2D rendering
   * of a 3D scene by projecting points onto a plane without perspective
   * distortion. This method modifies the current matrix to represent
   * the orthographic projection defined by the given parameters.
   *
   * @param {number} left - The coordinate for the left vertical clipping plane.
   * @param {number} right - The coordinate for the right vertical clipping plane.
   * @param {number} bottom - The coordinate for the bottom horizontal clipping plane.
   * @param {number} top - The coordinate for the top horizontal clipping plane.
   * @param {number} near - The distance to the near depth clipping plane. Must be positive.
   * @param {number} far - The distance to the far depth clipping plane. Must be positive.
   * @chainable
   * @returns {Matrix} The current matrix instance, updated with the orthographic projection.
   *
   * @example
   * <div class="norender"><code>
   * // Example using p5.js to demonstrate orthographic projection
   * function setup() {
   *  let orthoMatrix = new p5.Matrix(4);
   *  console.log(orthoMatrix.matrix.toString()) // Output: 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1
   *  orthoMatrix.ortho(-200, 200, -200, 200, 0.1, 1000);
   *  console.log(orthoMatrix.matrix.toString()) // Output: [24 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *  applyMatrix(
   *     orthoMatrix.mat4[0], orthoMatrix.mat4[1], orthoMatrix.mat4[2], orthoMatrix.mat4[3],
   *     orthoMatrix.mat4[4], orthoMatrix.mat4[5], orthoMatrix.mat4[6], orthoMatrix.mat4[7],
   *     orthoMatrix.mat4[8], orthoMatrix.mat4[9], orthoMatrix.mat4[10], orthoMatrix.mat4[11],
   *     orthoMatrix.mat4[12], orthoMatrix.mat4[13], orthoMatrix.mat4[14], orthoMatrix.mat4[15]
   *  );
   *  console.log(orthoMatrix.matrix.toString()) // Output: [31 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *   }
   * </code></div>
   *
   */ ortho(left, right, bottom, top, near, far) {
        const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
        this.matrix[0] = -2 * lr;
        this.matrix[1] = 0;
        this.matrix[2] = 0;
        this.matrix[3] = 0;
        this.matrix[4] = 0;
        this.matrix[5] = -2 * bt;
        this.matrix[6] = 0;
        this.matrix[7] = 0;
        this.matrix[8] = 0;
        this.matrix[9] = 0;
        this.matrix[10] = 2 * nf;
        this.matrix[11] = 0;
        this.matrix[12] = (left + right) * lr;
        this.matrix[13] = (top + bottom) * bt;
        this.matrix[14] = (far + near) * nf;
        this.matrix[15] = 1;
        return this;
    }
    /**
   * Applies a matrix to a vector with x, y, z, w components and returns the result as an array.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, w) and computes the resulting vector.
   * It is commonly used in 3D graphics for transformations such as translation, rotation, scaling, and perspective projection.
   *
   * The resulting vector is returned as an array of four numbers, representing the transformed x, y, z, and w components.
   *
   * @param {Number} x - The x component of the vector.
   * @param {Number} y - The y component of the vector.
   * @param {Number} z - The z component of the vector.
   * @param {Number} w - The w component of the vector.
   * @returns {Number[]} An array containing the transformed [x, y, z, w] components.
   *
   * @example
   * // Applying a matrix to a 4D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const result = matrix.multiplyVec4(1, 2, 3, 1); // Transform the vector [1, 2, 3, 1]
   * console.log(result); // Output: [1, 2, 3, 1] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Apply the matrix to a 4D vector
   *   const result = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector:", result); // Output: [1, 2, 3, 1]
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same vector
   *   const transformedResult = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector after Translation:", transformedResult); // Output: [6, 7, 8, 1]
   * }
   * </code></div>
   */ multiplyVec4(x, y, z, w) {
        const result = new Array(4);
        const m = this.matrix;
        result[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
        result[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
        result[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
        result[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
        return result;
    }
    /**
   * Applies a matrix to a vector. The fourth component is set to 1.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance.
   *
   * This is useful for applying transformations such as translation,
   * rotation, scaling, or perspective projection to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed point.
   *
   * @example
   * // Applying a matrix to a 3D point
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyPoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point
   *   const transformedPoint = matrix.multiplyPoint(point);
   *   console.log("Transformed Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const translatedPoint = matrix.multiplyPoint(point);
   *   console.log("Translated Point:", translatedPoint.toString()); // Output: [6, 7, 8]
   * }
   * </code></div>
   */ multiplyPoint({ x, y, z }) {
        const array = this.multiplyVec4(x, y, z, 1);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](array[0], array[1], array[2]);
    }
    /**
   * Applies a matrix to a vector.
   * The fourth component is set to 1.
   * Returns the result of dividing the 1st to 3rd components
   * of the result by the 4th component as a vector.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is normalized by dividing its x, y, and z components by the w component.
   * This is useful for applying transformations such as perspective projection
   * to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed and normalized point.
   *
   * @example
   * // Applying a matrix to a 3D point and normalizing it
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point and normalize it
   *   const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Transformed and Normalized Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a perspective transformation)
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Modified Matrix (Perspective):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const perspectivePoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Point after Perspective Transformation:", perspectivePoint.toString());
   * }
   * </code></div>
   */ multiplyAndNormalizePoint({ x, y, z }) {
        const array = this.multiplyVec4(x, y, z, 1);
        array[0] /= array[3];
        array[1] /= array[3];
        array[2] /= array[3];
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](array[0], array[1], array[2]);
    }
    /**
   * Applies a matrix to a vector.
   * The fourth component is set to 0.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 0),
   * effectively transforming the direction vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance. This is particularly useful
   * for transforming direction vectors (e.g., normals) without applying translation.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed direction.
   *
   * @example
   * // Applying a matrix to a direction vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const direction = new p5.Vector(1, 0, 0); // Define a direction vector
   * const transformedDirection = matrix.multiplyDirection(direction);
   * console.log(transformedDirection.toString()); // Output: [1, 0, 0] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a direction vector
   *   const direction = new p5.Vector(1, 0, 0);
   *   console.log("Original Direction:", direction.toString());
   *
   *   // Apply the matrix to the direction vector
   *   const transformedDirection = matrix.multiplyDirection(direction);
   *   console.log("Transformed Direction:", transformedDirection.toString());
   *
   *   // Modify the matrix (e.g., apply a rotation)
   *   matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   *   console.log("Modified Matrix (Rotation):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same direction vector
   *   const rotatedDirection = matrix.multiplyDirection(direction);
   *   console.log("Rotated Direction:", rotatedDirection.toString()); // Output: Rotated vector
   * }
   * </code></div>
   */ multiplyDirection({ x, y, z }) {
        const array = this.multiplyVec4(x, y, z, 0);
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Vector"](array[0], array[1], array[2]);
    }
    /**
   * Takes a vector and returns the vector resulting from multiplying. This function is only for 3x3 matrices.
   * that vector by this matrix from the left.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * This is useful for operations such as transforming points or directions
   * in 2D or 3D space using a 3x3 transformation matrix.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec3(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   // Create a 3x3 matrix
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a vector
   *   const vector = new p5.Vector(1, 2, 3);
   *   console.log("Original Vector:", vector.toString()); // Output: [1, 2, 3]
   *
   *   // Apply the matrix to the vector
   *   const transformedVector = matrix.multiplyVec3(vector);
   *   console.log("Transformed Vector:", transformedVector.toString()); // Output: [30, 36, 42]
   *
   *   // Modify the matrix (e.g., apply a scaling transformation)
   *   matrix.scale(2, 2, 2);
   *   console.log("Modified Matrix (Scaling):", matrix.matrix); // Output: [2, 4, 6, 8, 10, 12, 14, 16, 18]
   *
   *   // Apply the modified matrix to the same vector
   *   const scaledVector = matrix.multiplyVec3(vector);
   *   console.log("Scaled Vector:", scaledVector.toString()); // Output: [60, 72, 84]
   * }
   * </code></div>
   */ multiplyVec3(multVector, target) {
        if (target === undefined) {
            target = multVector.copy();
        }
        target.x = this.row(0).dot(multVector);
        target.y = this.row(1).dot(multVector);
        target.z = this.row(2).dot(multVector);
        return target;
    }
    // ====================
    // PRIVATE
    /**
   * Creates identity matrix
   * This method updates the current matrix with the result of the multiplication.
   *
   * @private
   */ #createIdentityMatrix(dimension) {
        // This it to prevent loops in the most common 3x3 and 4x4 cases
        // TODO: check performance if it actually helps
        if (dimension === 3) return new GLMAT_ARRAY_TYPE([
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
        ]);
        if (dimension === 4) return new GLMAT_ARRAY_TYPE([
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ]);
        const identityMatrix = new GLMAT_ARRAY_TYPE(dimension * dimension).fill(0);
        for(let i = 0; i < dimension; i++){
            identityMatrix[i * dimension + i] = 1;
        }
        return identityMatrix;
    }
    /**
   * Multiplies the current 4x4 matrix with another 4x4 matrix.
   * This method updates the current matrix with the result of the multiplication.
   *
   * @private
   * @param {number[]} _src - A 16-element array representing the 4x4 matrix to multiply with.
   *
   * @returns {this} The current instance with the updated matrix.
   *
   * @example
   * // Assuming `matrix` is an instance of the Matrix class
   * const srcMatrix = [
   *   1, 0, 0, 0,
   *   0, 1, 0, 0,
   *   0, 0, 1, 0,
   *   0, 0, 0, 1
   * ];
   * matrix.#mult4x4(srcMatrix);
   */ #mult4x4(_src) {
        // each row is used for the multiplier
        let b0 = this.matrix[0], b1 = this.matrix[1], b2 = this.matrix[2], b3 = this.matrix[3];
        this.matrix[0] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
        this.matrix[1] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
        this.matrix[2] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
        this.matrix[3] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
        b0 = this.matrix[4];
        b1 = this.matrix[5];
        b2 = this.matrix[6];
        b3 = this.matrix[7];
        this.matrix[4] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
        this.matrix[5] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
        this.matrix[6] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
        this.matrix[7] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
        b0 = this.matrix[8];
        b1 = this.matrix[9];
        b2 = this.matrix[10];
        b3 = this.matrix[11];
        this.matrix[8] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
        this.matrix[9] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
        this.matrix[10] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
        this.matrix[11] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
        b0 = this.matrix[12];
        b1 = this.matrix[13];
        b2 = this.matrix[14];
        b3 = this.matrix[15];
        this.matrix[12] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
        this.matrix[13] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
        this.matrix[14] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
        this.matrix[15] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
        return this;
    }
    /**
   * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
   *                                                we want to multiply by
   * @private
   * @chainable
   */ #multNxN(multMatrix) {
        if (multMatrix.length !== this.matrix.length) {
            throw new Error('Matrices must be of the same dimension to multiply.');
        }
        const result = new GLMAT_ARRAY_TYPE(this.matrix.length).fill(0);
        for(let i = 0; i < this.#sqDimention; i++){
            for(let j = 0; j < this.#sqDimention; j++){
                for(let k = 0; k < this.#sqDimention; k++){
                    result[i * this.#sqDimention + j] += this.matrix[i * this.#sqDimention + k] * multMatrix[k * this.#sqDimention + j];
                }
            }
        }
        this.matrix = result;
        return this;
    }
    /**
   * This function is only for 3x3 matrices.
   * multiply two mat3s. It is an operation to multiply the 3x3 matrix of
   * the argument from the right. Arguments can be a 3x3 p5.Matrix,
   * a Float32Array of length 9, or a javascript array of length 9.
   * In addition, it can also be done by enumerating 9 numbers.
   *
   * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
   *                                                we want to multiply by
   * @private
   * @chainable
   */ #mult3x3(_src) {
        // each row is used for the multiplier
        let b0 = this.mat3[0];
        let b1 = this.mat3[1];
        let b2 = this.mat3[2];
        this.mat3[0] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
        this.mat3[1] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
        this.mat3[2] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
        b0 = this.mat3[3];
        b1 = this.mat3[4];
        b2 = this.mat3[5];
        this.mat3[3] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
        this.mat3[4] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
        this.mat3[5] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
        b0 = this.mat3[6];
        b1 = this.mat3[7];
        b2 = this.mat3[8];
        this.mat3[6] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
        this.mat3[7] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
        this.mat3[8] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
        return this;
    }
    /**
   * Transposes a square matrix in place.
   * This method swaps the rows and columns of the matrix, effectively flipping it over its diagonal.
   *
   * @private
   * @returns {Matrix} The current instance of the Matrix, with the transposed values.
   */ #transposeNxN() {
        const n = this.#sqDimention;
        for(let i = 0; i < n; i++){
            for(let j = 0; j < n; j++){
                this.matrix[i * n + j] = this.matrix[j * n + i];
            }
        }
        return this;
    }
    /**
   * transpose according to a given matrix
   * @param  {p5.Matrix|Float32Array|Number[]} a  the matrix to be
   *                                               based on to transpose
   * @private
   * @chainable
   */ #transpose4x4(a) {
        console.log('====> 4x4');
        let a01, a02, a03, a12, a13, a23;
        if (a instanceof Matrix) {
            a01 = a.matrix[1];
            a02 = a.matrix[2];
            a03 = a.matrix[3];
            a12 = a.matrix[6];
            a13 = a.matrix[7];
            a23 = a.matrix[11];
            this.matrix[0] = a.matrix[0];
            this.matrix[1] = a.matrix[4];
            this.matrix[2] = a.matrix[8];
            this.matrix[3] = a.matrix[12];
            this.matrix[4] = a01;
            this.matrix[5] = a.matrix[5];
            this.matrix[6] = a.matrix[9];
            this.matrix[7] = a.matrix[13];
            this.matrix[8] = a02;
            this.matrix[9] = a12;
            this.matrix[10] = a.matrix[10];
            this.matrix[11] = a.matrix[14];
            this.matrix[12] = a03;
            this.matrix[13] = a13;
            this.matrix[14] = a23;
            this.matrix[15] = a.matrix[15];
        } else if (isMatrixArray(a)) {
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a12 = a[6];
            a13 = a[7];
            a23 = a[11];
            this.matrix[0] = a[0];
            this.matrix[1] = a[4];
            this.matrix[2] = a[8];
            this.matrix[3] = a[12];
            this.matrix[4] = a01;
            this.matrix[5] = a[5];
            this.matrix[6] = a[9];
            this.matrix[7] = a[13];
            this.matrix[8] = a02;
            this.matrix[9] = a12;
            this.matrix[10] = a[10];
            this.matrix[11] = a[14];
            this.matrix[12] = a03;
            this.matrix[13] = a13;
            this.matrix[14] = a23;
            this.matrix[15] = a[15];
        }
        return this;
    }
    /**
   * This function is only for 3x3 matrices.
   * transposes a 3×3 p5.Matrix by a mat3
   * If there is an array of arguments, the matrix obtained by transposing
   * the 3x3 matrix generated based on that array is set.
   * If no arguments, it transposes itself and returns it.
   *
   * @param  {Number[]} mat3 1-dimensional array
   * @private
   * @chainable
   */ #transpose3x3(mat3) {
        if (mat3 === undefined) {
            mat3 = this.mat3;
        }
        const a01 = mat3[1];
        const a02 = mat3[2];
        const a12 = mat3[5];
        this.mat3[0] = mat3[0];
        this.mat3[1] = mat3[3];
        this.mat3[2] = mat3[6];
        this.mat3[3] = a01;
        this.mat3[4] = mat3[4];
        this.mat3[5] = mat3[7];
        this.mat3[6] = a02;
        this.mat3[7] = a12;
        this.mat3[8] = mat3[8];
        return this;
    }
    /**
   * Only 4x4 becasuse determinant is only 4x4 currently
   * invert  matrix according to a give matrix
   * @param  {p5.Matrix|Float32Array|Number[]} a   the matrix to be
   *                                                based on to invert
   * @private
   * @chainable
   */ #invert4x4(a) {
        let a00, a01, a02, a03, a10, a11, a12, a13;
        let a20, a21, a22, a23, a30, a31, a32, a33;
        if (a instanceof Matrix) {
            a00 = a.matrix[0];
            a01 = a.matrix[1];
            a02 = a.matrix[2];
            a03 = a.matrix[3];
            a10 = a.matrix[4];
            a11 = a.matrix[5];
            a12 = a.matrix[6];
            a13 = a.matrix[7];
            a20 = a.matrix[8];
            a21 = a.matrix[9];
            a22 = a.matrix[10];
            a23 = a.matrix[11];
            a30 = a.matrix[12];
            a31 = a.matrix[13];
            a32 = a.matrix[14];
            a33 = a.matrix[15];
        } else if (isMatrixArray(a)) {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            a30 = a[12];
            a31 = a[13];
            a32 = a[14];
            a33 = a[15];
        }
        const b00 = a00 * a11 - a01 * a10;
        const b01 = a00 * a12 - a02 * a10;
        const b02 = a00 * a13 - a03 * a10;
        const b03 = a01 * a12 - a02 * a11;
        const b04 = a01 * a13 - a03 * a11;
        const b05 = a02 * a13 - a03 * a12;
        const b06 = a20 * a31 - a21 * a30;
        const b07 = a20 * a32 - a22 * a30;
        const b08 = a20 * a33 - a23 * a30;
        const b09 = a21 * a32 - a22 * a31;
        const b10 = a21 * a33 - a23 * a31;
        const b11 = a22 * a33 - a23 * a32;
        // Calculate the determinant
        let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        this.matrix[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
        this.matrix[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
        this.matrix[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
        this.matrix[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
        this.matrix[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
        this.matrix[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
        this.matrix[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
        this.matrix[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
        this.matrix[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
        this.matrix[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
        this.matrix[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
        this.matrix[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
        this.matrix[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
        this.matrix[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
        this.matrix[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
        this.matrix[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        return this;
    }
    /**
   * Inverts a 3×3 matrix
   * @chainable
   * @private
   */ #invert3x3() {
        const a00 = this.mat3[0];
        const a01 = this.mat3[1];
        const a02 = this.mat3[2];
        const a10 = this.mat3[3];
        const a11 = this.mat3[4];
        const a12 = this.mat3[5];
        const a20 = this.mat3[6];
        const a21 = this.mat3[7];
        const a22 = this.mat3[8];
        const b01 = a22 * a11 - a12 * a21;
        const b11 = -a22 * a10 + a12 * a20;
        const b21 = a21 * a10 - a11 * a20;
        // Calculate the determinant
        let det = a00 * b01 + a01 * b11 + a02 * b21;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        this.mat3[0] = b01 * det;
        this.mat3[1] = (-a22 * a01 + a02 * a21) * det;
        this.mat3[2] = (a12 * a01 - a02 * a11) * det;
        this.mat3[3] = b11 * det;
        this.mat3[4] = (a22 * a00 - a02 * a20) * det;
        this.mat3[5] = (-a12 * a00 + a02 * a10) * det;
        this.mat3[6] = b21 * det;
        this.mat3[7] = (-a21 * a00 + a01 * a20) * det;
        this.mat3[8] = (a11 * a00 - a01 * a10) * det;
        return this;
    }
    /**
   * inspired by Toji's mat4 determinant
   * @return {Number} Determinant of our 4×4 matrix
   * @private
   */ #determinant4x4() {
        if (this.#sqDimention !== 4) {
            throw new Error('Determinant is only implemented for 4x4 matrices. We are working on it.');
        }
        const d00 = this.matrix[0] * this.matrix[5] - this.matrix[1] * this.matrix[4], d01 = this.matrix[0] * this.matrix[6] - this.matrix[2] * this.matrix[4], d02 = this.matrix[0] * this.matrix[7] - this.matrix[3] * this.matrix[4], d03 = this.matrix[1] * this.matrix[6] - this.matrix[2] * this.matrix[5], d04 = this.matrix[1] * this.matrix[7] - this.matrix[3] * this.matrix[5], d05 = this.matrix[2] * this.matrix[7] - this.matrix[3] * this.matrix[6], d06 = this.matrix[8] * this.matrix[13] - this.matrix[9] * this.matrix[12], d07 = this.matrix[8] * this.matrix[14] - this.matrix[10] * this.matrix[12], d08 = this.matrix[8] * this.matrix[15] - this.matrix[11] * this.matrix[12], d09 = this.matrix[9] * this.matrix[14] - this.matrix[10] * this.matrix[13], d10 = this.matrix[9] * this.matrix[15] - this.matrix[11] * this.matrix[13], d11 = this.matrix[10] * this.matrix[15] - this.matrix[11] * this.matrix[14];
        // Calculate the determinant
        return d00 * d11 - d01 * d10 + d02 * d09 + d03 * d08 - d04 * d07 + d05 * d06;
    }
}
;
}),
"[project]/node_modules/p5/dist/math/p5.Matrix.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>matrix
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/Matrix.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$MatrixInterface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/Matrices/MatrixInterface.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @module Math
 * @requires constants
 * @todo see methods below needing further implementation.
 * future consideration: implement SIMD optimizations
 * when browser compatibility becomes available
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/
 *   Reference/Global_Objects/SIMD
 */ // import { MatrixNumjs as Matrix } from './Matrices/MatrixNumjs'
function matrix(p51, fn) {
    /**
   * A class to describe a matrix
   * for model and view matrix manipulation in the p5js webgl renderer.
   * The `Matrix` class represents a mathematical matrix and provides various methods for matrix operations.
   *
   * The `Matrix` class represents a mathematical matrix and provides various methods for matrix operations.
   * This class extends the `MatrixInterface` and includes methods for creating, manipulating, and performing
   * operations on matrices. It supports both 3x3 and 4x4 matrices, as well as general NxN matrices.
   * @private
   * @class p5.Matrix
   * @param {Array} [mat4] column-major array literal of our 4×4 matrix
   * @example
   * // Creating a 3x3 matrix from an array using column major arrangement
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *
   * // Creating a 4x4 identity matrix
   * const identityMatrix = new p5.Matrix(4);
   *
   * // Adding two matrices
   * const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   * matrix1.add(matrix2); // matrix1 is now [10, 10, 10, 10, 10, 10, 10, 10, 10]
   *
   * // Setting an element in the matrix
   * matrix.setElement(0, 10); // matrix is now [10, 2, 3, 4, 5, 6, 7, 8, 9]
   *
   * // Resetting the matrix to an identity matrix
   * matrix.reset();
   *
   * // Getting the diagonal elements of the matrix
   * const diagonal = matrix.diagonal(); // [1, 1, 1]
   *
   * // Transposing the matrix
   * matrix.transpose();
   *
   * // Multiplying two matrices
   * matrix1.mult(matrix2);
   *
   * // Inverting the matrix
   * matrix.invert();
   *
   * // Scaling the matrix
   * matrix.scale(2, 2, 2);
   *
   * // Rotating the matrix around an axis
   * matrix.rotate4x4(Math.PI / 4, 1, 0, 0);
   *
   * // Applying a perspective transformation
   * matrix.perspective(Math.PI / 4, 1, 0.1, 100);
   *
   * // Applying an orthographic transformation
   * matrix.ortho(-1, 1, -1, 1, 0.1, 100);
   *
   * // Multiplying a vector by the matrix
   * const vector = new Vector(1, 2, 3);
   * const result = matrix.multiplyPoint(vector);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   // Create a 4x4 identity matrix
   *   const matrix = new p5.Matrix(4);
   *   console.log("Original p5.Matrix:", matrix.matrix.toString()); // Output: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
   *
   *   // Add two matrices
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   *   matrix1.add(matrix2);
   *   console.log("After Addition:", matrix1.matrix.toString()); // Output: [10, 10, 10, 10, 10, 10, 10, 10, 10]
   *
   *   // Reset the matrix to an identity matrix
   *   matrix.reset();
   *   console.log("Reset p5.Matrix:", matrix.matrix.toString()); // [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
   *
   *   // Apply a scaling transformation
   *   matrix.scale(2, 2, 2);
   *   console.log("Scaled p5.Matrix:", matrix.matrix.toString()); // [2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1]
   *
   *   // Apply a rotation around the X-axis
   *   matrix.rotate4x4(Math.PI / 4, 1, 0, 0);
   *   console.log("Rotated p5.Matrix (X-axis):", matrix.matrix.toString()); // [2, 0, 0, 0, 0, 1.4142135381698608, 1.4142135381698608, 0, 0, -1.4142135381698608, 1.4142135381698608, 0, 0, 0, 0, 1]
   *
   *   // Apply a perspective transformation
   *   matrix.perspective(Math.PI / 4, 1, 0.1, 100);
   *   console.log("Perspective p5.Matrix:", matrix.matrix.toString());// [2.4142136573791504, 0, 0, 0, 0, 2.4142136573791504, 0, 0, 0, 0, -1.0020020008087158, -1, 0, 0, -0.20020020008087158, 0]
   *
   *   // Multiply a vector by the matrix
   *   const vector = new p5.Vector(1, 2, 3);
   *   const transformedVector = matrix.multiplyPoint(vector);
   *   console.log("Transformed Vector:", transformedVector.toString());
   * }
   * </code></div>
   */ p51.Matrix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$Matrices$2f$Matrix$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Matrix"];
}
if (typeof p5 !== 'undefined') {
    matrix(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/trigonometry.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>trigonometry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-client] (ecmascript)");
;
/**
 * @module Math
 * @submodule Trigonometry
 * @for p5
 * @requires core
 * @requires constants
 */ function trigonometry(p51, fn) {
    /**
   * A `String` constant that's used to set the
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * By default, functions such as <a href="#/p5/rotate">rotate()</a> and
   * <a href="#/p5/sin">sin()</a> expect angles measured in units of radians.
   * Calling `angleMode(DEGREES)` ensures that angles are measured in units of
   * degrees.
   *
   * Note: `TWO_PI` radians equals 360˚.
   *
   * @typedef {'degrees'} DEGREES
   * @property {DEGREES} DEGREES
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw a red arc from 0 to HALF_PI radians.
   *   fill(255, 0, 0);
   *   arc(50, 50, 80, 80, 0, HALF_PI);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Draw a blue arc from 90˚ to 180˚.
   *   fill(0, 0, 255);
   *   arc(50, 50, 80, 80, 90, 180);
   *
   *   describe('The bottom half of a circle drawn on a gray background. The bottom-right quarter is red. The bottom-left quarter is blue.');
   * }
   * </code>
   * </div>
   */ const DEGREES = fn.DEGREES = 'degrees';
    /**
   * A `String` constant that's used to set the
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * By default, functions such as <a href="#/p5/rotate">rotate()</a> and
   * <a href="#/p5/sin">sin()</a> expect angles measured in units of radians.
   * Calling `angleMode(RADIANS)` ensures that angles are measured in units of
   * radians. Doing so can be useful if the
   * <a href="#/p5/angleMode">angleMode()</a> has been set to
   * <a href="#/p5/DEGREES">DEGREES</a>.
   *
   * Note: `TWO_PI` radians equals 360˚.
   *
   * @typedef {'radians'} RADIANS
   * @property {RADIANS} RADIANS
   * @final
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Draw a red arc from 0˚ to 90˚.
   *   fill(255, 0, 0);
   *   arc(50, 50, 80, 80, 0, 90);
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Draw a blue arc from HALF_PI to PI.
   *   fill(0, 0, 255);
   *   arc(50, 50, 80, 80, HALF_PI, PI);
   *
   *   describe('The bottom half of a circle drawn on a gray background. The bottom-right quarter is red. The bottom-left quarter is blue.');
   * }
   * </code>
   * </div>
   */ const RADIANS = fn.RADIANS = 'radians';
    /*
   * all DEGREES/RADIANS conversion should be done in the p5 instance
   * if possible, using the p5._toRadians(), p5._fromRadians() methods.
   */ fn._angleMode = RADIANS;
    /**
   * Calculates the arc cosine of a number.
   *
   * `acos()` is the inverse of <a href="#/p5/cos">cos()</a>. It expects
   * arguments in the range -1 to 1. By default, `acos()` returns values in the
   * range 0 to &pi; (about 3.14). If the
   * <a href="#/p5/angleMode">angleMode()</a> is `DEGREES`, then values are
   * returned in the range 0 to 180.
   *
   * @method acos
   * @param  {Number} value value whose arc cosine is to be returned.
   * @return {Number}       arc cosine of the given value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate cos() and acos() values.
   *   let a = PI;
   *   let c = cos(a);
   *   let ac = acos(c);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(c, 3)}`, 35, 50);
   *   text(`${round(ac, 3)}`, 35, 75);
   *
   *   describe('The numbers 3.142, -1, and 3.142 written on separate rows.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate cos() and acos() values.
   *   let a = PI + QUARTER_PI;
   *   let c = cos(a);
   *   let ac = acos(c);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(c, 3)}`, 35, 50);
   *   text(`${round(ac, 3)}`, 35, 75);
   *
   *   describe('The numbers 3.927, -0.707, and 2.356 written on separate rows.');
   * }
   * </code>
   * </div>
   */ fn.acos = function(ratio) {
        return this._fromRadians(Math.acos(ratio));
    };
    /**
   * Calculates the arc sine of a number.
   *
   * `asin()` is the inverse of <a href="#/p5/sin">sin()</a>. It expects input
   * values in the range of -1 to 1. By default, `asin()` returns values in the
   * range -&pi; &divide; 2 (about -1.57) to &pi; &divide; 2 (about 1.57). If
   * the <a href="#/p5/angleMode">angleMode()</a> is `DEGREES` then values are
   * returned in the range -90 to 90.
   *
   * @method asin
   * @param  {Number} value value whose arc sine is to be returned.
   * @return {Number}       arc sine of the given value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate sin() and asin() values.
   *   let a = PI / 3;
   *   let s = sin(a);
   *   let as = asin(s);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(s, 3)}`, 35, 50);
   *   text(`${round(as, 3)}`, 35, 75);
   *
   *   describe('The numbers 1.047, 0.866, and 1.047 written on separate rows.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate sin() and asin() values.
   *   let a = PI + PI / 3;
   *   let s = sin(a);
   *   let as = asin(s);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(s, 3)}`, 35, 50);
   *   text(`${round(as, 3)}`, 35, 75);
   *
   *   describe('The numbers 4.189, -0.866, and -1.047 written on separate rows.');
   * }
   * </code>
   * </div>
   */ fn.asin = function(ratio) {
        return this._fromRadians(Math.asin(ratio));
    };
    /**
   * Calculates the arc tangent of a number.
   *
   * `atan()` is the inverse of <a href="#/p5/tan">tan()</a>. It expects input
   * values in the range of -Infinity to Infinity. By default, `atan()` returns
   * values in the range -&pi; &divide; 2 (about -1.57) to &pi; &divide; 2
   * (about 1.57). If the <a href="#/p5/angleMode">angleMode()</a> is `DEGREES`
   * then values are returned in the range -90 to 90.
   *
   * @method atan
   * @param  {Number} value value whose arc tangent is to be returned.
   * @return {Number}       arc tangent of the given value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate tan() and atan() values.
   *   let a = PI / 3;
   *   let t = tan(a);
   *   let at = atan(t);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(t, 3)}`, 35, 50);
   *   text(`${round(at, 3)}`, 35, 75);
   *
   *   describe('The numbers 1.047, 1.732, and 1.047 written on separate rows.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate tan() and atan() values.
   *   let a = PI + PI / 3;
   *   let t = tan(a);
   *   let at = atan(t);
   *
   *   // Display the values.
   *   text(`${round(a, 3)}`, 35, 25);
   *   text(`${round(t, 3)}`, 35, 50);
   *   text(`${round(at, 3)}`, 35, 75);
   *
   *   describe('The numbers 4.189, 1.732, and 1.047 written on separate rows.');
   * }
   * </code>
   * </div>
   */ fn.atan = function(ratio) {
        return this._fromRadians(Math.atan(ratio));
    };
    /**
   * Calculates the angle formed by a point, the origin, and the positive
   * x-axis.
   *
   * `atan2()` is most often used for orienting geometry to the mouse's
   * position, as in `atan2(mouseY, mouseX)`. The first parameter is the point's
   * y-coordinate and the second parameter is its x-coordinate.
   *
   * By default, `atan2()` returns values in the range
   * -&pi; (about -3.14) to &pi; (3.14). If the
   * <a href="#/p5/angleMode">angleMode()</a> is `DEGREES`, then values are
   * returned in the range -180 to 180.
   *
   * @method atan2
   * @param  {Number} y y-coordinate of the point.
   * @param  {Number} x x-coordinate of the point.
   * @return {Number}   arc tangent of the given point.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A rectangle at the top-left of the canvas rotates with mouse movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the angle between the mouse
   *   // and the origin.
   *   let a = atan2(mouseY, mouseX);
   *
   *   // Rotate.
   *   rotate(a);
   *
   *   // Draw the shape.
   *   rect(0, 0, 60, 10);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A rectangle at the center of the canvas rotates with mouse movements.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin to the center.
   *   translate(50, 50);
   *
   *   // Get the mouse's coordinates relative to the origin.
   *   let x = mouseX - 50;
   *   let y = mouseY - 50;
   *
   *   // Calculate the angle between the mouse and the origin.
   *   let a = atan2(y, x);
   *
   *   // Rotate.
   *   rotate(a);
   *
   *   // Draw the shape.
   *   rect(-30, -5, 60, 10);
   * }
   * </code>
   * </div>
   */ fn.atan2 = function(y, x) {
        return this._fromRadians(Math.atan2(y, x));
    };
    /**
   * Calculates the cosine of an angle.
   *
   * `cos()` is useful for many geometric tasks in creative coding. The values
   * returned oscillate between -1 and 1 as the input angle increases. `cos()`
   * calculates the cosine of an angle, using radians by default, or according
   * to if <a href="#/p5/angleMode">angleMode()</a> setting (RADIANS or DEGREES).
   *
   * @method cos
   * @param  {Number} angle the angle, in radians by default, or according to if <a href="/reference/p5/angleMode/">angleMode()</a> setting (RADIANS or DEGREES).
   * @return {Number}       cosine of the angle.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A white ball on a string oscillates left and right.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the coordinates.
   *   let x = 30 * cos(frameCount * 0.05) + 50;
   *   let y = 50;
   *
   *   // Draw the oscillator.
   *   line(50, y, x, y);
   *   circle(x, y, 20);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots form a wave pattern.');
   * }
   *
   * function draw() {
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 30 * cos(x * 0.1) + 50;
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots form an infinity symbol.');
   * }
   *
   * function draw() {
   *   // Calculate the coordinates.
   *   let x = 30 * cos(frameCount * 0.1) + 50;
   *   let y = 10 * sin(frameCount * 0.2) + 50;
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.cos = function(angle) {
        return Math.cos(this._toRadians(angle));
    };
    /**
   * Calculates the sine of an angle.
   *
   * `sin()` is useful for many geometric tasks in creative coding. The values
   * returned oscillate between -1 and 1 as the input angle increases. `sin()`
   * calculates the sine of an angle, using radians by default, or according to
   * if <a href="#/p5/angleMode">angleMode()</a> setting (RADIANS or DEGREES).
   *
   * @method sin
   * @param  {Number} angle the angle, in radians by default, or according to if <a href="/reference/p5/angleMode/">angleMode()</a> setting (RADIANS or DEGREES).
   * @return {Number}       sine of the angle.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A white ball on a string oscillates up and down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the coordinates.
   *   let x = 50;
   *   let y = 30 * sin(frameCount * 0.05) + 50;
   *
   *   // Draw the oscillator.
   *   line(50, y, x, y);
   *   circle(x, y, 20);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots form a wave pattern.');
   * }
   *
   * function draw() {
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 30 * sin(x * 0.1) + 50;
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots form an infinity symbol.');
   * }
   *
   * function draw() {
   *   // Calculate the coordinates.
   *   let x = 30 * cos(frameCount * 0.1) + 50;
   *   let y = 10 * sin(frameCount * 0.2) + 50;
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.sin = function(angle) {
        return Math.sin(this._toRadians(angle));
    };
    /**
   * Calculates the tangent of an angle.
   *
   * `tan()` is useful for many geometric tasks in creative coding. The values
   * returned range from -Infinity to Infinity and repeat periodically as the
   * input angle increases. `tan()` calculates the tan of an angle, using radians
   * by default, or according to
   * if <a href="#/p5/angleMode">angleMode()</a> setting (RADIANS or DEGREES).
   *
   * @method tan
   * @param  {Number} angle the angle, in radians by default, or according to if <a href="/reference/p5/angleMode/">angleMode()</a> setting (RADIANS or DEGREES).
   * @return {Number}       tangent of the angle.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of identical curves drawn with black dots. Each curve starts from the top of the canvas, continues down at a slight angle, flattens out at the middle of the canvas, then continues to the bottom.');
   * }
   *
   * function draw() {
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 5 * tan(x * 0.1) + 50;
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.tan = function(angle) {
        return Math.tan(this._toRadians(angle));
    };
    /**
   * Converts an angle measured in radians to its value in degrees.
   *
   * Degrees and radians are both units for measuring angles. There are 360˚ in
   * one full rotation. A full rotation is 2 &times; &pi; (about 6.28) radians.
   *
   * The same angle can be expressed in with either unit. For example, 90° is a
   * quarter of a full rotation. The same angle is 2 &times; &pi; &divide; 4
   * (about 1.57) radians.
   *
   * @method degrees
   * @param  {Number} radians radians value to convert to degrees.
   * @return {Number}         converted angle.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate the angle conversion.
   *   let rad = QUARTER_PI;
   *   let deg = degrees(rad);
   *
   *   // Display the conversion.
   *   text(`${round(rad, 2)} rad = ${deg}˚`, 10, 50);
   *
   *   describe('The text "0.79 rad = 45˚".');
   * }
   * </code>
   * </div>
   */ fn.degrees = (angle)=>angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
    /**
   * Converts an angle measured in degrees to its value in radians.
   *
   * Degrees and radians are both units for measuring angles. There are 360˚ in
   * one full rotation. A full rotation is 2 &times; &pi; (about 6.28) radians.
   *
   * The same angle can be expressed in with either unit. For example, 90° is a
   * quarter of a full rotation. The same angle is 2 &times; &pi; &divide; 4
   * (about 1.57) radians.
   *
   * @method radians
   * @param  {Number} degrees degree value to convert to radians.
   * @return {Number}         converted angle.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Caclulate the angle conversion.
   *   let deg = 45;
   *   let rad = radians(deg);
   *
   *   // Display the angle conversion.
   *   text(`${deg}˚ = ${round(rad, 3)} rad`, 10, 50);
   *
   *   describe('The text "45˚ = 0.785 rad".');
   * }
   * </code>
   * </div>
   */ fn.radians = (angle)=>angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
    /**
   * Changes the unit system used to measure angles.
   *
   * Degrees and radians are both units for measuring angles. There are 360˚ in
   * one full rotation. A full rotation is 2 &times; &pi; (about 6.28) radians.
   *
   * Functions such as <a href="#/p5/rotate">rotate()</a> and
   * <a href="#/p5/sin">sin()</a> expect angles measured radians by default.
   * Calling `angleMode(DEGREES)` switches to degrees. Calling
   * `angleMode(RADIANS)` switches back to radians.
   *
   * Calling `angleMode()` with no arguments returns current angle mode, which
   * is either `RADIANS` or `DEGREES`.
   *
   * @method angleMode
   * @param {(RADIANS|DEGREES)} mode either RADIANS or DEGREES.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Rotate 1/8 turn.
   *   rotate(QUARTER_PI);
   *
   *   // Draw a line.
   *   line(0, 0, 80, 0);
   *
   *   describe('A diagonal line radiating from the top-left corner of a square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Rotate 1/8 turn.
   *   rotate(45);
   *
   *   // Draw a line.
   *   line(0, 0, 80, 0);
   *
   *   describe('A diagonal line radiating from the top-left corner of a square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Calculate the angle to rotate.
   *   let angle = TWO_PI / 7;
   *
   *   // Move the origin to the center.
   *   translate(50, 50);
   *
   *   // Style the flower.
   *   noStroke();
   *   fill(255, 50);
   *
   *   // Draw the flower.
   *   for (let i = 0; i < 7; i += 1) {
   *     ellipse(0, 0, 80, 20);
   *     rotate(angle);
   *   }
   *
   *   describe('A translucent white flower on a dark background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(50);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Calculate the angle to rotate.
   *   let angle = 360 / 7;
   *
   *   // Move the origin to the center.
   *   translate(50, 50);
   *
   *   // Style the flower.
   *   noStroke();
   *   fill(255, 50);
   *
   *   // Draw the flower.
   *   for (let i = 0; i < 7; i += 1) {
   *     ellipse(0, 0, 80, 20);
   *     rotate(angle);
   *   }
   *
   *   describe('A translucent white flower on a dark background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A white ball on a string oscillates left and right.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the coordinates.
   *   let x = 30 * cos(frameCount * 0.05) + 50;
   *   let y = 50;
   *
   *   // Draw the oscillator.
   *   line(50, y, x, y);
   *   circle(x, y, 20);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   describe('A white ball on a string oscillates left and right.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the coordinates.
   *   let x = 30 * cos(frameCount * 2.86) + 50;
   *   let y = 50;
   *
   *   // Draw the oscillator.
   *   line(50, y, x, y);
   *   circle(x, y, 20);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Draw the upper line.
   *   rotate(PI / 6);
   *   line(0, 0, 80, 0);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Draw the lower line.
   *   rotate(30);
   *   line(0, 0, 80, 0);
   *
   *   describe('Two diagonal lines radiating from the top-left corner of a square. The lines are oriented 30 degrees from the edges of the square and 30 degrees apart from each other.');
   * }
   * </code>
   * </div>
   */ /**
   * @method angleMode
   * @return {(RADIANS|DEGREES)} mode either RADIANS or DEGREES
   */ fn.angleMode = function(mode) {
        // p5._validateParameters('angleMode', arguments);
        if (typeof mode === 'undefined') {
            return this._angleMode;
        } else if (mode === DEGREES || mode === RADIANS) {
            const prevMode = this._angleMode;
            // No change
            if (mode === prevMode) return;
            // Otherwise adjust pRotation according to new mode
            // This is necessary for acceleration events to work properly
            if (mode === RADIANS) {
                // Change pRotation to radians
                this.pRotationX = this.pRotationX * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
                this.pRotationY = this.pRotationY * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
                this.pRotationZ = this.pRotationZ * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
            } else {
                // Change pRotation to degrees
                this.pRotationX = this.pRotationX * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
                this.pRotationY = this.pRotationY * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
                this.pRotationZ = this.pRotationZ * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
            }
            this._angleMode = mode;
        }
    };
    /**
   * converts angles from the current angleMode to RADIANS
   *
   * @method _toRadians
   * @private
   * @param {Number} angle
   * @returns {Number}
   */ fn._toRadians = function(angle) {
        if (this._angleMode === DEGREES) {
            return angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
        }
        return angle;
    };
    /**
   * converts angles from the current angleMode to DEGREES
   *
   * @method _toDegrees
   * @private
   * @param {Number} angle
   * @returns {Number}
   */ fn._toDegrees = function(angle) {
        if (this._angleMode === RADIANS) {
            return angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
        }
        return angle;
    };
    /**
   * converts angles from RADIANS into the current angleMode
   *
   * @method _fromRadians
   * @private
   * @param {Number} angle
   * @returns {Number}
   */ fn._fromRadians = function(angle) {
        if (this._angleMode === DEGREES) {
            return angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["x"];
        }
        return angle;
    };
    /**
   * converts angles from DEGREES into the current angleMode
   *
   * @method _fromDegrees
   * @private
   * @param {Number} angle
   * @returns {Number}
   */ fn._fromDegrees = function(angle) {
        if (this._angleMode === RADIANS) {
            return angle * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["D"];
        }
        return angle;
    };
}
if (typeof p5 !== 'undefined') {
    trigonometry(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/calculation.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>calculation
]);
/**
 * @module Math
 * @submodule Calculation
 * @for p5
 * @requires core
 */ function calculation(p51, fn) {
    /**
   * Calculates the absolute value of a number.
   *
   * A number's absolute value is its distance from zero on the number line.
   * -5 and 5 are both five units away from zero, so calling `abs(-5)` and
   * `abs(5)` both return 5. The absolute value of a number is always positive.
   *
   * @method abs
   * @param  {Number} n number to compute.
   * @return {Number}   absolute value of given number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A gray square with a vertical black line that divides it in half. A white rectangle gets taller when the user moves the mouse away from the line.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Divide the canvas.
   *   line(50, 0, 50, 100);
   *
   *   // Calculate the mouse's distance from the middle.
   *   let h = abs(mouseX - 50);
   *
   *   // Draw a rectangle based on the mouse's distance
   *   // from the middle.
   *   rect(0, 100 - h, 100, h);
   * }
   * </code>
   * </div>
   */ fn.abs = Math.abs;
    /**
   * Calculates the closest integer value that is greater than or equal to a
   * number.
   *
   * For example, calling `ceil(9.03)` and `ceil(9.97)` both return the value
   * 10.
   *
   * @method ceil
   * @param  {Number} n number to round up.
   * @return {Integer}   rounded up number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Use RGB color with values from 0 to 1.
   *   colorMode(RGB, 1);
   *
   *   noStroke();
   *
   *   // Draw the left rectangle.
   *   let r = 0.3;
   *   fill(r, 0, 0);
   *   rect(0, 0, 50, 100);
   *
   *   // Round r up to 1.
   *   r = ceil(r);
   *
   *   // Draw the right rectangle.
   *   fill(r, 0, 0);
   *   rect(50, 0, 50, 100);
   *
   *   describe('Two rectangles. The one on the left is dark red and the one on the right is bright red.');
   * }
   * </code>
   * </div>
   */ fn.ceil = Math.ceil;
    /**
   * Constrains a number between a minimum and maximum value.
   *
   * @method constrain
   * @param  {Number} n    number to constrain.
   * @param  {Number} low  minimum limit.
   * @param  {Number} high maximum limit.
   * @return {Number}      constrained number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black dot drawn on a gray square follows the mouse from left to right. Its movement is constrained to the middle third of the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let x = constrain(mouseX, 33, 67);
   *   let y = 50;
   *
   *   strokeWeight(5);
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two vertical lines. Two circles move horizontally with the mouse. One circle stops at the vertical lines.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Set boundaries and draw them.
   *   let leftWall = 25;
   *   let rightWall = 75;
   *   line(leftWall, 0, leftWall, 100);
   *   line(rightWall, 0, rightWall, 100);
   *
   *   // Draw a circle that follows the mouse freely.
   *   fill(255);
   *   circle(mouseX, 33, 9);
   *
   *   // Draw a circle that's constrained.
   *   let xc = constrain(mouseX, leftWall, rightWall);
   *   fill(0);
   *   circle(xc, 67, 9);
   * }
   * </code>
   * </div>
   */ fn.constrain = function(n, low, high) {
        // p5._validateParameters('constrain', arguments);
        return Math.max(Math.min(n, high), low);
    };
    /**
   * Calculates the distance between two points.
   *
   * The version of `dist()` with four parameters calculates distance in two
   * dimensions.
   *
   * The version of `dist()` with six parameters calculates distance in three
   * dimensions.
   *
   * Use <a href="#/p5.Vector/dist">p5.Vector.dist()</a> to calculate the
   * distance between two <a href="#/p5.Vector">p5.Vector</a> objects.
   *
   * @method dist
   * @param  {Number} x1 x-coordinate of the first point.
   * @param  {Number} y1 y-coordinate of the first point.
   * @param  {Number} x2 x-coordinate of the second point.
   * @param  {Number} y2 y-coordinate of the second point.
   * @return {Number}    distance between the two points.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the coordinates.
   *   let x1 = 10;
   *   let y1 = 50;
   *   let x2 = 90;
   *   let y2 = 50;
   *
   *   // Draw the points and a line connecting them.
   *   line(x1, y1, x2, y2);
   *   strokeWeight(5);
   *   point(x1, y1);
   *   point(x2, y2);
   *
   *   // Calculate the distance.
   *   let d = dist(x1, y1, x2, y2);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the distance.
   *   text(d, 43, 40);
   *
   *   describe('Two dots connected by a horizontal line. The number 80 is written above the center of the line.');
   * }
   * </code>
   * </div>
   */ /**
   * @method dist
   * @param  {Number} x1
   * @param  {Number} y1
   * @param  {Number} z1 z-coordinate of the first point.
   * @param  {Number} x2
   * @param  {Number} y2
   * @param  {Number} z2 z-coordinate of the second point.
   * @return {Number}    distance between the two points.
   */ fn.dist = function(...args) {
        // p5._validateParameters('dist', args);
        if (args.length === 4) {
            //2D
            return Math.hypot(args[2] - args[0], args[3] - args[1]);
        } else if (args.length === 6) {
            //3D
            return Math.hypot(args[3] - args[0], args[4] - args[1], args[5] - args[2]);
        }
    };
    /**
   * Calculates the value of Euler's number e (2.71828...) raised to the power
   * of a number.
   *
   * @method exp
   * @param  {Number} n exponent to raise.
   * @return {Number}   e^n
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top-left.
   *   let d = exp(1);
   *   circle(10, 10, d);
   *
   *   // Left-center.
   *   d = exp(2);
   *   circle(20, 20, d);
   *
   *   // Right-center.
   *   d = exp(3);
   *   circle(40, 40, d);
   *
   *   // Bottom-right.
   *   d = exp(4);
   *   circle(80, 80, d);
   *
   *   describe('A series of circles that grow exponentially from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots that grow exponentially from left to right.');
   * }
   *
   * function draw() {
   *   // Invert the y-axis.
   *   scale(1, -1);
   *   translate(0, -100);
   *
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 0.005 * exp(x * 0.1);
   *
   *   // Draw a point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.exp = Math.exp;
    /**
   * Calculates the closest integer value that is less than or equal to the
   * value of a number.
   *
   * @method floor
   * @param  {Number} n number to round down.
   * @return {Integer}  rounded down number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use RGB color with values from 0 to 1.
   *   colorMode(RGB, 1);
   *
   *   noStroke();
   *
   *   // Draw the left rectangle.
   *   let r = 0.8;
   *   fill(r, 0, 0);
   *   rect(0, 0, 50, 100);
   *
   *   // Round r down to 0.
   *   r = floor(r);
   *
   *   // Draw the right rectangle.
   *   fill(r, 0, 0);
   *   rect(50, 0, 50, 100);
   *
   *   describe('Two rectangles. The one on the left is bright red and the one on the right is black.');
   * }
   * </code>
   * </div>
   */ fn.floor = Math.floor;
    /**
   * Calculates a number between two numbers at a specific increment.
   *
   * The `amt` parameter is the amount to interpolate between the two numbers.
   * 0.0 is equal to the first number, 0.1 is very near the first number, 0.5 is
   * half-way in between, and 1.0 is equal to the second number. The `lerp()`
   * function is convenient for creating motion along a straight path and for
   * drawing dotted lines.
   *
   * If the value of `amt` is less than 0 or more than 1, `lerp()` will return a
   * number outside of the original interval. For example, calling
   * `lerp(0, 10, 1.5)` will return 15.
   *
   * @method lerp
   * @param  {Number} start first value.
   * @param  {Number} stop  second value.
   * @param  {Number} amt   number.
   * @return {Number}       lerped value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Declare variables for coordinates.
   *   let a = 20;
   *   let b = 80;
   *   let c = lerp(a, b, 0.2);
   *   let d = lerp(a, b, 0.5);
   *   let e = lerp(a, b, 0.8);
   *
   *   strokeWeight(5);
   *
   *   // Draw the original points in black.
   *   stroke(0);
   *   point(a, 50);
   *   point(b, 50);
   *
   *   // Draw the lerped points in gray.
   *   stroke(100);
   *   point(c, 50);
   *   point(d, 50);
   *   point(e, 50);
   *
   *   describe('Five points in a horizontal line. The outer points are black and the inner points are gray.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let x = 50;
   * let y = 50;
   * let targetX = 50;
   * let targetY = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A white circle at the center of a gray canvas. The circle moves to where the user clicks, then moves smoothly back to the center.');
   * }
   *
   * function draw() {
   *   background(220);
   *
   *   // Move x and y toward the target.
   *   x = lerp(x, targetX, 0.05);
   *   y = lerp(y, targetY, 0.05);
   *
   *   // Draw the circle.
   *   circle(x, y, 20);
   * }
   *
   * // Set x and y when the user clicks the mouse.
   * function mouseClicked() {
   *   x = mouseX;
   *   y = mouseY;
   * }
   * </code>
   * </div>
   */ fn.lerp = function(start, stop, amt) {
        // p5._validateParameters('lerp', arguments);
        return amt * (stop - start) + start;
    };
    /**
   * Calculates the natural logarithm (the base-e logarithm) of a number.
   *
   * `log()` expects the `n` parameter to be a value greater than 0 because
   * the natural logarithm is defined that way.
   *
   * @method log
   * @param  {Number} n number greater than 0.
   * @return {Number}   natural logarithm of n.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top-left.
   *   let d = log(50);
   *   circle(33, 33, d);
   *
   *   // Bottom-right.
   *   d = log(500000000);
   *   circle(67, 67, d);
   *
   *   describe('Two white circles. The circle at the top-left is small. The circle at the bottom-right is about five times larger.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots that get higher slowly from left to right.');
   * }
   *
   * function draw() {
   *   // Invert the y-axis.
   *   scale(1, -1);
   *   translate(0, -100);
   *
   *   // Calculate coordinates.
   *   let x = frameCount;
   *   let y = 15 * log(x);
   *
   *   // Draw a point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.log = Math.log;
    /**
   * Calculates the magnitude, or length, of a vector.
   *
   * A vector can be thought of in different ways. In one view, a vector is a
   * point in space. The vector's components, `x` and `y`, are the point's
   * coordinates `(x, y)`. A vector's magnitude is the distance from the origin
   * `(0, 0)` to `(x, y)`. `mag(x, y)` is a shortcut for calling
   * `dist(0, 0, x, y)`.
   *
   * A vector can also be thought of as an arrow pointing in space. This view is
   * helpful for programming motion. See <a href="#/p5.Vector">p5.Vector</a> for
   * more details.
   *
   * Use <a href="#/p5.Vector/mag">p5.Vector.mag()</a> to calculate the
   * magnitude of a <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @method mag
   * @param  {Number} x first component.
   * @param  {Number} y second component.
   * @return {Number}   magnitude of vector.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the vector's components.
   *   let x = 30;
   *   let y = 40;
   *
   *   // Calculate the magnitude.
   *   let m = mag(x, y);
   *
   *   // Style the text.
   *   textSize(16);
   *
   *   // Display the vector and its magnitude.
   *   line(0, 0, x, y);
   *   text(m, x, y);
   *
   *   describe('A diagonal line is drawn from the top left of the canvas. The number 50 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */ fn.mag = function(x, y) {
        // p5._validateParameters('mag', arguments);
        return Math.hypot(x, y);
    };
    /**
   * Re-maps a number from one range to another.
   *
   * For example, calling `map(2, 0, 10, 0, 100)` returns 20. The first three
   * arguments set the original value to 2 and the original range from 0 to 10.
   * The last two arguments set the target range from 0 to 100. 20's position
   * in the target range [0, 100] is proportional to 2's position in the
   * original range [0, 10].
   *
   * The sixth parameter, `withinBounds`, is optional. By default, `map()` can
   * return values outside of the target range. For example,
   * `map(11, 0, 10, 0, 100)` returns 110. Passing `true` as the sixth parameter
   * constrains the remapped value to the target range. For example,
   * `map(11, 0, 10, 0, 100, true)` returns 100.
   *
   * @method map
   * @param  {Number} value  the value to be remapped.
   * @param  {Number} start1 lower bound of the value's current range.
   * @param  {Number} stop1  upper bound of the value's current range.
   * @param  {Number} start2 lower bound of the value's target range.
   * @param  {Number} stop2  upper bound of the value's target range.
   * @param  {Boolean} [withinBounds] constrain the value to the newly mapped range.
   * @return {Number}        remapped number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two horizontal lines. The top line grows horizontally as the mouse moves to the right. The bottom line also grows horizontally but is scaled to stay on the left half of the canvas.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the top line.
   *   line(0, 25, mouseX, 25);
   *
   *   // Remap mouseX from [0, 100] to [0, 50].
   *   let x = map(mouseX, 0, 100, 0, 50);
   *
   *   // Draw the bottom line.
   *   line(0, 75, 0, x);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A circle changes color from black to white as the mouse moves from left to right.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Remap mouseX from [0, 100] to [0, 255]
   *   let c = map(mouseX, 0, 100, 0, 255);
   *
   *   // Style the circle.
   *   fill(c);
   *
   *   // Draw the circle.
   *   circle(50, 50, 20);
   * }
   * </code>
   * </div>
   */ fn.map = function(n, start1, stop1, start2, stop2, withinBounds) {
        // p5._validateParameters('map', arguments);
        const newval = (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
        if (!withinBounds) {
            return newval;
        }
        if (start2 < stop2) {
            return this.constrain(newval, start2, stop2);
        } else {
            return this.constrain(newval, stop2, start2);
        }
    };
    /**
   * Returns the largest value in a sequence of numbers.
   *
   * The version of `max()` with one parameter interprets it as an array of
   * numbers and returns the largest number.
   *
   * The version of `max()` with two or more parameters interprets them as
   * individual numbers and returns the largest number.
   *
   * @method max
   * @param  {Number} n0 first number to compare.
   * @param  {Number} n1 second number to compare.
   * @return {Number}             maximum number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate the maximum of 10, 5, and 20.
   *   let m = max(10, 5, 20);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the max.
   *   text(m, 50, 50);
   *
   *   describe('The number 20 written in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let numbers = [10, 5, 20];
   *
   *   // Calculate the maximum of the array.
   *   let m = max(numbers);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the max.
   *   text(m, 50, 50);
   *
   *   describe('The number 20 written in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ /**
   * @method max
   * @param  {Number[]} nums numbers to compare.
   * @return {Number}
   */ fn.max = function(...args) {
        const findMax = (arr)=>{
            let max = -Infinity;
            for (let x of arr){
                max = Math.max(max, x);
            }
            return max;
        };
        if (args[0] instanceof Array) {
            return findMax(args[0]);
        } else {
            return findMax(args);
        }
    };
    /**
   * Returns the smallest value in a sequence of numbers.
   *
   * The version of `min()` with one parameter interprets it as an array of
   * numbers and returns the smallest number.
   *
   * The version of `min()` with two or more parameters interprets them as
   * individual numbers and returns the smallest number.
   *
   * @method min
   * @param  {Number} n0 first number to compare.
   * @param  {Number} n1 second number to compare.
   * @return {Number}             minimum number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Calculate the minimum of 10, 5, and 20.
   *   let m = min(10, 5, 20);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the min.
   *   text(m, 50, 50);
   *
   *   describe('The number 5 written in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of numbers.
   *   let numbers = [10, 5, 20];
   *
   *   // Calculate the minimum of the array.
   *   let m = min(numbers);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the min.
   *   text(m, 50, 50);
   *
   *   describe('The number 5 written in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */ /**
   * @method min
   * @param  {Number[]} nums numbers to compare.
   * @return {Number}
   */ fn.min = function(...args) {
        const findMin = (arr)=>{
            let min = Infinity;
            for (let x of arr){
                min = Math.min(min, x);
            }
            return min;
        };
        if (args[0] instanceof Array) {
            return findMin(args[0]);
        } else {
            return findMin(args);
        }
    };
    /**
   * Maps a number from one range to a value between 0 and 1.
   *
   * For example, `norm(2, 0, 10)` returns 0.2. 2's position in the original
   * range [0, 10] is proportional to 0.2's position in the range [0, 1]. This
   * is the same as calling `map(2, 0, 10, 0, 1)`.
   *
   * Numbers outside of the original range are not constrained between 0 and 1.
   * Out-of-range values are often intentional and useful.
   *
   * @method norm
   * @param  {Number} value incoming value to be normalized.
   * @param  {Number} start lower bound of the value's current range.
   * @param  {Number} stop  upper bound of the value's current range.
   * @return {Number}       normalized number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Use RGB color with values from 0 to 1.
   *   colorMode(RGB, 1);
   *
   *   describe('A square changes color from black to red as the mouse moves from left to right.');
   * }
   *
   * function draw() {
   *   // Calculate the redValue.
   *   let redValue = norm(mouseX, 0, 100);
   *
   *   // Paint the background.
   *   background(redValue, 0, 0);
   * }
   * </code>
   * </div>
   */ fn.norm = function(n, start, stop) {
        // p5._validateParameters('norm', arguments);
        return this.map(n, start, stop, 0, 1);
    };
    /**
   * Calculates exponential expressions such as <var>2<sup>3</sup></var>.
   *
   * For example, `pow(2, 3)` evaluates the expression
   * 2 &times; 2 &times; 2. `pow(2, -3)` evaluates 1 &#247;
   * (2 &times; 2 &times; 2).
   *
   * @method pow
   * @param  {Number} n base of the exponential expression.
   * @param  {Number} e power by which to raise the base.
   * @return {Number}   n^e.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the base of the exponent.
   *   let base = 3;
   *
   *   // Top-left.
   *   let d = pow(base, 1);
   *   circle(10, 10, d);
   *
   *   // Left-center.
   *   d = pow(base, 2);
   *   circle(20, 20, d);
   *
   *   // Right-center.
   *   d = pow(base, 3);
   *   circle(40, 40, d);
   *
   *   // Bottom-right.
   *   d = pow(base, 4);
   *   circle(80, 80, d);
   *
   *   describe('A series of circles that grow exponentially from top left to bottom right.');
   * }
   * </code>
   * </div>
   */ fn.pow = Math.pow;
    /**
   * Calculates the integer closest to a number.
   *
   * For example, `round(133.8)` returns the value 134.
   *
   * The second parameter, `decimals`, is optional. It sets the number of
   * decimal places to use when rounding. For example, `round(12.34, 1)` returns
   * 12.3. `decimals` is 0 by default.
   *
   * @method round
   * @param  {Number} n number to round.
   * @param  {Number} [decimals] number of decimal places to round to, default is 0.
   * @return {Integer}  rounded number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Round a number.
   *   let x = round(4.2);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the rounded number.
   *   text(x, 50, 50);
   *
   *   describe('The number 4 written in middle of the canvas.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Round a number to 2 decimal places.
   *   let x = round(12.782383, 2);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the rounded number.
   *   text(x, 50, 50);
   *
   *   describe('The number 12.78 written in middle of canvas.');
   * }
   * </code>
   * </div>
   */ fn.round = function(n, decimals) {
        if (!decimals) {
            return Math.round(n);
        }
        const multiplier = Math.pow(10, decimals);
        return Math.round(n * multiplier) / multiplier;
    };
    /**
   * Calculates the square of a number.
   *
   * Squaring a number means multiplying the number by itself. For example,
   * `sq(3)` evaluates 3 &times; 3 which is 9. `sq(-3)` evaluates -3 &times; -3
   * which is also 9. Multiplying two negative numbers produces a positive
   * number. The value returned by `sq()` is always positive.
   *
   * @method sq
   * @param  {Number} n number to square.
   * @return {Number}   squared number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top-left.
   *   let d = sq(3);
   *   circle(33, 33, d);
   *
   *   // Bottom-right.
   *   d = sq(6);
   *   circle(67, 67, d);
   *
   *   describe('Two white circles. The circle at the top-left is small. The circle at the bottom-right is four times larger.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots that get higher quickly from left to right.');
   * }
   *
   * function draw() {
   *   // Invert the y-axis.
   *   scale(1, -1);
   *   translate(0, -100);
   *
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 0.01 * sq(x);
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.sq = (n)=>n * n;
    /**
   * Calculates the square root of a number.
   *
   * A number's square root can be multiplied by itself to produce the original
   * number. For example, `sqrt(9)` returns 3 because 3 &times; 3 = 9. `sqrt()`
   * always returns a positive value. `sqrt()` doesn't work with negative arguments
   * such as `sqrt(-9)`.
   *
   * @method sqrt
   * @param  {Number} n non-negative number to square root.
   * @return {Number}   square root of number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top-left.
   *   let d = sqrt(16);
   *   circle(33, 33, d);
   *
   *   // Bottom-right.
   *   d = sqrt(1600);
   *   circle(67, 67, d);
   *
   *   describe('Two white circles. The circle at the top-left is small. The circle at the bottom-right is ten times larger.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A series of black dots that get higher slowly from left to right.');
   * }
   *
   * function draw() {
   *   // Invert the y-axis.
   *   scale(1, -1);
   *   translate(0, -100);
   *
   *   // Calculate the coordinates.
   *   let x = frameCount;
   *   let y = 5 * sqrt(x);
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ fn.sqrt = Math.sqrt;
    /**
   * Calculates the fractional part of a number.
   *
   * A number's fractional part includes its decimal values. For example,
   * `fract(12.34)` returns 0.34.
   *
   * @method fract
   * @param {Number} n number whose fractional part will be found.
   * @returns {Number} fractional part of n.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Original number.
   *   let n = 56.78;
   *   text(n, 50, 33);
   *
   *   // Fractional part.
   *   let f = fract(n);
   *   text(f, 50, 67);
   *
   *   describe('The number 56.78 written above the number 0.78.');
   * }
   * </code>
   * </div>
   */ fn.fract = function(toConvert) {
        // p5._validateParameters('fract', arguments);
        let sign = 0;
        let num = Number(toConvert);
        if (isNaN(num) || Math.abs(num) === Infinity) {
            return num;
        } else if (num < 0) {
            num = -num;
            sign = 1;
        }
        if (String(num).includes('.') && !String(num).includes('e')) {
            let toFract = String(num);
            toFract = Number('0' + toFract.slice(toFract.indexOf('.')));
            return Math.abs(sign - toFract);
        } else if (num < 1) {
            return Math.abs(sign - num);
        } else {
            return 0;
        }
    };
}
if (typeof p5 !== 'undefined') {
    calculation(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/noise.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>noise
]);
//////////////////////////////////////////////////////////////
// http://mrl.nyu.edu/~perlin/noise/
// Adapting from PApplet.java
// which was adapted from toxi
// which was adapted from the german demo group farbrausch
// as used in their demo "art": http://www.farb-rausch.de/fr010src.zip
// someday we might consider using "improved noise"
// http://mrl.nyu.edu/~perlin/paper445.pdf
// See: https://github.com/shiffman/The-Nature-of-Code-Examples-p5.js/
//      blob/main/introduction/Noise1D/noise.js
/**
 * @module Math
 * @submodule Noise
 * @for p5
 * @requires core
 */ function noise(p51, fn) {
    const PERLIN_YWRAPB = 4;
    const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
    const PERLIN_ZWRAPB = 8;
    const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
    const PERLIN_SIZE = 4095;
    let perlin_octaves = 4; // default to medium smooth
    let perlin_amp_falloff = 0.5; // 50% reduction/octave
    const scaled_cosine = (i)=>0.5 * (1.0 - Math.cos(i * Math.PI));
    let perlin; // will be initialized lazily by noise() or noiseSeed()
    /**
   * Returns random numbers that can be tuned to feel organic.
   *
   * Values returned by <a href="#/p5/random">random()</a> and
   * <a href="#/p5/randomGaussian">randomGaussian()</a> can change by large
   * amounts between function calls. By contrast, values returned by `noise()`
   * can be made "smooth". Calls to `noise()` with similar inputs will produce
   * similar outputs. `noise()` is used to create textures, motion, shapes,
   * terrains, and so on. Ken Perlin invented `noise()` while animating the
   * original <em>Tron</em> film in the 1980s.
   *
   * `noise()` always returns values between 0 and 1. It returns the same value
   * for a given input while a sketch is running. `noise()` produces different
   * results each time a sketch runs. The
   * <a href="#/p5/noiseSeed">noiseSeed()</a> function can be used to generate
   * the same sequence of Perlin noise values each time a sketch runs.
   *
   * The character of the noise can be adjusted in two ways. The first way is to
   * scale the inputs. `noise()` interprets inputs as coordinates. The sequence
   * of noise values will be smoother when the input coordinates are closer. The
   * second way is to use the <a href="#/p5/noiseDetail">noiseDetail()</a>
   * function.
   *
   * The version of `noise()` with one parameter computes noise values in one
   * dimension. This dimension can be thought of as space, as in `noise(x)`, or
   * time, as in `noise(t)`.
   *
   * The version of `noise()` with two parameters computes noise values in two
   * dimensions. These dimensions can be thought of as space, as in
   * `noise(x, y)`, or space and time, as in `noise(x, t)`.
   *
   * The version of `noise()` with three parameters computes noise values in
   * three dimensions. These dimensions can be thought of as space, as in
   * `noise(x, y, z)`, or space and time, as in `noise(x, y, t)`.
   *
   * @method noise
   * @param  {Number} x   x-coordinate in noise space.
   * @param  {Number} [y] y-coordinate in noise space.
   * @param  {Number} [z] z-coordinate in noise space.
   * @return {Number}     Perlin noise value at specified coordinates.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black dot moves randomly on a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the coordinates.
   *   let x = 100 * noise(0.005 * frameCount);
   *   let y = 100 * noise(0.005 * frameCount + 10000);
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black dot moves randomly on a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Set the noise level and scale.
   *   let noiseLevel = 100;
   *   let noiseScale = 0.005;
   *
   *   // Scale the input coordinate.
   *   let nt = noiseScale * frameCount;
   *
   *   // Compute the noise values.
   *   let x = noiseLevel * noise(nt);
   *   let y = noiseLevel * noise(nt + 10000);
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A hilly terrain drawn in gray against a black sky.');
   * }
   *
   * function draw() {
   *   // Set the noise level and scale.
   *   let noiseLevel = 100;
   *   let noiseScale = 0.02;
   *
   *   // Scale the input coordinate.
   *   let x = frameCount;
   *   let nx = noiseScale * x;
   *
   *   // Compute the noise value.
   *   let y = noiseLevel * noise(nx);
   *
   *   // Draw the line.
   *   line(x, 0, x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A calm sea drawn in gray against a black sky.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Set the noise level and scale.
   *   let noiseLevel = 100;
   *   let noiseScale = 0.002;
   *
   *   // Iterate from left to right.
   *   for (let x = 0; x < 100; x += 1) {
   *     // Scale the input coordinates.
   *     let nx = noiseScale * x;
   *     let nt = noiseScale * frameCount;
   *
   *     // Compute the noise value.
   *     let y = noiseLevel * noise(nx, nt);
   *
   *     // Draw the line.
   *     line(x, 0, x, y);
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the noise level and scale.
   *   let noiseLevel = 255;
   *   let noiseScale = 0.01;
   *
   *   // Iterate from top to bottom.
   *   for (let y = 0; y < 100; y += 1) {
   *     // Iterate from left to right.
   *     for (let x = 0; x < 100; x += 1) {
   *       // Scale the input coordinates.
   *       let nx = noiseScale * x;
   *       let ny = noiseScale * y;
   *
   *       // Compute the noise value.
   *       let c = noiseLevel * noise(nx, ny);
   *
   *       // Draw the point.
   *       stroke(c);
   *       point(x, y);
   *     }
   *   }
   *
   *   describe('A gray cloudy pattern.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A gray cloudy pattern that changes.');
   * }
   *
   * function draw() {
   *   // Set the noise level and scale.
   *   let noiseLevel = 255;
   *   let noiseScale = 0.009;
   *
   *   // Iterate from top to bottom.
   *   for (let y = 0; y < 100; y += 1) {
   *     // Iterate from left to right.
   *     for (let x = 0; x < width; x += 1) {
   *       // Scale the input coordinates.
   *       let nx = noiseScale * x;
   *       let ny = noiseScale * y;
   *       let nt = noiseScale * frameCount;
   *
   *       // Compute the noise value.
   *       let c = noiseLevel * noise(nx, ny, nt);
   *
   *       // Draw the point.
   *       stroke(c);
   *       point(x, y);
   *     }
   *   }
   * }
   * </code>
   * </div>
   */ fn.noise = function(x, y = 0, z = 0) {
        if (perlin == null) {
            perlin = new Array(PERLIN_SIZE + 1);
            for(let i = 0; i < PERLIN_SIZE + 1; i++){
                perlin[i] = Math.random();
            }
        }
        if (x < 0) {
            x = -x;
        }
        if (y < 0) {
            y = -y;
        }
        if (z < 0) {
            z = -z;
        }
        let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
        let xf = x - xi;
        let yf = y - yi;
        let zf = z - zi;
        let rxf, ryf;
        let r = 0;
        let ampl = 0.5;
        let n1, n2, n3;
        for(let o = 0; o < perlin_octaves; o++){
            let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
            rxf = scaled_cosine(xf);
            ryf = scaled_cosine(yf);
            n1 = perlin[of & PERLIN_SIZE];
            n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
            n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
            n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
            n1 += ryf * (n2 - n1);
            of += PERLIN_ZWRAP;
            n2 = perlin[of & PERLIN_SIZE];
            n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);
            n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
            n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
            n2 += ryf * (n3 - n2);
            n1 += scaled_cosine(zf) * (n2 - n1);
            r += n1 * ampl;
            ampl *= perlin_amp_falloff;
            xi <<= 1;
            xf *= 2;
            yi <<= 1;
            yf *= 2;
            zi <<= 1;
            zf *= 2;
            if (xf >= 1.0) {
                xi++;
                xf--;
            }
            if (yf >= 1.0) {
                yi++;
                yf--;
            }
            if (zf >= 1.0) {
                zi++;
                zf--;
            }
        }
        return r;
    };
    /**
   * Adjusts the character of the noise produced by the
   * <a href="#/p5/noise">noise()</a> function.
   *
   * Perlin noise values are created by adding layers of noise together. The
   * noise layers, called octaves, are similar to harmonics in music. Lower
   * octaves contribute more to the output signal. They define the overall
   * intensity of the noise. Higher octaves create finer-grained details.
   *
   * By default, noise values are created by combining four octaves. Each higher
   * octave contributes half as much (50% less) compared to its predecessor.
   * `noiseDetail()` changes the number of octaves and the falloff amount. For
   * example, calling `noiseDetail(6, 0.25)` ensures that
   * <a href="#/p5/noise">noise()</a> will use six octaves. Each higher octave
   * will contribute 25% as much (75% less) compared to its predecessor. Falloff
   * values between 0 and 1 are valid. However, falloff values greater than 0.5
   * might result in noise values greater than 1.
   *
   * @method noiseDetail
   * @param {Number} lod number of octaves to be used by the noise.
   * @param {Number} falloff falloff factor for each octave.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Set the noise level and scale.
   *   let noiseLevel = 255;
   *   let noiseScale = 0.02;
   *
   *   // Iterate from top to bottom.
   *   for (let y = 0; y < 100; y += 1) {
   *     // Iterate from left to right.
   *     for (let x = 0; x < 50; x += 1) {
   *       // Scale the input coordinates.
   *       let nx = noiseScale * x;
   *       let ny = noiseScale * y;
   *
   *       // Compute the noise value with six octaves
   *       // and a low falloff factor.
   *       noiseDetail(6, 0.25);
   *       let c = noiseLevel * noise(nx, ny);
   *
   *       // Draw the left side.
   *       stroke(c);
   *       point(x, y);
   *
   *       // Compute the noise value with four octaves
   *       // and a high falloff factor.
   *       noiseDetail(4, 0.5);
   *       c = noiseLevel * noise(nx, ny);
   *
   *       // Draw the right side.
   *       stroke(c);
   *       point(x + 50, y);
   *     }
   *   }
   *
   *   describe('Two gray cloudy patterns. The pattern on the right is cloudier than the pattern on the left.');
   * }
   * </code>
   * </div>
   */ fn.noiseDetail = function(lod, falloff) {
        if (lod > 0) {
            perlin_octaves = lod;
        }
        if (falloff > 0) {
            perlin_amp_falloff = falloff;
        }
    };
    /**
   * @private
   * Returns the current number of octaves used by noise().
   */ fn._getNoiseOctaves = function() {
        return perlin_octaves;
    };
    /**
   * @private
   * Returns the current falloff factor used by noise().
   */ fn._getNoiseAmpFalloff = function() {
        return perlin_amp_falloff;
    };
    /**
   * Sets the seed value for the <a href="#/p5/noise">noise()</a> function.
   *
   * By default, <a href="#/p5/noise">noise()</a> produces different results
   * each time a sketch is run. Calling `noiseSeed()` with a constant argument,
   * such as `noiseSeed(99)`, makes <a href="#/p5/noise">noise()</a> produce the
   * same results each time a sketch is run.
   *
   * @method noiseSeed
   * @param {Number} seed   seed value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the noise seed for consistent results.
   *   noiseSeed(99);
   *
   *   describe('A black rectangle that grows randomly, first to the right and then to the left.');
   * }
   *
   * function draw() {
   *   // Set the noise level and scale.
   *   let noiseLevel = 100;
   *   let noiseScale = 0.005;
   *
   *   // Scale the input coordinate.
   *   let nt = noiseScale * frameCount;
   *
   *   // Compute the noise value.
   *   let x = noiseLevel * noise(nt);
   *
   *   // Draw the line.
   *   line(x, 0, x, height);
   * }
   * </code>
   * </div>
   */ fn.noiseSeed = function(seed) {
        // Linear Congruential Generator
        // Variant of a Lehman Generator
        const lcg = (()=>{
            // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
            // m is basically chosen to be large (as it is the max period)
            // and for its relationships to a and c
            const m = 4294967296;
            // a - 1 should be divisible by m's prime factors
            const a = 1664525;
            // c and m should be co-prime
            const c = 1013904223;
            let seed, z;
            return {
                setSeed (val) {
                    // pick a random seed if val is undefined or null
                    // the >>> 0 casts the seed to an unsigned 32-bit integer
                    z = seed = (val == null ? Math.random() * m : val) >>> 0;
                },
                getSeed () {
                    return seed;
                },
                rand () {
                    // define the recurrence relationship
                    z = (a * z + c) % m;
                    // return a float in [0, 1)
                    // if z = m then z / m = 0 therefore (z % m) / m < 1 always
                    return z / m;
                }
            };
        })();
        lcg.setSeed(seed);
        perlin = new Array(PERLIN_SIZE + 1);
        for(let i = 0; i < PERLIN_SIZE + 1; i++){
            perlin[i] = lcg.rand();
        }
    };
}
if (typeof p5 !== 'undefined') {
    noise(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/random.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>random
]);
/**
 * @module Math
 * @submodule Random
 * @for p5
 * @requires core
 */ function random(p51, fn) {
    // variables used for random number generators
    const randomStateProp = '_lcg_random_state';
    // Set to values from http://en.wikipedia.org/wiki/Numerical_Recipes
    // m is basically chosen to be large (as it is the max period)
    // and for its relationships to a and c
    const m = 4294967296;
    // a - 1 should be divisible by m's prime factors
    const a = 1664525;
    // c and m should be co-prime
    const c = 1013904223;
    let y2 = 0;
    // Linear Congruential Generator that stores its state at instance[stateProperty]
    fn._lcg = function(stateProperty) {
        // define the recurrence relationship
        this[stateProperty] = (a * this[stateProperty] + c) % m;
        // return a float in [0, 1)
        // we've just used % m, so / m is always < 1
        return this[stateProperty] / m;
    };
    fn._lcgSetSeed = function(stateProperty, val) {
        // pick a random seed if val is undefined or null
        // the >>> 0 casts the seed to an unsigned 32-bit integer
        this[stateProperty] = (val == null ? Math.random() * m : val) >>> 0;
    };
    /**
   * Sets the seed value for the <a href="#/p5/random">random()</a> and
   * <a href="#/p5/randomGaussian">randomGaussian()</a> functions.
   *
   * By default, <a href="#/p5/random">random()</a> and
   * <a href="#/p5/randomGaussian">randomGaussian()</a> produce different
   * results each time a sketch is run. Calling `randomSeed()` with a constant
   * argument, such as `randomSeed(99)`, makes these functions produce the same
   * results each time a sketch is run.
   *
   * @method randomSeed
   * @param {Number} seed   seed value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get random coordinates.
   *   let x = random(0, 100);
   *   let y = random(0, 100);
   *
   *   // Draw the white circle.
   *   circle(x, y, 10);
   *
   *   // Set a random seed for consistency.
   *   randomSeed(99);
   *
   *   // Get random coordinates.
   *   x = random(0, 100);
   *   y = random(0, 100);
   *
   *   // Draw the black circle.
   *   fill(0);
   *   circle(x, y, 10);
   *
   *   describe('A white circle appears at a random position. A black circle appears at (27.4, 25.8).');
   * }
   * </code>
   * </div>
   */ fn.randomSeed = function(seed) {
        this._lcgSetSeed(randomStateProp, seed);
        this._gaussian_previous = false;
    };
    /**
   * Returns a random number or a random element from an array.
   *
   * `random()` follows uniform distribution, which means that all outcomes are
   * equally likely. When `random()` is used to generate numbers, all
   * numbers in the output range are equally likely to be returned. When
   * `random()` is used to select elements from an array, all elements are
   * equally likely to be chosen.
   *
   * By default, `random()` produces different results each time a sketch runs.
   * The <a href="#/p5/randomSeed">randomSeed()</a> function can be used to
   * generate the same sequence of numbers or choices each time a sketch runs.
   *
   * The version of `random()` with no parameters returns a random number from 0
   * up to but not including 1.
   *
   * The version of `random()` with one parameter works one of two ways. If the
   * argument passed is a number, `random()` returns a random number from 0 up
   * to but not including the number. For example, calling `random(5)` returns
   * values between 0 and 5. If the argument passed is an array, `random()`
   * returns a random element from that array. For example, calling
   * `random(['🦁', '🐯', '🐻'])` returns either a lion, tiger, or bear emoji.
   *
   * The version of `random()` with two parameters returns a random number from
   * a given range. The arguments passed set the range's lower and upper bounds.
   * For example, calling `random(-5, 10.2)` returns values from -5 up to but
   * not including 10.2.
   *
   * @method random
   * @param  {Number} [min]   lower bound (inclusive).
   * @param  {Number} [max]   upper bound (exclusive).
   * @return {Number} random number.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get random coordinates between 0 and 100.
   *   let x = random(0, 100);
   *   let y = random(0, 100);
   *
   *   // Draw a point.
   *   strokeWeight(5);
   *   point(x, y);
   *
   *   describe('A black dot appears in a random position on a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get random coordinates between 0 and 100.
   *   let x = random(100);
   *   let y = random(100);
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(x, y);
   *
   *   describe('A black dot appears in a random position on a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an array of emoji strings.
   *   let animals = ['🦁', '🐯', '🐻'];
   *
   *   // Choose a random element from the array.
   *   let choice = random(animals);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(20);
   *
   *   // Display the emoji.
   *   text(choice, 50, 50);
   *
   *   describe('An animal face is displayed at random. Either a lion, tiger, or bear.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(5);
   *
   *   describe('A black dot moves around randomly on a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get random coordinates between 0 and 100.
   *   let x = random(100);
   *   let y = random(100);
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(5);
   *
   *   describe('A black dot moves around randomly in the middle of a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get random coordinates between 45 and 55.
   *   let x = random(45, 55);
   *   let y = random(45, 55);
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(x, y);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let x = 50;
   * let y = 50;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('A black dot moves around randomly leaving a trail.');
   * }
   *
   * function draw() {
   *   // Update x and y randomly.
   *   x += random(-1, 1);
   *   y += random(-1, 1);
   *
   *   // Draw the point.
   *   point(x, y);
   * }
   * </code>
   * </div>
   */ /**
   * @method random
   * @param  {Array} choices   array to choose from.
   * @return {*} random element from the array.
   */ fn.random = function(min, max) {
        // p5._validateParameters('random', arguments);
        let rand;
        if (this[randomStateProp] != null) {
            rand = this._lcg(randomStateProp);
        } else {
            rand = Math.random();
        }
        if (typeof min === 'undefined') {
            return rand;
        } else if (typeof max === 'undefined') {
            if (min instanceof Array) {
                return min[Math.floor(rand * min.length)];
            } else {
                return rand * min;
            }
        } else {
            if (min > max) {
                const tmp = min;
                min = max;
                max = tmp;
            }
            return rand * (max - min) + min;
        }
    };
    /**
   * Returns a random number fitting a Gaussian, or normal, distribution.
   *
   * Normal distributions look like bell curves when plotted. Values from a
   * normal distribution cluster around a central value called the mean. The
   * cluster's standard deviation describes its spread.
   *
   * By default, `randomGaussian()` produces different results each time a
   * sketch runs. The <a href="#/p5/randomSeed">randomSeed()</a> function can be
   * used to generate the same sequence of numbers each time a sketch runs.
   *
   * There's no minimum or maximum value that `randomGaussian()` might return.
   * Values far from the mean are very unlikely and values near the mean are
   * very likely.
   *
   * The version of `randomGaussian()` with no parameters returns values with a
   * mean of 0 and standard deviation of 1.
   *
   * The version of `randomGaussian()` with one parameter interprets the
   * argument passed as the mean. The standard deviation is 1.
   *
   * The version of `randomGaussian()` with two parameters interprets the first
   * argument passed as the mean and the second as the standard deviation.
   *
   * @method randomGaussian
   * @param  {Number} [mean]  mean.
   * @param  {Number} [sd]    standard deviation.
   * @return {Number} random number.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   describe('Three horizontal black lines are filled in randomly. The top line spans entire canvas. The middle line is very short. The bottom line spans two-thirds of the canvas.');
   * }
   *
   * function draw() {
   *   // Style the circles.
   *   noStroke();
   *   fill(0, 10);
   *
   *   // Uniform distribution between 0 and 100.
   *   let x = random(100);
   *   let y = 25;
   *   circle(x, y, 5);
   *
   *   // Gaussian distribution with a mean of 50 and sd of 1.
   *   x = randomGaussian(50);
   *   y = 50;
   *   circle(x, y, 5);
   *
   *   // Gaussian distribution with a mean of 50 and sd of 10.
   *   x = randomGaussian(50, 10);
   *   y = 75;
   *   circle(x, y, 5);
   * }
   * </code>
   * </div>
   */ fn.randomGaussian = function(mean, sd = 1) {
        let y1, x1, x2, w;
        if (this._gaussian_previous) {
            y1 = y2;
            this._gaussian_previous = false;
        } else {
            do {
                x1 = this.random(2) - 1;
                x2 = this.random(2) - 1;
                w = x1 * x1 + x2 * x2;
            }while (w >= 1)
            w = Math.sqrt(-2 * Math.log(w) / w);
            y1 = x1 * w;
            y2 = x2 * w;
            this._gaussian_previous = true;
        }
        const m = mean || 0;
        return y1 * sd + m;
    };
}
if (typeof p5 !== 'undefined') {
    random(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/math.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>math
]);
/**
 * @module Math
 * @for p5
 * @requires core
 */ function math(p51, fn) {
    /**
   * Creates a new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * A vector can be thought of in different ways. In one view, a vector is like
   * an arrow pointing in space. Vectors have both magnitude (length) and
   * direction. This view is helpful for programming motion.
   *
   * A vector's components determine its magnitude and direction. For example,
   * calling `createVector(3, 4)` creates a new
   * <a href="#/p5.Vector">p5.Vector</a> object with an x-component of 3 and a
   * y-component of 4. From the origin, this vector's tip is 3 units to the
   * right and 4 units down.
   *
   * You can also pass N dimensions to the `createVector` function. For example,
   * calling `createVector(1, 2, 3, 4)` creates a vector with four components.
   * This allows for flexibility in representing vectors in higher-dimensional
   * spaces.
   *
   * Calling `createVector()` **with no arguments** is **deprecated** and will emit
   * a friendly warning. Use `createVector(0)`, `createVector(0, 0)`, or
   * `createVector(0, 0, 0)` instead.
   *
   * <a href="#/p5.Vector">p5.Vector</a> objects are often used to program
   * motion because they simplify the math. For example, a moving ball has a
   * position and a velocity. Position describes where the ball is in space. The
   * ball's position vector extends from the origin to the ball's center.
   * Velocity describes the ball's speed and the direction it's moving. If the
   * ball is moving straight up, its velocity vector points straight up. Adding
   * the ball's velocity vector to its position vector moves it, as in
   * `pos.add(vel)`. Vector math relies on methods inside the
   * <a href="#/p5.Vector">p5.Vector</a> class.
   *
   * @method createVector
   * @param {...Number} x Zero or more numbers, representing each component of the vector.
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let p1 = createVector(25, 25);
   *   let p2 = createVector(50, 50);
   *   let p3 = createVector(75, 75);
   *
   *   // Draw the dots.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots form a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pos;
   * let vel;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create p5.Vector objects.
   *   pos = createVector(50, 100);
   *   vel = createVector(0, -1);
   *
   *   describe('A black dot moves from bottom to top on a gray square. The dot reappears at the bottom when it reaches the top.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add velocity to position.
   *   pos.add(vel);
   *
   *   // If the dot reaches the top of the canvas,
   *   // restart from the bottom.
   *   if (pos.y < 0) {
   *     pos.y = 100;
   *   }
   *
   *   // Draw the dot.
   *   strokeWeight(5);
   *   point(pos);
   * }
   * </code>
   * </div>
   */ fn.createVector = function(x, y, z) {
        if (arguments.length === 0) {
            p51._friendlyError('In 1.x, createVector() was a shortcut for createVector(0, 0, 0). In 2.x, p5.js has vectors of any dimension, so you must provide your desired number of zeros. Use createVector(0, 0) for a 2D vector and createVector(0, 0, 0) for a 3D vector.');
        }
        if (this instanceof p51) {
            return new p51.Vector(this._fromRadians.bind(this), this._toRadians.bind(this), ...arguments);
        } else {
            return new p51.Vector(x, y, z);
        }
    };
    /**
   * Creates a new <a href="#/p5.Matrix">p5.Matrix</a> object.
   *
   * A matrix is a mathematical concept that is useful in many fields, including
   * computer graphics. In p5.js, matrices are used to perform transformations
   * on shapes and images. The `createMatrix` method can take a column-major
   * array representation of a square matrix as an argument. In the current implementation we only use squared matrices.
   *
   * @private
   * @method createMatrix
   * @param {Array<Number>} components Column-major array representation of the square matrix.
   *
   * @return {p5.Matrix} new <a href="#/p5.Matrix">p5.Matrix</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   let matrix = createMatrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * }
   * </code>
   * </div>
   */ fn.createMatrix = function(...args) {
        return new p51.Matrix(...args);
    };
}
if (typeof p5 !== 'undefined') {
    math(p5, p5.prototype);
}
;
}),
"[project]/node_modules/p5/dist/math/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>math
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$calculation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/calculation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$noise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/noise.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$random$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/random.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/trigonometry.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/math.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/math/p5.Vector.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$constants$2d$Bt1VTUeD$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p5/dist/constants-Bt1VTUeD.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function math(p5) {
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$calculation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$noise$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$random$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$trigonometry$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$math$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
    p5.registerAddon(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p5$2f$dist$2f$math$2f$p5$2e$Vector$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]);
}
;
}),
]);

//# sourceMappingURL=node_modules_p5_dist_math_e8724940._.js.map