{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/ir_types.js"],"sourcesContent":["/////////////////////\n// Enums for nodes //\n/////////////////////\nconst NodeType = {\n  OPERATION: 'operation',\n  LITERAL: 'literal',\n  VARIABLE: 'variable',\n  CONSTANT: 'constant',\n  STRUCT: 'struct',\n  PHI: 'phi',\n  STATEMENT: 'statement',\n  ASSIGNMENT: 'assignment',\n};\nconst NodeTypeToName = Object.fromEntries(\n  Object.entries(NodeType).map(([key, val]) => [val, key])\n);\nconst NodeTypeRequiredFields = {\n  [NodeType.OPERATION]: [\"opCode\", \"dependsOn\", \"dimension\", \"baseType\"],\n  [NodeType.LITERAL]: [\"value\", \"dimension\", \"baseType\"],\n  [NodeType.VARIABLE]: [\"identifier\", \"dimension\", \"baseType\"],\n  [NodeType.CONSTANT]: [\"value\", \"dimension\", \"baseType\"],\n  [NodeType.STRUCT]: [\"\"],\n  [NodeType.PHI]: [\"dependsOn\", \"phiBlocks\", \"dimension\", \"baseType\"],\n  [NodeType.STATEMENT]: [\"statementType\"],\n  [NodeType.ASSIGNMENT]: [\"dependsOn\"]\n};\nconst StatementType = {\n  DISCARD: 'discard',\n  BREAK: 'break',\n  EXPRESSION: 'expression', // Used when we want to output a single expression as a statement, e.g. a for loop condition\n  EMPTY: 'empty', // Used for empty statements like ; in for loops\n};\nconst BaseType = {\n  FLOAT: \"float\",\n  INT: \"int\",\n  BOOL: \"bool\",\n  MAT: \"mat\",\n  DEFER: \"defer\",\n  SAMPLER2D: \"sampler2D\",\n};\nconst BasePriority = {\n  [BaseType.FLOAT]: 3,\n  [BaseType.INT]: 2,\n  [BaseType.BOOL]: 1,\n  [BaseType.MAT]: 0,\n  [BaseType.DEFER]: -1,\n  [BaseType.SAMPLER2D]: -10,\n};\nconst DataType = {\n  float1: { fnName: \"float\", baseType: BaseType.FLOAT, dimension:1, priority: 3,  },\n  float2: { fnName: \"vec2\", baseType: BaseType.FLOAT, dimension:2, priority: 3,  },\n  float3: { fnName: \"vec3\", baseType: BaseType.FLOAT, dimension:3, priority: 3,  },\n  float4: { fnName: \"vec4\", baseType: BaseType.FLOAT, dimension:4, priority: 3,  },\n  int1: { fnName: \"int\", baseType: BaseType.INT, dimension:1, priority: 2,  },\n  int2: { fnName: \"ivec2\", baseType: BaseType.INT, dimension:2, priority: 2,  },\n  int3: { fnName: \"ivec3\", baseType: BaseType.INT, dimension:3, priority: 2,  },\n  int4: { fnName: \"ivec4\", baseType: BaseType.INT, dimension:4, priority: 2,  },\n  bool1: { fnName: \"bool\", baseType: BaseType.BOOL, dimension:1, priority: 1,  },\n  bool2: { fnName: \"bvec2\", baseType: BaseType.BOOL, dimension:2, priority: 1,  },\n  bool3: { fnName: \"bvec3\", baseType: BaseType.BOOL, dimension:3, priority: 1,  },\n  bool4: { fnName: \"bvec4\", baseType: BaseType.BOOL, dimension:4, priority: 1,  },\n  mat2: { fnName: \"mat2x2\", baseType: BaseType.MAT, dimension:2, priority: 0,  },\n  mat3: { fnName: \"mat3x3\", baseType: BaseType.MAT, dimension:3, priority: 0,  },\n  mat4: { fnName: \"mat4x4\", baseType: BaseType.MAT, dimension:4, priority: 0,  },\n  defer: { fnName:  null, baseType: BaseType.DEFER, dimension: null, priority: -1 },\n  sampler2D: { fnName: \"sampler2D\", baseType: BaseType.SAMPLER2D, dimension: 1, priority: -10 },\n};\nconst structType = function (hookType) {\n  let T = hookType.type === undefined ? hookType : hookType.type;\n  const structType = {\n    name: hookType.name,\n    properties: [],\n    typeName: T.typeName,\n  };\n  // TODO: handle struct properties that are themselves structs\n  for (const prop of T.properties) {\n    const propType = TypeInfoFromGLSLName[prop.type.typeName];\n    structType.properties.push(\n      {name: prop.name, dataType: propType }\n    );\n  }\n  return structType;\n};\nfunction isStructType(typeName) {\n  return !isNativeType(typeName);\n}\nfunction isNativeType(typeName) {\n  // Check if it's in DataType keys (internal names like 'float4')\n  if (Object.keys(DataType).includes(typeName)) {\n    return true;\n  }\n\n  // Check if it's a GLSL type name (like 'vec4', 'float', etc.)\n  const glslNativeTypes = {\n    'float': true,\n    'vec2': true,\n    'vec3': true,\n    'vec4': true,\n    'int': true,\n    'ivec2': true,\n    'ivec3': true,\n    'ivec4': true,\n    'bool': true,\n    'bvec2': true,\n    'bvec3': true,\n    'bvec4': true,\n    'mat2': true,\n    'mat3': true,\n    'mat4': true,\n    'sampler2D': true\n  };\n\n  return !!glslNativeTypes[typeName];\n}\nconst GenType = {\n  FLOAT: { baseType: BaseType.FLOAT, dimension: null, priority: 3 },\n  INT: { baseType: BaseType.INT, dimension: null, priority: 2 },\n  BOOL: { baseType: BaseType.BOOL, dimension: null, priority: 1 },\n};\nfunction typeEquals(nodeA, nodeB) {\n  return (nodeA.dimension === nodeB.dimension) && (nodeA.baseType === nodeB.baseType);\n}\nconst TypeInfoFromGLSLName = Object.fromEntries(\n  Object.values(DataType)\n    .filter(info => info.fnName !== null)\n    .map(info => [info.fnName, info])\n);\nconst OpCode = {\n  Binary: {\n    ADD: 0,\n    SUBTRACT: 1,\n    MULTIPLY: 2,\n    DIVIDE: 3,\n    MODULO: 4,\n    EQUAL: 5,\n    NOT_EQUAL: 6,\n    GREATER_THAN: 7,\n    GREATER_EQUAL: 8,\n    LESS_THAN: 9,\n    LESS_EQUAL: 10,\n    LOGICAL_AND: 11,\n    LOGICAL_OR: 12,\n    MEMBER_ACCESS: 13,\n  },\n  Unary: {\n    LOGICAL_NOT: 100,\n    NEGATE: 101,\n    PLUS: 102,\n    SWIZZLE: 103,\n  },\n  Nary: {\n    FUNCTION_CALL: 200,\n    CONSTRUCTOR: 201,\n  },\n  ControlFlow: {\n    RETURN: 300,\n    JUMP: 301,\n    BRANCH_IF_FALSE: 302,\n    DISCARD: 303,\n    BREAK: 304,\n  }\n};\nconst OperatorTable = [\n  { arity: \"unary\", name: \"not\", symbol: \"!\", opCode: OpCode.Unary.LOGICAL_NOT },\n  { arity: \"unary\", name: \"neg\", symbol: \"-\", opCode: OpCode.Unary.NEGATE },\n  { arity: \"unary\", name: \"plus\", symbol: \"+\", opCode: OpCode.Unary.PLUS },\n  { arity: \"binary\", name: \"add\", symbol: \"+\", opCode: OpCode.Binary.ADD },\n  { arity: \"binary\", name: \"sub\", symbol: \"-\", opCode: OpCode.Binary.SUBTRACT },\n  { arity: \"binary\", name: \"mult\", symbol: \"*\", opCode: OpCode.Binary.MULTIPLY },\n  { arity: \"binary\", name: \"div\", symbol: \"/\", opCode: OpCode.Binary.DIVIDE },\n  { arity: \"binary\", name: \"mod\", symbol: \"%\", opCode: OpCode.Binary.MODULO },\n  { arity: \"binary\", name: \"equalTo\", symbol: \"==\", opCode: OpCode.Binary.EQUAL },\n  { arity: \"binary\", name: \"notEqual\", symbol: \"!=\", opCode: OpCode.Binary.NOT_EQUAL },\n  { arity: \"binary\", name: \"greaterThan\", symbol: \">\", opCode: OpCode.Binary.GREATER_THAN },\n  { arity: \"binary\", name: \"greaterEqual\", symbol: \">=\", opCode: OpCode.Binary.GREATER_EQUAL },\n  { arity: \"binary\", name: \"lessThan\", symbol: \"<\", opCode: OpCode.Binary.LESS_THAN },\n  { arity: \"binary\", name: \"lessEqual\", symbol: \"<=\", opCode: OpCode.Binary.LESS_EQUAL },\n  { arity: \"binary\", name: \"and\", symbol: \"&&\", opCode: OpCode.Binary.LOGICAL_AND },\n  { arity: \"binary\", name: \"or\", symbol: \"||\", opCode: OpCode.Binary.LOGICAL_OR },\n];\nconst ConstantFolding = {\n  [OpCode.Binary.ADD]: (a, b) => a + b,\n  [OpCode.Binary.SUBTRACT]: (a, b) => a - b,\n  [OpCode.Binary.MULTIPLY]: (a, b) => a * b,\n  [OpCode.Binary.DIVIDE]: (a, b) => a / b,\n  [OpCode.Binary.MODULO]: (a, b) => a % b,\n  [OpCode.Binary.EQUAL]: (a, b) => a == b,\n  [OpCode.Binary.NOT_EQUAL]: (a, b) => a != b,\n  [OpCode.Binary.GREATER_THAN]: (a, b) => a > b,\n  [OpCode.Binary.GREATER_EQUAL]: (a, b) => a >= b,\n  [OpCode.Binary.LESS_THAN]: (a, b) => a < b,\n  [OpCode.Binary.LESS_EQUAL]: (a, b) => a <= b,\n  [OpCode.Binary.LOGICAL_AND]: (a, b) => a && b,\n  [OpCode.Binary.LOGICAL_OR]: (a, b) => a || b,\n};\n// export const SymbolToOpCode = {};\nconst OpCodeToSymbol = {};\nconst UnarySymbolToName = {};\nconst BinarySymbolToName = {};\nfor (const { symbol, opCode, name, arity } of OperatorTable) {\n  // SymbolToOpCode[symbol] = opCode;\n  OpCodeToSymbol[opCode] = symbol;\n  if (arity === 'unary') {\n    UnarySymbolToName[symbol] = name;\n  }\n  if (arity === 'binary') {\n    BinarySymbolToName[symbol] = name;\n  }\n}\nconst BlockType = {\n  GLOBAL: 'global',\n  FUNCTION: 'function',\n  BRANCH: 'branch',\n  IF_COND: 'if_cond',\n  IF_BODY: 'if_body',\n  ELSE_COND: 'else_cond',\n  SCOPE_START: 'scope_start',\n  SCOPE_END: 'scope_end',\n  FOR: 'for',\n  MERGE: 'merge',\n  DEFAULT: 'default',\n};\nconst BlockTypeToName = Object.fromEntries(\n  Object.entries(BlockType).map(([key, val]) => [val, key])\n);\n\nexport { BasePriority, BaseType, BinarySymbolToName, BlockType, BlockTypeToName, ConstantFolding, DataType, GenType, NodeType, NodeTypeRequiredFields, NodeTypeToName, OpCode, OpCodeToSymbol, OperatorTable, StatementType, TypeInfoFromGLSLName, UnarySymbolToName, isNativeType, isStructType, structType, typeEquals };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_FES.js"],"sourcesContent":["function internalError(errorMessage) {\n    const prefixedMessage = `[p5.strands internal error]: ${errorMessage}`; \n    throw new Error(prefixedMessage);\n}\n\nfunction userError(errorType, errorMessage) {\n    const prefixedMessage = `[p5.strands ${errorType}]: ${errorMessage}`;\n    throw new Error(prefixedMessage);\n}\n\nexport { internalError, userError };\n"],"names":[],"mappings":";;;;;;AAAA,SAAS,cAAc,YAAY;IAC/B,MAAM,kBAAkB,CAAC,6BAA6B,EAAE,cAAc;IACtE,MAAM,IAAI,MAAM;AACpB;AAEA,SAAS,UAAU,SAAS,EAAE,YAAY;IACtC,MAAM,kBAAkB,CAAC,YAAY,EAAE,UAAU,GAAG,EAAE,cAAc;IACpE,MAAM,IAAI,MAAM;AACpB","ignoreList":[0]}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/ir_dag.js"],"sourcesContent":["import { BasePriority, NodeTypeRequiredFields, NodeTypeToName } from './ir_types.js';\nimport { internalError } from './strands_FES.js';\n\n/////////////////////////////////\n// Public functions for strands runtime\n/////////////////////////////////\n\nfunction createDirectedAcyclicGraph() {\n  const graph = {\n    nextID: 0,\n    cache: new Map(),\n    nodeTypes: [],\n    baseTypes: [],\n    dimensions: [],\n    opCodes: [],\n    values: [],\n    identifiers: [],\n    phiBlocks: [],\n    dependsOn: [],\n    usedBy: [],\n    statementTypes: [],\n    swizzles: [],\n  };\n\n  return graph;\n}\n\nfunction getOrCreateNode(graph, node) {\n  // const key = getNodeKey(node);\n  // const existing = graph.cache.get(key);\n\n  // if (existing !== undefined) {\n    // return existing;\n  // } else {\n    const id = createNode(graph, node);\n    // graph.cache.set(key, id);\n    return id;\n  // }\n}\n\nfunction createNodeData(data = {}) {\n  const node = {\n    nodeType: data.nodeType ?? null,\n    baseType: data.baseType ?? null,\n    dimension: data.dimension ?? null,\n    opCode: data.opCode ?? null,\n    value: data.value ?? null,\n    identifier: data.identifier ?? null,\n    statementType: data.statementType ?? null,\n    swizzle: data.swizzle ?? null,\n    dependsOn: Array.isArray(data.dependsOn) ? data.dependsOn : [],\n    usedBy: Array.isArray(data.usedBy) ? data.usedBy : [],\n    phiBlocks: Array.isArray(data.phiBlocks) ? data.phiBlocks : [],\n  };\n  validateNode(node);\n  return node;\n}\n\nfunction getNodeDataFromID(graph, id) {\n  return {\n    id,\n    nodeType: graph.nodeTypes[id],\n    opCode: graph.opCodes[id],\n    value: graph.values[id],\n    identifier: graph.identifiers[id],\n    dependsOn: graph.dependsOn[id],\n    usedBy: graph.usedBy[id],\n    phiBlocks: graph.phiBlocks[id],\n    dimension: graph.dimensions[id],\n    baseType: graph.baseTypes[id],\n    statementType: graph.statementTypes[id],\n    swizzle: graph.swizzles[id],\n  }\n}\n\nfunction extractNodeTypeInfo(dag, nodeID) {\n  return {\n    baseType: dag.baseTypes[nodeID],\n    dimension: dag.dimensions[nodeID],\n    priority: BasePriority[dag.baseTypes[nodeID]],\n  };\n}\n\n/////////////////////////////////\n// Private functions\n/////////////////////////////////\nfunction createNode(graph, node) {\n  const id = graph.nextID++;\n  graph.nodeTypes[id] = node.nodeType;\n  graph.opCodes[id] = node.opCode;\n  graph.values[id] = node.value;\n  graph.identifiers[id] = node.identifier;\n  graph.dependsOn[id] = node.dependsOn.slice();\n  graph.usedBy[id] = node.usedBy;\n  graph.phiBlocks[id] = node.phiBlocks.slice();\n  graph.baseTypes[id] = node.baseType;\n  graph.dimensions[id] = node.dimension;\n  graph.statementTypes[id] = node.statementType;\n  graph.swizzles[id] = node.swizzle;\n\n  for (const dep of node.dependsOn) {\n    if (!Array.isArray(graph.usedBy[dep])) {\n      graph.usedBy[dep] = [];\n    }\n    graph.usedBy[dep].push(id);\n  }\n  return id;\n}\n\nfunction validateNode(node){\n  const nodeType = node.nodeType;\n  const requiredFields = NodeTypeRequiredFields[nodeType];\n  if (requiredFields.length === 2) {\n    internalError(`Required fields for node type '${NodeTypeToName[nodeType]}' not defined. Please add them to the utils.js file in p5.strands!`);\n  }\n  const missingFields = [];\n  for (const field of requiredFields) {\n    if (node[field] === null) {\n      missingFields.push(field);\n    }\n  }\n  if (node.dependsOn?.some(v => v === undefined)) {\n    throw new Error('Undefined dependency!');\n  }\n  if (missingFields.length > 0) {\n    internalError(`Missing fields ${missingFields.join(', ')} for a node type '${NodeTypeToName[nodeType]}'.`);\n  }\n}\n\nexport { createDirectedAcyclicGraph, createNodeData, extractNodeTypeInfo, getNodeDataFromID, getOrCreateNode };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 638, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_glslBackend.js"],"sourcesContent":["import { NodeTypeToName, NodeType, OpCode, BaseType, OpCodeToSymbol, isStructType, StatementType, BlockType } from './ir_types.js';\nimport { getNodeDataFromID, extractNodeTypeInfo } from './ir_dag.js';\nimport { internalError } from './strands_FES.js';\n\nfunction shouldCreateTemp(dag, nodeID) {\n  const nodeType = dag.nodeTypes[nodeID];\n  if (nodeType !== NodeType.OPERATION) return false;\n  if (dag.baseTypes[nodeID] === BaseType.SAMPLER2D) return false;\n  const uses = dag.usedBy[nodeID] || [];\n  return uses.length > 1;\n}\nconst TypeNames = {\n  'float1': 'float',\n  'float2': 'vec2',\n  'float3': 'vec3',\n  'float4': 'vec4',\n  'int1': 'int',\n  'int2': 'ivec2',\n  'int3': 'ivec3',\n  'int4': 'ivec4',\n  'bool1': 'bool',\n  'bool2': 'bvec2',\n  'bool3': 'bvec3',\n  'bool4': 'bvec4',\n  'mat2': 'mat2x2',\n  'mat3': 'mat3x3',\n  'mat4': 'mat4x4',\n};\nconst cfgHandlers = {\n  [BlockType.DEFAULT]: (blockID, strandsContext, generationContext) => {\n    const { dag, cfg } = strandsContext;\n    const instructions = cfg.blockInstructions[blockID] || [];\n    for (const nodeID of instructions) {\n      const nodeType = dag.nodeTypes[nodeID];\n      if (shouldCreateTemp(dag, nodeID)) {\n        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);\n        generationContext.write(declaration);\n      }\n      if (nodeType === NodeType.STATEMENT) {\n        glslBackend.generateStatement(generationContext, dag, nodeID);\n      }\n      if (nodeType === NodeType.ASSIGNMENT) {\n        glslBackend.generateAssignment(generationContext, dag, nodeID);\n        generationContext.visitedNodes.add(nodeID);\n      }\n    }\n  },\n  [BlockType.BRANCH](blockID, strandsContext, generationContext) {\n    const { dag, cfg } = strandsContext;\n    // Find all phi nodes in this branch block and declare them\n    const blockInstructions = cfg.blockInstructions[blockID] || [];\n    for (const nodeID of blockInstructions) {\n      const node = getNodeDataFromID(dag, nodeID);\n      if (node.nodeType === NodeType.PHI) {\n        // Check if the phi node's first dependency already has a temp name\n        const dependsOn = node.dependsOn || [];\n        if (dependsOn.length > 0) {\n          const firstDependency = dependsOn[0];\n          const existingTempName = generationContext.tempNames[firstDependency];\n          if (existingTempName) {\n            // Reuse the existing temp name instead of creating a new one\n            generationContext.tempNames[nodeID] = existingTempName;\n            continue; // Skip declaration, just alias to existing variable\n          }\n        }\n\n        // Otherwise, create a new temp variable for the phi node\n        const tmp = `T${generationContext.nextTempID++}`;\n        generationContext.tempNames[nodeID] = tmp;\n        const T = extractNodeTypeInfo(dag, nodeID);\n        const typeName = glslBackend.getTypeName(T.baseType, T.dimension);\n        generationContext.write(`${typeName} ${tmp};`);\n      }\n    }\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n  },\n  [BlockType.IF_COND](blockID, strandsContext, generationContext) {\n    const { dag, cfg } = strandsContext;\n    const conditionID = cfg.blockConditions[blockID];\n    const condExpr = glslBackend.generateExpression(generationContext, dag, conditionID);\n    generationContext.write(`if (${condExpr})`);\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n  },\n  [BlockType.ELSE_COND](blockID, strandsContext, generationContext) {\n    generationContext.write(`else`);\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n  },\n  [BlockType.IF_BODY](blockID, strandsContext, generationContext) {\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n    this.assignPhiNodeValues(blockID, strandsContext, generationContext);\n  },\n  [BlockType.SCOPE_START](blockID, strandsContext, generationContext) {\n    generationContext.write(`{`);\n    generationContext.indent++;\n  },\n  [BlockType.SCOPE_END](blockID, strandsContext, generationContext) {\n    generationContext.indent--;\n    generationContext.write(`}`);\n  },\n  [BlockType.MERGE](blockID, strandsContext, generationContext) {\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n  },\n  [BlockType.FUNCTION](blockID, strandsContext, generationContext) {\n    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);\n  },\n  [BlockType.FOR](blockID, strandsContext, generationContext) {\n    const { dag, cfg } = strandsContext;\n    const instructions = cfg.blockInstructions[blockID] || [];\n\n    generationContext.write(`for (`);\n\n    // Set flag to suppress semicolon on the last statement\n    const originalSuppressSemicolon = generationContext.suppressSemicolon;\n\n    for (let i = 0; i < instructions.length; i++) {\n      const nodeID = instructions[i];\n      const node = getNodeDataFromID(dag, nodeID);\n      const isLast = i === instructions.length - 1;\n\n      // Suppress semicolon on the last statement\n      generationContext.suppressSemicolon = isLast;\n\n      if (shouldCreateTemp(dag, nodeID)) {\n        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);\n        generationContext.write(declaration);\n      }\n      if (node.nodeType === NodeType.STATEMENT) {\n        glslBackend.generateStatement(generationContext, dag, nodeID);\n      }\n      if (node.nodeType === NodeType.ASSIGNMENT) {\n        glslBackend.generateAssignment(generationContext, dag, nodeID);\n        generationContext.visitedNodes.add(nodeID);\n      }\n    }\n\n    // Restore original flag\n    generationContext.suppressSemicolon = originalSuppressSemicolon;\n\n    generationContext.write(`)`);\n  },\n  assignPhiNodeValues(blockID, strandsContext, generationContext) {\n    const { dag, cfg } = strandsContext;\n    // Find all phi nodes that this block feeds into\n    const successors = cfg.outgoingEdges[blockID] || [];\n    for (const successorBlockID of successors) {\n      const instructions = cfg.blockInstructions[successorBlockID] || [];\n      for (const nodeID of instructions) {\n        const node = getNodeDataFromID(dag, nodeID);\n        if (node.nodeType === NodeType.PHI) {\n          // Find which input of this phi node corresponds to our block\n          const branchIndex = node.phiBlocks?.indexOf(blockID);\n          if (branchIndex !== -1 && branchIndex < node.dependsOn.length) {\n            const sourceNodeID = node.dependsOn[branchIndex];\n            const tempName = generationContext.tempNames[nodeID];\n            if (tempName && sourceNodeID !== null) {\n              const sourceExpr = glslBackend.generateExpression(generationContext, dag, sourceNodeID);\n              generationContext.write(`${tempName} = ${sourceExpr};`);\n            }\n          }\n        }\n      }\n    }\n  },\n};\nconst glslBackend = {\n  hookEntry(hookType) {\n    const firstLine = `(${hookType.parameters.flatMap((param) => {\n      return `${param.qualifiers?.length ? param.qualifiers.join(' ') : ''}${param.type.typeName} ${param.name}`;\n    }).join(', ')}) {`;\n    return firstLine;\n  },\n  getTypeName(baseType, dimension) {\n    const primitiveTypeName = TypeNames[baseType + dimension];\n    if (!primitiveTypeName) {\n      return baseType;\n    }\n    return primitiveTypeName;\n  },\n  generateUniformDeclaration(name, typeInfo) {\n    return `${this.getTypeName(typeInfo.baseType, typeInfo.dimension)} ${name}`;\n  },\n  generateStatement(generationContext, dag, nodeID) {\n    const node = getNodeDataFromID(dag, nodeID);\n    const semicolon = generationContext.suppressSemicolon ? '' : ';';\n    if (node.statementType === StatementType.DISCARD) {\n      generationContext.write(`discard${semicolon}`);\n    } else if (node.statementType === StatementType.BREAK) {\n      generationContext.write(`break${semicolon}`);\n    } else if (node.statementType === StatementType.EXPRESSION) {\n      // Generate the expression followed by semicolon (unless suppressed)\n      const exprNodeID = node.dependsOn[0];\n      const expr = this.generateExpression(generationContext, dag, exprNodeID);\n      generationContext.write(`${expr}${semicolon}`);\n    } else if (node.statementType === StatementType.EMPTY) {\n      // Generate just a semicolon (unless suppressed)\n      generationContext.write(semicolon);\n    }\n  },\n  generateAssignment(generationContext, dag, nodeID) {\n    const node = getNodeDataFromID(dag, nodeID);\n    // dependsOn[0] = targetNodeID, dependsOn[1] = sourceNodeID\n    const targetNodeID = node.dependsOn[0];\n    const sourceNodeID = node.dependsOn[1];\n\n    // Generate the target expression (could be variable or swizzle)\n    const targetExpr = this.generateExpression(generationContext, dag, targetNodeID);\n    const sourceExpr = this.generateExpression(generationContext, dag, sourceNodeID);\n    const semicolon = generationContext.suppressSemicolon ? '' : ';';\n\n    // Generate assignment if we have both target and source\n    if (targetExpr && sourceExpr && targetExpr !== sourceExpr) {\n      generationContext.write(`${targetExpr} = ${sourceExpr}${semicolon}`);\n    }\n  },\n  generateDeclaration(generationContext, dag, nodeID) {\n    const expr = this.generateExpression(generationContext, dag, nodeID);\n    const tmp = `T${generationContext.nextTempID++}`;\n    generationContext.tempNames[nodeID] = tmp;\n    const T = extractNodeTypeInfo(dag, nodeID);\n    const typeName = this.getTypeName(T.baseType, T.dimension);\n    return `${typeName} ${tmp} = ${expr};`;\n  },\n  generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType) {\n    const dag = strandsContext.dag;\n    const rootNode = getNodeDataFromID(dag, rootNodeID);\n    if (isStructType(rootNode.baseType)) {\n      const structTypeInfo = returnType;\n      for (let i = 0; i < structTypeInfo.properties.length; i++) {\n        const prop = structTypeInfo.properties[i];\n        const val = this.generateExpression(generationContext, dag, rootNode.dependsOn[i]);\n        if (prop.name !== val) {\n          generationContext.write(\n            `${rootNode.identifier}.${prop.name} = ${val};`\n          );\n        }\n      }\n    }\n    generationContext.write(`return ${this.generateExpression(generationContext, dag, rootNodeID)};`);\n  },\n  generateExpression(generationContext, dag, nodeID) {\n    const node = getNodeDataFromID(dag, nodeID);\n    if (generationContext.tempNames?.[nodeID]) {\n      return generationContext.tempNames[nodeID];\n    }\n    switch (node.nodeType) {\n      case NodeType.LITERAL:\n      if (node.baseType === BaseType.FLOAT) {\n        return node.value.toFixed(4);\n      }\n      else {\n        return node.value;\n      }\n      case NodeType.VARIABLE:\n      // Track shared variable usage context\n      if (generationContext.shaderContext && generationContext.strandsContext?.sharedVariables?.has(node.identifier)) {\n        const sharedVar = generationContext.strandsContext.sharedVariables.get(node.identifier);\n        if (generationContext.shaderContext === 'vertex') {\n          sharedVar.usedInVertex = true;\n        } else if (generationContext.shaderContext === 'fragment') {\n          sharedVar.usedInFragment = true;\n        }\n      }\n      return node.identifier;\n      case NodeType.OPERATION:\n      const useParantheses = node.usedBy.length > 0;\n      if (node.opCode === OpCode.Nary.CONSTRUCTOR) {\n        // TODO: differentiate casts and constructors for more efficient codegen.\n        // if (node.dependsOn.length === 1 && node.dimension === 1) {\n        //   return this.generateExpression(generationContext, dag, node.dependsOn[0]);\n        // }\n        if (node.baseType === BaseType.SAMPLER2D) {\n          return this.generateExpression(generationContext, dag, node.dependsOn[0]);\n        }\n        const T = this.getTypeName(node.baseType, node.dimension);\n        const deps = node.dependsOn.map((dep) => this.generateExpression(generationContext, dag, dep));\n        return `${T}(${deps.join(', ')})`;\n      }\n      if (node.opCode === OpCode.Nary.FUNCTION_CALL) {\n        const functionArgs = node.dependsOn.map(arg =>this.generateExpression(generationContext, dag, arg));\n        return `${node.identifier}(${functionArgs.join(', ')})`;\n      }\n      if (node.opCode === OpCode.Binary.MEMBER_ACCESS) {\n        const [lID, rID] = node.dependsOn;\n        const lName = this.generateExpression(generationContext, dag, lID);\n        const rName = this.generateExpression(generationContext, dag, rID);\n        return `${lName}.${rName}`;\n      }\n      if (node.opCode === OpCode.Unary.SWIZZLE) {\n        const parentID = node.dependsOn[0];\n        const parentExpr = this.generateExpression(generationContext, dag, parentID);\n        return `${parentExpr}.${node.swizzle}`;\n      }\n      if (node.dependsOn.length === 2) {\n        const [lID, rID] = node.dependsOn;\n        const left  = this.generateExpression(generationContext, dag, lID);\n        const right = this.generateExpression(generationContext, dag, rID);\n\n        // Special case for modulo: use mod() function for floats in GLSL\n        if (node.opCode === OpCode.Binary.MODULO) {\n          const leftNode = getNodeDataFromID(dag, lID);\n          const rightNode = getNodeDataFromID(dag, rID);\n          // If either operand is float, use mod() function\n          if (leftNode.baseType === BaseType.FLOAT || rightNode.baseType === BaseType.FLOAT) {\n            return `mod(${left}, ${right})`;\n          }\n          // For integers, use % operator\n          return `(${left} % ${right})`;\n        }\n\n        const opSym = OpCodeToSymbol[node.opCode];\n        if (useParantheses) {\n          return `(${left} ${opSym} ${right})`;\n        } else {\n          return `${left} ${opSym} ${right}`;\n        }\n      }\n      if (node.opCode === OpCode.Unary.LOGICAL_NOT\n        || node.opCode === OpCode.Unary.NEGATE\n        || node.opCode === OpCode.Unary.PLUS\n        ) {\n        const [i] = node.dependsOn;\n        const val  = this.generateExpression(generationContext, dag, i);\n        const sym  = OpCodeToSymbol[node.opCode];\n        return `${sym}${val}`;\n      }\n      case NodeType.PHI:\n      // Phi nodes represent conditional merging of values\n      // If this phi node has an identifier (like varying variables), use that\n      if (node.identifier) {\n        return node.identifier;\n      }\n      // Otherwise, they should have been declared as temporary variables\n      // and assigned in the appropriate branches\n      if (generationContext.tempNames?.[nodeID]) {\n        return generationContext.tempNames[nodeID];\n      } else {\n        // If no temp was created, this phi node only has one input\n        // so we can just use that directly\n        const validInputs = node.dependsOn.filter(id => id !== null);\n        if (validInputs.length > 0) {\n          return this.generateExpression(generationContext, dag, validInputs[0]);\n        } else {\n          throw new Error(`No valid inputs for node`)\n        }\n      }\n      case NodeType.ASSIGNMENT:\n      internalError(`ASSIGNMENT nodes should not be used as expressions`);\n      default:\n      internalError(`${NodeTypeToName[node.nodeType]} code generation not implemented yet`);\n    }\n  },\n  generateBlock(blockID, strandsContext, generationContext) {\n    const type = strandsContext.cfg.blockTypes[blockID];\n    const handler = cfgHandlers[type] || cfgHandlers[BlockType.DEFAULT];\n    handler.call(cfgHandlers, blockID, strandsContext, generationContext);\n  }\n};\n\nexport { glslBackend };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 988, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_transpiler.js"],"sourcesContent":["import { parse } from 'acorn';\nimport { ancestor, recursive } from 'acorn-walk';\nimport escodegen from 'escodegen';\nimport { UnarySymbolToName } from './ir_types.js';\n\nlet blockVarCounter = 0;\nfunction replaceBinaryOperator(codeSource) {\n  switch (codeSource) {\n    case '+': return 'add';\n    case '-': return 'sub';\n    case '*': return 'mult';\n    case '/': return 'div';\n    case '%': return 'mod';\n    case '==':\n    case '===': return 'equalTo';\n    case '!=':\n    case '!==': return 'notEqual';\n    case '>': return 'greaterThan';\n    case '>=': return 'greaterEqual';\n    case '<': return 'lessThan';\n    case '<=': return 'lessEqual';\n    case '&&': return 'and';\n    case '||': return 'or';\n    // TODO: handle ** --> pow, but make it stay pow in\n    // GLSL instead of turning it back into **\n  }\n}\nfunction nodeIsUniform(ancestor) {\n  return ancestor.type === 'CallExpression'\n    && (\n      (\n        // Global mode\n        ancestor.callee?.type === 'Identifier' &&\n        ancestor.callee?.name.startsWith('uniform')\n      ) || (\n        // Instance mode\n        ancestor.callee?.type === 'MemberExpression' &&\n        ancestor.callee?.property.name.startsWith('uniform')\n      )\n    );\n}\n\nfunction nodeIsVarying(node) {\n  return node?.type === 'CallExpression'\n    && (\n      (\n        // Global mode\n        node.callee?.type === 'Identifier' &&\n        (node.callee?.name.startsWith('varying') || node.callee?.name.startsWith('shared'))\n      ) || (\n        // Instance mode\n        node.callee?.type === 'MemberExpression' &&\n        (node.callee?.property.name.startsWith('varying') || node.callee?.property.name.startsWith('shared'))\n      )\n    );\n}\nconst ASTCallbacks = {\n  UnaryExpression(node, _state, ancestors) {\n    if (ancestors.some(nodeIsUniform)) { return; }\n    const unaryFnName = UnarySymbolToName[node.operator];\n    const standardReplacement = (node) => {\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'Identifier',\n        name: `__p5.${unaryFnName}`,\n      };\n      node.arguments = [node.argument];\n    };\n    if (node.type === 'MemberExpression') {\n      const property = node.argument.property.name;\n      const swizzleSets = [\n        ['x', 'y', 'z', 'w'],\n        ['r', 'g', 'b', 'a'],\n        ['s', 't', 'p', 'q']\n      ];\n      let isSwizzle = swizzleSets.some(set =>\n        [...property].every(char => set.includes(char))\n      ) && node.argument.type === 'MemberExpression';\n      if (isSwizzle) {\n        node.type = 'MemberExpression';\n        node.object = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: `__p5.${unaryFnName}`\n          },\n          arguments: [node.argument.object],\n        };\n        node.property = {\n          type: 'Identifier',\n          name: property\n        };\n      } else {\n        standardReplacement(node);\n      }\n    } else {\n      standardReplacement(node);\n    }\n    delete node.argument;\n    delete node.operator;\n  },\n  BreakStatement(node, _state, ancestors) {\n    if (ancestors.some(nodeIsUniform)) { return; }\n    node.callee = {\n      type: 'Identifier',\n      name: '__p5.break'\n    };\n    node.arguments = [];\n    node.type = 'CallExpression';\n  },\n  VariableDeclarator(node, _state, ancestors) {\n    if (ancestors.some(nodeIsUniform)) { return; }\n    if (nodeIsUniform(node.init)) {\n      const uniformNameLiteral = {\n        type: 'Literal',\n        value: node.id.name\n      };\n      node.init.arguments.unshift(uniformNameLiteral);\n    }\n    if (nodeIsVarying(node.init)) {\n      const varyingNameLiteral = {\n        type: 'Literal',\n        value: node.id.name\n      };\n      node.init.arguments.unshift(varyingNameLiteral);\n      _state.varyings[node.id.name] = varyingNameLiteral;\n    }\n  },\n  Identifier(node, _state, ancestors) {\n    if (ancestors.some(nodeIsUniform)) { return; }\n    if (_state.varyings[node.name]\n      && !ancestors.some(a => a.type === 'AssignmentExpression' && a.left === node)) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'getValue'\n            },\n          },\n          arguments: [],\n        };\n      }\n    },\n    // The callbacks for AssignmentExpression and BinaryExpression handle\n    // operator overloading including +=, *= assignment expressions\n    ArrayExpression(node, _state, ancestors) {\n      if (ancestors.some(nodeIsUniform)) { return; }\n      const original = JSON.parse(JSON.stringify(node));\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'Identifier',\n        name: '__p5.strandsNode',\n      };\n      node.arguments = [original];\n    },\n    AssignmentExpression(node, _state, ancestors) {\n      if (ancestors.some(nodeIsUniform)) { return; }\n      if (node.operator !== '=') {\n        const methodName = replaceBinaryOperator(node.operator.replace('=',''));\n        const rightReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: node.left,\n            property: {\n              type: 'Identifier',\n              name: methodName,\n            },\n          },\n          arguments: [node.right]\n        };\n        node.operator = '=';\n        node.right = rightReplacementNode;\n      }\n      // Handle direct varying variable assignment: myVarying = value\n      if (_state.varyings[node.left.name]) {\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'MemberExpression',\n            object: {\n              type: 'Identifier',\n              name: node.left.name\n            },\n            property: {\n              type: 'Identifier',\n              name: 'bridge',\n            }\n          },\n          arguments: [node.right],\n        };\n      }\n      // Handle swizzle assignment to varying variable: myVarying.xyz = value\n      // Note: node.left.object might be worldPos.getValue() due to prior Identifier transformation\n      else if (node.left.type === 'MemberExpression') {\n        let varyingName = null;\n\n        // Check if it's a direct identifier: myVarying.xyz\n        if (node.left.object.type === 'Identifier' && _state.varyings[node.left.object.name]) {\n          varyingName = node.left.object.name;\n        }\n        // Check if it's a getValue() call: myVarying.getValue().xyz\n        else if (node.left.object.type === 'ExpressionStatement' &&\n                 node.left.object.expression?.type === 'CallExpression' &&\n                 node.left.object.expression.callee?.type === 'MemberExpression' &&\n                 node.left.object.expression.callee.property?.name === 'getValue' &&\n                 node.left.object.expression.callee.object?.type === 'Identifier' &&\n                 _state.varyings[node.left.object.expression.callee.object.name]) {\n          varyingName = node.left.object.expression.callee.object.name;\n        }\n\n        if (varyingName) {\n          const swizzlePattern = node.left.property.name;\n          node.type = 'ExpressionStatement';\n          node.expression = {\n            type: 'CallExpression',\n            callee: {\n              type: 'MemberExpression',\n              object: {\n                type: 'Identifier',\n                name: varyingName\n              },\n              property: {\n                type: 'Identifier',\n                name: 'bridgeSwizzle',\n              }\n            },\n            arguments: [\n              {\n                type: 'Literal',\n                value: swizzlePattern\n              },\n              node.right\n            ],\n          };\n        }\n      }\n    },\n    BinaryExpression(node, _state, ancestors) {\n      // Don't convert uniform default values to node methods, as\n      // they should be evaluated at runtime, not compiled.\n      if (ancestors.some(nodeIsUniform)) { return; }\n      // If the left hand side of an expression is one of these types,\n      // we should construct a node from it.\n      const unsafeTypes = ['Literal', 'ArrayExpression', 'Identifier'];\n      if (unsafeTypes.includes(node.left.type)) {\n        const leftReplacementNode = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: '__p5.strandsNode',\n          },\n          arguments: [node.left]\n        };\n        node.left = leftReplacementNode;\n      }\n      // Replace the binary operator with a call expression\n      // in other words a call to BaseNode.mult(), .div() etc.\n      node.type = 'CallExpression';\n      node.callee = {\n        type: 'MemberExpression',\n        object: node.left,\n        property: {\n          type: 'Identifier',\n          name: replaceBinaryOperator(node.operator),\n        },\n      };\n      node.arguments = [node.right];\n    },\n    IfStatement(node, _state, ancestors) {\n      if (ancestors.some(nodeIsUniform)) { return; }\n      // Transform if statement into strandsIf() call\n      // The condition is evaluated directly, not wrapped in a function\n      const condition = node.test;\n      // Create the then function\n      const thenFunction = {\n        type: 'ArrowFunctionExpression',\n        params: [],\n        body: node.consequent.type === 'BlockStatement' ? node.consequent : {\n          type: 'BlockStatement',\n          body: [node.consequent]\n        }\n      };\n      // Start building the call chain: __p5.strandsIf(condition, then)\n      let callExpression = {\n        type: 'CallExpression',\n        callee: {\n          type: 'Identifier',\n          name: '__p5.strandsIf'\n        },\n        arguments: [condition, thenFunction]\n      };\n      // Always chain .Else() even if there's no explicit else clause\n      // This ensures the conditional completes and returns phi nodes\n      let elseFunction;\n      if (node.alternate) {\n        elseFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [],\n          body: node.alternate.type === 'BlockStatement' ? node.alternate : {\n            type: 'BlockStatement',\n            body: [node.alternate]\n          }\n        };\n      } else {\n        // Create an empty else function\n        elseFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [],\n          body: {\n            type: 'BlockStatement',\n            body: []\n          }\n        };\n      }\n      callExpression = {\n        type: 'CallExpression',\n        callee: {\n          type: 'MemberExpression',\n          object: callExpression,\n          property: {\n            type: 'Identifier',\n            name: 'Else'\n          }\n        },\n        arguments: [elseFunction]\n      };\n      // Analyze which outer scope variables are assigned in any branch\n      const assignedVars = new Set();\n      const analyzeBlock = (body) => {\n        if (body.type !== 'BlockStatement') return;\n        // First pass: collect variable declarations within this block\n        const localVars = new Set();\n        for (const stmt of body.body) {\n          if (stmt.type === 'VariableDeclaration') {\n            for (const decl of stmt.declarations) {\n              if (decl.id.type === 'Identifier') {\n                localVars.add(decl.id.name);\n              }\n            }\n          }\n        }\n        // Second pass: find assignments to non-local variables\n        for (const stmt of body.body) {\n          if (stmt.type === 'ExpressionStatement' &&\n              stmt.expression.type === 'AssignmentExpression') {\n            const left = stmt.expression.left;\n            if (left.type === 'Identifier') {\n              // Direct variable assignment: x = value\n              if (!localVars.has(left.name)) {\n                assignedVars.add(left.name);\n              }\n            } else if (left.type === 'MemberExpression' &&\n                       left.object.type === 'Identifier') {\n              // Property assignment: obj.prop = value\n              if (!localVars.has(left.object.name)) {\n                assignedVars.add(left.object.name);\n              }\n            }\n          } else if (stmt.type === 'BlockStatement') {\n            // Recursively analyze nested block statements\n            analyzeBlock(stmt);\n          }\n        }\n      };\n      // Analyze all branches for assignments to outer scope variables\n      analyzeBlock(thenFunction.body);\n      analyzeBlock(elseFunction.body);\n      if (assignedVars.size > 0) {\n        // Add copying, reference replacement, and return statements to branch functions\n        const addCopyingAndReturn = (functionBody, varsToReturn) => {\n          if (functionBody.type === 'BlockStatement') {\n            // Create temporary variables and copy statements\n            const tempVarMap = new Map(); // original name -> temp name\n            const copyStatements = [];\n            for (const varName of varsToReturn) {\n              const tempName = `__copy_${varName}_${blockVarCounter++}`;\n              tempVarMap.set(varName, tempName);\n              // let tempName = originalVar.copy()\n              copyStatements.push({\n                type: 'VariableDeclaration',\n                declarations: [{\n                  type: 'VariableDeclarator',\n                  id: { type: 'Identifier', name: tempName },\n                  init: {\n                    type: 'CallExpression',\n                    callee: {\n                      type: 'MemberExpression',\n                      object: { type: 'Identifier', name: varName },\n                      property: { type: 'Identifier', name: 'copy' },\n                      computed: false\n                    },\n                    arguments: []\n                  }\n                }],\n                kind: 'let'\n              });\n            }\n            // Replace all references to original variables with temp variables\n            // and wrap literal assignments in strandsNode calls\n            const replaceReferences = (node) => {\n              if (!node || typeof node !== 'object') return;\n              if (node.type === 'Identifier' && tempVarMap.has(node.name)) {\n                node.name = tempVarMap.get(node.name);\n              } else if (node.type === 'MemberExpression' &&\n                         node.object.type === 'Identifier' &&\n                         tempVarMap.has(node.object.name)) {\n                node.object.name = tempVarMap.get(node.object.name);\n              }\n              // Handle literal assignments to temp variables\n              if (node.type === 'AssignmentExpression' &&\n                  node.left.type === 'Identifier' &&\n                  tempVarMap.has(node.left.name) &&\n                  (node.right.type === 'Literal' || node.right.type === 'ArrayExpression')) {\n                // Wrap the right hand side in a strandsNode call to make sure\n                // it's not just a literal and has a type\n                node.right = {\n                  type: 'CallExpression',\n                  callee: {\n                    type: 'Identifier',\n                    name: '__p5.strandsNode'\n                  },\n                  arguments: [node.right]\n                };\n              }\n              // Recursively process all properties\n              for (const key in node) {\n                if (node.hasOwnProperty(key) && key !== 'parent') {\n                  if (Array.isArray(node[key])) {\n                    node[key].forEach(replaceReferences);\n                  } else if (typeof node[key] === 'object') {\n                    replaceReferences(node[key]);\n                  }\n                }\n              }\n            };\n            // Apply reference replacement to all statements\n            functionBody.body.forEach(replaceReferences);\n            // Insert copy statements at the beginning\n            functionBody.body.unshift(...copyStatements);\n            // Add return statement with temp variable names\n            const returnObj = {\n              type: 'ObjectExpression',\n              properties: Array.from(varsToReturn).map(varName => ({\n                type: 'Property',\n                key: { type: 'Identifier', name: varName },\n                value: { type: 'Identifier', name: tempVarMap.get(varName) },\n                kind: 'init',\n                computed: false,\n                shorthand: false\n              }))\n            };\n            functionBody.body.push({\n              type: 'ReturnStatement',\n              argument: returnObj\n            });\n          }\n        };\n        addCopyingAndReturn(thenFunction.body, assignedVars);\n        addCopyingAndReturn(elseFunction.body, assignedVars);\n        // Create a block variable to capture the return value\n        const blockVar = `__block_${blockVarCounter++}`;\n        // Replace with a block statement\n        const statements = [];\n        // Make sure every assigned variable starts as a node\n        for (const varName of assignedVars) {\n          statements.push({\n            type: 'ExpressionStatement',\n            expression: {\n              type: 'AssignmentExpression',\n              operator: '=',\n              left: { type: 'Identifier', name: varName },\n              right: {\n                type: 'CallExpression',\n                callee: { type: 'Identifier', name: '__p5.strandsNode' },\n                arguments: [{ type: 'Identifier', name: varName }],\n              }\n            }\n          });\n        }\n        statements.push({\n          type: 'VariableDeclaration',\n          declarations: [{\n            type: 'VariableDeclarator',\n            id: { type: 'Identifier', name: blockVar },\n            init: callExpression\n          }],\n          kind: 'const'\n        });\n        // 2. Assignments for each modified variable\n        for (const varName of assignedVars) {\n          statements.push({\n            type: 'ExpressionStatement',\n            expression: {\n              type: 'AssignmentExpression',\n              operator: '=',\n              left: { type: 'Identifier', name: varName },\n              right: {\n                type: 'MemberExpression',\n                object: { type: 'Identifier', name: blockVar },\n                property: { type: 'Identifier', name: varName },\n                computed: false\n              }\n            }\n          });\n        }\n        // Replace the if statement with a block statement\n        node.type = 'BlockStatement';\n        node.body = statements;\n      } else {\n        // No assignments, just replace with the call expression\n        node.type = 'ExpressionStatement';\n        node.expression = callExpression;\n      }\n      delete node.test;\n      delete node.consequent;\n      delete node.alternate;\n    },\n    UpdateExpression(node, _state, ancestors) {\n      if (ancestors.some(nodeIsUniform)) { return; }\n\n      // Transform ++var, var++, --var, var-- into assignment expressions\n      let operator;\n      if (node.operator === '++') {\n        operator = '+';\n      } else if (node.operator === '--') {\n        operator = '-';\n      } else {\n        return; // Unknown update operator\n      }\n\n      // Convert to: var = var + 1 or var = var - 1\n      const assignmentExpr = {\n        type: 'AssignmentExpression',\n        operator: '=',\n        left: node.argument,\n        right: {\n          type: 'BinaryExpression',\n          operator: operator,\n          left: node.argument,\n          right: {\n            type: 'Literal',\n            value: 1\n          }\n        }\n      };\n\n      // Replace the update expression with the assignment expression\n      Object.assign(node, assignmentExpr);\n      delete node.prefix;\n      this.BinaryExpression(node.right, _state, [...ancestors, node]);\n      this.AssignmentExpression(node, _state, ancestors);\n    },\n    ForStatement(node, _state, ancestors) {\n      if (ancestors.some(nodeIsUniform)) { return; }\n\n      // Transform for statement into strandsFor() call\n      // for (init; test; update) body -> strandsFor(initCb, conditionCb, updateCb, bodyCb, initialVars)\n\n      // Create the initial callback from the for loop's init\n      let initialFunction;\n      if (node.init && node.init.type === 'VariableDeclaration') {\n        // Handle: for (let i = 0; ...)\n        const declaration = node.init.declarations[0];\n        let initValue = declaration.init;\n\n        const initAst = { body: [{ type: 'ExpressionStatement', expression: initValue }] };\n        initValue = initAst.body[0].expression;\n\n        initialFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [],\n          body: {\n            type: 'BlockStatement',\n            body: [{\n              type: 'ReturnStatement',\n              argument: initValue\n            }]\n          }\n        };\n      } else {\n        // Handle other cases - return a default value\n        initialFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [],\n          body: {\n            type: 'BlockStatement',\n            body: [{\n              type: 'ReturnStatement',\n              argument: {\n                type: 'Literal',\n                value: 0\n              }\n            }]\n          }\n        };\n      }\n\n      // Create the condition callback\n      let conditionBody = node.test || { type: 'Literal', value: true };\n      // Replace loop variable references with the parameter\n      if (node.init?.type === 'VariableDeclaration') {\n        const loopVarName = node.init.declarations[0].id.name;\n        conditionBody = this.replaceIdentifierReferences(conditionBody, loopVarName, 'loopVar');\n      }\n      const conditionAst = { body: [{ type: 'ExpressionStatement', expression: conditionBody }] };\n      conditionBody = conditionAst.body[0].expression;\n\n      const conditionFunction = {\n        type: 'ArrowFunctionExpression',\n        params: [{ type: 'Identifier', name: 'loopVar' }],\n        body: conditionBody\n      };\n\n      // Create the update callback\n      let updateFunction;\n      if (node.update) {\n        let updateExpr = node.update;\n        // Replace loop variable references with the parameter\n        if (node.init?.type === 'VariableDeclaration') {\n          const loopVarName = node.init.declarations[0].id.name;\n          updateExpr = this.replaceIdentifierReferences(updateExpr, loopVarName, 'loopVar');\n        }\n        const updateAst = { body: [{ type: 'ExpressionStatement', expression: updateExpr }] };\n        updateExpr = updateAst.body[0].expression;\n\n        updateFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [{ type: 'Identifier', name: 'loopVar' }],\n          body: {\n            type: 'BlockStatement',\n            body: [{\n              type: 'ReturnStatement',\n              argument: updateExpr\n            }]\n          }\n        };\n      } else {\n        updateFunction = {\n          type: 'ArrowFunctionExpression',\n          params: [{ type: 'Identifier', name: 'loopVar' }],\n          body: {\n            type: 'BlockStatement',\n            body: [{\n              type: 'ReturnStatement',\n              argument: { type: 'Identifier', name: 'loopVar' }\n            }]\n          }\n        };\n      }\n\n      // Create the body callback\n      let bodyBlock = node.body.type === 'BlockStatement' ? node.body : {\n        type: 'BlockStatement',\n        body: [node.body]\n      };\n\n      // Replace loop variable references in the body\n      if (node.init?.type === 'VariableDeclaration') {\n        const loopVarName = node.init.declarations[0].id.name;\n        bodyBlock = this.replaceIdentifierReferences(bodyBlock, loopVarName, 'loopVar');\n      }\n\n      const bodyFunction = {\n        type: 'ArrowFunctionExpression',\n        params: [\n          { type: 'Identifier', name: 'loopVar' },\n          { type: 'Identifier', name: 'vars' }\n        ],\n        body: bodyBlock\n      };\n\n      // Analyze which outer scope variables are assigned in the loop body\n      const assignedVars = new Set();\n      const analyzeBlock = (body, parentLocalVars = new Set()) => {\n        if (body.type !== 'BlockStatement') return;\n\n        // First pass: collect variable declarations within this block\n        const localVars = new Set([...parentLocalVars]);\n        for (const stmt of body.body) {\n          if (stmt.type === 'VariableDeclaration') {\n            for (const decl of stmt.declarations) {\n              if (decl.id.type === 'Identifier') {\n                localVars.add(decl.id.name);\n              }\n            }\n          }\n        }\n\n        // Second pass: find assignments to non-local variables\n        for (const stmt of body.body) {\n          if (stmt.type === 'ExpressionStatement' &&\n              stmt.expression.type === 'AssignmentExpression') {\n            const left = stmt.expression.left;\n            if (left.type === 'Identifier') {\n              // Direct variable assignment: x = value\n              if (!localVars.has(left.name)) {\n                assignedVars.add(left.name);\n              }\n            } else if (left.type === 'MemberExpression' &&\n                       left.object.type === 'Identifier') {\n              // Property assignment: obj.prop = value (includes swizzles)\n              if (!localVars.has(left.object.name)) {\n                assignedVars.add(left.object.name);\n              }\n            }\n          } else if (stmt.type === 'BlockStatement') {\n            // Recursively analyze nested block statements, passing down local vars\n            analyzeBlock(stmt, localVars);\n          }\n        }\n      };\n\n      analyzeBlock(bodyFunction.body);\n\n      if (assignedVars.size > 0) {\n        // Add copying, reference replacement, and return statements similar to if statements\n        const addCopyingAndReturn = (functionBody, varsToReturn) => {\n          if (functionBody.type === 'BlockStatement') {\n            const tempVarMap = new Map();\n            const copyStatements = [];\n\n            for (const varName of varsToReturn) {\n              const tempName = `__copy_${varName}_${blockVarCounter++}`;\n              tempVarMap.set(varName, tempName);\n\n              copyStatements.push({\n                type: 'VariableDeclaration',\n                declarations: [{\n                  type: 'VariableDeclarator',\n                  id: { type: 'Identifier', name: tempName },\n                  init: {\n                    type: 'CallExpression',\n                    callee: {\n                      type: 'MemberExpression',\n                      object: {\n                        type: 'MemberExpression',\n                        object: { type: 'Identifier', name: 'vars' },\n                        property: { type: 'Identifier', name: varName },\n                        computed: false\n                      },\n                      property: { type: 'Identifier', name: 'copy' },\n                      computed: false\n                    },\n                    arguments: []\n                  }\n                }],\n                kind: 'let'\n              });\n            }\n\n            // Replace references to original variables with temp variables\n            const replaceReferences = (node) => {\n              if (!node || typeof node !== 'object') return;\n              if (node.type === 'Identifier' && tempVarMap.has(node.name)) {\n                node.name = tempVarMap.get(node.name);\n              }\n\n              for (const key in node) {\n                if (node.hasOwnProperty(key) && key !== 'parent') {\n                  if (Array.isArray(node[key])) {\n                    node[key].forEach(replaceReferences);\n                  } else if (typeof node[key] === 'object') {\n                    replaceReferences(node[key]);\n                  }\n                }\n              }\n            };\n\n            functionBody.body.forEach(replaceReferences);\n            functionBody.body.unshift(...copyStatements);\n\n            // Add return statement\n            const returnObj = {\n              type: 'ObjectExpression',\n              properties: Array.from(varsToReturn).map(varName => ({\n                type: 'Property',\n                key: { type: 'Identifier', name: varName },\n                value: { type: 'Identifier', name: tempVarMap.get(varName) },\n                kind: 'init',\n                computed: false,\n                shorthand: false\n              }))\n            };\n\n            functionBody.body.push({\n              type: 'ReturnStatement',\n              argument: returnObj\n            });\n          }\n        };\n\n        addCopyingAndReturn(bodyFunction.body, assignedVars);\n\n        // Create block variable and assignments similar to if statements\n        const blockVar = `__block_${blockVarCounter++}`;\n        const statements = [];\n\n        // Create initial vars object from assigned variables\n        const initialVarsProperties = [];\n        for (const varName of assignedVars) {\n          initialVarsProperties.push({\n            type: 'Property',\n            key: { type: 'Identifier', name: varName },\n            value: {\n              type: 'CallExpression',\n              callee: {\n                type: 'Identifier',\n                name: '__p5.strandsNode',\n              },\n              arguments: [\n                { type: 'Identifier', name: varName },\n              ],\n            },\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed: false\n          });\n        }\n\n        const initialVarsObject = {\n          type: 'ObjectExpression',\n          properties: initialVarsProperties\n        };\n\n        // Create the strandsFor call\n        const callExpression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: '__p5.strandsFor'\n          },\n          arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, initialVarsObject]\n        };\n\n        statements.push({\n          type: 'VariableDeclaration',\n          declarations: [{\n            type: 'VariableDeclarator',\n            id: { type: 'Identifier', name: blockVar },\n            init: callExpression\n          }],\n          kind: 'const'\n        });\n\n        // Add assignments back to original variables\n        for (const varName of assignedVars) {\n          statements.push({\n            type: 'ExpressionStatement',\n            expression: {\n              type: 'AssignmentExpression',\n              operator: '=',\n              left: { type: 'Identifier', name: varName },\n              right: {\n                type: 'MemberExpression',\n                object: { type: 'Identifier', name: blockVar },\n                property: { type: 'Identifier', name: varName },\n                computed: false\n              }\n            }\n          });\n        }\n\n        node.type = 'BlockStatement';\n        node.body = statements;\n      } else {\n        // No assignments, just replace with call expression\n        node.type = 'ExpressionStatement';\n        node.expression = {\n          type: 'CallExpression',\n          callee: {\n            type: 'Identifier',\n            name: '__p5.strandsFor'\n          },\n          arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, {\n            type: 'ObjectExpression',\n            properties: []\n          }]\n        };\n      }\n\n      delete node.init;\n      delete node.test;\n      delete node.update;\n    },\n\n    // Helper method to replace identifier references in AST nodes\n    replaceIdentifierReferences(node, oldName, newName) {\n      if (!node || typeof node !== 'object') return node;\n\n      const replaceInNode = (n) => {\n        if (!n || typeof n !== 'object') return n;\n\n        if (n.type === 'Identifier' && n.name === oldName) {\n          return { ...n, name: newName };\n        }\n\n        // Create a copy and recursively process properties\n        const newNode = { ...n };\n        for (const key in n) {\n          if (n.hasOwnProperty(key) && key !== 'parent') {\n            if (Array.isArray(n[key])) {\n              newNode[key] = n[key].map(replaceInNode);\n            } else if (typeof n[key] === 'object') {\n              newNode[key] = replaceInNode(n[key]);\n            }\n          }\n        }\n        return newNode;\n      };\n\n      return replaceInNode(node);\n    }\n  };\n  function transpileStrandsToJS(p5, sourceString, srcLocations, scope) {\n    const ast = parse(sourceString, {\n      ecmaVersion: 2021,\n      locations: srcLocations\n    });\n    // First pass: transform everything except if/for statements using normal ancestor traversal\n    const nonControlFlowCallbacks = { ...ASTCallbacks };\n    delete nonControlFlowCallbacks.IfStatement;\n    delete nonControlFlowCallbacks.ForStatement;\n    ancestor(ast, nonControlFlowCallbacks, undefined, { varyings: {} });\n    // Second pass: transform if/for statements in post-order using recursive traversal\n    const postOrderControlFlowTransform = {\n      IfStatement(node, state, c) {\n        // First recursively process children\n        if (node.test) c(node.test, state);\n        if (node.consequent) c(node.consequent, state);\n        if (node.alternate) c(node.alternate, state);\n        // Then apply the transformation to this node\n        ASTCallbacks.IfStatement(node, state, []);\n      },\n      ForStatement(node, state, c) {\n        // First recursively process children\n        if (node.init) c(node.init, state);\n        if (node.test) c(node.test, state);\n        if (node.update) c(node.update, state);\n        if (node.body) c(node.body, state);\n        // Then apply the transformation to this node\n        ASTCallbacks.ForStatement(node, state, []);\n      }\n    };\n    recursive(ast, { varyings: {} }, postOrderControlFlowTransform);\n    const transpiledSource = escodegen.generate(ast);\n    const scopeKeys = Object.keys(scope);\n    const internalStrandsCallback = new Function(\n        // Create a parameter called __p5, not just p5, because users of instance mode\n        // may pass in a variable called p5 as a scope variable. If we rely on a variable called\n        // p5, then the scope variable called p5 might accidentally override internal function\n        // calls to p5 static methods.\n      '__p5',\n      ...scopeKeys,\n      transpiledSource\n      .slice(\n        transpiledSource.indexOf('{') + 1,\n        transpiledSource.lastIndexOf('}')\n      ).replaceAll(';', '')\n    );\n    return () => internalStrandsCallback(p5, ...scopeKeys.map(key => scope[key]));\n  }\n\nexport { transpileStrandsToJS };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2125, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/ir_cfg.js"],"sourcesContent":["import { BlockTypeToName } from './ir_types.js';\nimport { internalError } from './strands_FES.js';\n\n// Todo: remove edges to simplify. Block order is always ordered already.\n\nfunction createControlFlowGraph() {\n  return {\n    // graph structure\n    blockTypes: [],\n    incomingEdges: [],\n    outgoingEdges: [],\n    blockInstructions: [],\n    // runtime data for constructing graph\n    nextID: 0,\n    blockStack: [],\n    blockOrder: [],\n    blockConditions: {},\n    currentBlock: -1,\n  };\n}\n\nfunction pushBlock(graph, blockID) {\n  graph.blockStack.push(blockID);\n  graph.blockOrder.push(blockID);\n  graph.currentBlock = blockID;\n}\n\nfunction popBlock(graph) {\n  graph.blockStack.pop();\n  const len = graph.blockStack.length;\n  graph.currentBlock = graph.blockStack[len-1];\n}\n\nfunction pushBlockForModification(graph, blockID) {\n  graph.blockStack.push(blockID);\n  graph.currentBlock = blockID;\n}\n\nfunction createBasicBlock(graph, blockType) {\n  const id = graph.nextID++;\n  graph.blockTypes[id] = blockType;\n  graph.incomingEdges[id] = [];\n  graph.outgoingEdges[id] = [];\n  graph.blockInstructions[id]= [];\n  return id;\n}\n\nfunction addEdge(graph, from, to) {\n  graph.outgoingEdges[from].push(to);\n  graph.incomingEdges[to].push(from);\n}\n\nfunction recordInBasicBlock(graph, blockID, nodeID) {\n  if (nodeID === undefined) {\n    internalError('undefined nodeID in `recordInBasicBlock()`');\n  }\n  if (blockID === undefined) {\n    internalError('undefined blockID in `recordInBasicBlock()');\n  }\n  graph.blockInstructions[blockID] = graph.blockInstructions[blockID] || [];\n  graph.blockInstructions[blockID].push(nodeID);\n}\n\nfunction getBlockDataFromID(graph, id) {\n  return {\n    id,\n    blockType: graph.blockTypes[id],\n    incomingEdges: graph.incomingEdges[id],\n    outgoingEdges: graph.outgoingEdges[id],\n    blockInstructions: graph.blockInstructions[id],\n  }\n}\n\nfunction printBlockData(graph, id) {\n  const block = getBlockDataFromID(graph, id);\n  block.blockType = BlockTypeToName[block.blockType];\n  console.log(block);\n}\n\nfunction sortCFG(adjacencyList, start) {\n  const visited = new Set();\n  const postOrder = [];\n  function dfs(v) {\n    if (visited.has(v)) {\n      return;\n    }\n    visited.add(v);\n    for (let w of adjacencyList[v].sort((a, b) => b-a) || []) {\n      dfs(w);\n    }\n    postOrder.push(v);\n  }\n\n  dfs(start);\n  return postOrder.reverse();\n}\n\nexport { addEdge, createBasicBlock, createControlFlowGraph, getBlockDataFromID, popBlock, printBlockData, pushBlock, pushBlockForModification, recordInBasicBlock, sortCFG };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;;;AAEA,yEAAyE;AAEzE,SAAS;IACP,OAAO;QACL,kBAAkB;QAClB,YAAY,EAAE;QACd,eAAe,EAAE;QACjB,eAAe,EAAE;QACjB,mBAAmB,EAAE;QACrB,sCAAsC;QACtC,QAAQ;QACR,YAAY,EAAE;QACd,YAAY,EAAE;QACd,iBAAiB,CAAC;QAClB,cAAc,CAAC;IACjB;AACF;AAEA,SAAS,UAAU,KAAK,EAAE,OAAO;IAC/B,MAAM,UAAU,CAAC,IAAI,CAAC;IACtB,MAAM,UAAU,CAAC,IAAI,CAAC;IACtB,MAAM,YAAY,GAAG;AACvB;AAEA,SAAS,SAAS,KAAK;IACrB,MAAM,UAAU,CAAC,GAAG;IACpB,MAAM,MAAM,MAAM,UAAU,CAAC,MAAM;IACnC,MAAM,YAAY,GAAG,MAAM,UAAU,CAAC,MAAI,EAAE;AAC9C;AAEA,SAAS,yBAAyB,KAAK,EAAE,OAAO;IAC9C,MAAM,UAAU,CAAC,IAAI,CAAC;IACtB,MAAM,YAAY,GAAG;AACvB;AAEA,SAAS,iBAAiB,KAAK,EAAE,SAAS;IACxC,MAAM,KAAK,MAAM,MAAM;IACvB,MAAM,UAAU,CAAC,GAAG,GAAG;IACvB,MAAM,aAAa,CAAC,GAAG,GAAG,EAAE;IAC5B,MAAM,aAAa,CAAC,GAAG,GAAG,EAAE;IAC5B,MAAM,iBAAiB,CAAC,GAAG,GAAE,EAAE;IAC/B,OAAO;AACT;AAEA,SAAS,QAAQ,KAAK,EAAE,IAAI,EAAE,EAAE;IAC9B,MAAM,aAAa,CAAC,KAAK,CAAC,IAAI,CAAC;IAC/B,MAAM,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC;AAC/B;AAEA,SAAS,mBAAmB,KAAK,EAAE,OAAO,EAAE,MAAM;IAChD,IAAI,WAAW,WAAW;QACxB,IAAA,wKAAa,EAAC;IAChB;IACA,IAAI,YAAY,WAAW;QACzB,IAAA,wKAAa,EAAC;IAChB;IACA,MAAM,iBAAiB,CAAC,QAAQ,GAAG,MAAM,iBAAiB,CAAC,QAAQ,IAAI,EAAE;IACzE,MAAM,iBAAiB,CAAC,QAAQ,CAAC,IAAI,CAAC;AACxC;AAEA,SAAS,mBAAmB,KAAK,EAAE,EAAE;IACnC,OAAO;QACL;QACA,WAAW,MAAM,UAAU,CAAC,GAAG;QAC/B,eAAe,MAAM,aAAa,CAAC,GAAG;QACtC,eAAe,MAAM,aAAa,CAAC,GAAG;QACtC,mBAAmB,MAAM,iBAAiB,CAAC,GAAG;IAChD;AACF;AAEA,SAAS,eAAe,KAAK,EAAE,EAAE;IAC/B,MAAM,QAAQ,mBAAmB,OAAO;IACxC,MAAM,SAAS,GAAG,uKAAe,CAAC,MAAM,SAAS,CAAC;IAClD,QAAQ,GAAG,CAAC;AACd;AAEA,SAAS,QAAQ,aAAa,EAAE,KAAK;IACnC,MAAM,UAAU,IAAI;IACpB,MAAM,YAAY,EAAE;IACpB,SAAS,IAAI,CAAC;QACZ,IAAI,QAAQ,GAAG,CAAC,IAAI;YAClB;QACF;QACA,QAAQ,GAAG,CAAC;QACZ,KAAK,IAAI,KAAK,aAAa,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,IAAE,MAAM,EAAE,CAAE;YACxD,IAAI;QACN;QACA,UAAU,IAAI,CAAC;IACjB;IAEA,IAAI;IACJ,OAAO,UAAU,OAAO;AAC1B","ignoreList":[0]}},
    {"offset": {"line": 2238, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_codegen.js"],"sourcesContent":["import { sortCFG } from './ir_cfg.js';\nimport { structType, TypeInfoFromGLSLName } from './ir_types.js';\nimport './strands_FES.js';\n\nfunction generateShaderCode(strandsContext) {\n  const {\n    cfg,\n    backend,\n    vertexDeclarations,\n    fragmentDeclarations\n  } = strandsContext;\n\n  const hooksObj = {\n    uniforms: {},\n  };\n\n  for (const {name, typeInfo, defaultValue} of strandsContext.uniforms) {\n    const declaration = backend.generateUniformDeclaration(name, typeInfo);\n    hooksObj.uniforms[declaration] = defaultValue;\n  }\n\n  for (const { hookType, rootNodeID, entryBlockID, shaderContext } of strandsContext.hooks) {\n    const generationContext = {\n      indent: 1,\n      codeLines: [],\n      write(line) {\n        this.codeLines.push('  '.repeat(this.indent) + line);\n      },\n      tempNames: {},\n      declarations: [],\n      nextTempID: 0,\n      visitedNodes: new Set(),\n      shaderContext, // 'vertex' or 'fragment'\n      strandsContext, // For shared variable tracking\n    };\n\n    const blocks = sortCFG(cfg.outgoingEdges, entryBlockID);\n    for (const blockID of blocks) {\n      backend.generateBlock(blockID, strandsContext, generationContext);\n    }\n\n    // Process any unvisited global assignments to ensure side effects are generated\n    for (const assignmentNodeID of strandsContext.globalAssignments) {\n      if (!generationContext.visitedNodes.has(assignmentNodeID)) {\n        // This assignment hasn't been visited yet, so we need to generate it\n        backend.generateAssignment(generationContext, strandsContext.dag, assignmentNodeID);\n        generationContext.visitedNodes.add(assignmentNodeID);\n      }\n    }\n\n    // Reset global assignments for next hook\n    strandsContext.globalAssignments = [];\n\n    const firstLine = backend.hookEntry(hookType);\n    let returnType = hookType.returnType.properties\n      ? structType(hookType.returnType)\n      : TypeInfoFromGLSLName[hookType.returnType.typeName];\n    backend.generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType);\n    hooksObj[`${hookType.returnType.typeName} ${hookType.name}`] = [firstLine, ...generationContext.codeLines, '}'].join('\\n');\n  }\n\n  // Finalize shared variable declarations based on usage\n  if (strandsContext.sharedVariables) {\n    for (const [varName, varInfo] of strandsContext.sharedVariables) {\n      if (varInfo.usedInVertex && varInfo.usedInFragment) {\n        // Used in both shaders - declare as varying\n        vertexDeclarations.add(`OUT ${varInfo.typeInfo.fnName} ${varName};`);\n        fragmentDeclarations.add(`IN ${varInfo.typeInfo.fnName} ${varName};`);\n      } else if (varInfo.usedInVertex) {\n        // Only used in vertex shader - declare as local variable\n        vertexDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);\n      } else if (varInfo.usedInFragment) {\n        // Only used in fragment shader - declare as local variable\n        fragmentDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);\n      }\n      // If not used anywhere, don't declare it\n    }\n  }\n\n  hooksObj.vertexDeclarations = [...vertexDeclarations].join('\\n');\n  hooksObj.fragmentDeclarations = [...fragmentDeclarations].join('\\n');\n\n  return hooksObj;\n}\n\nexport { generateShaderCode };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,SAAS,mBAAmB,cAAc;IACxC,MAAM,EACJ,GAAG,EACH,OAAO,EACP,kBAAkB,EAClB,oBAAoB,EACrB,GAAG;IAEJ,MAAM,WAAW;QACf,UAAU,CAAC;IACb;IAEA,KAAK,MAAM,EAAC,IAAI,EAAE,QAAQ,EAAE,YAAY,EAAC,IAAI,eAAe,QAAQ,CAAE;QACpE,MAAM,cAAc,QAAQ,0BAA0B,CAAC,MAAM;QAC7D,SAAS,QAAQ,CAAC,YAAY,GAAG;IACnC;IAEA,KAAK,MAAM,EAAE,QAAQ,EAAE,UAAU,EAAE,YAAY,EAAE,aAAa,EAAE,IAAI,eAAe,KAAK,CAAE;QACxF,MAAM,oBAAoB;YACxB,QAAQ;YACR,WAAW,EAAE;YACb,OAAM,IAAI;gBACR,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,MAAM,CAAC,IAAI,CAAC,MAAM,IAAI;YACjD;YACA,WAAW,CAAC;YACZ,cAAc,EAAE;YAChB,YAAY;YACZ,cAAc,IAAI;YAClB;YACA;QACF;QAEA,MAAM,SAAS,IAAA,6JAAO,EAAC,IAAI,aAAa,EAAE;QAC1C,KAAK,MAAM,WAAW,OAAQ;YAC5B,QAAQ,aAAa,CAAC,SAAS,gBAAgB;QACjD;QAEA,gFAAgF;QAChF,KAAK,MAAM,oBAAoB,eAAe,iBAAiB,CAAE;YAC/D,IAAI,CAAC,kBAAkB,YAAY,CAAC,GAAG,CAAC,mBAAmB;gBACzD,qEAAqE;gBACrE,QAAQ,kBAAkB,CAAC,mBAAmB,eAAe,GAAG,EAAE;gBAClE,kBAAkB,YAAY,CAAC,GAAG,CAAC;YACrC;QACF;QAEA,yCAAyC;QACzC,eAAe,iBAAiB,GAAG,EAAE;QAErC,MAAM,YAAY,QAAQ,SAAS,CAAC;QACpC,IAAI,aAAa,SAAS,UAAU,CAAC,UAAU,GAC3C,IAAA,kKAAU,EAAC,SAAS,UAAU,IAC9B,4KAAoB,CAAC,SAAS,UAAU,CAAC,QAAQ,CAAC;QACtD,QAAQ,uBAAuB,CAAC,gBAAgB,mBAAmB,YAAY;QAC/E,QAAQ,CAAC,GAAG,SAAS,UAAU,CAAC,QAAQ,CAAC,CAAC,EAAE,SAAS,IAAI,EAAE,CAAC,GAAG;YAAC;eAAc,kBAAkB,SAAS;YAAE;SAAI,CAAC,IAAI,CAAC;IACvH;IAEA,uDAAuD;IACvD,IAAI,eAAe,eAAe,EAAE;QAClC,KAAK,MAAM,CAAC,SAAS,QAAQ,IAAI,eAAe,eAAe,CAAE;YAC/D,IAAI,QAAQ,YAAY,IAAI,QAAQ,cAAc,EAAE;gBAClD,4CAA4C;gBAC5C,mBAAmB,GAAG,CAAC,CAAC,IAAI,EAAE,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;gBACnE,qBAAqB,GAAG,CAAC,CAAC,GAAG,EAAE,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;YACtE,OAAO,IAAI,QAAQ,YAAY,EAAE;gBAC/B,yDAAyD;gBACzD,mBAAmB,GAAG,CAAC,GAAG,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;YACjE,OAAO,IAAI,QAAQ,cAAc,EAAE;gBACjC,2DAA2D;gBAC3D,qBAAqB,GAAG,CAAC,GAAG,QAAQ,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC;YACnE;QACA,yCAAyC;QAC3C;IACF;IAEA,SAAS,kBAAkB,GAAG;WAAI;KAAmB,CAAC,IAAI,CAAC;IAC3D,SAAS,oBAAoB,GAAG;WAAI;KAAqB,CAAC,IAAI,CAAC;IAE/D,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2324, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_builtins.js"],"sourcesContent":["import { DataType, GenType } from './ir_types.js';\n\n// Need the .js extension because we also import this from a Node script.\n// Try to keep this file minimal because of that.\n\n// GLSL Built in functions\n// https://docs.gl/el3/abs\nconst builtInGLSLFunctions = {\n  //////////// Trigonometry //////////\n  acos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  acosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  asin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  asinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  atan: [\n    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n  ],\n  atanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  cos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  cosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  degrees: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  radians: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  sin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT , isp5Function: true}],\n  sinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  tan: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  tanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n\n  ////////// Mathematics //////////\n  abs: [\n    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.FLOAT], returnType: GenType.INT, isp5Function: true}\n  ],\n  ceil: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  clamp: [\n    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [GenType.FLOAT,DataType.float1,DataType.float1], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [GenType.INT, GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: false},\n    { params: [GenType.INT, DataType.int1, DataType.int1], returnType: GenType.INT, isp5Function: false},\n  ],\n  dFdx: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  dFdy: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  exp: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  exp2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  floor: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  fma: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  fract: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  fwidth: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  inversesqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  // \"isinf\": [{}],\n  // \"isnan\": [{}],\n  log: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  log2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  max: [\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.FLOAT,DataType.float1], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true},\n    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true},\n  ],\n  min: [\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.FLOAT,DataType.float1], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true},\n    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true},\n  ],\n  mix: [\n    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [GenType.FLOAT, GenType.FLOAT,DataType.float1], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [GenType.FLOAT, GenType.FLOAT, GenType.BOOL], returnType: GenType.FLOAT, isp5Function: false},\n  ],\n  mod: [\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true},\n    { params: [GenType.FLOAT,DataType.float1], returnType: GenType.FLOAT, isp5Function: true},\n  ],\n  // \"modf\": [{}],\n  pow: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  round: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  roundEven: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  sign: [\n    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [GenType.INT], returnType: GenType.INT, isp5Function: false},\n  ],\n  smoothstep: [\n    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false},\n    { params: [ DataType.float1,DataType.float1, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false},\n  ],\n  sqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  step: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  trunc: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n\n  ////////// Vector //////////\n  cross: [{ params: [DataType.float3, DataType.float3], returnType: DataType.float3, isp5Function: true}],\n  distance: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType:DataType.float1, isp5Function: true}],\n  dot: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType:DataType.float1, isp5Function: true}],\n  equal: [\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false},\n    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false},\n    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false},\n  ],\n  faceforward: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  length: [{ params: [GenType.FLOAT], returnType:DataType.float1, isp5Function: false}],\n  normalize: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true}],\n  notEqual: [\n    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false},\n    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false},\n    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false},\n  ],\n  reflect: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false}],\n  refract: [{ params: [GenType.FLOAT, GenType.FLOAT,DataType.float1], returnType: GenType.FLOAT, isp5Function: false}],\n\n  ////////// Texture sampling //////////\n  texture: [{params: [DataType.sampler2D, DataType.float2], returnType: DataType.float4, isp5Function: true}],\n  getTexture: [{params: [DataType.sampler2D, DataType.float2], returnType: DataType.float4, isp5Function: true}]\n};\n\nconst strandsBuiltinFunctions = {\n  ...builtInGLSLFunctions,\n};\n\nexport { strandsBuiltinFunctions };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3008, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_phi_utils.js"],"sourcesContent":["import { recordInBasicBlock } from './ir_cfg.js';\nimport { getNodeDataFromID, getOrCreateNode } from './ir_dag.js';\nimport { NodeType } from './ir_types.js';\nimport './strands_FES.js';\n\nfunction createPhiNode(strandsContext, phiInputs, varName) {\n  // Determine the proper dimension and baseType from the inputs\n  const validInputs = phiInputs.filter(input => input.value.id !== null);\n  if (validInputs.length === 0) {\n    throw new Error(`No valid inputs for phi node for variable ${varName}`);\n  }\n  // Get dimension and baseType from first valid input\n  const firstInput = getNodeDataFromID(strandsContext.dag, validInputs[0].value.id);\n  const dimension = firstInput.dimension;\n  const baseType = firstInput.baseType;\n  const nodeData = {\n    nodeType: NodeType.PHI,\n    dimension,\n    baseType,\n    dependsOn: phiInputs.map(input => input.value.id).filter(id => id !== null),\n    phiBlocks: phiInputs.map(input => input.blockId)};\n  const id = getOrCreateNode(strandsContext.dag, nodeData);\n  recordInBasicBlock(strandsContext.cfg, strandsContext.cfg.currentBlock, id);\n  return {\n    id,\n    dimension,\n    baseType\n  };\n}\n\nexport { createPhiNode };\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA,SAAS,cAAc,cAAc,EAAE,SAAS,EAAE,OAAO;IACvD,8DAA8D;IAC9D,MAAM,cAAc,UAAU,MAAM,CAAC,CAAA,QAAS,MAAM,KAAK,CAAC,EAAE,KAAK;IACjE,IAAI,YAAY,MAAM,KAAK,GAAG;QAC5B,MAAM,IAAI,MAAM,CAAC,0CAA0C,EAAE,SAAS;IACxE;IACA,oDAAoD;IACpD,MAAM,aAAa,IAAA,uKAAiB,EAAC,eAAe,GAAG,EAAE,WAAW,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE;IAChF,MAAM,YAAY,WAAW,SAAS;IACtC,MAAM,WAAW,WAAW,QAAQ;IACpC,MAAM,WAAW;QACf,UAAU,gKAAQ,CAAC,GAAG;QACtB;QACA;QACA,WAAW,UAAU,GAAG,CAAC,CAAA,QAAS,MAAM,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAA,KAAM,OAAO;QACtE,WAAW,UAAU,GAAG,CAAC,CAAA,QAAS,MAAM,OAAO;IAAC;IAClD,MAAM,KAAK,IAAA,qKAAe,EAAC,eAAe,GAAG,EAAE;IAC/C,IAAA,wKAAkB,EAAC,eAAe,GAAG,EAAE,eAAe,GAAG,CAAC,YAAY,EAAE;IACxE,OAAO;QACL;QACA;QACA;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3050, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_conditionals.js"],"sourcesContent":["import { createBasicBlock, addEdge, pushBlock, popBlock, pushBlockForModification, recordInBasicBlock } from './ir_cfg.js';\nimport { getOrCreateNode } from './ir_dag.js';\nimport { BlockType, NodeType } from './ir_types.js';\nimport { c as createStrandsNode } from '../ir_builders-Cn4s8QTL.js';\nimport { createPhiNode } from './strands_phi_utils.js';\nimport './strands_FES.js';\nimport './strands_builtins.js';\n\nclass StrandsConditional {\n  constructor(strandsContext, condition, branchCallback) {\n    // Condition must be a node...\n    this.branches = [{\n      condition,\n      branchCallback,\n      blockType: BlockType.IF_BODY\n    }];\n    this.ctx = strandsContext;\n  }\n  ElseIf(condition, branchCallback) {\n    this.branches.push({\n      condition,\n      branchCallback,\n      blockType: BlockType.IF_BODY\n    });\n    return this;\n  }\n  Else(branchCallback = () => ({})) {\n    this.branches.push({\n      condition: null,\n      branchCallback,\n      blockType: BlockType.IF_BODY\n    });\n    const phiNodes = buildConditional(this.ctx, this);\n    const assignments = {};\n    for (const [varName, phiNode] of Object.entries(phiNodes)) {\n      assignments[varName] = createStrandsNode(phiNode.id, phiNode.dimension, this.ctx);\n    }\n    return assignments;\n  }\n}\nfunction buildConditional(strandsContext, conditional) {\n  const cfg = strandsContext.cfg;\n  const branches = conditional.branches;\n  const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);\n  const results = [];\n  const branchEndBlocks = [];\n  const mergedAssignments = {};\n  const phiBlockDependencies = {};\n  // Create a BRANCH block to handle phi node declarations\n  const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);\n  addEdge(cfg, cfg.currentBlock, branchBlock);\n  addEdge(cfg, branchBlock, mergeBlock);\n  let previousBlock = branchBlock;\n  for (let i = 0; i < branches.length; i++) {\n    const { condition, branchCallback, blockType } = branches[i];\n    if (condition !== null) {\n      const conditionBlock = createBasicBlock(cfg, BlockType.IF_COND);\n      addEdge(cfg, previousBlock, conditionBlock);\n      pushBlock(cfg, conditionBlock);\n      cfg.blockConditions[conditionBlock] = condition.id;\n      previousBlock = conditionBlock;\n      popBlock(cfg);\n    } else {\n      const elseCondBlock = createBasicBlock(cfg, BlockType.ELSE_COND);\n      addEdge(cfg, previousBlock, elseCondBlock);\n      previousBlock = elseCondBlock;\n    }\n    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);\n    addEdge(cfg, previousBlock, scopeStartBlock);\n    const branchContentBlock = createBasicBlock(cfg, blockType);\n    addEdge(cfg, scopeStartBlock, branchContentBlock);\n    pushBlock(cfg, branchContentBlock);\n    const branchResults = branchCallback();\n    for (const key in branchResults) {\n      if (!phiBlockDependencies[key]) {\n        phiBlockDependencies[key] = [{ value: branchResults[key], blockId: branchContentBlock }];\n      } else {\n        phiBlockDependencies[key].push({ value: branchResults[key], blockId: branchContentBlock });\n      }\n    }\n    results.push(branchResults);\n\n    // Create BRANCH_END block for phi assignments\n    const branchEndBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    addEdge(cfg, cfg.currentBlock, branchEndBlock);\n    branchEndBlocks.push(branchEndBlock);\n    popBlock(cfg);\n\n    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);\n    addEdge(cfg, branchEndBlock, scopeEndBlock);\n    addEdge(cfg, scopeEndBlock, mergeBlock);\n    previousBlock = scopeStartBlock;\n  }\n  // Push the branch block for modification to avoid changing the ordering\n  pushBlockForModification(cfg, branchBlock);\n  for (const key in phiBlockDependencies) {\n    mergedAssignments[key] = createPhiNode(strandsContext, phiBlockDependencies[key], key);\n  }\n  popBlock(cfg);\n  for (let i = 0; i < results.length; i++) {\n    const branchResult = results[i];\n    const branchEndBlockID = branchEndBlocks[i];\n    pushBlockForModification(cfg, branchEndBlockID);\n    for (const key in branchResult) {\n      if (mergedAssignments[key]) {\n        // Create an assignment statement: phiNode = branchResult[key]\n        const phiNodeID = mergedAssignments[key].id;\n        const sourceNodeID = branchResult[key].id;\n        // Create an assignment operation node\n        // Use dependsOn[0] for phiNodeID and dependsOn[1] for sourceNodeID\n        // This represents: dependsOn[0] = dependsOn[1] (phiNode = sourceNode)\n        const assignmentNode = {\n          nodeType: NodeType.ASSIGNMENT,\n          dependsOn: [phiNodeID, sourceNodeID],\n          phiBlocks: []\n        };\n        const assignmentID = getOrCreateNode(strandsContext.dag, assignmentNode);\n        recordInBasicBlock(cfg, branchEndBlockID, assignmentID);\n      }\n    }\n    popBlock(cfg);\n  }\n  pushBlock(cfg, mergeBlock);\n  return mergedAssignments;\n}\n\nexport { StrandsConditional };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3201, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_for.js"],"sourcesContent":["import { createBasicBlock, addEdge, pushBlock, popBlock, pushBlockForModification, recordInBasicBlock } from './ir_cfg.js';\nimport { getNodeDataFromID, createNodeData, getOrCreateNode } from './ir_dag.js';\nimport { BlockType, NodeType, StatementType, BaseType, OpCode } from './ir_types.js';\nimport { c as createStrandsNode, S as StrandsNode, p as primitiveConstructorNode } from '../ir_builders-Cn4s8QTL.js';\nimport { createPhiNode } from './strands_phi_utils.js';\nimport './strands_FES.js';\nimport './strands_builtins.js';\n\nclass StrandsFor {\n  constructor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars) {\n    this.strandsContext = strandsContext;\n    this.initialCb = initialCb;\n    this.conditionCb = conditionCb;\n    this.updateCb = updateCb;\n    this.bodyCb = bodyCb;\n    this.initialVars = initialVars;\n  }\n\n  build() {\n    const cfg = this.strandsContext.cfg;\n    const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);\n\n    // Create a BRANCH block to handle phi node declarations\n    const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);\n    addEdge(cfg, cfg.currentBlock, branchBlock);\n    addEdge(cfg, branchBlock, mergeBlock);\n\n    // Initialize loop variable phi node\n    const { initialVar, phiNode } = this.initializeLoopVariable(cfg, branchBlock);\n\n    // Execute condition and update callbacks to get nodes for analysis\n    pushBlock(cfg, cfg.currentBlock);\n    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);\n    const conditionNode = this.conditionCb(loopVarNode);\n    const updateResult = this.updateCb(loopVarNode);\n    popBlock(cfg);\n\n    // Check if loop has bounded iteration count\n    const isBounded = this.loopIsBounded(initialVar, conditionNode, updateResult);\n\n    if (isBounded) {\n      this.buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);\n    } else {\n      this.buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);\n    }\n\n    // Update the phi nodes created in buildBoundedLoop with actual body results\n    const finalPhiNodes = this.phiNodesForBody;\n    pushBlockForModification(cfg, branchBlock);\n    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {\n      if (varName !== 'loopVar' && finalPhiNodes[varName]) {\n        // Update the phi node's second input to use the actual body result\n        const phiNodeID = finalPhiNodes[varName].id;\n        const phiNodeData = getNodeDataFromID(this.strandsContext.dag, phiNodeID);\n        // Update the dependsOn array to include the actual body result\n        if (phiNodeData.dependsOn.length > 1) {\n          phiNodeData.dependsOn[1] = resultNode.id;\n        }\n        if (phiNodeData.phiInputs && phiNodeData.phiInputs.length > 1) {\n          phiNodeData.phiInputs[1].value = resultNode;\n        }\n      }\n    }\n    popBlock(cfg);\n\n    // Create assignment nodes in the branch block for initial values\n    pushBlockForModification(cfg, branchBlock);\n    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {\n      if (varName !== 'loopVar' && finalPhiNodes[varName]) {\n        // Create an assignment statement: phiNode = initialValue\n        const phiNodeID = finalPhiNodes[varName].id;\n        const sourceNodeID = initialValueNode.id;\n        // Create an assignment operation node for the initial value\n        const assignmentNode = createNodeData({\n          nodeType: NodeType.ASSIGNMENT,\n          dependsOn: [phiNodeID, sourceNodeID],\n          phiBlocks: []\n        });\n        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);\n        recordInBasicBlock(cfg, branchBlock, assignmentID);\n      }\n    }\n    popBlock(cfg);\n\n    // Create assignment nodes in the final block after body execution (following conditionals pattern)\n    // After executing the body callback, cfg.currentBlock should be the final block in the control flow\n    pushBlockForModification(cfg, this.finalBodyBlock);\n    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {\n      if (varName !== 'loopVar' && finalPhiNodes[varName]) {\n        // Create an assignment statement: phiNode = bodyResult[varName]\n        const phiNodeID = finalPhiNodes[varName].id;\n        const sourceNodeID = resultNode.id;\n        // Create an assignment operation node\n        // Use dependsOn[0] for phiNodeID and dependsOn[1] for sourceNodeID\n        // This represents: dependsOn[0] = dependsOn[1] (phiNode = sourceNode)\n        const assignmentNode = createNodeData({\n          nodeType: NodeType.ASSIGNMENT,\n          dependsOn: [phiNodeID, sourceNodeID],\n          phiBlocks: []\n        });\n        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);\n        recordInBasicBlock(cfg, this.finalBodyBlock, assignmentID);\n      }\n    }\n    popBlock(cfg);\n\n    // Convert phi nodes to StrandsNodes for the final result\n    const finalBodyResults = {};\n    for (const [varName, phiNode] of Object.entries(finalPhiNodes)) {\n      finalBodyResults[varName] = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);\n    }\n\n    pushBlock(cfg, mergeBlock);\n\n    return finalBodyResults;\n  }\n\n  buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {\n    // For bounded loops, create FOR block with three statements: init, condition, update\n    const forBlock = createBasicBlock(cfg, BlockType.FOR);\n    addEdge(cfg, branchBlock, forBlock);\n\n    // Now add only the specific nodes we need to the FOR block\n    pushBlock(cfg, forBlock);\n\n    // 1. Init statement - assign initial value to phi node (or empty if no initializer)\n    if (initialVar) {\n      const initAssignmentNode = createNodeData({\n        nodeType: NodeType.ASSIGNMENT,\n        dependsOn: [phiNode.id, initialVar.id],\n        phiBlocks: []\n      });\n      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);\n      recordInBasicBlock(cfg, forBlock, initAssignmentID);\n    }\n\n    // 2. Condition statement - wrap in ExpressionStatement to force generation\n    const conditionStatementNode = createNodeData({\n      nodeType: NodeType.STATEMENT,\n      statementType: StatementType.EXPRESSION,\n      dependsOn: [conditionNode.id],\n      phiBlocks: []\n    });\n    const conditionStatementID = getOrCreateNode(this.strandsContext.dag, conditionStatementNode);\n    recordInBasicBlock(cfg, forBlock, conditionStatementID);\n\n    // 3. Update statement - create assignment of update result to phi node\n    const updateAssignmentNode = createNodeData({\n      nodeType: NodeType.ASSIGNMENT,\n      dependsOn: [phiNode.id, updateResult.id],\n      phiBlocks: []\n    });\n    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);\n    recordInBasicBlock(cfg, forBlock, updateAssignmentID);\n\n    popBlock(cfg);\n\n    // Verify we have the right number of statements (2 or 3 depending on initializer)\n    const instructions = cfg.blockInstructions[forBlock] || [];\n    const expectedLength = initialVar ? 3 : 2;\n    if (instructions.length !== expectedLength) {\n      throw new Error(`FOR block must have exactly ${expectedLength} statements, got ${instructions.length}`);\n    }\n\n    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);\n    addEdge(cfg, forBlock, scopeStartBlock);\n\n    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    this.bodyBlock = bodyBlock;\n    addEdge(cfg, scopeStartBlock, bodyBlock);\n\n    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);\n\n    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);\n    addEdge(cfg, bodyBlock, scopeEndBlock);\n    addEdge(cfg, scopeEndBlock, mergeBlock);\n  }\n\n  buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {\n    // For unbounded loops, create FOR block with infinite loop and break condition\n    const forBlock = createBasicBlock(cfg, BlockType.FOR);\n    addEdge(cfg, branchBlock, forBlock);\n\n    // Create FOR block with three empty statements for for(;;) syntax\n    pushBlock(cfg, forBlock);\n\n    // 1. Init statement - initialize loop variable or empty\n    if (initialVar) {\n      const initAssignmentNode = createNodeData({\n        nodeType: NodeType.ASSIGNMENT,\n        dependsOn: [phiNode.id, initialVar.id],\n        phiBlocks: []\n      });\n      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);\n      recordInBasicBlock(cfg, forBlock, initAssignmentID);\n    } else {\n      // Create empty statement for init\n      const emptyInitNode = createNodeData({\n        nodeType: NodeType.STATEMENT,\n        statementType: StatementType.EMPTY,\n        dependsOn: [],\n        phiBlocks: []\n      });\n      const emptyInitID = getOrCreateNode(this.strandsContext.dag, emptyInitNode);\n      recordInBasicBlock(cfg, forBlock, emptyInitID);\n    }\n\n    // 2. Condition statement - empty for infinite loop\n    const emptyConditionNode = createNodeData({\n      nodeType: NodeType.STATEMENT,\n      statementType: StatementType.EMPTY,\n      dependsOn: [],\n      phiBlocks: []\n    });\n    const emptyConditionID = getOrCreateNode(this.strandsContext.dag, emptyConditionNode);\n    recordInBasicBlock(cfg, forBlock, emptyConditionID);\n\n    // 3. Update statement - empty for infinite loop\n    const emptyUpdateNode = createNodeData({\n      nodeType: NodeType.STATEMENT,\n      statementType: StatementType.EMPTY,\n      dependsOn: [],\n      phiBlocks: []\n    });\n    const emptyUpdateID = getOrCreateNode(this.strandsContext.dag, emptyUpdateNode);\n    recordInBasicBlock(cfg, forBlock, emptyUpdateID);\n\n    popBlock(cfg);\n\n    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);\n    addEdge(cfg, forBlock, scopeStartBlock);\n\n    // Add break condition check right after scope start\n    const breakCheckBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    addEdge(cfg, scopeStartBlock, breakCheckBlock);\n\n    pushBlock(cfg, breakCheckBlock);\n\n    // Generate break statement: if (!condition) break;\n    // First, create the logical NOT of the condition: !condition\n    const condition = conditionNode;\n    const negatedCondition = this.createLogicalNotNode(condition);\n\n    // Create a conditional break using the existing conditional structure\n    // We'll create an IF_COND block that leads to a break statement\n    const breakConditionBlock = createBasicBlock(cfg, BlockType.IF_COND);\n    addEdge(cfg, breakCheckBlock, breakConditionBlock);\n    cfg.blockConditions[breakConditionBlock] = negatedCondition.id;\n\n    const breakStatementBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    addEdge(cfg, breakConditionBlock, breakStatementBlock);\n\n    // Create the break statement in the break statement block\n    pushBlock(cfg, breakStatementBlock);\n    const breakStatementNode = createNodeData({\n      nodeType: NodeType.STATEMENT,\n      statementType: StatementType.BREAK,\n      dependsOn: [],\n      phiBlocks: []\n    });\n    const breakStatementID = getOrCreateNode(this.strandsContext.dag, breakStatementNode);\n    recordInBasicBlock(cfg, breakStatementBlock, breakStatementID);\n    popBlock(cfg);\n\n    // The break statement block leads to the merge block (exits the loop)\n    addEdge(cfg, breakStatementBlock, mergeBlock);\n\n    popBlock(cfg);\n\n    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    this.bodyBlock = bodyBlock;\n    addEdge(cfg, breakCheckBlock, bodyBlock);\n\n    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);\n\n    const updateBlock = createBasicBlock(cfg, BlockType.DEFAULT);\n    addEdge(cfg, bodyBlock, updateBlock);\n\n    // Update the loop variable in the update block (like bounded loops)\n    pushBlock(cfg, updateBlock);\n    const updateAssignmentNode = createNodeData({\n      nodeType: NodeType.ASSIGNMENT,\n      dependsOn: [phiNode.id, updateResult.id],\n      phiBlocks: []\n    });\n    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);\n    recordInBasicBlock(cfg, updateBlock, updateAssignmentID);\n    popBlock(cfg);\n\n    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);\n    addEdge(cfg, updateBlock, scopeEndBlock);\n\n    // Loop back to break check\n    addEdge(cfg, scopeEndBlock, breakCheckBlock);\n\n    // Break condition exits to merge\n    addEdge(cfg, breakCheckBlock, mergeBlock);\n  }\n\n  initializeLoopVariable(cfg, branchBlock) {\n    pushBlock(cfg, branchBlock);\n    let initialVar = this.initialCb();\n\n    // Convert to StrandsNode if it's not already one\n    if (!(initialVar instanceof StrandsNode)) {\n      const { id, dimension } = primitiveConstructorNode(this.strandsContext, { baseType: BaseType.FLOAT, dimension: 1 }, initialVar);\n      initialVar = createStrandsNode(id, dimension, this.strandsContext);\n    }\n\n    // Create phi node for the loop variable in the BRANCH block\n    const phiNode = createPhiNode(this.strandsContext, [\n      { value: initialVar, blockId: branchBlock },\n      { value: initialVar, blockId: branchBlock } // Placeholder, will be updated later\n    ], 'loopVar');\n    popBlock(cfg);\n\n    return { initialVar, phiNode };\n  }\n\n  createLogicalNotNode(conditionNode) {\n    const notOperationNode = createNodeData({\n      nodeType: NodeType.OPERATION,\n      opCode: OpCode.Unary.LOGICAL_NOT,\n      baseType: BaseType.BOOL,\n      dimension: 1,\n      dependsOn: [conditionNode.id],\n      phiBlocks: [],\n      usedBy: []\n    });\n    const notOperationID = getOrCreateNode(this.strandsContext.dag, notOperationNode);\n    return createStrandsNode(notOperationID, 1, this.strandsContext);\n  }\n\n  executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode) {\n    pushBlock(cfg, bodyBlock);\n\n    // Create phi node references to pass to the body callback\n    const phiVars = {};\n    const phiNodesForBody = {};\n    pushBlockForModification(cfg, branchBlock);\n    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {\n      if (varName !== 'loopVar') {\n        // Create phi node that will be used for the final result\n        const varPhiNode = createPhiNode(this.strandsContext, [\n          { value: initialValueNode, blockId: branchBlock }, // Initial value\n          { value: initialValueNode, blockId: bodyBlock }     // Placeholder - will update after body execution\n        ], varName);\n        phiNodesForBody[varName] = varPhiNode;\n        phiVars[varName] = createStrandsNode(varPhiNode.id, varPhiNode.dimension, this.strandsContext);\n      }\n    }\n    popBlock(cfg);\n\n    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);\n    this.bodyResults = this.bodyCb(loopVarNode, phiVars);\n    this.phiNodesForBody = phiNodesForBody;\n    // Capture the final block after body execution before popping\n    this.finalBodyBlock = cfg.currentBlock;\n    popBlock(cfg);\n  }\n\n  loopIsBounded(initialVar, conditionNode, updateVar) {\n    // A loop is considered \"bounded\" if we can determine at compile time that it will\n    // execute a known number of iterations. This happens when:\n    // 1. The condition compares the loop variable against a compile-time constant\n    // 2. At least one side of the comparison uses only literals (no variables/uniforms)\n\n    if (!conditionNode) return false;\n\n    // Analyze the condition node - it should be a comparison operation\n    const conditionData = getNodeDataFromID(this.strandsContext.dag, conditionNode.id);\n\n    if (conditionData.nodeType !== NodeType.OPERATION) {\n      return false;\n    }\n\n    // For a comparison like \"i < bound\", we need at least one side to use only literals\n    // The condition should have two dependencies: left and right operands\n    if (!conditionData.dependsOn || conditionData.dependsOn.length !== 2) {\n      return false;\n    }\n\n    // Check if either operand uses only literals\n    const leftOperand = createStrandsNode(conditionData.dependsOn[0], 1, this.strandsContext);\n    const rightOperand = createStrandsNode(conditionData.dependsOn[1], 1, this.strandsContext);\n\n    const leftUsesOnlyLiterals = this.nodeUsesOnlyLiterals(leftOperand);\n    const rightUsesOnlyLiterals = this.nodeUsesOnlyLiterals(rightOperand);\n\n    // At least one side should use only literals for the loop to be bounded\n    return leftUsesOnlyLiterals || rightUsesOnlyLiterals;\n  }\n\n  nodeUsesOnlyLiterals(node) {\n    // Recursively check if a node and all its dependencies use only literals\n    const nodeData = getNodeDataFromID(this.strandsContext.dag, node.id);\n\n    switch (nodeData.nodeType) {\n      case NodeType.LITERAL:\n        return true;\n\n      case NodeType.VARIABLE:\n        // Variables (like uniforms) make this branch unbounded\n        return false;\n\n      case NodeType.PHI:\n        // Phi nodes (like loop variables) are not literals\n        return false;\n\n      case NodeType.OPERATION:\n        // For operations, all dependencies must use only literals\n        if (nodeData.dependsOn) {\n          for (const depId of nodeData.dependsOn) {\n            const depNode = createStrandsNode(depId, 1, this.strandsContext);\n            if (!this.nodeUsesOnlyLiterals(depNode)) {\n              return false;\n            }\n          }\n        }\n        return true;\n\n      default:\n        // Conservative: if we don't know the node type, assume not literal\n        return false;\n    }\n  }\n}\n\nexport { StrandsFor };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3616, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/strands_api.js"],"sourcesContent":["import { u as unaryOpNode, c as createStrandsNode, s as statementNode, v as variableNode, S as StrandsNode, p as primitiveConstructorNode, f as functionCallNode, a as structConstructorNode, b as structInstanceNode, d as binaryOpNode } from '../ir_builders-Cn4s8QTL.js';\nimport { OperatorTable, DataType, BaseType, BlockType, isStructType, structType, TypeInfoFromGLSLName, StatementType } from './ir_types.js';\nimport { strandsBuiltinFunctions } from './strands_builtins.js';\nimport { StrandsConditional } from './strands_conditionals.js';\nimport { StrandsFor } from './strands_for.js';\nimport { createBasicBlock, addEdge, pushBlock, popBlock } from './ir_cfg.js';\nimport { userError } from './strands_FES.js';\nimport { getNodeDataFromID } from './ir_dag.js';\nimport './strands_phi_utils.js';\n\nvar noiseGLSL = \"// Based on https://github.com/stegu/webgl-noise/blob/22434e04d7753f7e949e8d724ab3da2864c17a0f/src/noise3D.glsl\\n// MIT licensed, adapted for p5.strands\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n  return mod289(((x*34.0)+10.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat baseNoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n  // First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n  // Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n  // Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n  //Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n  // Mix final noise value\\n  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n        dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nfloat noise(vec3 st, int octaves, float ampFalloff) {\\n  float result = 0.0;\\n  float amplitude = 1.0;\\n  float frequency = 1.0;\\n\\n  for (int i = 0; i < 8; i++) {\\n    if (i >= octaves) break;\\n    result += amplitude * baseNoise(st * frequency);\\n    frequency *= 2.0;\\n    amplitude *= ampFalloff;\\n  }\\n\\n  return result;\\n}\\n\";\n\n//////////////////////////////////////////////\n// User nodes\n//////////////////////////////////////////////\nfunction initGlobalStrandsAPI(p5, fn, strandsContext) {\n  // We augment the strands node with operations programatically\n  // this means methods like .add, .sub, etc can be chained\n  for (const { name, arity, opCode } of OperatorTable) {\n    if (arity === 'binary') {\n      StrandsNode.prototype[name] = function (...right) {\n        const { id, dimension } = binaryOpNode(strandsContext, this, right, opCode);\n        return createStrandsNode(id, dimension, strandsContext);\n      };\n    }\n    if (arity === 'unary') {\n      p5[name] = function (nodeOrValue) {\n        const { id, dimension } = unaryOpNode(strandsContext, nodeOrValue, opCode);\n        return createStrandsNode(id, dimension, strandsContext);\n      };\n    }\n  }\n  //////////////////////////////////////////////\n  // Unique Functions\n  //////////////////////////////////////////////\n  fn.discard = function() {\n    statementNode(strandsContext, StatementType.DISCARD);\n  };\n  fn.break = function() {\n    statementNode(strandsContext, StatementType.BREAK);\n  };\n  p5.break = fn.break;\n  fn.instanceID = function() {\n    const node = variableNode(strandsContext, { baseType: BaseType.INT, dimension: 1 }, 'gl_InstanceID');\n    return createStrandsNode(node.id, node.dimension, strandsContext);\n  };\n  // Internal methods use p5 static methods; user-facing methods use fn.\n  // Some methods need to be used by both.\n  p5.strandsIf = function(conditionNode, ifBody) {\n    return new StrandsConditional(strandsContext, conditionNode, ifBody);\n  };\n  fn.strandsIf = p5.strandsIf;\n  p5.strandsFor = function(initialCb, conditionCb, updateCb, bodyCb, initialVars) {\n    return new StrandsFor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars).build();\n  };\n  fn.strandsFor = p5.strandsFor;\n  p5.strandsNode = function(...args) {\n    if (args.length === 1 && args[0] instanceof StrandsNode) {\n      return args[0];\n    }\n    if (args.length > 4) {\n      userError(\"type error\", \"It looks like you've tried to construct a p5.strands node implicitly, with more than 4 components. This is currently not supported.\");\n    }\n    const { id, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, args.flat());\n    return createStrandsNode(id, dimension, strandsContext);//new StrandsNode(id, dimension, strandsContext);\n  };\n  //////////////////////////////////////////////\n  // Builtins, uniforms, variable constructors\n  //////////////////////////////////////////////\n  for (const [functionName, overrides] of Object.entries(strandsBuiltinFunctions)) {\n    const isp5Function = overrides[0].isp5Function;\n    if (isp5Function) {\n      const originalFn = fn[functionName];\n      fn[functionName] = function(...args) {\n        if (strandsContext.active) {\n          const { id, dimension } =  functionCallNode(strandsContext, functionName, args);\n          return createStrandsNode(id, dimension, strandsContext);\n        } else {\n          return originalFn.apply(this, args);\n        }\n      };\n    } else {\n      fn[functionName] = function (...args) {\n        if (strandsContext.active) {\n          const { id, dimension } = functionCallNode(strandsContext, functionName, args);\n          return createStrandsNode(id, dimension, strandsContext);\n        } else {\n          p5._friendlyError(\n            `It looks like you've called ${functionName} outside of a shader's modify() function.`\n          );\n        }\n      };\n    }\n  }\n  // Add GLSL noise. TODO: Replace this with a backend-agnostic implementation\n  const originalNoise = fn.noise;\n  const originalNoiseDetail = fn.noiseDetail;\n\n  strandsContext._noiseOctaves = null;\n  strandsContext._noiseAmpFalloff = null;\n\n  fn.noiseDetail = function (lod, falloff) {\n    if (!strandsContext.active) {\n      return originalNoiseDetail.apply(this, arguments);\n    }\n\n    strandsContext._noiseOctaves = lod;\n    strandsContext._noiseAmpFalloff = falloff;\n  };\n\n  fn.noise = function (...args) {\n    if (!strandsContext.active) {\n      return originalNoise.apply(this, args); // fallback to regular p5.js noise\n    }\n    strandsContext.vertexDeclarations.add(noiseGLSL);\n    strandsContext.fragmentDeclarations.add(noiseGLSL);\n\n    // Make each input into a strands node so that we can check their dimensions\n    const strandsArgs = args.map(arg => p5.strandsNode(arg));\n    let nodeArgs;\n    if (strandsArgs.length === 3) {\n      nodeArgs = [fn.vec3(strandsArgs[0], strandsArgs[1], strandsArgs[2])];\n    } else if (strandsArgs.length === 2) {\n      nodeArgs = [fn.vec3(strandsArgs[0], strandsArgs[1], 0)];\n    } else if (strandsArgs.length === 1 && strandsArgs[0].dimension <= 3) {\n      if (strandsArgs[0].dimension === 3) {\n        nodeArgs = strandsArgs;\n      } else if (strandsArgs[0].dimension === 2) {\n        nodeArgs = [fn.vec3(strandsArgs[0], 0)];\n      } else {\n        nodeArgs = [fn.vec3(strandsArgs[0], 0, 0)];\n      }\n    } else {\n      p5._friendlyError(\n        `It looks like you've called noise() with ${args.length} arguments. It only supports 1D to 3D input.`\n      );\n    }\n\n    const octaves = strandsContext._noiseOctaves !== null\n      ? strandsContext._noiseOctaves\n      : fn._getNoiseOctaves();\n    const falloff = strandsContext._noiseAmpFalloff !== null\n      ? strandsContext._noiseAmpFalloff\n      : fn._getNoiseAmpFalloff();\n\n    nodeArgs.push(octaves);\n    nodeArgs.push(falloff);\n\n    const { id, dimension } = functionCallNode(strandsContext, 'noise', nodeArgs, {\n      overloads: [{\n        params: [DataType.float3, DataType.int1, DataType.float1],\n        returnType: DataType.float1,\n      }]\n    });\n    return createStrandsNode(id, dimension, strandsContext);\n  };\n\n  // Next is type constructors and uniform functions.\n  // For some of them, we have aliases so that you can write either a more human-readable\n  // variant or also one more directly translated from GLSL, or to be more compatible with\n  // APIs we documented at the release of 2.x and have to continue supporting.\n  for (const type in DataType) {\n    if (type === BaseType.DEFER) {\n      continue;\n    }\n    const typeInfo = DataType[type];\n    const typeAliases = [];\n    let pascalTypeName;\n    if (/^[ib]vec/.test(typeInfo.fnName)) {\n      pascalTypeName = typeInfo.fnName\n        .slice(0, 2).toUpperCase()\n        + typeInfo.fnName\n          .slice(2)\n          .toLowerCase();\n      typeAliases.push(pascalTypeName.replace('Vec', 'Vector'));\n    } else {\n      pascalTypeName = typeInfo.fnName.charAt(0).toUpperCase()\n        + typeInfo.fnName.slice(1);\n      if (pascalTypeName === 'Sampler2D') {\n        typeAliases.push('Texture');\n      } else if (/^vec/.test(typeInfo.fnName)) {\n        typeAliases.push(pascalTypeName.replace('Vec', 'Vector'));\n      }\n    }\n    fn[`uniform${pascalTypeName}`] = function(name, defaultValue) {\n      const { id, dimension } = variableNode(strandsContext, typeInfo, name);\n      strandsContext.uniforms.push({ name, typeInfo, defaultValue });\n      return createStrandsNode(id, dimension, strandsContext);\n    };\n    // Shared variables with smart context detection\n    fn[`shared${pascalTypeName}`] = function(name) {\n      const { id, dimension } = variableNode(strandsContext, typeInfo, name);\n\n      // Initialize shared variables tracking if not present\n      if (!strandsContext.sharedVariables) {\n        strandsContext.sharedVariables = new Map();\n      }\n\n      // Track this shared variable for smart declaration generation\n      strandsContext.sharedVariables.set(name, {\n        typeInfo,\n        usedInVertex: false,\n        usedInFragment: false,\n        declared: false\n      });\n\n      return createStrandsNode(id, dimension, strandsContext);\n    };\n\n    // Alias varying* as shared* for backward compatibility\n    fn[`varying${pascalTypeName}`] = fn[`shared${pascalTypeName}`];\n\n    for (const typeAlias of typeAliases) {\n      // For compatibility, also alias uniformVec2 as uniformVector2, what we initially\n      // documented these as\n      fn[`uniform${typeAlias}`] = fn[`uniform${pascalTypeName}`];\n      fn[`varying${typeAlias}`] = fn[`varying${pascalTypeName}`];\n      fn[`shared${typeAlias}`] = fn[`shared${pascalTypeName}`];\n    }\n    const originalp5Fn = fn[typeInfo.fnName];\n    fn[typeInfo.fnName] = function(...args) {\n      if (strandsContext.active) {\n        if (args.length === 1 && args[0].dimension && args[0].dimension === typeInfo.dimension) {\n          const { id, dimension } = functionCallNode(strandsContext, typeInfo.fnName, args, {\n            overloads: [{\n              params: [args[0].typeInfo()],\n              returnType: typeInfo,\n            }]\n          });\n          return createStrandsNode(id, dimension, strandsContext);\n        } else {\n          const { id, dimension } = primitiveConstructorNode(strandsContext, typeInfo, args);\n          return createStrandsNode(id, dimension, strandsContext);\n        }\n      } else if (originalp5Fn) {\n        return originalp5Fn.apply(this, args);\n      } else {\n        p5._friendlyError(\n          `It looks like you've called ${typeInfo.fnName} outside of a shader's modify() function.`\n        );\n      }\n    };\n  }\n}\n//////////////////////////////////////////////\n// Per-Hook functions\n//////////////////////////////////////////////\nfunction createHookArguments(strandsContext, parameters){\n  const args = [];\n  const dag = strandsContext.dag;\n  for (const param of parameters) {\n    if(isStructType(param.type.typeName)) {\n      const structTypeInfo = structType(param);\n      const { id, dimension } = structInstanceNode(strandsContext, structTypeInfo, param.name, []);\n      const structNode = createStrandsNode(id, dimension, strandsContext);\n      for (let i = 0; i < structTypeInfo.properties.length; i++) {\n        const propertyType = structTypeInfo.properties[i];\n        Object.defineProperty(structNode, propertyType.name, {\n          get() {\n            const propNode = getNodeDataFromID(dag, dag.dependsOn[structNode.id][i]);\n            const onRebind = (newFieldID) => {\n              const oldDeps = dag.dependsOn[structNode.id];\n              const newDeps = oldDeps.slice();\n              newDeps[i] = newFieldID;\n              const rebuilt = structInstanceNode(strandsContext, structTypeInfo, param.name, newDeps);\n              structNode.id = rebuilt.id;\n            };\n            // TODO: implement member access operations\n            // const { id, components } = createMemberAccessNode(strandsContext, structNode, componentNodes[i], componentTypeInfo.dataType);\n            // const memberAccessNode = new StrandsNode(id, components);\n            // return memberAccessNode;\n            return createStrandsNode(propNode.id, propNode.dimension, strandsContext, onRebind);\n          },\n          set(val) {\n            const oldDependsOn = dag.dependsOn[structNode.id];\n            const newDependsOn = [...oldDependsOn];\n            let newValueID;\n            if (val instanceof StrandsNode) {\n              newValueID = val.id;\n            }\n            else {\n              let newVal = primitiveConstructorNode(strandsContext, propertyType.dataType, val);\n              newValueID = newVal.id;\n            }\n            newDependsOn[i] = newValueID;\n            const newStructInfo = structInstanceNode(strandsContext, structTypeInfo, param.name, newDependsOn);\n            structNode.id = newStructInfo.id;\n          }\n        });\n      }\n      args.push(structNode);\n    }\n    else /*if(isNativeType(paramType.typeName))*/ {\n      const typeInfo = TypeInfoFromGLSLName[param.type.typeName];\n      const { id, dimension } = variableNode(strandsContext, typeInfo, param.name);\n      const arg = createStrandsNode(id, dimension, strandsContext);\n      args.push(arg);\n    }\n  }\n  return args;\n}\nfunction enforceReturnTypeMatch(strandsContext, expectedType, returned, hookName) {\n  if (!(returned instanceof StrandsNode)) {\n    // try {\n      const result = primitiveConstructorNode(strandsContext, expectedType, returned);\n      return result.id;\n    // } catch (e) {\n      // FES.userError('type error',\n        // `There was a type mismatch for a value returned from ${hookName}.\\n` +\n        // `The value in question was supposed to be:\\n` +\n        // `${expectedType.baseType + expectedType.dimension}\\n` +\n        // `But you returned:\\n` +\n        // `${returned}`\n      // );\n    // }\n  }\n  const dag = strandsContext.dag;\n  let returnedNodeID = returned.id;\n  const receivedType = {\n    baseType: dag.baseTypes[returnedNodeID],\n    dimension: dag.dimensions[returnedNodeID],\n  };\n  if (receivedType.dimension !== expectedType.dimension) {\n    if (receivedType.dimension !== 1) {\n      userError('type error', `You have returned a vector with ${receivedType.dimension} components in ${hookName} when a ${expectedType.baseType + expectedType.dimension} was expected!`);\n    }\n    else {\n      const result = primitiveConstructorNode(strandsContext, expectedType, returned);\n      returnedNodeID = result.id;\n    }\n  }\n  else if (receivedType.baseType !== expectedType.baseType) {\n    const result = primitiveConstructorNode(strandsContext, expectedType, returned);\n    returnedNodeID = result.id;\n  }\n  return returnedNodeID;\n}\nfunction createShaderHooksFunctions(strandsContext, fn, shader) {\n  // Add shader context to hooks before spreading\n  const vertexHooksWithContext = Object.fromEntries(\n    Object.entries(shader.hooks.vertex).map(([name, hook]) => [name, { ...hook, shaderContext: 'vertex' }])\n  );\n  const fragmentHooksWithContext = Object.fromEntries(\n    Object.entries(shader.hooks.fragment).map(([name, hook]) => [name, { ...hook, shaderContext: 'fragment' }])\n  );\n\n  const availableHooks = {\n    ...vertexHooksWithContext,\n    ...fragmentHooksWithContext,\n  };\n  const hookTypes = Object.keys(availableHooks).map(name => shader.hookTypes(name));\n\n  const { cfg, dag } = strandsContext;\n  for (const hookType of hookTypes) {\n    const hookImplementation = function(hookUserCallback) {\n      const entryBlockID = createBasicBlock(cfg, BlockType.FUNCTION);\n      addEdge(cfg, cfg.currentBlock, entryBlockID);\n      pushBlock(cfg, entryBlockID);\n      const args = createHookArguments(strandsContext, hookType.parameters);\n      const userReturned = hookUserCallback(...args);\n      const expectedReturnType = hookType.returnType;\n      let rootNodeID = null;\n      if(isStructType(expectedReturnType.typeName)) {\n        const expectedStructType = structType(expectedReturnType);\n        if (userReturned instanceof StrandsNode) {\n          const returnedNode = getNodeDataFromID(strandsContext.dag, userReturned.id);\n          if (returnedNode.baseType !== expectedStructType.typeName) {\n            userError(\"type error\", `You have returned a ${userReturned.baseType} from ${hookType.name} when a ${expectedStructType.typeName} was expected.`);\n          }\n          const newDeps = returnedNode.dependsOn.slice();\n          for (let i = 0; i < expectedStructType.properties.length; i++) {\n            const expectedType = expectedStructType.properties[i].dataType;\n            const receivedNode = createStrandsNode(returnedNode.dependsOn[i], dag.dependsOn[userReturned.id], strandsContext);\n            newDeps[i] = enforceReturnTypeMatch(strandsContext, expectedType, receivedNode, hookType.name);\n          }\n          dag.dependsOn[userReturned.id] = newDeps;\n          rootNodeID = userReturned.id;\n        }\n        else {\n          const expectedProperties = expectedStructType.properties;\n          const newStructDependencies = [];\n          for (let i = 0; i < expectedProperties.length; i++) {\n            const expectedProp = expectedProperties[i];\n            const propName = expectedProp.name;\n            const receivedValue = userReturned[propName];\n            if (receivedValue === undefined) {\n              userError('type error', `You've returned an incomplete struct from ${hookType.name}.\\n` +\n                `Expected: { ${expectedReturnType.properties.map(p => p.name).join(', ')} }\\n` +\n                `Received: { ${Object.keys(userReturned).join(', ')} }\\n` +\n                `All of the properties are required!`);\n            }\n            const expectedTypeInfo = expectedProp.dataType;\n            const returnedPropID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, receivedValue, hookType.name);\n            newStructDependencies.push(returnedPropID);\n          }\n          const newStruct = structConstructorNode(strandsContext, expectedStructType, newStructDependencies);\n          rootNodeID = newStruct.id;\n        }\n      }\n      else /*if(isNativeType(expectedReturnType.typeName))*/ {\n        const expectedTypeInfo = TypeInfoFromGLSLName[expectedReturnType.typeName];\n        rootNodeID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, userReturned, hookType.name);\n      }\n      const fullHookName = `${hookType.returnType.typeName} ${hookType.name}`;\n      const hookInfo = availableHooks[fullHookName];\n      strandsContext.hooks.push({\n        hookType,\n        entryBlockID,\n        rootNodeID,\n        shaderContext: hookInfo?.shaderContext, // 'vertex' or 'fragment'\n      });\n      popBlock(cfg);\n    };\n    strandsContext.windowOverrides[hookType.name] = window[hookType.name];\n    strandsContext.fnOverrides[hookType.name] = fn[hookType.name];\n    window[hookType.name] = hookImplementation;\n    fn[hookType.name] = hookImplementation;\n  }\n}\n\nexport { createShaderHooksFunctions, initGlobalStrandsAPI };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4053, "column": 0}, "map": {"version":3,"sources":["file:///home/kcat/Desktop/workingFolder/web/yaku-soba-2025/frontend/node_modules/p5/dist/strands/p5.strands.js"],"sourcesContent":["import { glslBackend } from './strands_glslBackend.js';\nimport { transpileStrandsToJS } from './strands_transpiler.js';\nimport { BlockType } from './ir_types.js';\nimport { createDirectedAcyclicGraph } from './ir_dag.js';\nimport { createBasicBlock, pushBlock, popBlock, createControlFlowGraph } from './ir_cfg.js';\nimport { generateShaderCode } from './strands_codegen.js';\nimport { initGlobalStrandsAPI, createShaderHooksFunctions } from './strands_api.js';\nimport './strands_FES.js';\nimport 'acorn';\nimport 'acorn-walk';\nimport 'escodegen';\nimport '../ir_builders-Cn4s8QTL.js';\nimport './strands_builtins.js';\nimport './strands_conditionals.js';\nimport './strands_phi_utils.js';\nimport './strands_for.js';\n\n/**\n* @module 3D\n* @submodule strands\n* @for p5\n* @requires core\n*/\n\nfunction strands(p5, fn) {\n  //////////////////////////////////////////////\n  // Global Runtime\n  //////////////////////////////////////////////\n  function initStrandsContext(ctx, backend, { active = false } = {}) {\n    ctx.dag = createDirectedAcyclicGraph();\n    ctx.cfg = createControlFlowGraph();\n    ctx.uniforms = [];\n    ctx.vertexDeclarations = new Set();\n    ctx.fragmentDeclarations = new Set();\n    ctx.hooks = [];\n    ctx.globalAssignments = [];\n    ctx.backend = backend;\n    ctx.active = active;\n    ctx.previousFES = p5.disableFriendlyErrors;\n    ctx.windowOverrides = {};\n    ctx.fnOverrides = {};\n    if (active) {\n      p5.disableFriendlyErrors = true;\n    }\n  }\n\n  function deinitStrandsContext(ctx) {\n    ctx.dag = createDirectedAcyclicGraph();\n    ctx.cfg = createControlFlowGraph();\n    ctx.uniforms = [];\n    ctx.vertexDeclarations = new Set();\n    ctx.fragmentDeclarations = new Set();\n    ctx.hooks = [];\n    ctx.globalAssignments = [];\n    ctx.active = false;\n    p5.disableFriendlyErrors = ctx.previousFES;\n    for (const key in ctx.windowOverrides) {\n      window[key] = ctx.windowOverrides[key];\n    }\n    for (const key in ctx.fnOverrides) {\n      fn[key] = ctx.fnOverrides[key];\n    }\n  }\n\n  const strandsContext = {};\n  initStrandsContext(strandsContext);\n  initGlobalStrandsAPI(p5, fn, strandsContext);\n\n  //////////////////////////////////////////////\n  // Entry Point\n  //////////////////////////////////////////////\n  const oldModify = p5.Shader.prototype.modify;\n\n  p5.Shader.prototype.modify = function(shaderModifier, scope = {}) {\n    if (shaderModifier instanceof Function) {\n      try {\n        // Reset the context object every time modify is called;\n        // const backend = glslBackend;\n        initStrandsContext(strandsContext, glslBackend, { active: true });\n        createShaderHooksFunctions(strandsContext, fn, this);\n        // TODO: expose this, is internal for debugging for now.\n        const options = { parser: true, srcLocations: false };\n\n        // 1. Transpile from strands DSL to JS\n        let strandsCallback;\n        if (options.parser) {\n          // #7955 Wrap function declaration code in brackets so anonymous functions are not top level statements, which causes an error in acorn when parsing\n          // https://github.com/acornjs/acorn/issues/1385\n          const sourceString = `(${shaderModifier.toString()})`;\n          strandsCallback = transpileStrandsToJS(p5, sourceString, options.srcLocations, scope);\n        }\n\n        // 2. Build the IR from JavaScript API\n        const globalScope = createBasicBlock(strandsContext.cfg, BlockType.GLOBAL);\n        pushBlock(strandsContext.cfg, globalScope);\n        strandsCallback();\n        popBlock(strandsContext.cfg);\n\n        // 3. Generate shader code hooks object from the IR\n        // .......\n        const hooksObject = generateShaderCode(strandsContext);\n\n        // Call modify with the generated hooks object\n        return oldModify.call(this, hooksObject);\n      } finally {\n        // Reset the strands runtime context\n        deinitStrandsContext(strandsContext);\n      }\n    }\n    else {\n      return oldModify.call(this, shaderModifier)\n    }\n  };\n}\n\nif (typeof p5 !== 'undefined') {\n  p5.registerAddon(strands);\n}\n\n/* ------------------------------------------------------------- */\n/**\n * @method getWorldInputs\n * @description\n * Registers a callback to modify the world-space properties of each vertex in a shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to customize vertex positions, normals, texture coordinates, and colors before rendering. \"World space\" refers to the coordinate system of the 3D scene, before any camera or projection transformations are applied.\n *\n * The callback receives a vertex object with the following properties:\n * - `position`: a three-component vector representing the original position of the vertex.\n * - `normal`: a three-component vector representing the direction the surface is facing.\n * - `texCoord`: a two-component vector representing the texture coordinates.\n * - `color`: a four-component vector representing the color of the vertex (red, green, blue, alpha).\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives a vertex object containing position (vec3), normal (vec3), texCoord (vec2), and color (vec4) properties. The function should return the modified vertex object.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseMaterialShader().modify(() => {\n *     let t = uniformFloat(() => millis());\n *     getWorldInputs(inputs => {\n *       // Move the vertex up and down in a wave in world space\n *       // In world space, moving the object (e.g., with translate()) will affect these coordinates\n*       // The sphere is ~50 units tall here, so 20 gives a noticeable wave\n *       inputs.position.y += 20 * sin(t * 0.001 + inputs.position.x * 0.05);\n *       return inputs;\n *     });\n *   });\n * }\n * function draw() {\n *   background(255);\n *   shader(myShader);\n *   lights();\n *   noStroke();\n *   fill('red');\n *   sphere(50);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method combineColors\n * @description\n * Registers a callback to customize how color components are combined in the fragment shader. This hook can be used inside <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to control the final color output of a material. The callback receives an object with the following properties:\n *\n * - `baseColor`: a three-component vector representing the base color (red, green, blue).\n * - `diffuse`: a single number representing the diffuse reflection.\n * - `ambientColor`: a three-component vector representing the ambient color.\n * - `ambient`: a single number representing the ambient reflection.\n * - `specularColor`: a three-component vector representing the specular color.\n * - `specular`: a single number representing the specular reflection.\n * - `emissive`: a three-component vector representing the emissive color.\n * - `opacity`: a single number representing the opacity.\n *\n * The callback should return a vector with four components (red, green, blue, alpha) for the final color.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the object described above and returns a vector with four components for the final color.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseMaterialShader().modify(() => {\n *     combineColors(components => {\n *       // Custom color combination: add a green tint using vector properties\n *       return [\n *         components.baseColor * components.diffuse +\n *           components.ambientColor * components.ambient +\n *           components.specularColor * components.specular +\n *           components.emissive +\n *           [0, 0.2, 0], // Green tint for visibility\n *         components.opacity\n *       ];\n *     });\n *   });\n * }\n * function draw() {\n *   background(255);\n *   shader(myShader);\n *   lights();\n *   noStroke();\n *   fill('white');\n *   sphere(50);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method beforeVertex\n * @private\n * @description\n * Registers a callback to run custom code at the very start of the vertex shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to set up variables or perform calculations that affect every vertex before processing begins. The callback receives no arguments.\n *\n * Note: This hook is currently limited to per-vertex operations; storing variables for later use is not supported.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which is called before each vertex is processed.\n */\n\n/**\n * @method afterVertex\n * @private\n * @description\n * Registers a callback to run custom code at the very end of the vertex shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to perform cleanup or final calculations after all vertex processing is done. The callback receives no arguments.\n *\n * Note: This hook is currently limited to per-vertex operations; storing variables for later use is not supported.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which is called after each vertex is processed.\n */\n\n/**\n * @method beforeFragment\n * @private\n * @description\n * Registers a callback to run custom code at the very start of the fragment shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to set up variables or perform calculations that affect every pixel before color calculations begin. The callback receives no arguments.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which is called before each fragment is processed.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseColorShader().modify(() => {\n *     beforeFragment(() => {\n *       // Set a value for use in getFinalColor\n *       this.brightness = 0.5 + 0.5 * sin(millis() * 0.001);\n *     });\n *     getFinalColor(color => {\n *       // Use the value set in beforeFragment to tint the color\n *       color.r *= this.brightness; // Tint red channel\n *       return color;\n *     });\n *   });\n * }\n * function draw() {\n *   background(220);\n *   shader(myShader);\n *   noStroke();\n *   fill('teal');\n *   box(100);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method getPixelInputs\n * @description\n * Registers a callback to modify the properties of each fragment (pixel) before the final color is calculated in the fragment shader. This hook can be used inside <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to adjust per-pixel data before lighting/mixing.\n *\n * The callback receives an `Inputs` object. Available fields depend on the shader:\n *\n * - In <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>:\n *   - `normal`: a three-component vector representing the surface normal.\n *   - `texCoord`: a two-component vector representing the texture coordinates (u, v).\n *   - `ambientLight`: a three-component vector representing the ambient light color.\n *   - `ambientMaterial`: a three-component vector representing the material's ambient color.\n *   - `specularMaterial`: a three-component vector representing the material's specular color.\n *   - `emissiveMaterial`: a three-component vector representing the material's emissive color.\n *   - `color`: a four-component vector representing the base color (red, green, blue, alpha).\n *   - `shininess`: a number controlling specular highlights.\n *   - `metalness`: a number controlling the metalness factor.\n *\n * - In <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>:\n *   - `color`: a four-component vector representing the stroke color (red, green, blue, alpha).\n *   - `tangent`: a two-component vector representing the stroke tangent.\n *   - `center`: a two-component vector representing the cap/join center.\n *   - `position`: a two-component vector representing the current fragment position.\n *   - `strokeWeight`: a number representing the stroke weight in pixels.\n *\n * Return the modified object to update the fragment.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the fragment inputs object and should return it after making any changes.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseMaterialShader().modify(() => {\n *     let t = uniformFloat(() => millis());\n *     getPixelInputs(inputs => {\n *       // Animate alpha (transparency) based on x position\n *       inputs.color.a = 0.5 + 0.5 * sin(inputs.texCoord.x * 10.0 + t * 0.002);\n *       return inputs;\n *     });\n *   });\n * }\n * function draw() {\n *   background(240);\n *   shader(myShader);\n *   lights();\n *   noStroke();\n *   fill('purple');\n *   circle(0, 0, 100);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method shouldDiscard\n * @private\n * @description\n * Registers a callback to decide whether to discard (skip drawing) a fragment (pixel) in the fragment shader. This hook can be used inside <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to create effects like round points or custom masking. The callback receives a boolean:\n * - `willDiscard`: true if the fragment would be discarded by default\n *\n * Return true to discard the fragment, or false to keep it.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives a boolean and should return a boolean.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseStrokeShader().modify({\n *      'bool shouldDiscard': '(bool outside) { return outside; }'\n *   });\n * }\n * function draw() {\n *   background(255);\n *   strokeShader(myShader);\n *   strokeWeight(30);\n *   line(-width/3, 0, width/3, 0);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method getFinalColor\n * @description\n * Registers a callback to change the final color of each pixel after all lighting and mixing is done in the fragment shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to adjust the color before it appears on the screen. The callback receives a four component vector representing red, green, blue, and alpha.\n *\n * Return a new color array to change the output color.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the color array and should return a color array.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseColorShader().modify(() => {\n *     getFinalColor(color => {\n *       // Add a blue tint to the output color\n *       color.b += 0.4;\n *       return color;\n *     });\n *   });\n * }\n * function draw() {\n *   background(230);\n *   shader(myShader);\n *   noStroke();\n *   fill('green');\n *   circle(0, 0, 100);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method afterFragment\n * @private\n * @description\n * Registers a callback to run custom code at the very end of the fragment shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to perform cleanup or final per-pixel effects after all color calculations are done. The callback receives no arguments.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which is called after each fragment is processed.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseColorShader().modify(() => {\n *     getFinalColor(color => {\n *       // Add a purple tint to the color\n *       color.b += 0.2;\n *       return color;\n *     });\n *     afterFragment(() => {\n *       // This hook runs after the final color is set for each fragment.\n *       // You could use this for debugging or advanced effects.\n *     });\n *   });\n * }\n * function draw() {\n *   background(240);\n *   shader(myShader);\n *   noStroke();\n *   fill('purple');\n *   sphere(60);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method getColor\n * @description\n * Registers a callback to set the final color for each pixel in a filter shader. This hook can be used inside <a href=\"#/p5/baseFilterShader\">baseFilterShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to control the output color for each pixel. The callback receives the following arguments:\n * - `inputs`: an object with the following properties:\n *   - `texCoord`: a two-component vector representing the texture coordinates (u, v).\n *   - `canvasSize`: a two-component vector representing the canvas size in pixels (width, height).\n *   - `texelSize`: a two-component vector representing the size of a single texel in texture space.\n * - `canvasContent`: a texture containing the sketch's contents before the filter is applied.\n *\n * Return a four-component vector `[r, g, b, a]` for the pixel.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseFilterShader\">baseFilterShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the inputs object and canvasContent, and should return a color array.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseFilterShader().modify(() => {\n *     getColor((inputs, canvasContent) => {\n *       // Warp the texture coordinates for a wavy effect\n *       let warped = [inputs.texCoord.x, inputs.texCoord.y + 0.1 * sin(inputs.texCoord.x * 10.0)];\n *       return getTexture(canvasContent, warped);\n *     });\n *   });\n * }\n * function draw() {\n *   background(180);\n *   // Draw something to the canvas\n *   fill('yellow');\n *   circle(0, 0, 150);\n *   filter(myShader);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method getObjectInputs\n * @description\n * Registers a callback to modify the properties of each vertex before any transformations are applied in the vertex shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to move, color, or otherwise modify the raw model data. The callback receives an object with the following properties:\n *\n * - `position`: a three-component vector representing the original position of the vertex.\n * - `normal`: a three-component vector representing the direction the surface is facing.\n * - `texCoord`: a two-component vector representing the texture coordinates.\n * - `color`: a four-component vector representing the color of the vertex (red, green, blue, alpha).\n *\n * Return the modified object to update the vertex.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the vertex object and should return it after making any changes.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseColorShader().modify(() => {\n *     let t = uniformFloat(() => millis());\n *     getObjectInputs(inputs => {\n *       // Create a sine wave along the x axis in object space\n *       inputs.position.y += sin(t * 0.001 + inputs.position.x);\n *       return inputs;\n *     });\n *   });\n * }\n * function draw() {\n *   background(220);\n *   shader(myShader);\n *   noStroke();\n *   fill('orange');\n *   sphere(50);\n * }\n * </code>\n * </div>\n */\n\n/**\n * @method getCameraInputs\n * @description\n * Registers a callback to adjust vertex properties after the model has been transformed by the camera, but before projection, in the vertex shader. This hook can be used inside <a href=\"#/p5/baseColorShader\">baseColorShader()</a>.modify() and similar shader <a href=\"#/p5.Shader/modify\">modify()</a> calls to create effects that depend on the camera's view. The callback receives an object with the following properties:\n *\n * - `position`: a three-component vector representing the position after camera transformation.\n * - `normal`: a three-component vector representing the normal after camera transformation.\n * - `texCoord`: a two-component vector representing the texture coordinates.\n * - `color`: a four-component vector representing the color of the vertex (red, green, blue, alpha).\n *\n * Return the modified object to update the vertex.\n *\n * This hook is available in:\n * - <a href=\"#/p5/baseColorShader\">baseColorShader()</a>\n * - <a href=\"#/p5/baseMaterialShader\">baseMaterialShader()</a>\n * - <a href=\"#/p5/baseNormalShader\">baseNormalShader()</a>\n * - <a href=\"#/p5/baseStrokeShader\">baseStrokeShader()</a>\n *\n * @param {Function} callback\n *        A callback function which receives the vertex object and should return it after making any changes.\n *\n * @example\n * <div modernizr='webgl'>\n * <code>\n * let myShader;\n * function setup() {\n *   createCanvas(200, 200, WEBGL);\n *   myShader = baseColorShader().modify(() => {\n *     getCameraInputs(inputs => {\n *       // Move vertices in camera space based on their x position\n *       let t = uniformFloat(() => millis());\n *       inputs.position.y += 30 * sin(inputs.position.x * 0.05 + t * 0.001);\n *       // Tint all vertices blue\n *       inputs.color.b = 1;\n *       return inputs;\n *     });\n *   });\n * }\n * function draw() {\n *   background(200);\n *   shader(myShader);\n *   noStroke();\n *   fill('red');\n *   sphere(50);\n * }\n * </code>\n * </div>\n */\n\nexport { strands as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}